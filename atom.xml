<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>咸鱼享乐，摸鱼快�?</title>
  
  
  <link href="http://akkaduilin.com/atom.xml" rel="self"/>
  
  <link href="http://akkaduilin.com/"/>
  <updated>2022-08-02T06:30:33.989Z</updated>
  <id>http://akkaduilin.com/</id>
  
  <author>
    <name>不对de�?</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>汇编代码</title>
    <link href="http://akkaduilin.com/2022/08/01/x86-64%E6%B1%87%E7%BC%96/"/>
    <id>http://akkaduilin.com/2022/08/01/x86-64%E6%B1%87%E7%BC%96/</id>
    <published>2022-08-01T08:22:24.000Z</published>
    <updated>2022-08-02T06:30:33.989Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>汇编代码和原始的C代码相差比较大，一些通常对C语言程序员隐蔽的处理器状态是可见的：</p><p>程序计数器(PC，用 %eip 表示)指示将要执行的下一条指令在存储器中的地址。<br>整数寄存器文件包含 8 个命名的位置，分别存储 32 位的值。这些寄存器可以存储地址(对应于 C 语言的指针)或证书数据。有的寄存器被用来记录某些重要的程序状态，而其他的寄存器则用来保存临时数据。<br>条件码(codition code)寄存器保存着最近执行的算术或逻辑指令的状态信息。它们用来实现控制或数据流中的条件变化。<br>一组浮点寄存器存放浮点数据。</p><span id="more"></span><h1 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h1><p><a href="https://sm.ms/image/JV4Sr8Dpyq9HzZx" target="_blank"><img src="https://s2.loli.net/2022/08/02/JV4Sr8Dpyq9HzZx.png" ></a></p><h1 id="操作数指示符"><a href="#操作数指示符" class="headerlink" title="操作数指示符"></a>操作数指示符</h1><p>大多数指令有一个或多个操作数(operand)，指示出执行一个操作中要引用的源数据值，以及放置结果的目标位置。操作数可能被分为三种类型：</p><ol><li>立即数(immediate)，也就是常数值</li><li>寄存器(register)，表示某个寄存器的内容</li><li>存储器(memory)引用，它会根据计算出来的地址访问某个存储器位置</li></ol><p><a href="https://sm.ms/image/bJ84KYTCsHigZP7" target="_blank"><img src="https://s2.loli.net/2022/08/02/bJ84KYTCsHigZP7.png" ></a></p><h1 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h1><p><a href="https://sm.ms/image/jLvqNehi8JEPsUr" target="_blank"><img src="https://s2.loli.net/2022/08/02/jLvqNehi8JEPsUr.png" ></a></p><h1 id="算术逻辑操作"><a href="#算术逻辑操作" class="headerlink" title="算术逻辑操作"></a>算术逻辑操作</h1><p><a href="https://sm.ms/image/JV4Sr8Dpyq9HzZx" target="_blank"><img src="https://s2.loli.net/2022/08/02/JV4Sr8Dpyq9HzZx.png" ></a></p><h1 id="xx2x"><a href="#xx2x" class="headerlink" title="xx2x"></a>xx2x</h1><h1 id="xx3x"><a href="#xx3x" class="headerlink" title="xx3x"></a>xx3x</h1><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;汇编代码和原始的C代码相差比较大，一些通常对C语言程序员隐蔽的处理器状态是可见的：&lt;/p&gt;
&lt;p&gt;程序计数器(PC，用 %eip 表示)指示将要执行的下一条指令在存储器中的地址。&lt;br&gt;整数寄存器文件包含 8 个命名的位置，分别存储 32 位的值。这些寄存器可以存储地址(对应于 C 语言的指针)或证书数据。有的寄存器被用来记录某些重要的程序状态，而其他的寄存器则用来保存临时数据。&lt;br&gt;条件码(codition code)寄存器保存着最近执行的算术或逻辑指令的状态信息。它们用来实现控制或数据流中的条件变化。&lt;br&gt;一组浮点寄存器存放浮点数据。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>娅娅和林林</title>
    <link href="http://akkaduilin.com/2022/07/15/%E5%A8%85%E5%A8%85%E5%92%8C%E6%9E%97%E6%9E%97/"/>
    <id>http://akkaduilin.com/2022/07/15/%E5%A8%85%E5%A8%85%E5%92%8C%E6%9E%97%E6%9E%97/</id>
    <published>2022-07-15T04:15:45.000Z</published>
    <updated>2022-08-22T03:35:15.430Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><span id="more"></span><p><a href="https://sm.ms/image/tl2zvbw7yJGcYrp" target="_blank"><img src="https://s2.loli.net/2022/08/22/tl2zvbw7yJGcYrp.jpg" ></a></p><p>糊你一个大逼兜！</p><h1 id="2022-6-30"><a href="#2022-6-30" class="headerlink" title="2022.6.30"></a>2022.6.30</h1><p>不知道从什么时候开始，变得时时刻刻会给你发消息，会给你发一些奇奇怪怪的话，会把你当作分享生活的对象，会期待你回到兰州的日子，很多人都说我们两个有什么，但是我都很认真的告诉他们没什么，就是关系很好的朋友。可能那个时候，真的只是想抓住愿意回自己消息的那个人吧。</p><p>比个心心！</p><p><a href="https://sm.ms/image/jtvxK9YDuPs6qaN" target="_blank"><img src="https://s2.loli.net/2022/08/22/jtvxK9YDuPs6qaN.jpg" ></a></p><h1 id="2022-7-3"><a href="#2022-7-3" class="headerlink" title="2022.7.3"></a>2022.7.3</h1><p>回兰州见到的第一面，不知道是我刻意为止还是怎么样，第一次见面就是在那个公园，黄河边，现在回想起来，当时可能已经有心动的感觉了吧，但是怎么能想到自己真的有勇气说出来呢。</p><p>断断续续的一起出去玩！</p><h1 id="2022-7-13"><a href="#2022-7-13" class="headerlink" title="2022.7.13"></a>2022.7.13</h1><p>猫头鹰先生喜欢上了月亮姑娘，他每晚都睁大眼睛抬头看着月亮，一夜都不合眼。</p><p>月亮姑娘很伤心地对他说，我们是不可能的，我们隔得太远了。</p><p>猫头鹰先生似懂非懂的点了点头，飞到小河边，对着月亮的倒影，悄悄的亲了一口。</p><p>疫情聊聊聊！</p><p><a href="https://sm.ms/image/9r6XRotHQmS5xO4" target="_blank"><img src="https://s2.loli.net/2022/08/22/9r6XRotHQmS5xO4.jpg" ></a></p><p>而且—–和你聊天越来越甜！</p><p><a href="https://sm.ms/image/IvC679Wsnufw2RN" target="_blank"><img src="https://s2.loli.net/2022/08/22/IvC679Wsnufw2RN.jpg" ></a></p><h1 id="2022-8-8"><a href="#2022-8-8" class="headerlink" title="2022.8.8"></a>2022.8.8</h1><p>解封啦！！！<br>和你一起出去，去了那家很久没去的甜品店，这次，是和你一起<br>笨蛋蛋！</p><h1 id="2022-8-10"><a href="#2022-8-10" class="headerlink" title="2022.8.10"></a>2022.8.10</h1><p>终于兑现了给你做饭的诺言，做了你觉得很好吃的排骨！</p><p>通关双人成行，真的好喜欢和你在一起的感觉</p><h1 id="2022-8-12"><a href="#2022-8-12" class="headerlink" title="2022.8.12"></a>2022.8.12</h1><p>去老街！ 拍照！<br><a href="https://sm.ms/image/msPiKjwe7HaZyXF" target="_blank"><img src="https://s2.loli.net/2022/08/22/msPiKjwe7HaZyXF.jpg" ></a><br><a href="https://sm.ms/image/aFREYPmxyrTOKou" target="_blank"><img src="https://s2.loli.net/2022/08/22/aFREYPmxyrTOKou.jpg" ></a><br><a href="https://sm.ms/image/3ug2VmMFwqkcv5H" target="_blank"><img src="https://s2.loli.net/2022/08/22/3ug2VmMFwqkcv5H.jpg" ></a><br><a href="https://sm.ms/image/1D2TZOwB5gEPrLj" target="_blank"><img src="https://s2.loli.net/2022/08/22/1D2TZOwB5gEPrLj.jpg" ></a><br><a href="https://sm.ms/image/lK21HhFIwex85dj" target="_blank"><img src="https://s2.loli.net/2022/08/22/lK21HhFIwex85dj.jpg" ></a><br><a href="https://sm.ms/image/QOCDu4NfkclYEGR" target="_blank"><img src="https://s2.loli.net/2022/08/22/QOCDu4NfkclYEGR.jpg" ></a></p><p>晚上睡不着：</p><p>没有想到，竟然会因为你睡不着觉。可能自己这次真的心动了吧，在一起干了这么多我认为是应该和自己喜欢的人一起做的事情之后，真的有心动的感觉了。这就是我失去了的喜欢吗？会想到你的样子，会想到一起逛街拍照，会想捏你的脸，摸摸你的头。<br>在上次见面之后才发现，自己已经真的放下了之前的那份感情，也感觉到自己不需要爱情也可以过的很好了，可能，真的可以开始下一段感情了吧。但是会更加害怕失去，会害怕这次又会弄丢得来不易的喜欢，那种单纯的喜欢。</p><h1 id="2022-8-13"><a href="#2022-8-13" class="headerlink" title="2022.8.13"></a>2022.8.13</h1><p>没有想到这么快自己就会主动说出来这件事情，也更没有得到的答案是如此的肯定，虽然现在还不算是真正意义上的情侣，但是至少两个人都互相喜欢，愿意在一起。可能正如东东说的叭，这次会是标准答案。不管怎么样，我都不会给她给自己太多压力，现在这样就很好了，有了目标之后，剩下的就是尽人事听天命了吧。</p><p>现在的自己，过的很开心！！！</p><h1 id="2022-8-14"><a href="#2022-8-14" class="headerlink" title="2022.8.14"></a>2022.8.14</h1><p>甜甜甜！</p><p><a href="https://sm.ms/image/n8AhVwxNsmoKuLc" target="_blank"><img src="https://s2.loli.net/2022/08/22/n8AhVwxNsmoKuLc.jpg" ></a></p><h1 id="2022-8-15"><a href="#2022-8-15" class="headerlink" title="2022.8.15"></a>2022.8.15</h1><p>在路上<br>行驶在山中的路上，看着天边的夕阳，这次，不止是一个人。<br><a href="https://sm.ms/image/4Ji1rGS6fgyMjEl" target="_blank"><img src="https://s2.loli.net/2022/08/22/4Ji1rGS6fgyMjEl.jpg" ></a><br><a href="https://sm.ms/image/sNIlJ1CYPoegpOF" target="_blank"><img src="https://s2.loli.net/2022/08/22/sNIlJ1CYPoegpOF.jpg" ></a><br><a href="https://sm.ms/image/NxbVoyjOurFqH5W" target="_blank"><img src="https://s2.loli.net/2022/08/22/NxbVoyjOurFqH5W.jpg" ></a></p><h1 id="2022-8-19"><a href="#2022-8-19" class="headerlink" title="2022.8.19"></a>2022.8.19</h1><p>想做的浪漫午餐！</p><p><a href="https://sm.ms/image/uhCBOWnH9GPZUm2" target="_blank"><img src="https://s2.loli.net/2022/08/22/uhCBOWnH9GPZUm2.jpg" ></a></p><p><a href="https://sm.ms/image/YIBvg7SP1szFw4q" target="_blank"><img src="https://s2.loli.net/2022/08/22/YIBvg7SP1szFw4q.jpg" ></a></p><p>从再次熟悉，到牵手拥抱亲吻，这一切好像变化的太快了，快到我不知道是好是坏，离分开还有一周的时间，一周之后我们也会像以前一样各分东西，我也像以前一样挂念着远方的那个她。只能希望这次会不一样吧，希望距离不会拉长我们之间的亲密，希望哪怕不在她的身边，自己也可以快乐的生活下去！</p><p><a href="https://sm.ms/image/RFQkLeUtPNrX7E2" target="_blank"><img src="https://s2.loli.net/2022/08/22/RFQkLeUtPNrX7E2.jpg" ></a></p><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="日常" scheme="http://akkaduilin.com/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
    <category term="想法" scheme="http://akkaduilin.com/tags/%E6%83%B3%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理-储存系统</title>
    <link href="http://akkaduilin.com/2022/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%82%A8%E5%AD%98%E7%B3%BB%E7%BB%9F/"/>
    <id>http://akkaduilin.com/2022/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%82%A8%E5%AD%98%E7%B3%BB%E7%BB%9F/</id>
    <published>2022-06-15T03:21:44.000Z</published>
    <updated>2022-06-25T06:40:22.609Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p><a href="https://sm.ms/image/GqxMmSXHt5fobK4" target="_blank"><img src="https://s2.loli.net/2022/06/25/GqxMmSXHt5fobK4.png" ></a></p><p>三级存储结构：高速缓冲存储器、内存、外存</p><p><a href="https://sm.ms/image/fAi3R8N9DSa1dTz" target="_blank"><img src="https://s2.loli.net/2022/06/24/fAi3R8N9DSa1dTz.png" ></a> </p><span id="more"></span><h1 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h1><p>Cache：高速缓冲存储器<br>容量小：几百KB~几MB<br>cache采用静态存储器技术，每位至少需要6个晶体管，直接用触发器方式维持固定的逻辑，所以不需要刷新<br>与内核紧密相连，采用高速同步运行</p><h1 id="执行原理"><a href="#执行原理" class="headerlink" title="执行原理"></a>执行原理</h1><p><a href="https://sm.ms/image/1IScn824AOelkrE" target="_blank"><img src="https://s2.loli.net/2022/06/24/1IScn824AOelkrE.png" ></a></p><p>CPU从内存访问第一条指令<br>同时将第一条指令所在的页内容复制到cache中</p><p>CPU从cache中查找下一条要执行的指令<br>查找到(命中)，从cache中取指令，执行</p><p>查找不到，从内存中取指令<br>同时将该指令所在的页内容复制到cache中</p><p><a href="https://sm.ms/image/71bFwBuyXfI3aOg" target="_blank"><img src="https://s2.loli.net/2022/06/24/71bFwBuyXfI3aOg.png" ></a></p><h1 id="访问原理"><a href="#访问原理" class="headerlink" title="访问原理"></a>访问原理</h1><h2 id="直接映射"><a href="#直接映射" class="headerlink" title="直接映射"></a>直接映射</h2><p><a href="https://sm.ms/image/DcJoZ5kjd9bfMNK" target="_blank"><img src="https://s2.loli.net/2022/06/24/DcJoZ5kjd9bfMNK.png" ></a></p><p>把主存的每一块映射到一个固定的Cache槽中。<br>j=i mod 2c，<br>j为Cache槽号<br>i为主存的块号，<br>2c为Cache的槽数。<br>优点：实现简单、花费少。<br>缺点：Cache利用率不高。</p><h2 id="全相联"><a href="#全相联" class="headerlink" title="全相联"></a>全相联</h2><p>通过允许每个主存块装入到Cache的任何一槽中来克服直接映射的缺点</p><h2 id="组相联映射"><a href="#组相联映射" class="headerlink" title="组相联映射"></a>组相联映射</h2><p><a href="https://sm.ms/image/JtmLc9T6D3MbCrv" target="_blank"><img src="https://s2.loli.net/2022/06/24/JtmLc9T6D3MbCrv.png" ></a><br>上述两种方案的折中。<br>按号分组 组内随意放<br>把Cache分成2C’组<br>每组有2r个槽<br>2C =2C’×2r<br>j=(i mod 2C’)* 2r +k<br>(k=0，1，…，2r-1)</p><h1 id="替换算法"><a href="#替换算法" class="headerlink" title="替换算法"></a>替换算法</h1><p><a href="https://sm.ms/image/KEGcbyUmNiJzu7Y" target="_blank"><img src="https://s2.loli.net/2022/06/24/KEGcbyUmNiJzu7Y.png" ></a></p><p><a href="https://sm.ms/image/GubwWY1dnm85Dr2" target="_blank"><img src="https://s2.loli.net/2022/06/24/GubwWY1dnm85Dr2.png" ></a></p><p><a href="https://sm.ms/image/KtrxRQVGBmcWay5" target="_blank"><img src="https://s2.loli.net/2022/06/24/KtrxRQVGBmcWay5.png" ></a></p><h1 id="写策略"><a href="#写策略" class="headerlink" title="写策略"></a>写策略</h1><p>主存和cache中数据一致性问题的解决办法：<br>  写通过（Write through）：所有的写操作对主存和Cache同时进行。<br>  <strong>直写法不需要维护位</strong></p><p>  回写（write back）：只在Cache中修改，当进行修改时，设置与槽有关的修改位。因此，当某个块被替换时，当且仅当修改位被设置时，才将它写回主存。<br>  <strong>写回法需要一位的维护位</strong></p><p>当系统中存在多个Cache时，解决多个Cache中数据的一致性问题的方法：<br>  总线监视法<br>  硬件监视法<br>  划出不可高速缓存存储区法</p><h1 id="虚拟储存器"><a href="#虚拟储存器" class="headerlink" title="虚拟储存器"></a>虚拟储存器</h1><p>虚拟存储器指的是“主存-辅存”层次，它能使计算机具有辅存的容量，接近于主存的速度和辅存的每位成本。使程序员可以按比主存大得多的空间来编制程序，即按虚存空间编址。</p><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://sm.ms/image/GqxMmSXHt5fobK4&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://s2.loli.net/2022/06/25/GqxMmSXHt5fobK4.png&quot; &gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;三级存储结构：高速缓冲存储器、内存、外存&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://sm.ms/image/fAi3R8N9DSa1dTz&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://s2.loli.net/2022/06/24/fAi3R8N9DSa1dTz.png&quot; &gt;&lt;/a&gt; &lt;/p&gt;</summary>
    
    
    
    <category term="计算机组成原理" scheme="http://akkaduilin.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机组成原理-中央处理器</title>
    <link href="http://akkaduilin.com/2022/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/"/>
    <id>http://akkaduilin.com/2022/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/</id>
    <published>2022-06-15T03:21:24.000Z</published>
    <updated>2022-06-27T09:30:04.765Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p><a href="https://sm.ms/image/q3H5Q21hRClFuIp" target="_blank"><img src="https://s2.loli.net/2022/06/23/q3H5Q21hRClFuIp.png" ></a></p><p><a href="https://www.bilibili.com/video/BV1BE411D7">https://www.bilibili.com/video/BV1BE411D7</a></p><span id="more"></span><h1 id="中央处理器的功能和组成"><a href="#中央处理器的功能和组成" class="headerlink" title="中央处理器的功能和组成"></a>中央处理器的功能和组成</h1><p>指令控制：程序的顺序控制<br>操作控制：一条指令有若干操作信号实现<br>时间控制：指令各个操作实施时间的定时<br>数据加工：算术运算和逻辑运算</p><p><strong>运算器：</strong><br>数据加工 </p><p><strong>控制器：</strong><br>①取指令 ②翻译指令 ③发送信号执行指令</p><p><strong>根本任务就是从应用程序中取指令并执行。</strong></p><h1 id="运算器-控制器"><a href="#运算器-控制器" class="headerlink" title="运算器/控制器"></a>运算器/控制器</h1><p><a href="https://sm.ms/image/ZGMEuWvyVO1irja" target="_blank"><img src="https://s2.loli.net/2022/06/23/ZGMEuWvyVO1irja.png" ></a></p><h2 id="运算器基本结构"><a href="#运算器基本结构" class="headerlink" title="运算器基本结构"></a>运算器基本结构</h2><p>定点运算器是数据的加工处理部件，<br>是CPU的重要组成部分。</p><p>包括：ALU算术/逻辑单元 ，阵列乘法器、阵列除法器、移位电路、寄存器组、选择电路、数据总线（内部总线），…… 等逻辑电路构成。</p><p><a href="https://sm.ms/image/hQplsKOZ7uGRHTv" target="_blank"><img src="https://s2.loli.net/2022/06/23/hQplsKOZ7uGRHTv.png" ></a></p><h2 id="控制器基本结构"><a href="#控制器基本结构" class="headerlink" title="控制器基本结构"></a>控制器基本结构</h2><p>控制器的功能：<br>        取指令<br>        分析指令<br>        执行指令<br>        控制程序和数据的输入与输出<br>        对异常和请求进行处理</p><p>控制器的组成：<br>        程序计数器（PC）<br>        指令寄存器（IR）<br>        地址寄存器（MAR）<br>        数据缓冲寄存器（MDR）<br>        指令译码器（I-decoder）<br>        脉冲源和启停线路<br>        时序控制信号形成部件</p><p><a href="https://sm.ms/image/5UuHYnQ68s4WNdV" target="_blank"><img src="https://s2.loli.net/2022/06/23/5UuHYnQ68s4WNdV.png" ></a></p><p><a href="https://sm.ms/image/V9IBsav6ljLkRXh" target="_blank"><img src="https://s2.loli.net/2022/06/27/V9IBsav6ljLkRXh.png" ></a></p><h1 id="指令的执行过程"><a href="#指令的执行过程" class="headerlink" title="指令的执行过程"></a>指令的执行过程</h1><p><a href="https://sm.ms/image/eWaRlAn9srFwpt1" target="_blank"><img src="https://s2.loli.net/2022/06/23/eWaRlAn9srFwpt1.png" ></a></p><p><a href="https://sm.ms/image/58InB7T3ZFapjNu" target="_blank"><img src="https://s2.loli.net/2022/06/23/58InB7T3ZFapjNu.png" ></a></p><h1 id="微程序"><a href="#微程序" class="headerlink" title="微程序"></a>微程序</h1><p>微指令：由同时发出的控制信号所执行的一组微操作。<br>    例如：<br>加法指令的执行可分为：取指、计算地址、取操作数和加法运算四步，每一步都由一组微操作实现。这一组能同时执行的微操作就构成一条微指令。</p><p>微程序：一组微指令的集合。这样：<br>程序由一组指令组成<br>指令由一个微程序实现<br>微程序由一组微指令实现<br>微指令由一组微操作实现</p><p><a href="https://sm.ms/image/byHGVLgcBQqlJuM" target="_blank"><img src="https://s2.loli.net/2022/06/23/byHGVLgcBQqlJuM.png" ></a></p><ol><li>将每个控制信号用1bit表示，当该位为1时，表示有控制信号；为0时，表示无控制信号。</li><li>对M/IO#、W/R#，则当该位为1时，分别表示访问存储器和写；当该位为0时，分别表示IO访问和读。</li><li> 每条微指令执行完后，需要给出下条微指令执行的地址。</li></ol><p><strong>基本结构</strong><br><a href="https://sm.ms/image/yWT27H4VsfIvw1S" target="_blank"><img src="https://s2.loli.net/2022/06/23/yWT27H4VsfIvw1S.png" ></a></p><p><strong>格式</strong><br><a href="https://sm.ms/image/OD6Fxvcz7U1IsuP" target="_blank"><img src="https://s2.loli.net/2022/06/23/OD6Fxvcz7U1IsuP.png" ></a></p><p><strong>编码方式</strong></p><p><a href="https://sm.ms/image/bO2VIUrWYnGfBTl" target="_blank"><img src="https://s2.loli.net/2022/06/23/bO2VIUrWYnGfBTl.png" ></a></p><p><a href="https://sm.ms/image/EFtsVHRleOXjYGz" target="_blank"><img src="https://s2.loli.net/2022/06/23/EFtsVHRleOXjYGz.png" ></a></p><p><a href="https://sm.ms/image/FnYSmG6Th1Dy7OX" target="_blank"><img src="https://s2.loli.net/2022/06/23/FnYSmG6Th1Dy7OX.png" ></a></p><p><a href="https://sm.ms/image/lBfQGSecj1xbRir" target="_blank"><img src="https://s2.loli.net/2022/06/23/lBfQGSecj1xbRir.png" ></a></p><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://sm.ms/image/q3H5Q21hRClFuIp&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://s2.loli.net/2022/06/23/q3H5Q21hRClFuIp.png&quot; &gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1BE411D7&quot;&gt;https://www.bilibili.com/video/BV1BE411D7&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="计算机组成原理" scheme="http://akkaduilin.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机组成原理-指令系统</title>
    <link href="http://akkaduilin.com/2022/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"/>
    <id>http://akkaduilin.com/2022/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/</id>
    <published>2022-06-15T03:21:02.000Z</published>
    <updated>2022-06-22T15:46:36.810Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>指令：要求计算机完成某种操作的命令。<br><strong>指令系统：1台计算机所能执行的全部指令的集合。</strong></p><p>计算机的性能与它所设置的指令系统有很大关系，而指令系统的设置又与机器的硬件结构密切相关。<br>机器指令的基本要素：<br>操作码<br>操作数的地址<br>操作结果的存储地址<br>下一条指令的地址</p><p><a href="https://sm.ms/image/ZBzuHGcbDaMfi3v" target="_blank"><img src="https://s2.loli.net/2022/06/22/ZBzuHGcbDaMfi3v.png" ></a></p><span id="more"></span><h1 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h1><p>计算机的指令格式与机器的字长、存储器的容量及指令的功能都有很大关系。</p><p>从机器指令的基本要素可知，一条指令包括两种信息：<strong>操作码和地址码</strong>。</p><p>操作码（operation code）：用来表示指令所要完成的操作(如加、减、乘、除、数据传送等)，其长度取决于指令系统中指令的条数。</p><p>地址码：用来描述指令的操作对象。或者直接给出操作数、或者指出操作数的存储地址或寄存器地址(即寄存器名)。</p><p><a href="https://sm.ms/image/xWrsiaveQNfA6E7" target="_blank"><img src="https://s2.loli.net/2022/06/21/xWrsiaveQNfA6E7.png" ></a></p><p>n位操作码可以定义2^n 条指令</p><h1 id="拓展操作码"><a href="#拓展操作码" class="headerlink" title="拓展操作码"></a>拓展操作码</h1><p>器字长位16位，用15/15/15扩展法可以设计一个具有15条三地址指令、15条双地址指令、15条单地址指令和16条零地址指令的指令系统</p><p><a href="https://sm.ms/image/nKU4ZgGrDqh1bBW" target="_blank"><img src="https://s2.loli.net/2022/06/21/nKU4ZgGrDqh1bBW.png" ></a></p><p>拓展思路：<br>设地址长度为n<br>上一层留出m种状态，下一层可拓展m*2^n种状态</p><p><a href="https://sm.ms/image/EDqNY35sZ9AWUi1" target="_blank"><img src="https://s2.loli.net/2022/06/21/EDqNY35sZ9AWUi1.png" ></a></p><h1 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h1><p>方式                 算法                 优点                     缺点           访存次数(执行期间)<br>立即               操作数=A           无存储器访问            操作数大小受限          0<br>直接               EA=A                   简单                   地址范围有限        1<br>间接               EA=(A)             大的地址范围            多重存储器访问          2<br>寄存器             EA=R                无存储器访问             地址范围有限          0<br>寄存器间接          EA=(R)              大的地址范围            额外地址访问           1<br>偏移               EA=A+(R)               灵活                    复杂               1<br>堆栈               EA=栈顶              无存储器访问              应用有限</p><p><a href="https://sm.ms/image/k6ZWhsAXx7BjClS" target="_blank"><img src="https://s2.loli.net/2022/06/22/k6ZWhsAXx7BjClS.png" ></a></p><p><a href="https://sm.ms/image/nS9tfvlFGAdrmiN" target="_blank"><img src="https://s2.loli.net/2022/06/22/nS9tfvlFGAdrmiN.png" ></a></p><p><a href="https://sm.ms/image/TBQYOV3H1s7cod9" target="_blank"><img src="https://s2.loli.net/2022/06/22/TBQYOV3H1s7cod9.png" ></a></p><p><a href="https://sm.ms/image/pjioez9wXZJ37Em" target="_blank"><img src="https://s2.loli.net/2022/06/22/pjioez9wXZJ37Em.png" ></a></p><p><a href="https://sm.ms/image/pqOaijgm4QP1BWk" target="_blank"><img src="https://s2.loli.net/2022/06/22/pqOaijgm4QP1BWk.png" ></a></p><p><a href="https://sm.ms/image/SHP3uXbOAWslLq1" target="_blank"><img src="https://s2.loli.net/2022/06/22/SHP3uXbOAWslLq1.png" ></a></p><p><a href="https://sm.ms/image/Lu76NVml8rbAItc" target="_blank"><img src="https://s2.loli.net/2022/06/22/Lu76NVml8rbAItc.png" ></a></p><p><a href="https://sm.ms/image/75dqoFezIgmlTZ8" target="_blank"><img src="https://s2.loli.net/2022/06/22/75dqoFezIgmlTZ8.png" ></a></p><h1 id="CISC-和-RISC"><a href="#CISC-和-RISC" class="headerlink" title="CISC 和 RISC"></a>CISC 和 RISC</h1><p>1、CISC计算机<br>CISC：复杂指令系统(集)计算机 (complex instruction set computer)的缩写。<br>一条指令完成一个复杂的功能<br>  DEC公司的VAX11/780计算机、Intel公司的80x86微处理器、IBM公司的大、中型计算机都是CISC。<br>2、RISC计算机<br>   RISC：精简指令系统(集)计算机 (reduced instruction set computer)的缩写。<br>   一条指令完成一个基本动作 多条指令组合完成一个复杂的基本功能</p><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;指令：要求计算机完成某种操作的命令。&lt;br&gt;&lt;strong&gt;指令系统：1台计算机所能执行的全部指令的集合。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;计算机的性能与它所设置的指令系统有很大关系，而指令系统的设置又与机器的硬件结构密切相关。&lt;br&gt;机器指令的基本要素：&lt;br&gt;操作码&lt;br&gt;操作数的地址&lt;br&gt;操作结果的存储地址&lt;br&gt;下一条指令的地址&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://sm.ms/image/ZBzuHGcbDaMfi3v&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://s2.loli.net/2022/06/22/ZBzuHGcbDaMfi3v.png&quot; &gt;&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="计算机组成原理" scheme="http://akkaduilin.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>数据库-关系数据</title>
    <link href="http://akkaduilin.com/2022/06/15/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE/"/>
    <id>http://akkaduilin.com/2022/06/15/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE/</id>
    <published>2022-06-15T03:18:26.000Z</published>
    <updated>2022-06-26T07:56:20.757Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>关系：笛卡尔积的一个子集，是一张二维表。没有重复的元组。</p><p>关系模式：用于定义关系，记作 [公式] 。<br>R：关系名，U：属性名集合，D：属性的域（的集合？)，DOM属性向域的映象集合（？什么鬼，是指属性和域的对应关系吗？），F：属性间数据依赖关系的集合（数据依赖后文会定义）。</p><p>关系数据库：基于关系模型的数据库，形式上由一组关系组成。</p><p>关系数据库模式：定义这组关系的关系模式全体，关系模式的集合。</p><p>数据依赖：包括函数依赖和多值依赖</p><p><strong>函数依赖：某个属性集决定另一个属性集时，称另一属性集依赖于该属性集。</strong></p><span id="more"></span><h1 id="码"><a href="#码" class="headerlink" title="码"></a>码</h1><p>候选码、主属性、非主属性、全码、主码：</p><p>被整个属性组完全函数依赖的属性组是候选码。</p><p>候选码包含的属性就是主属性，反之为非主属性。</p><p>全码：整个属性组都是候选码。</p><p>主码：候选码里选一个喜欢的当主码。</p><p>可以当主码的就是候选码，属于候选码的属性是主属性</p><h1 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h1><p><a href="https://blog.csdn.net/lqiqil/article/details/102801521?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-102801521-blog-124936003.pc_relevant_downloadblacklistv1&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3">https://blog.csdn.net/lqiqil/article/details/102801521?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-102801521-blog-124936003.pc_relevant_downloadblacklistv1&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3</a></p><h2 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h2><p>部分函数依赖：设X,Y是关系R的两个属性集合，存在X→Y，若X’是X的真子集，存在X’→Y，则称Y部分函数依赖于X。</p><p>完全函数依赖：设X,Y是关系R的两个属性集合，X’是X的真子集，存在X→Y，但对每一个X’都有X’!→Y，则称Y完全函数依赖于X。</p><p>传递函数依赖：设X,Y,Z是关系R中互不相同的属性集合，存在X→Y(Y !→X),Y→Z，则称Z传递函数依赖于X。</p><h2 id="四个范式"><a href="#四个范式" class="headerlink" title="四个范式"></a>四个范式</h2><p>1NF：如果一个关系模式R的所有属性都是不可分的基本数据项，则R∈1NF。可能存在增删改异常和数据冗余。</p><p>2NF：若关系模式R∈1NF，并且每一个非主属性都完全函数依赖于R的候选码，则R∈2NF。可能存在增删改异常和数据冗余。</p><p>3NF：若关系模式R∈2NF，并且非主属性都不传递依赖于R的候选码。基本上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。可能存在增删改异常和数据冗余。</p><p>BCNF：若关系模式R∈3NF，并且主属性也不传递依赖或部分依赖于R的候选码。每个属性都不部分依赖于候选码也不传递依赖于候选码，那么R是BC范式 。</p><h1 id="xx3x"><a href="#xx3x" class="headerlink" title="xx3x"></a>xx3x</h1><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关系：笛卡尔积的一个子集，是一张二维表。没有重复的元组。&lt;/p&gt;
&lt;p&gt;关系模式：用于定义关系，记作 [公式] 。&lt;br&gt;R：关系名，U：属性名集合，D：属性的域（的集合？)，DOM属性向域的映象集合（？什么鬼，是指属性和域的对应关系吗？），F：属性间数据依赖关系的集合（数据依赖后文会定义）。&lt;/p&gt;
&lt;p&gt;关系数据库：基于关系模型的数据库，形式上由一组关系组成。&lt;/p&gt;
&lt;p&gt;关系数据库模式：定义这组关系的关系模式全体，关系模式的集合。&lt;/p&gt;
&lt;p&gt;数据依赖：包括函数依赖和多值依赖&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;函数依赖：某个属性集决定另一个属性集时，称另一属性集依赖于该属性集。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="http://akkaduilin.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库" scheme="http://akkaduilin.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="关系数据" scheme="http://akkaduilin.com/tags/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>数据库设计</title>
    <link href="http://akkaduilin.com/2022/06/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/"/>
    <id>http://akkaduilin.com/2022/06/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/</id>
    <published>2022-06-15T03:17:34.000Z</published>
    <updated>2022-06-26T09:25:46.047Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>•按照规范设计法，考虑数据库及其应用系统开发全过<br>程，可将数据库设计分为以下六个阶段：<br>• 需求分析阶段<br>  分析用户数据需求与处理需求。<br>• 概念结构设计阶级<br>  对用户需求进行综合、归纳与抽象，形成独立于<br>  具体DBMS的概念模型(E-R图)<br>• 逻辑结构设计阶段<br>  首先将E-R图转换成具体的DBMS支持的数据模型，如关系模型，形成数据库逻辑模式<br>  •然后根据用户处理的要求、安全性的考虑，在基本表的基础上再建立必要的视图(View)，形成数据的外模式<br>• 物理结构设计阶段<br>  为逻辑数据模型选取一个最适合应用环境的物理结构（包括存储结构和存取方法）<br>• 数据库实施阶段<br>  设计人员运用DBMS提供的数据语言及宿主语言，根据逻辑设计和物理设计的结果<br>  •建立数据库<br>  •编制与调试应用程序<br>  •组织数据入库<br>  •并进行试运行<br>• 数据库运行和维护阶段<br>  数据库应用系统经过试运行后即可投入正式运行，在数据库系统运行过程中不断进行评价、调整、修改等维护工作。<br>•需求分析和概念设计独立于任何数据库管理系统<br>•逻辑设计和物理设计与选用的DBMS密切相关</p><span id="more"></span><h1 id="ER模型"><a href="#ER模型" class="headerlink" title="ER模型"></a>ER模型</h1><p>三要素：<br>•实体<br>•联系<br>•属性</p><h2 id="模型结构"><a href="#模型结构" class="headerlink" title="模型结构"></a>模型结构</h2><p>（1） 实体集用矩形框表示，矩形框内写上实体名。</p><p>（2） 实体的属性用椭圆框表示，框内写上属性名，并用无向边与其实体集相连。</p><p>（3） 实体间的联系用菱形框表示，联系以适当的含义命名，名字写在菱形框中，用无向连线将参加联系的实体矩形框分别与菱形框相连，并在连线上标明联系的类型，即1—1、1—N或M—N。</p><p>（4）主键的名称下加实线</p><p><a href="https://sm.ms/image/6V4iWbL7QKJMmYO" target="_blank"><img src="https://s2.loli.net/2022/06/26/6V4iWbL7QKJMmYO.png" ></a></p><p><a href="https://sm.ms/image/XQFPUhOfybRjTu6" target="_blank"><img src="https://s2.loli.net/2022/06/26/XQFPUhOfybRjTu6.png" ></a></p><p><a href="https://sm.ms/image/3wh6u7oJRtpGZOm" target="_blank"><img src="https://s2.loli.net/2022/06/26/3wh6u7oJRtpGZOm.png" ></a></p><h2 id="弱实体和强实体"><a href="#弱实体和强实体" class="headerlink" title="弱实体和强实体"></a>弱实体和强实体</h2><p>弱实体：一个实体必须依赖于另一个实体存在，那么前者是弱实体，后者是强实体，弱实体必须依赖强实体存在，例如学生实体和成绩单实体，成绩单依赖于学生实体而存在，因此学生是强实体，而成绩单是弱实体。</p><p>弱实体和强实体的联系必然只有1：N或者1：1，这是由于弱实体完全依赖于强实体，强实体不存在，那么弱实体就不存在，所以弱实体是完全参与联系的，<strong>因此弱实体与联系之间的联系也是用的双线菱形</strong>。</p><p>复合实体：复合实体也称联合实体或桥接实体，常常用于实现两个或多个实体间的M：N联系，它由每个关联实体的主玛组成，用长方体内加一个菱形来表示</p><p><a href="https://sm.ms/image/AtzIeaLgbcdrNxX" target="_blank"><img src="https://s2.loli.net/2022/06/26/AtzIeaLgbcdrNxX.png" ></a></p><h1 id="xx2x"><a href="#xx2x" class="headerlink" title="xx2x"></a>xx2x</h1><h1 id="xx3x"><a href="#xx3x" class="headerlink" title="xx3x"></a>xx3x</h1><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;•按照规范设计法，考虑数据库及其应用系统开发全过&lt;br&gt;程，可将数据库设计分为以下六个阶段：&lt;br&gt;• 需求分析阶段&lt;br&gt;  分析用户数据需求与处理需求。&lt;br&gt;• 概念结构设计阶级&lt;br&gt;  对用户需求进行综合、归纳与抽象，形成独立于&lt;br&gt;  具体DBMS的概念模型(E-R图)&lt;br&gt;• 逻辑结构设计阶段&lt;br&gt;  首先将E-R图转换成具体的DBMS支持的数据模型，如关系模型，形成数据库逻辑模式&lt;br&gt;  •然后根据用户处理的要求、安全性的考虑，在基本表的基础上再建立必要的视图(View)，形成数据的外模式&lt;br&gt;• 物理结构设计阶段&lt;br&gt;  为逻辑数据模型选取一个最适合应用环境的物理结构（包括存储结构和存取方法）&lt;br&gt;• 数据库实施阶段&lt;br&gt;  设计人员运用DBMS提供的数据语言及宿主语言，根据逻辑设计和物理设计的结果&lt;br&gt;  •建立数据库&lt;br&gt;  •编制与调试应用程序&lt;br&gt;  •组织数据入库&lt;br&gt;  •并进行试运行&lt;br&gt;• 数据库运行和维护阶段&lt;br&gt;  数据库应用系统经过试运行后即可投入正式运行，在数据库系统运行过程中不断进行评价、调整、修改等维护工作。&lt;br&gt;•需求分析和概念设计独立于任何数据库管理系统&lt;br&gt;•逻辑设计和物理设计与选用的DBMS密切相关&lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="http://akkaduilin.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库" scheme="http://akkaduilin.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="数据库设计" scheme="http://akkaduilin.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>数据库-事务</title>
    <link href="http://akkaduilin.com/2022/06/13/%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/"/>
    <id>http://akkaduilin.com/2022/06/13/%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/</id>
    <published>2022-06-13T08:08:54.000Z</published>
    <updated>2022-06-26T09:26:18.885Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>把多条语句作为一个整体进行操作的功能，被称为数据库事务。数据库事务可以确保该事务范围内的所有操作都可以全部成</p><p>功或者全部失败。如果事务失败，那么效果就和没有执行这些SQL一样，不会对数据库数据有任何改动。</p><p><a href="https://blog.csdn.net/qq_42192693/article/details/109963032">https://blog.csdn.net/qq_42192693/article/details/109963032</a></p><span id="more"></span><h1 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h1><p>数据库事务具有ACID这4个特性：</p><p>A：Atomic，原子性，将所有SQL作为原子工作单元执行，要么全部执行，要么全部不执行；<br>C：Consistent，一致性，事务完成后，所有数据的状态都是一致的，即A账户只要减去了100，B账户则必定加上了100；<br>I：Isolation，隔离性，如果有多个事务并发执行，每个事务作出的修改必须与其他事务隔离；<br>D：Duration，持久性，即事务完成后，对数据库数据的修改被持久化存储。</p><p>对于单条SQL语句，数据库系统自动将其作为一个事务执行，这种事务被称为<strong>隐式事务</strong>。</p><p>要手动把多条SQL语句作为一个事务执行，使用BEGIN开启一个事务，使用COMMIT提交一个事务，这种事务被称为<strong>显式事务</strong></p><h1 id="rollback-commit"><a href="#rollback-commit" class="headerlink" title="rollback/commit"></a>rollback/commit</h1><ol><li><p>使用 <strong>begin + transaction_name</strong> 来创建一个事务</p></li><li><p>commit 指提交事务，即尝试将事务内的SQL做出的修改尝试保存。</p></li><li><p>rollback 指回滚，主动让事务失败，事务内的SQL语句不生效</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BEGIN TRANsaction </span><br><span class="line">     Update student set sage=sage+1 where sno=’0001’</span><br><span class="line">     Select * from student where sno=’0002’</span><br><span class="line"></span><br><span class="line">ROLLBACK  TRANsaction</span><br><span class="line"></span><br><span class="line">commit transaction</span><br></pre></td></tr></table></figure><h1 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h1><p>事务是并发控制的基本单位</p><h2 id="封锁协议"><a href="#封锁协议" class="headerlink" title="封锁协议"></a>封锁协议</h2><p><a href="https://blog.csdn.net/weixin_40448140/article/details/115269643">https://blog.csdn.net/weixin_40448140/article/details/115269643</a></p><p>S锁 - 排他锁、写锁 只允许读取事务和修改数据对象</p><p>X锁 - 共享锁、读锁 只允许读取数据对象但不能修改数据对象</p><p><strong>第一类封锁协议</strong><br>第一类封锁协议指的是在对数据进行修改操作时需要对数据添加X锁.第一类封锁协议相当于把数据的读取和修改看成一个整体,在事务完成之前其他事务都不能对数据进行修改操作.</p><p><strong>第二类封锁协议</strong><br>第二类封锁协议是在第一类封锁协议的基础上加入了S锁.在读取数据前需要对数据添加S锁, 当数据读取完成后释放S锁 .如果一个事务读取数据并添加了S锁,另一个事务添加了X锁,那么添加X锁的那个事务必须等待添加了S锁的事务释放S锁后才能对数据进行修改操作.</p><p><strong>第三类封锁协议</strong><br>第三类封锁协议是在第一类封锁协议的基础上加入了S锁,在读取数据前需要对数据添加S锁, <strong>当事务结束后释放S锁</strong>.第三类封锁协议同时解决了数据的修改丢失,不可重复读和读脏数据问题.</p><h2 id="活锁-死锁"><a href="#活锁-死锁" class="headerlink" title="活锁/死锁"></a>活锁/死锁</h2><p><a href="https://sm.ms/image/DzEbiMu4OVh8XWm" target="_blank"><img src="https://s2.loli.net/2022/06/15/DzEbiMu4OVh8XWm.png" ></a></p><p>避免活锁：采用先来先服务的策略；当多个事务请求封锁同一数据对象时，按请求封锁的先后次序对这些事务排队，该数据对象上的锁一旦释放，首先批准申请队列中第一个事务获得锁。</p><p><a href="https://sm.ms/image/3OpRzWXJSKM4YoP" target="_blank"><img src="https://s2.loli.net/2022/06/15/3OpRzWXJSKM4YoP.png" ></a></p><p>解决死锁方法： 预防死锁（一次性封锁法和顺序封锁法）、诊断死锁并解除（超时法和等待图法）。<br>一次性封锁法：每个事务必须将所要求的数据对象全部上锁后才能执行读写操作，否则释放占用的资源。<br>顺序封锁法：对所有数据对象规定一个封锁顺序，所有事务均按这个顺序实行封锁。</p><h2 id="可串行性"><a href="#可串行性" class="headerlink" title="可串行性"></a>可串行性</h2><p><strong>可串行化调度</strong>：多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行这些事务时的结果相同。</p><p>可串行性是并发事务正确调度的准则，一个给定的并发调度，当且仅当它是可串行化的，才认为是正确调度。对若干个事务，不同的并发调度策略其最终的执行结果不一定完全相同。但只要它们的调度是可串行化的，则都是正确调度。                                                           </p><p><strong>冲突操作</strong>：是指不同的事务对同一数据的读写操作和写写操作。</p><p>一个调度Sc在保证冲突操作的次序不变的情况下，通过交换两个事务不冲突操作的次序得到另一个调度Sc’，如果Sc’是串行的，称调度Sc是<strong>冲突可串行化的调度</strong>。</p><p><strong>冲突可串行化调度是可串行化调度的充分条件</strong>，不是必要条件。还有不满足冲突可串行化条件的可串行化调度。</p><h2 id="两段锁协议"><a href="#两段锁协议" class="headerlink" title="两段锁协议"></a>两段锁协议</h2><p>数据库管理系统普遍采用两段锁协议的方法实现并发调度的可串行性，从而保证调度的正确性</p><p>两段封锁协议（也称两相上锁协议，简写2PL）指所有事务必须分两个阶段对数据项加锁和解锁。</p><p>（1）在对任何数据进行读、写操作之前，事务首先要申请并获得对该数据的封锁（读时S锁，写时X锁）；</p><p>（2）在释放一个封锁之后，事务不再申请和获得新的封锁。</p><p> “两段”锁的含义是事务分为两个阶段</p><p>第一阶段是获得封锁，也称为扩展阶段事务可以申请获得任何数据项上的任何类型的锁，但是不能释放任何锁<br>第二阶段是释放封锁，也称为收缩阶段事务可以释放任何数据项上的任何类型的锁，但是不能再申请任何锁<br>若所有事务都遵守两段封锁协议，则对这些事务的任何并发调度策略都是可串行化的。</p><h2 id="粒度"><a href="#粒度" class="headerlink" title="粒度"></a>粒度</h2><p>封锁的粒度：封锁对象的大小。可以是数据库、表、记录、字段等。</p><p>封锁粒度与系统的并发度和并发控制的开销密切相关。封锁的粒度越大，数据库所能够封锁的数据单元就越少，并发度就越小，系统开销也越小；封锁的粒度越小，并发度较高，但系统开销也就越大。</p><h1 id="数据库恢复"><a href="#数据库恢复" class="headerlink" title="数据库恢复"></a>数据库恢复</h1><p>计算机硬件故障<br>软件的错误<br>操作员的失误<br>恶意的破坏<br>故障的影响<br>运行事务非正常中断，影响数据库中数据的正确性<br>破坏数据库；全部或部分丢失数据</p><h2 id="数据库的恢复"><a href="#数据库的恢复" class="headerlink" title="数据库的恢复"></a>数据库的恢复</h2><p>数据库管理系统必须具有把数据库从错误状态恢复到某一已知的正确状态（亦称为一致状态或完整状态）的功能，这就是数据库的恢复管理系统对故障的对策</p><p>恢复子系统是数据库管理系统的一个重要组成部分<br>恢复技术是衡量系统优劣的重要指标</p><h2 id="故障的种类"><a href="#故障的种类" class="headerlink" title="故障的种类"></a>故障的种类</h2><ol><li>事务内部的故障</li></ol><p>有的是可以通过事务程序本身发现的（转账事务的例子）。有的是非预期的，不能由事务程序处理的。（如运算溢出、并发事务发生死锁而被选中撤销该事务、违反了某些完整性限制等）</p><ol start="2"><li>系统故障</li></ol><p>称为软故障，是指造成系统停止运转的任何事件，使得系统要重新启动。如：整个系统的正常运行突然被破坏、所有正在运行的事务都非正常终止、不破坏数据库、内存中数据库缓冲区的信息全部丢失。常见原因：特定类型的硬件错误（如CPU故障）、操作系统故障、DBMS代码错误、系统断电等。</p><ol start="3"><li>介质故障</li></ol><p>称为硬故障，指外存故障，如：磁盘损坏、磁头碰撞、操作系统的某种潜在错误、瞬时强磁场干扰。介质故障破坏数据库或部分数据库，并影响正在存取这部分数据的所有事务。</p><p>介质故障比前两类故障的可能性小得多，但破坏性大得多。</p><ol start="4"><li>计算机病毒</li></ol><p>一种人为的故障或破坏，是一些恶作剧者研制的一种计算机程序。可以繁殖和传播，造成对计算机系统包括数据库的危害。</p><h2 id="恢复的实现技术"><a href="#恢复的实现技术" class="headerlink" title="恢复的实现技术"></a>恢复的实现技术</h2><p>恢复操作的基本原理：冗余</p><p>利用存储这系统其他地方的冗余数据来重建数据库中已被破坏或不正确的那部分数据</p><p>恢复的实现技术：复杂</p><p>一个大型数据库产品，恢复子系统的代码要占全部代码的10%以上</p><p>恢复机制涉及的关键问题</p><p>如何建立冗余数据（恢复方式）</p><p>数据转储（backup）转储是指DBA将整个数据库复制到磁带或另一个磁盘上保存起来的过程</p><p>备用的数据文本称为后备副本或后援副本</p><p><strong>登录日志文件（logging）日志文件（log）是用来记录事务对数据库的更新操作的文件</strong></p><p>如何利用这些冗余数据实施数据库恢复</p><h2 id="恢复策略"><a href="#恢复策略" class="headerlink" title="恢复策略"></a>恢复策略</h2><ol><li>事务故障：事务在运行至正常终止点前被终止。</li></ol><p>恢复策略：由恢复子系统利用日志文件撤消（ UNDO ）此事务已对数据库进行的修改，使得该事务像根本没有启 动过一样。</p><p>事务故障的恢复由系统自动完成，对用户是透明的，不需要用户干预</p><ol start="2"><li>系统故障 造成数据库不一致状态的原因：</li></ol><p>①未完成事务对数据库的更新已写入数据库</p><p>②已提交事务对数据库的更新还留 在 缓冲区没来得及写入数据库。</p><p>恢复策略：</p><p>①Undo 故障发生时未完成的事务</p><p>②Redo 已完成的事务 系统故障的恢复由系统在 重新启动时 自动完成，不需要用户干预</p><ol start="3"><li>介质故障: 称为硬故障，指外存故障，如：磁盘损坏、磁头碰撞、操作系统的某种潜在错误、瞬时强磁场干扰。</li></ol><p>恢复策略：</p><p>①重装数据库</p><p>②重做已完成的事务</p><p>介质故障的恢复需要 DBA 介入，DBA 的工作</p><p>①重装最近转储的数据库副本和有关的各日志文件副本</p><p>②执行系统 提供的恢复命令。具体的恢复操作仍由 DBMS 完成。</p><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;把多条语句作为一个整体进行操作的功能，被称为数据库事务。数据库事务可以确保该事务范围内的所有操作都可以全部成&lt;/p&gt;
&lt;p&gt;功或者全部失败。如果事务失败，那么效果就和没有执行这些SQL一样，不会对数据库数据有任何改动。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_42192693/article/details/109963032&quot;&gt;https://blog.csdn.net/qq_42192693/article/details/109963032&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="http://akkaduilin.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="SQL" scheme="http://akkaduilin.com/tags/SQL/"/>
    
    <category term="数据库" scheme="http://akkaduilin.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="事务" scheme="http://akkaduilin.com/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>语法制导的翻译</title>
    <link href="http://akkaduilin.com/2022/06/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%9A%84%E7%BF%BB%E8%AF%91/"/>
    <id>http://akkaduilin.com/2022/06/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%9A%84%E7%BF%BB%E8%AF%91/</id>
    <published>2022-06-07T01:19:19.000Z</published>
    <updated>2022-06-19T09:16:15.297Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>将语义分析和中间代码生成统称为语义翻译，而语义翻译和语法分析统称为语法制导翻译</p><p><a href="https://blog.csdn.net/qq_33414271/article/details/95333962">https://blog.csdn.net/qq_33414271/article/details/95333962</a></p><span id="more"></span><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><ol><li>语法制导定义SDD：上下文无关文法+属性+规则</li></ol><p><strong>属性：和文法符号相关联</strong><br>每个文法符号都有一个相关的属性集，属性可以代表任何对象：字符串、数字、类型、内存单元或其他对象。<br>与这些属性相关的信息，即属性值可以在语法分析过程中计算和传递。属性加工的过程即语义的处理过程。</p><p><strong>规则：和产生式相关联</strong></p><ol start="2"><li><p>语法制导翻译方案SDT：文法产生式和语义规则交错<br>把语义规则用{}括起来，插入到规则右部的合适位置上，指明了语义规则的计算顺序，以便说明某些实现细节<br>高效、适合用于翻译的实现，一个语义动作在产生式中的位置决定了这个动作的执行时间<br>可以看作是对SDD的一种补充，是SDD的具体实施方案<br>显式地指明了语义规则的计算顺序，以便说明某些实现细节</p></li><li><p>综合属性<br>在分析树结点N上的非终结符A的综合属性只能通过N的子结点或N本身的属性值来定义<br>产生式 E → E1 + T<br>语义规则 E.val =E1.val + T.val<br><a href="https://sm.ms/image/hF23EsDWfGvrqBH" target="_blank"><img src="https://s2.loli.net/2022/06/17/hF23EsDWfGvrqBH.png" ></a></p></li><li><p>继承属性<br>在分析树结点N上的非终结符A的继承属性只能通过 N的父结点、N的兄弟结点或N本身的属性值来定义 。<br>产生式 D →T L<br>语义规则 L.inh= T.typeL<br><a href="https://sm.ms/image/ZkPwGbjzvAaRChV" target="_blank"><img src="https://s2.loli.net/2022/06/17/ZkPwGbjzvAaRChV.png" ></a><br>终结符没有继承属性。终结符从词法分析器处获得的属性值被归为综合属性值。</p></li><li><p>属性依赖图<br>给定一棵语法分析树和一个SDD，我们在各个语法分析树结点所关联的属性实例之间画上边，以指明位于边的头部的属性值要根据位于边的尾部的属性值计算得到。</p></li></ol><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将语义分析和中间代码生成统称为语义翻译，而语义翻译和语法分析统称为语法制导翻译&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_33414271/article/details/95333962&quot;&gt;https://blog.csdn.net/qq_33414271/article/details/95333962&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="编译原理" scheme="http://akkaduilin.com/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="语法制导翻译" scheme="http://akkaduilin.com/tags/%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>编译原理-语法分析</title>
    <link href="http://akkaduilin.com/2022/06/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/"/>
    <id>http://akkaduilin.com/2022/06/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/</id>
    <published>2022-06-07T01:18:47.000Z</published>
    <updated>2022-06-19T09:16:17.732Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><span id="more"></span><h1 id="上下文无关文法定义"><a href="#上下文无关文法定义" class="headerlink" title="上下文无关文法定义"></a>上下文无关文法定义</h1><p><a href="https://sm.ms/image/PNZyGmSsribpeCa" target="_blank"><img src="https://s2.loli.net/2022/06/17/PNZyGmSsribpeCa.png" ></a></p><p>由上下文无关文法生成的语言是上下文无关语言(CFL)。</p><h2 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h2><p><a href="https://sm.ms/image/PSjsKY7DxWOFQG2" target="_blank"><img src="https://s2.loli.net/2022/06/17/PSjsKY7DxWOFQG2.png" ></a></p><h1 id="语法错误处理机制"><a href="#语法错误处理机制" class="headerlink" title="语法错误处理机制"></a>语法错误处理机制</h1><p>一个文法，如果存在某个句子不止一棵分析树，或者说这个句子存在不止一种最左（最右）推导，那么称这个文法是二义的。</p><p><strong>消除二义性</strong></p><p>改写二义文法的关键步骤：</p><p>划分优先级和结合性<br>引入一个新的非终结符，增加一个子结构并提高一级优先级（优先级的判断）；<br>递归非终结符在终结符左边，运算具有左结合性，否则具有右结合性。</p><p><a href="https://sm.ms/image/t2vFunjK5AhaDVQ" target="_blank"><img src="https://s2.loli.net/2022/06/17/t2vFunjK5AhaDVQ.png" ></a></p><h2 id="消除左递归"><a href="#消除左递归" class="headerlink" title="消除左递归"></a>消除左递归</h2><p><a href="https://blog.csdn.net/qq2071114140/article/details/102787831">https://blog.csdn.net/qq2071114140/article/details/102787831</a></p><p>一个文法是左递归的，如果它有非终结符A，对某个串α，存在推导A =&gt; +Aα。</p><p>自顶向下语法分析不能处理左递归的方法，因此需要一个转换方法消除左递归。</p><p><a href="https://sm.ms/image/Wh7RnfweOJlZzpa" target="_blank"><img src="https://s2.loli.net/2022/06/17/Wh7RnfweOJlZzpa.png" ></a></p><p><a href="https://sm.ms/image/rj9nEzqmkOSKJif" target="_blank"><img src="https://s2.loli.net/2022/06/17/rj9nEzqmkOSKJif.png" ></a></p><p>不是之间左递归则转换为直接左递归</p><p>eg：<br>S → Aa | b<br>A → Aad | bd | ε</p><p>S → Aa | b<br>A → bdA’ | A’<br>A’→ adA’ | ε</p><h1 id="自顶向下语法分析"><a href="#自顶向下语法分析" class="headerlink" title="自顶向下语法分析"></a>自顶向下语法分析</h1><h2 id="first-follow集"><a href="#first-follow集" class="headerlink" title="first/follow集"></a>first/follow集</h2><p><a href="https://blog.csdn.net/RENSRM/article/details/111595754">https://blog.csdn.net/RENSRM/article/details/111595754</a></p><p>FIRST(α)被定义为可从α推导得到的串的首符号的集合，其中α是任意的文法符号串<br><a href="https://sm.ms/image/Cr9wlYHtuSze1da" target="_blank"><img src="https://s2.loli.net/2022/06/17/Cr9wlYHtuSze1da.png" ></a><br><a href="https://sm.ms/image/DzglIiXdoB2QhMH" target="_blank"><img src="https://s2.loli.net/2022/06/17/DzglIiXdoB2QhMH.png" ></a></p><p>FOLLOW(A)被定义为可能在某些举行中紧跟在 A 右边的终结符号的集合。<br><a href="https://sm.ms/image/FjSOXfoWsV6iDPv" target="_blank"><img src="https://s2.loli.net/2022/06/17/FjSOXfoWsV6iDPv.png" ></a><br><a href="https://sm.ms/image/wXo9DnCaky1Kh2E" target="_blank"><img src="https://s2.loli.net/2022/06/17/wXo9DnCaky1Kh2E.png" ></a></p><h2 id="构造预测分析表"><a href="#构造预测分析表" class="headerlink" title="构造预测分析表"></a>构造预测分析表</h2><ol><li>当非终结符遇到其First集中的终结符时填入相应候选式</li><li>当非终结符的First集中含有ε元素时，遇到其Follow集中的终结符时填入 非终结符→ ε </li></ol><p><a href="https://sm.ms/image/DC9vnpNFqImTRGi" target="_blank"><img src="https://s2.loli.net/2022/06/17/DC9vnpNFqImTRGi.png" ></a><br><a href="https://sm.ms/image/3Co6gEQvVdpUfNS" target="_blank"><img src="https://s2.loli.net/2022/06/17/3Co6gEQvVdpUfNS.png" ></a></p><h1 id="自底向上语法分析"><a href="#自底向上语法分析" class="headerlink" title="自底向上语法分析"></a>自底向上语法分析</h1><p><a href="https://blog.csdn.net/qq_44202160/article/details/123145144">https://blog.csdn.net/qq_44202160/article/details/123145144</a><br><a href="https://blog.csdn.net/qq_30225253/article/details/106078803">https://blog.csdn.net/qq_30225253/article/details/106078803</a></p><p><a href="https://sm.ms/image/DEBv1YPoQe8LKRW" target="_blank"><img src="https://s2.loli.net/2022/06/17/DEBv1YPoQe8LKRW.png" ></a></p><h2 id="LR语法分析算法"><a href="#LR语法分析算法" class="headerlink" title="LR语法分析算法"></a>LR语法分析算法</h2><p>输入：一个输入串w和一个LR语法分析表。</p><p>输出：如果w在L(G)中，输出w的自底向上语法分析过程中的归约步骤；否则给出错误提示。</p><p>方法：最初，语法分析器栈中的内容为初试状态S0，输入缓冲区的内容为w $。然后，执行语法分析程序。</p><p><a href="https://sm.ms/image/3CDQ4lIWgakO78G" target="_blank"><img src="https://s2.loli.net/2022/06/17/3CDQ4lIWgakO78G.png" ></a><br><a href="https://sm.ms/image/SjPTMxwNdVRAKlz" target="_blank"><img src="https://s2.loli.net/2022/06/17/SjPTMxwNdVRAKlz.png" ></a></p><p>在当前状态(编号)下, 面对当前文法符号时, 该采取什么动作</p><p>ACTION表指明动作, GOTO表仅用于归约时的状态转换</p><p><a href="https://sm.ms/image/vc3yGxOuZDXCiTd" target="_blank"><img src="https://s2.loli.net/2022/06/17/vc3yGxOuZDXCiTd.png" ></a></p><h2 id="SLR分析表"><a href="#SLR分析表" class="headerlink" title="SLR分析表"></a>SLR分析表</h2><p>在右部的某个地方加点的产生式<br>加点的目的是用来表示分析过程中的状态</p><p>例，从A·XYZ文法可得到如下四个项目;<br>A ·XYZ<br>A -&gt; X·YZ<br>A -&gt; XY·Z<br>A -&gt; XYZ·</p><p>拓广文法<br>如果G是一个以S为开始符号的文法, 那么G的拓广文法G’就是在G中加上新开始符号S’和产生式S’ -&gt; S而得到的文法。</p><p>项集闭包的求法<br>如果I是文法G的一个项集，那么CLOSURE(I)就是根据下面的两个规则从I构造得到的项集:：</p><p>一开始，将I中的各个项加入到CLOSURE(I)中。<br>如果A -&gt; α•Bβ在CLOSURE(I)中，B-&gt;γ是一个产生式，并且B-&gt;•γ不在CLOSURE(I)中，就将这个项加入其中。不断应用这个规则，直至没有新项添加。（大概意思就是如果闭包里如果没有希望识别γ的状态，就添加这个状态）</p><p>构造SLR分析表</p><ol><li>构造LR(0)项目核心规范族</li></ol><p>从增广文法添加的那个文法开始求闭包得到 I0</p><p>在接收符号后 · 向后移一位 得到核心项目 非核心项目通过对核心项目求闭包得到 In</p><p><a href="https://sm.ms/image/5uY9VglcPLXp3D7" target="_blank"><img src="https://s2.loli.net/2022/06/17/5uY9VglcPLXp3D7.png" ></a><br><a href="https://sm.ms/image/yciMVDXSqOn7Qdh" target="_blank"><img src="https://s2.loli.net/2022/06/17/yciMVDXSqOn7Qdh.png" ></a></p><ol start="2"><li>构造分析表<br><a href="https://sm.ms/image/wZS4KlgcLC7FHbU" target="_blank"><img src="https://s2.loli.net/2022/06/17/wZS4KlgcLC7FHbU.png" ></a></li></ol><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="编译原理" scheme="http://akkaduilin.com/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="语法分析" scheme="http://akkaduilin.com/tags/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/"/>
    
    <category term="编译原理" scheme="http://akkaduilin.com/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Java ArrayList</title>
    <link href="http://akkaduilin.com/2022/05/23/ArrayList/"/>
    <id>http://akkaduilin.com/2022/05/23/ArrayList/</id>
    <published>2022-05-23T08:01:07.000Z</published>
    <updated>2022-06-19T09:19:05.631Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>Java ArrayList 方法</p><p>sort函数的一些理解</p><p>Comparator接口的用法</p><span id="more"></span><h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><p>ArrayList是实现List接口的，底层采用数组实现。</p><p>ArrayList 实现了Cloneable接口，即覆盖了函数clone()，能被克隆。</p><p>ArrayList 实现java.io.Serializable接口，这意味着ArrayList支持序列化，能通过序列化去传输。</p><p>头文件<br>import java.util.ArrayList;</p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p><a href="https://blog.csdn.net/ly0724ok/article/details/117966154/">https://blog.csdn.net/ly0724ok/article/details/117966154/</a></p><p><a href="https://sm.ms/image/fOX4cxyuBvkgrKb" target="_blank"><img src="https://s2.loli.net/2022/05/23/fOX4cxyuBvkgrKb.png" ></a></p><h1 id="sort自定义排序"><a href="#sort自定义排序" class="headerlink" title="sort自定义排序"></a>sort自定义排序</h1><p>方法原型<br>void java.util.ArrayList.sort(Comparator&lt;? super Contury&gt; c)</p><p>Comparator接口具有比较的功能，接口注重容器<br>而Comparator接口中必须要实现的compare(T o1,T o2)有两个参数</p><p><strong>在数组sort中实现Comparator接口的重写</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">table.sort( new Comparator&lt;Contury&gt;() &#123;</span><br><span class="line">  @Override</span><br><span class="line">  // compare重写</span><br><span class="line">  public int compare(Contury c1,Contury c2)&#123;</span><br><span class="line">      if(c1.gold&gt;c2.gold)&#123;</span><br><span class="line">          return 0;</span><br><span class="line">      &#125;</span><br><span class="line">      else return -1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>直接重写Comparator接口</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class StudentComparator implements Comparator&lt;Student&gt;&#123;  </span><br><span class="line">    @Override  </span><br><span class="line">    public int compare(Student o1, Student o2) &#123;  </span><br><span class="line">        // TODO Auto-generated method stub  </span><br><span class="line">        if(o1.getScore()&gt;o2.getScore())  </span><br><span class="line">            return -1;  </span><br><span class="line">        else if(o1.getScore()&lt;o2.getScore())  </span><br><span class="line">            return 1;  </span><br><span class="line">        else&#123;  </span><br><span class="line">            if(o1.getAge()&gt;o2.getAge())  </span><br><span class="line">                return 1;  </span><br><span class="line">            else if(o1.getAge()&lt;o2.getAge())  </span><br><span class="line">                return -1;  </span><br><span class="line">            else   </span><br><span class="line">                return 0;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p><a href="https://blog.51cto.com/u_15338614/3582482">https://blog.51cto.com/u_15338614/3582482</a></p><h1 id="xx3x"><a href="#xx3x" class="headerlink" title="xx3x"></a>xx3x</h1><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Java ArrayList 方法&lt;/p&gt;
&lt;p&gt;sort函数的一些理解&lt;/p&gt;
&lt;p&gt;Comparator接口的用法&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="http://akkaduilin.com/categories/Java/"/>
    
    
    <category term="Java - ArrayList - Comparator" scheme="http://akkaduilin.com/tags/Java-ArrayList-Comparator/"/>
    
  </entry>
  
  <entry>
    <title>SQL-触发器</title>
    <link href="http://akkaduilin.com/2022/05/16/SQL-%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
    <id>http://akkaduilin.com/2022/05/16/SQL-%E8%A7%A6%E5%8F%91%E5%99%A8/</id>
    <published>2022-05-16T13:33:46.000Z</published>
    <updated>2022-08-21T11:13:35.324Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>触发器与存储过程非常相似，触发器也是 SQL 语句集，它是通过事件进行触发而被执行的，不能用 EXECUTE 语句调用；而存储过程可以通过存储过程名字而被直接调用。当对某一表进行诸如 UPDATE、INSERT、DELETE 这些操作时，SQL Server 就会自动执行触发器所定义的 SQL 语句，从而确保对数据的处理必须符合由这些 SQL 语句所定义的规则。</p><span id="more"></span><h1 id="DML触发器"><a href="#DML触发器" class="headerlink" title="DML触发器"></a>DML触发器</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ol><li><p>AFTER 触发器<br>又称后触发器。在执行了 INSERT、UPDATE 或 DELETE 语句操作之后执行 AFTER<br>触发器。如果仅指定 FOR 关键字，则 AFTER 为默认值。AFTER 触发器只能在表上指定，<br>可以为任何一个 DML 操作定义多个 AFTER 触发器</p></li><li><p>INSTEAD OF 触发器<br>又称替代触发器。INSTEAD OF 触发器在数据变动之前被触发，代替引起触发器执行<br>的 T-SQL 语句，即 INSTEAD OF 触发器执行时并不执行所定义的 INSERT、UPDATE 或<br>DELETE 操作，而仅执行触发器本身。</p></li></ol><h2 id="相关的逻辑表"><a href="#相关的逻辑表" class="headerlink" title="相关的逻辑表"></a>相关的逻辑表</h2><p>Inserted 表用于存储 INSERT 和 UPDATE 语句所影响的行的副本。在插入或更新事务<br>期间，新行将同时被添加到 Inserted 表和触发器表（即对其尝试执行了用户操作的表）。<br>Inserted 表中的行是触发器表中的新行的副本。<br>Deleted 表用于存储 DELETE 和 UPDATE 语句所影响的行的副本。在执行 DELETE<br>或 UPDATE 语句的过程中，行从触发器表中删除，并传输到 Deleted 表中。Deleted 表和触<br>发器表通常没有相同的行。</p><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER trigger_name </span><br><span class="line">ON &#123; OBJECT NAME &#125; </span><br><span class="line">&#123; FOR → AFTER → INSTEAD OF &#125; </span><br><span class="line">&#123;[INSERT][,][UPFATE][,][DELETE]&#125; </span><br><span class="line"> AS </span><br><span class="line">&#123; sql_statement [ ...n ] &#125;</span><br></pre></td></tr></table></figure><p>1） trigger_name ：指定触发器名称<br>2） OBJECT NAME ：要对其执行 DML 触发器的表或视图<br>3） { FOR → AFTER → INSTEAD OF } ：指定触发器的类型，如果仅指定 FOR 关键<br>字，则 AFTER 是默认值<br>4） {[INSERT][,][UPDATE][,][DELETE]} ：指定激活触发器的数据修改语句，必须至少<br>指定一项，在触发器定义中允许使用上述选项的任意顺序组合。<br>5） sql_statement：指定触发器所指定的 T-SQL 语句。<br>6） 在 DML 触发器中不允许使用下列 Transact-SQL 语句：CREATE /ALTER/ DROP<br>DATABASE、CREATE/DROP INDEX、DROP TABLE；用于执行以下操作的 ALTER TABLE：<br>添加、修改或删除列、添加或删除 PRIMARY KEY 或 UNIQUE 约束。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>创建一个触发器，在修改 SC 表中的 grade 列时，判断平均成绩是否大于 80，<br>如果大于 80，拒绝该修改操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER trgUpdateSC ON dbo.SC</span><br><span class="line">FOR UPDATE</span><br><span class="line">AS</span><br><span class="line">begin</span><br><span class="line">  IF UPDATE (Grade)</span><br><span class="line">    BEGIN</span><br><span class="line">    --判断平均 grade 是否大于 80，如果大于 80，回滚</span><br><span class="line">    if(select avg(Grade) from dbo.SC)&gt;80</span><br><span class="line">      begin</span><br><span class="line">      print &#x27;The average value of Grade cannot be more than 80&#x27;</span><br><span class="line">      rollback</span><br><span class="line">      end</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h1 id="DDL触发器"><a href="#DDL触发器" class="headerlink" title="DDL触发器"></a>DDL触发器</h1><p>DDL 触发器当服务器或者数据库中发生数据定义语言（DDL，CREATE、ALTER 和<br>DROP）事件时将被触发。</p><h2 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER trigger_name </span><br><span class="line">ON &#123; ALL SERVER → DATABASE &#125; </span><br><span class="line">[ WITH &lt;ddl_trigger_option&gt; [ ,...n ] ]</span><br><span class="line">&#123; FOR → AFTER &#125; &#123; event_type → event_group &#125; [ ,...n ]</span><br><span class="line">AS &#123; sql_statement [ ; ] [ ,...n ]&#125;</span><br></pre></td></tr></table></figure><p>1） DATABASE :将 DDL 触发器的作用域应用于当前数据库。如果指定了此参数，则<br>只要当前数据库中出现 event_type 或 event_group，就会激发该触发器。<br>2） ALL SERVER :将 DDL 触发器的作用域应用于当前服务器。如果指定了此参数，<br>则只要当前服务器中的任何位置上出现 event_type 或 event_group，就会激发该触发器。<br>3） event_type ：执行之后将导致激发 DDL 触发器的 T-SQL 语言事件的名称。<br>4） event_group ：预定义的 T-SQL 语言事件分组的名称。执行任何属于 event_group<br>的 T-SQL 语言事件之后，都将激发 DDL 触发器。</p><h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h2><p>为“Music”数据库创建 DDL 触发器，用于禁止对数据库中的表进行删除和修改操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER trg_safe ON DATABASE </span><br><span class="line">FOR DROP_TABLE, ALTER_TABLE </span><br><span class="line">AS </span><br><span class="line">PRINT &#x27;You must disable Trigger &quot; trg_safe&quot; to drop or alter tables!&#x27; </span><br><span class="line">ROLLBACK</span><br></pre></td></tr></table></figure><h1 id="管理触发器"><a href="#管理触发器" class="headerlink" title="管理触发器"></a>管理触发器</h1><h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec sp_helptext trg_delete</span><br></pre></td></tr></table></figure><h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ALTER TRIGGER trigger_name</span><br><span class="line">ON &#123; table → view &#125;</span><br><span class="line">&#123; &#123; FOR → AFTER → INSTEAD OF &#125;</span><br><span class="line">&#123; [DELETE] [,] [INSERT] [,] [UPDATE] &#125;</span><br><span class="line">AS</span><br><span class="line">&#123;sql_statement&#125;&#125;</span><br></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TRIGGER Trg_delete</span><br></pre></td></tr></table></figure><h2 id="禁用"><a href="#禁用" class="headerlink" title="禁用"></a>禁用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1）禁用对表的 DML 触发器</span><br><span class="line">DISABLE TRIGGER trg_delete ON Songs</span><br><span class="line"></span><br><span class="line">2）禁用对数据库的 DDL 触发器</span><br><span class="line">DISABLE TRIGGER trig_DDL ON DATABASE</span><br><span class="line"></span><br><span class="line">3）禁用以同一作用域定义的所有触发器</span><br><span class="line">DISABLE TRIGGER ALL ON ALL SERVER</span><br></pre></td></tr></table></figure><p>禁用之后的启用操作，应该使用语句 ENABLE TRIGGER，该语句的参数与对应的禁用语句相同。</p><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;触发器与存储过程非常相似，触发器也是 SQL 语句集，它是通过事件进行触发而被执行的，不能用 EXECUTE 语句调用；而存储过程可以通过存储过程名字而被直接调用。当对某一表进行诸如 UPDATE、INSERT、DELETE 这些操作时，SQL Server 就会自动执行触发器所定义的 SQL 语句，从而确保对数据的处理必须符合由这些 SQL 语句所定义的规则。&lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="http://akkaduilin.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="SQL" scheme="http://akkaduilin.com/tags/SQL/"/>
    
    <category term="数据库" scheme="http://akkaduilin.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Transact-SQL</title>
    <link href="http://akkaduilin.com/2022/05/13/Transact-SQL/"/>
    <id>http://akkaduilin.com/2022/05/13/Transact-SQL/</id>
    <published>2022-05-13T10:52:21.000Z</published>
    <updated>2022-06-19T10:34:12.106Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>SQL Server 在支持标准 SQL 语言的同时，对其进行了扩充，引入了 T-SQL，即 Transact-SQL。通过 T-SQL，可以定义变量、使用流控制语句、自定义函数和存储过程，极大地扩展了 SQL Server 的功能。</p><span id="more"></span><h1 id="语法约定"><a href="#语法约定" class="headerlink" title="语法约定"></a>语法约定</h1><p><a href="https://sm.ms/image/ul2WgxJFGmYLaAs" target="_blank"><img src="https://s2.loli.net/2022/05/13/ul2WgxJFGmYLaAs.png" ></a></p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>注释语句不是可执行语句，不参与程序的编译、注释语句通常是用来说明代码的功能或<br>者对代码的实现方式给出简单的解释和提示。<br>在 T-SQL 中可使用两类注释符：</p><ol><li>“–”用于单行注释；</li><li>“/* */”用于多行注释。“/<em>”用于注释文字的开头，“</em>/”用于注释文字的结束。</li></ol><h1 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h1><p>SQL Server 有两类标识符：<br>1）常规标识符：符合标识符的格式规则。在 T-SQL 语句中使用常规标识符时不用将其<br>分隔开。<br><strong>常规标识符的定义规则如下：</strong><br>  1） 名称的长度可以从 1 到 128（对于本地临时表，标识符最多可以有 116 个字符）。<br>  2） 名称的第一个字符必须是一个字母或者“_”、“@”和“#”中的任意字符。<br>  3） 在中文版 SQL Server 中，可以直接使用中文名称。<br>  4） 名称中不能有空格<br>  5） 不允许使用 SQL Server 的保留字。<br>2）分隔标识符：在 T-SQL 中，不符合常规标识符定义规则的标识符必须用分隔符双引<br>号 (“) 或者方括号 ([ ])分隔，称为分隔标识符。例如：Select * from [my table]中，因为“my<br>table”中间含有空格，不符合常规标识符的定义规则，因此必须用分隔符 ([ ])进行分隔。</p><p><strong>使用</strong><br>[[[server.][database].][owner_name].] object_name<br>1）server：本地服务器；<br>2）database：当前数据库；<br>3）owner_name：在数据库中与当前连接会话登录标识相关联的数据库用户名或数据库<br>所有者（dbo）。<br>例如，需要引用 customer 数据库中 employee 表的 telephone 列，可指定 customer..<br>employee.telephone。</p><h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><ol><li><p>字符串<br>单引号内</p></li><li><p>Unicode字符串<br>与普通字符串类似，前面有N标识</p></li><li><p>二进制常量<br>前有 0x 标识</p></li><li><p>datetime 常量<br>datetime 常量使用特定格式的字符日期值来表示，并被单引号括起来。<br>下面是 datetime 常量的示例：<br>‘December 5, 1985’； ‘5 December, 1985’； ‘12/5/98’<br>‘851205’（其中的 0 不能省略）<br>下面是时间常量的示例：’14:30:24’； ‘04:24 PM’</p></li><li><p>int<br>不包含小数</p></li><li><p>decimal<br>包含小数点的数字</p></li><li><p>float/real<br>科学计数法表示</p></li><li><p>money<br>money 常量以前缀为可选的小数点和可选的货币符号的数字字符串来表示。money 常<br>量不使用引号括起。money 常量的示例：$542023.14，￥30。</p></li></ol><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>声明变量：<br>DECLARE @变量名 变量类型[,@变量名 变量类型…]</p><p>赋值：<br>SET @变量名=表达式<br>或：SELECT @局部变量=变量值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DECLARE @no varchar(10) </span><br><span class="line">--变量赋值</span><br><span class="line">SET @no=&#x27;Bj10001&#x27; </span><br><span class="line">--显示指定学生学号、姓名 </span><br><span class="line">SELECT Sid,Sname FROM student WHERE SID=@no</span><br></pre></td></tr></table></figure><p>全局变量是 SQL Server 系统内部使用的变量，其作用范围并不局限于某一程序，而是<br>任何程序均可随时调用。<br>格式：@@变量名。<br><a href="https://sm.ms/image/muU79kRgsFht4bn" target="_blank"><img src="https://s2.loli.net/2022/05/13/muU79kRgsFht4bn.png" alt="image.png"></a></p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><ol><li><p>ASCII 函数<br>函数格式：<br>ASCII（character_expression）<br>功能：求 character_expression（char 或 varchar 类型）左端第一个字符的 ASCII 码。<br>返回值数据类型：int。例如：<br>Select ASCII（’abcd’） –结果为字符 a 的 ASCII 码 97。</p></li><li><p>CHAR 函数<br>函数格式：<br>CHAR（integer_expression）<br>功能：求 ASCII 码 integer_expression 对应的字符，<br>integer_expression 的有效范围为[0,255]，如果超出范围，则返<br>回值 NULL。<br>返回值数据类型：CHAR。例如：<br>Select CHAR（97） –结果为’a’。<br>CHAR 可用于将控制字符插入字符串中。表 9- 8 显示了<br>一些常用的控制字符。<br>例9- 6: 使用回车符。<br>select ‘<strong>‘+char(13)+’</strong>*’<br>结果如图 9- 1 所示（注意，显示该结果时，在查询编辑器中，<br>需在查询工具栏选择“以文本格式显示结果”）。</p></li><li><p>UNICODE 函数<br>语法:<br>UNICODE ( ‘ncharacter_expression’ )<br>功能：按照 Unicode 标准的定义，返回输入表达式的第一个字<br>符的整数值。<br>返回类型：int。例如：<br>Select unicode(N’kerge’) –返回字符 k 的 unicode 值 107</p></li><li><p>NCHAR 函数<br>语法：NCHAR ( integer_expression )<br>功能: 根据 Unicode 标准所进行的定义，用给定整数代码返回 Unicode 字符。<br>integer_expression 介于 0 与 65535 之间的所有正整数。如果指定了超出此范围的值，将返<br>回 NULL。<br>返回类型：nchar(1)。例如：<br>select nchar(107) –返回 unicode 字符 k</p></li><li><p>CHARINDEX 函数<br>函数格式：<br>CHARINDEX（expression1, expression2[,start]）<br>功能：在 expression2 中由 start 指定的位置开始查找 expression1 第一次出现的位置，如<br>表 9- 8 控制字符及值<br>控制字符 值<br>制表符 CHAR(9)<br>换行符 CHAR(10)<br>回车 CHAR(13)<br>图 9- 1 char 函数示例<br>果没有找到，则返回 0。如果省略 start，或 start≤0，则从 expression2 的第一个字符开始。<br>返回类型：int。例如：<br>Select CHARINDEX(‘ab’, ‘123abc123abc’) –结果为 4。</p></li><li><p>LEFT 函数<br>函数格式：<br>LEFT（expression1,n）<br>功能：返回字符串 expression1 从左边开始 n 个字符组成的字符串。如果 n=0，则返回一<br>个空字符串。<br>返回类型：varchar。例如：<br>LEFT(‘abcde’, 3) –结果为’abc’。 例 9- 7：找出 dbo.student 中名字以’刘’开头的学生信息。<br>select sno,sname from dbo.student where left(sname,1)=’刘’</p></li><li><p>RIGHT 函数<br>函数格式：<br>RIGHT（expression1,n）<br>功能：返回字符串 expression1 从右边开始 n 个字符组成的字符串。如果 n=0，则返回一<br>个空字符串。<br>返回类型：varchar。例如：<br>Select RIGHT(‘abcde’, 3) –结果为’cde’。</p></li><li><p>SUBSTRING 函数<br>函数格式：<br>SUBSTRING（expression1,start,length）<br>功能：返回 expression1（数据类型为字符串、binary、text 或 image）中从 start 开始长<br>度为 length 个字符或字节的子串。<br>返回值：数据类型与 expression1 数据类型相同，但 text 类型返回值为 varchar，image 类<br>型返回值为 varbinary，next 类型返回值为 nvarchar。例如：<br>Select SUBSTRING(‘abcde123’,3,4) –结果为’cde1’。 例 9- 7 也可以写成：<br>select sno,sname from dbo.student where substring(sname,1,1)=’刘’</p></li><li><p>LEN 函数<br>函数格式：<br>LEN（expression1）<br>功能：返回字符串 expression1 中的字符个数，不包括字符串末尾的空格。<br>返回类型：int。例如：<br>Select LEN(‘abcde ‘) –结果为 5。<br>select len(‘刘’) –结果为 1。</p></li><li><p>DATALENGTH 函数<br>DATALENGTH ( expression )<br>功能：返回用于表示任何表达式的字节数。<br>返回类型：int。例如：<br>Select DATALENGTH(‘abcde ‘) –结果为 8（含 3 个空格）。<br>select DATALENGTH(‘刘’) –结果为 2。</p></li><li><p>LOWER 函数<br>函数格式：<br>LOWER（expression1）<br>功能：将字符串 expression1 中的大写字母替换为小写字母。<br>返回类型：varchar。例如：<br>Select LOWER(‘12ABC45*%^def’) –结果为’12abc45*%^def’。</p></li><li><p>UPPER 函数<br>函数格式：<br>UPPER（expression1）<br>功能：将字符串 expression1 中的小写字母替换为大写字母。<br>返回类型：varchar。例如：<br>Select UPPER(‘12ABC45*%^def’) –结果为’12ABC45 *%^DEF’。</p></li><li><p>LTRIM 函数<br>函数格式：<br>LTRIM（expression1）<br>功能：删除字符串 expression1 左端的空格。<br>返回类型：varchar。例如：<br>Select LTRIM(‘ 12AB’) –结果为’12AB’。</p></li><li><p>RTRIM 函数<br>函数格式：<br>RTRIM（expression1）<br>功能：删除字符串 expression1 末尾的空格。<br>返回类型：varchar。例如：<br>Select RTRIM(LTRIM(‘ 12AB ‘)) –结果为’12AB’。</p></li><li><p>REPLACE 函数<br>函数格式：<br>REPLACE（expression1, expression2, expression3）<br>功能：将字符串 expression1 中所有的子字符串 expression2 替换为 expression3。<br>返回值数据类型：varchar。例如：<br>Select REPLACE(‘abcde’,’de’,’12’) –结果为’abc12’。</p></li><li><p>STUFF 函数<br>语法:<br>STUFF (character_expression,start,length,character_expression )<br>功能：删除指定长度的字符并在指定的起始点插入另一组字符。<br>返回类型:如果 character_expression 是一个支持的字符数据类型，则返回字符数据。<br>例如：<br>Select STUFF(‘abcde’,4,2,’12’) –结果为’abc12’。</p></li><li><p>REVERSE 函数<br>函数格式：<br>REVERSE（expression1）<br>功能：按相反顺序返回字符串 expression1 中的字符。<br>返回值数据类型：varchar。例如：<br>Select REVERSE (‘edcba’) –结果为 abcde。</p></li><li><p>SPACE 函数<br>函数格式：<br>SPACE（n）<br>功能：返回包含 n 个空格的字符串，如果 n 为负数，则返回一个空字符串。<br>返回值数据类型：char。</p></li><li><p>STR 函数<br>函数格式：<br>STR（expression1[,length[,decimal]]）<br>功能：将数字数据转换为字符数据。length 为转换得到的字符串总长度，包括符号、小<br>数点、数字或空格。如果数字长度不够，则在左端加入空格补足长度，如果小数部分超过总<br>长度，则进行四舍五入，length 的默认值为 10，decimal 为小数位位数。<br>返回值数据类型：char。例如：<br>select str(123,6) –结果为’ 123’<br>select str(123.456,5) –结果为’ 123’<br>select str(123.456,5,2) –结果为’123.5’<br>select str(123.456,8,2) –结果为’ 123.46’</p></li><li><p>REPLICATE(character_expression,times)<br>语法：<br>REPLICATE(character_expression,times)<br>功能：返回多次复制后的字符表达式。times 参数的计算结果必须为整数。例如：<br>select replicate(‘<em>‘,3) –返回‘</em><em><em>’ 例 9- 8：以“</em>”方式输出菱形。<br>输出结果见 图 9- 2（在查询编辑器中以文本格式显示结果）。<br>declare @i int<br>set @i=1<br>while @i&lt;=4<br>begin<br>print space(4-@i)+<br>replicate(‘<em>‘,2</em>@i-1)<br>set @i=@i+1<br>end<br>set @i=1<br>while @i&lt;=3<br>begin<br>print space(@i)+replicate(‘*’,7-2</em>@i)<br>set @i=@i+1<br>end</p></li><li><p>CAST 函数<br>功能：将一种数据类型的表达式转换为另一种数据类型的表达式。<br>语法：<br>CAST ( expression AS data_type [ (length ) ])<br>例：</p></li></ol><p>–将日期时间类型转换为 char 类型<br>select cast(‘2010-3-2’ as char(10))</p><ol start="22"><li><p>CONVERT 函数<br>CONVERT 函数将一种数据类型的表达式转换为另一种数据类型的表达式。<br>语法：<br>CONVERT ( data_type [ ( length ) ] , expression [ , style ] )</p></li><li><p>ISDATE 函数<br>语法：<br>ISDATE( expression )<br>功能：如果 expression 是 datetime 或 smalldatetime 数据类型的有效日期或时间值，则<br>返回 1；否则，返回 0。例如：<br>select ISDATE(‘2009/2/29’) –返回 0</p></li><li><p>ISNULL ( check_expression , replacement_value )<br>语法：<br>ISNULL ( check_expression , replacement_value )<br>功能：如果 check_expression 不为 NULL，则返回它的值；否则，在将 replacement_value<br>隐式转换为 check_expression 的类型（如果这两个类型不同）后，则返回前者。例如：</p></li></ol><p>–如果成绩为 NULL，替换为 0<br>select grade as 成绩,ISNULL(grade,0) as ISNULL_结果 from sc</p><ol start="25"><li><p>NULLIF 函数<br>NULLIF ( expression , expression )<br>功能：如果两个指定的表达式相等，则返回空值。</p></li><li><p>ISNUMERIC 函数<br>语法：<br>ISNUMERIC ( expression )<br>功能：确定表达式是否为有效的数值类型。</p></li></ol><h2 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h2><ol><li>GETDATE 函数<br>函数格式：<br>图 9- 2 输出菱形<br>GETDATE（）<br>功能：按 SQL Server 内部标准格式返回系统日期和时间。<br>返回值数据类型：datetime。例如：<br>Select getdate() –结果为 2012-08-13 21:51:32.390</li><li>YEAR 函数<br>函数格式：<br>YEAR（date）<br>功能：返回指定日期 date 中年的整数。<br>返回值数据类型：int。例如：<br>Select year(‘2004-3-5’) –结果为 2004<br>例 9- 9：返回学生表中学生的年龄。<br>select sname as 学号, BirthDate as 出生日期,<br>YEAR(getdate())-YEAR(birthdate) as 年龄<br>from dbo.student<br>结果见图 9- 3 所示。</li><li>MONTH 函数<br>函数格式：<br>MONTH（date）<br>功能：返回指定日期 date 中月份的整数。<br>返回值数据类型：int。例如：<br>Select month(‘2004-3-5’) –结果为 3</li><li>DAY 函数<br>函数格式：<br>DAY（date）<br>功能：返回指定日期 date 中天的整数。<br>返回值数据类型：int。例如：<br>Select day(‘2004-3-5’) –结果为 5</li><li>DATENAME 函数<br>函数格式：<br>DATENAME（datepart,date）<br>功能：返回日期 date 中由 datepart 指定的日期部分的字符串。<br>返回类型：nvarchar。</li><li>DATEPART 函数<br>函数格式：<br>DATEPART（dateprrt,date）<br>功能：与 DATENAME 类似，只是返回值为整数。<br>返回值数据类型：int。</li><li>DATEADD 函数<br>函数格式：<br>DATEADD（dateprrt,n,date）<br>功能：在 date 指定日期时间的 datepart 部分加上 n，得到一个新的日期时间值。<br>返回值数据类型：datetime，如果参数 date 为 smalldatetime，则返回值为 smalldatetime<br>类型。参数 datepart 可以使用如表 9- 9 所示中的短语或缩写。例如：<br>Select dateadd(yy,2,’2012-3-4’) –结果为’2014-03-04 00:00:00.000’<br>Select dateadd(m,2,’2012-3-4’) –结果为’2012-05-04 00:00:00.000’<br>Select dateadd(d,2,’2012-3-4’) –结果为’2012-03-06 00:00:00.000’</li><li>DATEDIFF 函数<br>格式：<br>DATEDIFF ( datepart , startdate , enddate )<br>功能：返回指定的 startdate 和 enddate 之间所跨的指定 datepart 边界的计数（带符号<br>的整数）。<br>例 9- 9：返回学生表中学生的年龄。<br>select sname as 学号, BirthDate as 出生日期,<br>DATEDIFF(yy, birthdate,getdate()) as 年龄 from dbo.student</li></ol><p>datepart可选参数<br>日期部分 缩写 日期部分 缩写<br>年份 yy、yyyy 工作日 dw<br>季度 qq、q 小时 hh<br>月份 mm、m 分钟 mi、n<br>每年的某一日 dy、y 秒 ss、s<br>图 9- 3 YEAR 函数示例<br>日期 dd、d 毫秒 ms<br>星期 wk、ww 工作日 dw</p><h1 id="批处理和流程控制语句"><a href="#批处理和流程控制语句" class="headerlink" title="批处理和流程控制语句"></a>批处理和流程控制语句</h1><h2 id="IF…ELSE-语句"><a href="#IF…ELSE-语句" class="headerlink" title="IF…ELSE 语句"></a>IF…ELSE 语句</h2><ol><li>如果满足条件，则在 IF 关键字及其条件之后执行<br>T-SQL 语句。可选的 ELSE 关键字引入另一个 T-SQL 语句，当不满足 IF 条件时就执行该<br>语句。</li><li>在实际程序中，IF…ELSE 语句中不止包含一条语句，而是一组的 SQL 语句。为了可以<br>一次执行一组 SQL 语句，这时就需要使用 BEGIN…END 语句将多条语句封闭起来。</li></ol><p>eg 查找学号为 200215121 的成绩。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">DECLARE @message varchar(255),@grade_num int</span><br><span class="line">--得到 200215121 号同学的选修课程的数目</span><br><span class="line">SELECT @grade_num=COUNT(grade) FROM sc </span><br><span class="line">WHERE sno=&#x27;200215121&#x27;</span><br><span class="line">IF @grade_num=0</span><br><span class="line"> BEGIN</span><br><span class="line">  SET @message= &#x27;没有学生 200215121 的成绩&#x27;</span><br><span class="line">  PRINT @message</span><br><span class="line"> END</span><br><span class="line">ELSE</span><br><span class="line"> BEGIN</span><br><span class="line">  SET @message= &#x27;有学生 200215121 的&#x27;</span><br><span class="line">  + convert(char(2),@grade_num)+ &#x27;门课程的成绩。&#x27;</span><br><span class="line">  PRINT @message</span><br><span class="line"> END</span><br><span class="line">SET @message=&#x27;课程号查询完毕&#x27;</span><br><span class="line">PRINT @message</span><br><span class="line">GO</span><br></pre></td></tr></table></figure><h2 id="CASE-分支语句"><a href="#CASE-分支语句" class="headerlink" title="CASE 分支语句"></a>CASE 分支语句</h2><p>CASE 关键字可根据表达式的真假来确定是否返回某个值，可在允许使用表达式的任意<br>位置使用这一关键字。<br>eg 为学生表的每个院系添加说明。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT sname AS 学号,sdept AS 院系, &#x27;院系说明&#x27;=</span><br><span class="line">CASE sdept</span><br><span class="line">  --分别为各个院系添加说明</span><br><span class="line">  WHEN &#x27;IS&#x27; THEN &#x27;属于信息系&#x27;</span><br><span class="line">  WHEN &#x27;MA&#x27; THEN &#x27;属于数学院&#x27;</span><br><span class="line">  WHEN &#x27;CS&#x27; THEN &#x27;属于计算机科学与技术学院&#x27;</span><br><span class="line">ELSE &#x27;其他院系&#x27;</span><br><span class="line">END </span><br><span class="line">FROM student ORDER BY sname --按照姓名排序</span><br></pre></td></tr></table></figure><h2 id="WHILE-语句"><a href="#WHILE-语句" class="headerlink" title="WHILE 语句"></a>WHILE 语句</h2><p>设置重复执行 SQL 语句或语句块的条件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">WHILE 逻辑表达式</span><br><span class="line">Begin</span><br><span class="line"> T-SQL 语句组</span><br><span class="line">[break] /*终止整个语句的执行*/</span><br><span class="line">[continue] /*结束一次循环体的执行*/</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p>eg 求 1 到 10 之间偶数的和。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">DECLARE @i smallint,@sum smallint</span><br><span class="line">SET @i=0</span><br><span class="line">SET @sum=0</span><br><span class="line">WHILE @i&gt;=0</span><br><span class="line">BEGIN</span><br><span class="line"> SET @i=@i+1</span><br><span class="line"> IF @i&gt;10</span><br><span class="line"> BEGIN</span><br><span class="line">SELECT &#x27;1 到之间偶数的和&#x27;=@sum</span><br><span class="line"> BREAK</span><br><span class="line"> END</span><br><span class="line"> IF (@i%2)!=0</span><br><span class="line"> CONTINUE</span><br><span class="line"> ELSE</span><br></pre></td></tr></table></figure><h2 id="GOTO-语句"><a href="#GOTO-语句" class="headerlink" title="GOTO 语句"></a>GOTO 语句</h2><p>GOTO 语句将执行语句无条件跳转到标签处，并从标签位置继续处理。GOTO 语句和标<br>签可在过程、批处理或语句块中的任何位置使用。其语法格式为：<br>GOTO label</p><h2 id="WAITFOR-语句"><a href="#WAITFOR-语句" class="headerlink" title="WAITFOR 语句"></a>WAITFOR 语句</h2><p>WAITFOR 语句，称为延迟语句，就是暂停执行一个指定的时间间隔或者到一个指定的时间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">WAITFOR </span><br><span class="line">&#123; </span><br><span class="line">DELAY &#x27;time_to_pass&#x27; /* 设定等待时间 */</span><br><span class="line"></span><br><span class="line">| TIME &#x27;time_to_execute&#x27; /* 设定等待到某一时刻 */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">延迟 30 秒执行查询。</span><br><span class="line">WAITFOR DELAY &#x27;00:00:30&#x27;</span><br><span class="line">SELECT * FROM student</span><br></pre></td></tr></table></figure> <h2 id="TRY-CATCH"><a href="#TRY-CATCH" class="headerlink" title="TRY-CATCH"></a>TRY-CATCH</h2><p>TRY 块包含一组 T-SQL 语句。如果 TRY 块的语句中发生任何错误，控制将传递给CATCH 块。CATCH 块包含另外一组语句，这些语句在错误发生时执行。如果 TRY 块中没有错误，控制将传递到关联的 END CATCH 语句后紧跟的语句。如果 END CATCH 语句是存储过程或触发器中的最后一条语句，控制将传递到调用该存储过程或触发器的语句。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">BEGIN TRY </span><br><span class="line">&#123; sql_statement | statement_block &#125; </span><br><span class="line">END TRY</span><br><span class="line">BEGIN CATCH </span><br><span class="line">&#123; sql_statement | statement_block &#125; </span><br><span class="line">END CATCH [ ; ]</span><br><span class="line"></span><br></pre></td></tr></table></figure> <h2 id="Raiserror"><a href="#Raiserror" class="headerlink" title="Raiserror"></a>Raiserror</h2><p>有时会遇到 SQL SERVER 实际并不知道的一些错误，但我们希望能在客户端产生运行错误，而客户端使用的时候能够唤醒异常处理并进行相应的处理。RAISERROR 生成的错误与数据库引擎代码生成的错误的运行方式相同。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">RAISERROR(&lt;message ID | message_string&gt;, &lt;severity #级别 &gt;,&lt;state #状态 &gt; [,&lt;argument&gt; </span><br><span class="line">[,&lt;…n&gt;]]) </span><br><span class="line">[WITH option[,…n]]</span><br></pre></td></tr></table></figure><h1 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h1><p>游标（Cursor）是一种从包括多条数据记录的结果集中每次提取一条记录以便处理的机<br>制，可以看做是查询结果的记录指针。<br><strong>游标的作用：</strong><br>1） 允许定位在结果集的特定行。<br>2） 从结果集的当前位置检索一行或一部分行。<br>3） 支持对结果集中当前位置的行进行数据修改。<br>4） 为由其他用户对显示在结果集中的数据所做的更改提供不同级别的可见性支持。<br>5） 提供脚本、存储过程和触发器中用于访问结果集中的数据的 T-SQL 语句。</p><p><strong>@@FETCH_STATUS 全局变量</strong>返回上次执行 FETCH 命令的状态。在每次用 FETCH 从<br>游标中读取数据时，都应检查该变量，以确定上次 FETCH 操作是否成功，来决定如何进行<br>下一步处理。@@FETCH_STATUS 变量有三个不同的返回值: 1）返回值为 0，说明 FETCH 语句成功。<br>2）返回值为-1，说明 FETCH 语句失败或行不在结果集中。<br>3）返回值为-2，说明提取的行不存在。</p><p>利用游标将成绩表（SC）中不及格的成绩改为 60 分。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">--声明变量</span><br><span class="line">declare @v_sno varchar(10),</span><br><span class="line">@v_cno varchar(10),@v_grade int</span><br><span class="line">--声明游标</span><br><span class="line">declare cur scroll cursor</span><br><span class="line">for select sno,cno,grade from sc</span><br><span class="line">--打开游标</span><br><span class="line">open cur</span><br><span class="line">--取出第一行记录</span><br><span class="line">fetch next from cur into @v_sno,@v_cno,@v_grade</span><br><span class="line">--循环取值</span><br><span class="line">while @@FETCH_STATUS=0</span><br><span class="line">begin</span><br><span class="line">--判断当前记录的成绩值</span><br><span class="line">if @v_grade&lt;60</span><br><span class="line"> begin </span><br><span class="line">--显示修改前的成绩</span><br><span class="line"> select sno as 学号,cno as 课程号,grade as 更改前的成绩</span><br><span class="line"> from sc where sno=@v_sno and cno=@v_cno</span><br><span class="line">--修改游标所在行的成绩</span><br><span class="line">update sc set grade=60 where current of cur</span><br><span class="line">--显示修改后的成绩</span><br><span class="line"> select sno as 学号,cno as 课程号,grade as 更改后的成绩</span><br><span class="line"> from sc where sno=@v_sno and cno=@v_cno</span><br><span class="line"> end</span><br><span class="line">--取下一行记录</span><br><span class="line">fetch next from cur into @v_sno,@v_cno,@v_grade</span><br><span class="line">end</span><br><span class="line">--关闭游标</span><br><span class="line">close cur</span><br><span class="line">--释放游标</span><br><span class="line">deallocate cur</span><br></pre></td></tr></table></figure><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SQL Server 在支持标准 SQL 语言的同时，对其进行了扩充，引入了 T-SQL，即 Transact-SQL。通过 T-SQL，可以定义变量、使用流控制语句、自定义函数和存储过程，极大地扩展了 SQL Server 的功能。&lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="http://akkaduilin.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="SQL" scheme="http://akkaduilin.com/tags/SQL/"/>
    
    <category term="数据库" scheme="http://akkaduilin.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理-运算方法</title>
    <link href="http://akkaduilin.com/2022/04/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/"/>
    <id>http://akkaduilin.com/2022/04/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/</id>
    <published>2022-04-24T06:25:34.000Z</published>
    <updated>2022-06-19T09:17:19.612Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>计算机组成与结构课程笔记</p><span id="more"></span><h1 id="原码、反码、补码"><a href="#原码、反码、补码" class="headerlink" title="原码、反码、补码"></a>原码、反码、补码</h1><ol><li>原码<br>原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:</li></ol><p>[+1]原 = 0000 0001</p><p>[-1]原 = 1000 0001</p><p>第一位是符号位. 因为第一位是符号位, 所以8位二进制数的取值范围就是:</p><p>[1111 1111 , 0111 1111]</p><p>即</p><p>[-127 , 127]</p><p>原码是人脑最容易理解和计算的表示方式.</p><ol start="2"><li>反码<br>反码的表示方法是:</li></ol><p>正数的反码是其本身</p><p>负数的反码是在其原码的基础上, 符号位不变，其余各个位取反.</p><p>[+1] = [00000001]原 = [00000001]反</p><p>[-1] = [10000001]原 = [11111110]反</p><p>可见如果一个反码表示的是负数, 人脑无法直观的看出来它的数值. 通常要将其转换成原码再计算.</p><ol start="3"><li>补码<br>补码的表示方法是:</li></ol><p>正数的补码就是其本身</p><p>负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)</p><p>[+1] = [00000001]原 = [00000001]反 = [00000001]补</p><p>[-1] = [10000001]原 = [11111110]反 = [11111111]补</p><p>对于负数, 补码表示方式也是人脑无法直观看出其数值的. 通常也需要转换成原码在计算其数值.</p><h1 id="加减法溢出处理"><a href="#加减法溢出处理" class="headerlink" title="加减法溢出处理"></a>加减法溢出处理</h1><p><a href="https://sm.ms/image/nNip3D4zq6t8CIX" target="_blank"><img src="https://s2.loli.net/2022/04/25/nNip3D4zq6t8CIX.png" ></a></p><p>fa fb 两操作数的符号位<br>Cf 为符号位的进位<br>C 为数值最高位的进位</p><ol><li>符号相同，结果符号位与加数符号位不同，溢出</li><li>任意符号两数相加，Cf 不等于 C 溢出</li><li>双符号位f1 f2 正数为00 负数为11 符号位参与运算 结果 f1 f2 不相等，溢出<br><a href="https://sm.ms/image/Mc7uPzleO1vfNSR" target="_blank"><img src="https://s2.loli.net/2022/04/25/Mc7uPzleO1vfNSR.png" ></a></li></ol><h1 id="乘法、除法"><a href="#乘法、除法" class="headerlink" title="乘法、除法"></a>乘法、除法</h1><h2 id="定点乘法"><a href="#定点乘法" class="headerlink" title="定点乘法"></a>定点乘法</h2><ol><li><p>手工算法<br><a href="https://sm.ms/image/OYLmCwtvenBGKX4" target="_blank"><img src="https://s2.loli.net/2022/04/25/OYLmCwtvenBGKX4.png" ></a></p></li><li><p>定点原码一位乘法<br><a href="https://sm.ms/image/4VhK8T6pauRebyw" target="_blank"><img src="https://s2.loli.net/2022/04/25/4VhK8T6pauRebyw.png" ></a></p></li><li><p>定点补码一位乘法<br>布斯算法<br><a href="https://blog.csdn.net/qq_41844076/article/details/109594076">https://blog.csdn.net/qq_41844076/article/details/109594076</a></p></li></ol><h2 id="定点除法"><a href="#定点除法" class="headerlink" title="定点除法"></a>定点除法</h2><ol><li><p>手工算法<br><a href="https://sm.ms/image/5KX1bTh2tz9Ovj4" target="_blank"><img src="https://s2.loli.net/2022/04/25/5KX1bTh2tz9Ovj4.png" ></a></p></li><li><p>加减交替法<br><a href="https://sm.ms/image/w9F68ncKEaPxBUg" target="_blank"><img src="https://s2.loli.net/2022/04/25/w9F68ncKEaPxBUg.png" ></a></p></li></ol><h1 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h1><p><a href="http://kaito-kidd.com/2018/08/08/computer-system-float-point/">http://kaito-kidd.com/2018/08/08/computer-system-float-point/</a></p><p><a href="https://sm.ms/image/LiutGTOhM2p89Pq" target="_blank"><img src="https://s2.loli.net/2022/04/25/LiutGTOhM2p89Pq.png" ></a></p><p>Ms 为符号位 0正1负<br>E 为阶码 8位以2为底，阶码 = 阶码真值 + 127<br>M 为尾数 23位，采用隐含尾数最高位1的表示方法，<br>实际尾数24位，尾数真值 = 1 + 尾数</p><p>单精度浮点数 float：32 位，符号位 Ms 占 1 bit，指数 E 占 8 bit，尾数 M 占 23 bit<br>双精度浮点数 float：64 位，符号位 Ms 占 1 bit，指数 E 占 11 bit，尾数 M 占 52 bit</p><p><a href="https://sm.ms/image/wSd3TPiebLayWMI" target="_blank"><img src="https://s2.loli.net/2022/04/25/wSd3TPiebLayWMI.png" ></a></p><h2 id="移码"><a href="#移码" class="headerlink" title="移码"></a>移码</h2><p>阶码采用移码<br>尾数采用原码或补码</p><p>移码：<br><strong>补码的符号位取反</strong><br>最高位为符号位<br>只执行加减运算，加以2^n的修正量<br><a href="https://sm.ms/image/2o4zguAIMrUP7lN" target="_blank"><img src="https://s2.loli.net/2022/04/25/2o4zguAIMrUP7lN.png" ></a><br><a href="https://sm.ms/image/IAx7zFtaqHSn4TP" target="_blank"><img src="https://s2.loli.net/2022/04/26/IAx7zFtaqHSn4TP.png" ></a></p><h2 id="精度、范围"><a href="#精度、范围" class="headerlink" title="精度、范围"></a>精度、范围</h2><p><a href="https://blog.csdn.net/l1028386804/article/details/113065755">https://blog.csdn.net/l1028386804/article/details/113065755</a></p><p><a href="https://sm.ms/image/UG82NABqjEu1tKp" target="_blank"><img src="https://s2.loli.net/2022/04/25/UG82NABqjEu1tKp.png" ></a></p><p>单精度浮点数 32 位<br>符号位1位，阶码8位，尾数23位。<br>精度24位，范围 -2^127 - (1-(2^-23))*2^127</p><h2 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h2><ol><li><p>对阶</p></li><li><p>尾数的计算(加减乘除)</p></li><li><p>规格化处理<br>如果<strong>结果的两个符号位的值不同</strong>,表示运算尾数结果溢出,应“右规”,即尾数结果右移一位,阶码+1。</p></li></ol><p>如果<strong>最高数值位与符号位相同</strong>,应“左规”,此时尾数连续左移,直到最高数值位与符号位的值不同为止;同时从阶码中减去移位的位数。</p><ol start="4"><li><p>舍入<br>截断处理:无条件地丢掉正常尾数最低位之后的全部数值<br>舍入处理:运算过程中保留右移中移出的若干高位的值,然而再按某种规则用这些位上的值修正尾数</p></li><li><p>判断溢出</p></li></ol><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;计算机组成与结构课程笔记&lt;/p&gt;</summary>
    
    
    
    <category term="计算机组成原理" scheme="http://akkaduilin.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="运算方法" scheme="http://akkaduilin.com/tags/%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成笔记-主存储器</title>
    <link href="http://akkaduilin.com/2022/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E7%AC%94%E8%AE%B0-%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8/"/>
    <id>http://akkaduilin.com/2022/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E7%AC%94%E8%AE%B0-%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8/</id>
    <published>2022-04-23T07:59:21.000Z</published>
    <updated>2022-06-19T09:17:01.448Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>计算机组成原理</p><p>主存储器</p><p><a href="https://sm.ms/image/UQvDjshEwNZuA92" target="_blank"><img src="https://s2.loli.net/2022/04/23/UQvDjshEwNZuA92.jpg" ></a></p><span id="more"></span><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><a href="https://sm.ms/image/nJjHB8GmbpCu14X" target="_blank"><img src="https://s2.loli.net/2022/04/23/nJjHB8GmbpCu14X.jpg" alt="Screenshot 2022-04-12 144845.jpg"></a></p><ol><li><p>主要指标：主存容量、储存器存储时间(启动一次读写操作到完成该操作的时间)、存储周期(连续启动两次独立的储存器操作所需间隔的最小时间)</p></li><li><p>一个字节 = 8个二进制位</p></li><li><p>总线：地址总线、数据总线、控制总线 连接主存储器和CPU</p></li><li><p>AR(地址寄存器)K位 DR(数码寄存器)n位 允许主存包含2^K个可寻址的字节 在一个存储周期内，CPU和主存通过总线进行n位数据传送。</p></li></ol><h1 id="RAM"><a href="#RAM" class="headerlink" title="RAM"></a>RAM</h1><p>半导体读/写存储器按存储元件在运行中能否长时间保存信息来分为静态存储器（SRAM）和动态存储器（DRAM）。<br>其中SRAM利用双稳态触发器来保存信息,而且只要不断电,信息不会丢失,<br>DRAM使用MOS电容来保存信息,使用时需要不断给电容充电。</p><p><a href="https://sm.ms/image/pu7XfFymj3beQW9" target="_blank"><img src="https://s2.loli.net/2022/04/23/pu7XfFymj3beQW9.jpg" ></a></p><h2 id="SRAM"><a href="#SRAM" class="headerlink" title="SRAM"></a>SRAM</h2><p>静态RAM是利用双稳态触发器来记忆信息的。六管静态MOS记忆单元电路中的T1～T4组成两个反相器，交叉耦合连接成一个触发器；T1～T6管构成一个记忆单元的主体，能存放一位二进制信息。</p><h3 id="SRAM的读写"><a href="#SRAM的读写" class="headerlink" title="SRAM的读写"></a>SRAM的读写</h3><p><a href="https://sm.ms/image/TcMNbC6OUJIL1ik" target="_blank"><img src="https://s2.loli.net/2022/04/23/TcMNbC6OUJIL1ik.png" ></a></p><p>存储单元未被选中时，字选择线保持低电位，两位线保持高电位；单元被选中时，字选择线保持高电位。<br><a href="https://sm.ms/image/LHjvTfwScrnu2X7" target="_blank"><img src="https://s2.loli.net/2022/04/23/LHjvTfwScrnu2X7.png" ></a></p><p>由存储单元组成的存储器结构和功能表如下:</p><p><a href="https://sm.ms/image/g1dLcKMHYA46eSX" target="_blank"><img src="https://s2.loli.net/2022/04/23/g1dLcKMHYA46eSX.png" ></a></p><h3 id="读写时序"><a href="#读写时序" class="headerlink" title="读写时序"></a>读写时序</h3><p><a href="https://sm.ms/image/1mBpUZ6OlN3zSoe" target="_blank"><img src="https://s2.loli.net/2022/04/23/1mBpUZ6OlN3zSoe.jpg" ></a></p><p><a href="https://sm.ms/image/9dAgNRVwfpqcYKF" target="_blank"><img src="https://s2.loli.net/2022/04/23/9dAgNRVwfpqcYKF.jpg" ></a></p><h2 id="DRAM"><a href="#DRAM" class="headerlink" title="DRAM"></a>DRAM</h2><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><strong>储存单元</strong></p><p><a href="https://sm.ms/image/8c2nm7i9VG1AJvs" target="_blank"><img src="https://s2.loli.net/2022/04/23/8c2nm7i9VG1AJvs.png" ></a></p><p><strong>写入</strong>: 字线为高电平,T导通<br>写1: 位线为低电平,VDD通过T对Cs充电，  电容中有电荷则保持不变。<br>写0: 位线为高电平,Cs通过T放电，电容中无电荷则不变。</p><p><strong>读出</strong>:位线预充电至高电平; 当字线出现高电平后,T导通,若原来Cs充有电荷,则Cs放电,使位线电位下降,经放大后,读出为1; 若原来Cs上无电荷,则位线无电位变化,放大器无输出,读出为0。<br>读出后,若原来Cs充有电荷也被放掉了,和没有充电一样,因此读出是破坏性的,故读出后要立即对单元进行“重写”,以恢复原信息。</p><p><strong>储存器</strong></p><p>16K由两个64*128矩阵组成<br>WE为允许信号，若为0，执行写操作，Din通过T7T8以及T5T6进入单元<br>为1执行读操作，单元的状态通过位线1 位线2和T7T8传至读放<br>若CS = 1 不进行读写操作<br><a href="https://sm.ms/image/BSKJy8L15fWlOd4" target="_blank"><img src="https://s2.loli.net/2022/04/23/BSKJy8L15fWlOd4.png" ></a></p><h3 id="刷新"><a href="#刷新" class="headerlink" title="刷新"></a>刷新</h3><p><a href="https://sm.ms/image/3jAh5Px18slzZIi" target="_blank"><img src="https://s2.loli.net/2022/04/23/3jAh5Px18slzZIi.jpg" ></a></p><h2 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h2><ol><li><p>SDRAM —— 同步动态随机读写存储器<br>将CPU与RAM通过一个相同的时钟信号锁在一起，使RAM和CPU能够共享一个时钟周期，以相同的速度同步工作。在每一个时钟脉冲的上升沿开始传送数据。</p></li><li><p>DDR —— 双倍数据传输速率同步动态随机存储器<br>是SDRAM的一种新技术。<br>可在同一时钟周期的上升和下降沿都能传送数据，同样时间内的数据传送量翻了一倍。</p></li></ol><h1 id="ROM"><a href="#ROM" class="headerlink" title="ROM"></a>ROM</h1><p>停电时信息不丢失的存储器称为非易失性存储器。<br>可分为ROM、 PROM、EPROM、 E2 PROM 和 flash memory。</p><p>芯片的内容在制造时已经输入，只能读，不能修改。<br>存储原理：是根据元件的有无来表示该存储单元的信息（1或0）。<br>存储元件：二极管或晶体管</p><h1 id="容量扩展"><a href="#容量扩展" class="headerlink" title="容量扩展"></a>容量扩展</h1><p>1 bit  = 8 位</p><p><strong>数据线数目 = 芯片位长</strong></p><p><strong>存储器容量=字数*位长</strong></p><p><strong>地址线数 = log2(字数)</strong></p><h2 id="位扩展"><a href="#位扩展" class="headerlink" title="位扩展"></a>位扩展</h2><p>位扩展指只在位数方向扩展（加大字长），而芯片的字数和存储器的字数是一致的。位扩展的连接方式是将各存储芯片的地址线、片选线和读/写线相应地并联起来，而将各芯片的数据线单独列出。</p><p>eg:</p><p>两个16K* 4位的芯片采用位扩展方式扩展成一16K * 8 位的存储器。如下图所示。 16K * 4位的芯片的字长为4位，所以有4条数据线，分别用D0<del>D3和D4</del>D7表示；容量为16K = 2^14 ，有14条地址线，用A0~A13 表示。</p><p><a href="https://sm.ms/image/9GQzPrZYRTU6dtp" target="_blank"><img src="https://s2.loli.net/2022/04/23/9GQzPrZYRTU6dtp.png" ></a></p><h2 id="字扩展"><a href="#字扩展" class="headerlink" title="字扩展"></a>字扩展</h2><p>字扩展是指仅在容量方向扩展，而位数不变。字扩展将芯片的地址线、数据线、读/写线并联，由片选信号来区分各个芯片。64K<em>8位的存储器需要4个16K</em>8位芯片组成，连接图如下。</p><p><a href="https://sm.ms/image/CBHkpyxucihlNUZ" target="_blank"><img src="https://s2.loli.net/2022/04/23/CBHkpyxucihlNUZ.png" ></a></p><p>数据线D0 - D7线与各片的数据端相连，地址总线（共16条）低位A0 -A13 与各芯片的14个地址端相连，两位高位A14和A15经过译码器和4个片选端相连。<br>在同一时间内四个芯片中只能有一个芯片被选中。</p><h2 id="同时扩展"><a href="#同时扩展" class="headerlink" title="同时扩展"></a>同时扩展</h2><p>当构成一个容量较大的存储器时，往往需要在字方向和位方向上同时扩展，这将是前两种扩展的组合，实现起来也是很容易的。</p><p>一个存储器的容量为M<em>N位，若使用L</em>K位存储器芯片，需要(M/L)*(N/K)个芯片</p><p>如用16K×4位的SRAM组成64K×8位的存储器，需要8个芯片。</p><h1 id="xx3x"><a href="#xx3x" class="headerlink" title="xx3x"></a>xx3x</h1><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;计算机组成原理&lt;/p&gt;
&lt;p&gt;主存储器&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://sm.ms/image/UQvDjshEwNZuA92&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://s2.loli.net/2022/04/23/UQvDjshEwNZuA92.jpg&quot; &gt;&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="计算机组成原理" scheme="http://akkaduilin.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="主存储器" scheme="http://akkaduilin.com/tags/%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>节点选择</title>
    <link href="http://akkaduilin.com/2022/04/04/%E8%8A%82%E7%82%B9%E9%80%89%E6%8B%A9/"/>
    <id>http://akkaduilin.com/2022/04/04/%E8%8A%82%E7%82%B9%E9%80%89%E6%8B%A9/</id>
    <published>2022-04-04T09:39:27.000Z</published>
    <updated>2022-04-24T06:28:14.389Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>问题描述</p><p>有一棵 n 个节点的树，树上每个节点都有一个正整数权值。如果一个点被选择了，那么在树上和它相邻的点都不能被选择。求选出的点的权值和最大是多少？</p><span id="more"></span><p>输入格式<br>第一行包含一个整数 n 。<br>接下来的一行包含 n 个正整数，第 i 个正整数代表点 i 的权值。<br>接下来一共 n-1 行，每行描述树上的一条边。</p><p>输出格式<br>输出一个整数，代表选出的点的权值和的最大值。</p><p>样例输入<br>5<br>1 2 3 4 5<br>1 2<br>1 3<br>2 4<br>2 5</p><p>样例输出<br>12</p><p>样例说明<br>选择3、4、5号点，权值和为 3+4+5 = 12 。</p><p>数据规模与约定<br>对于20%的数据， n &lt;= 20。<br>对于50%的数据， n &lt;= 1000。<br>对于100%的数据， n &lt;= 100000。<br>权值均为不超过1000的正整数</p><p><a href="https://www.cnblogs.com/program-ccc/p/5221932.html">https://www.cnblogs.com/program-ccc/p/5221932.html</a></p><p>状态转移方程：</p><p>dp[x][1] = dp[x][1] + dp[u][0]  (u为x的子结点)</p><p>dp[x][0] = dp[x][0] + max{dp[u][0],dp[u][1]}(u为x的子结点)</p><figure class="highlight plaintext"><figcaption><span>[结点选择] [lang:C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN=8;</span><br><span class="line">int w[MAXN]; // 各点的权值</span><br><span class="line">vector&lt;int&gt; tree[MAXN]; // 数组下标对应的向量存贮该下标结点的邻接点</span><br><span class="line">int n;</span><br><span class="line">int dp[MAXN][2]; //dp[u][1] 存储 选了自己结点u的权值最大值 dp[u][0]存储不选结点u权值和</span><br><span class="line">int vis[MAXN]; // 判断是否遍历过</span><br><span class="line"></span><br><span class="line">void dfs(int u) // 结点u的dfs</span><br><span class="line">&#123;</span><br><span class="line">    vis[u]=1; </span><br><span class="line">    dp[u][0]=0;</span><br><span class="line">    dp[u][1]=w[u];</span><br><span class="line">    int s0=0,s1=0;</span><br><span class="line">    for(int i=0;i&lt;tree[u].size();i++) // 遍历结点u邻接结点v</span><br><span class="line">    &#123;</span><br><span class="line">        int v=tree[u][i]; </span><br><span class="line">        if(!vis[v])</span><br><span class="line">        &#123;</span><br><span class="line">            dfs(v); // 结点v的dfs</span><br><span class="line">            s0+=max(dp[v][0],dp[v][1]);</span><br><span class="line">            s1+=dp[v][0];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[u][0]+=s0;</span><br><span class="line">    dp[u][1]+=s1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;w[i]);</span><br><span class="line">    </span><br><span class="line">    for(int i=1;i&lt;=n-1;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int u,v;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;u,&amp;v);</span><br><span class="line">        tree[u].push_back(v);</span><br><span class="line">        tree[v].push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs(1);</span><br><span class="line">    </span><br><span class="line">    printf(&quot;%d\n&quot;,max(dp[1][0],dp[1][1]));</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;问题描述&lt;/p&gt;
&lt;p&gt;有一棵 n 个节点的树，树上每个节点都有一个正整数权值。如果一个点被选择了，那么在树上和它相邻的点都不能被选择。求选出的点的权值和最大是多少？&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="http://akkaduilin.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="C++" scheme="http://akkaduilin.com/tags/C/"/>
    
    <category term="树形DP" scheme="http://akkaduilin.com/tags/%E6%A0%91%E5%BD%A2DP/"/>
    
  </entry>
  
  <entry>
    <title>归并排序实战——逆序对问题</title>
    <link href="http://akkaduilin.com/2022/04/04/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E9%80%86%E5%BA%8F%E5%AF%B9%E9%97%AE%E9%A2%98/"/>
    <id>http://akkaduilin.com/2022/04/04/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E9%80%86%E5%BA%8F%E5%AF%B9%E9%97%AE%E9%A2%98/</id>
    <published>2022-04-04T09:38:03.000Z</published>
    <updated>2022-06-19T09:16:43.301Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>关于逆序对问题的题解和思路</p><span id="more"></span><p><strong>归并排序原算法指路：</strong></p><a href="/2021/12/01/%E6%8E%92%E5%BA%8F/" title="五种排序">五种排序</a><a href="/2021/12/01/%E6%8E%92%E5%BA%8F/" title="排序">排序</a><p><strong>逆序对：设a[0…n]为包含n个不数的一个序列，如果n&lt;m，且a[n]&gt;a[m],则称(n,m)构成a中的一个逆序对；</strong></p><p><a href="https://www.jb51.net/article/55283.htm">https://www.jb51.net/article/55283.htm</a></p><p>归并排序思想，先递归分治至两个数组内再依次返回排序比较<br>注意若左边数组大于右边数组，总计数应加上 <strong>mid - index1 + 1</strong><br>因为右数组是有序的，当左指针移动时会出现多个逆序对的情况，所以加上中间指针下标减去右指针所在下标加上1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int array[] = &#123;3, 9, 7, 4, 5, 2&#125;;</span><br><span class="line">const int size = sizeof array / sizeof *array;</span><br><span class="line">int temp[size];</span><br><span class="line">//int numbers[size];</span><br><span class="line"></span><br><span class="line">int reversePair(int *numbers, int start, int last, int &amp;index, int &amp;count)</span><br><span class="line">&#123;</span><br><span class="line">  if(start == last)</span><br><span class="line">  return 0;</span><br><span class="line">  int mid = (last - start) / 2 + start;</span><br><span class="line">  //递归分治</span><br><span class="line">  reversePair(numbers, start, mid, index, count);</span><br><span class="line">  reversePair(numbers, mid + 1, last, index, count);</span><br><span class="line"></span><br><span class="line">  for(int i = start; i &lt;= last; i++)</span><br><span class="line">    temp[i] = numbers[i];</span><br><span class="line"></span><br><span class="line">  int index1 = start, index2 = mid + 1;</span><br><span class="line">  index = start;</span><br><span class="line">  while(index1 &lt;= mid &amp;&amp; index2 &lt;= last) &#123;</span><br><span class="line">    if(temp[index1] &gt; temp[index2]) &#123;</span><br><span class="line">      numbers[index] = temp[index2];//将值较小的优先排入数组，起到排序作用</span><br><span class="line">      count += mid - index1 + 1;</span><br><span class="line">      index++;</span><br><span class="line">      index2++;</span><br><span class="line">    &#125; </span><br><span class="line">    else if(temp[index1] == temp[index2]) &#123;</span><br><span class="line">      numbers[index] = temp[index1];</span><br><span class="line">      index++;</span><br><span class="line">      index1++;</span><br><span class="line">      index2++;</span><br><span class="line">    &#125; </span><br><span class="line">    else if(temp[index1] &lt; temp[index2]) &#123;</span><br><span class="line">      numbers[index] = temp[index1];</span><br><span class="line">      index++;</span><br><span class="line">      index1++;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(index1 &lt;= mid) &#123;</span><br><span class="line">      while(index1 &lt;= mid) &#123;</span><br><span class="line">        numbers[index] = temp[index1];</span><br><span class="line">        index++;</span><br><span class="line">        index1++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    else &#123;</span><br><span class="line">      while(index2 &lt;= last) &#123;</span><br><span class="line">        numbers[index] = temp[index2];</span><br><span class="line">        index++;</span><br><span class="line">        index2++;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">  int count = 0;</span><br><span class="line">  int index = 0;</span><br><span class="line">  reversePair(array, 0, size - 1, index, count);</span><br><span class="line">  cout &lt;&lt; &quot;count = &quot; &lt;&lt; count &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关于逆序对问题的题解和思路&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="http://akkaduilin.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="C++" scheme="http://akkaduilin.com/tags/C/"/>
    
    <category term="归并排序" scheme="http://akkaduilin.com/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    
    <category term="逆序对" scheme="http://akkaduilin.com/tags/%E9%80%86%E5%BA%8F%E5%AF%B9/"/>
    
  </entry>
  
  <entry>
    <title>Java GUI</title>
    <link href="http://akkaduilin.com/2022/04/02/Java%20GUI/"/>
    <id>http://akkaduilin.com/2022/04/02/Java%20GUI/</id>
    <published>2022-04-02T01:29:22.000Z</published>
    <updated>2022-06-19T09:19:37.666Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>Swing 是一个为Java设计的GUI工具包。</p><p>Swing是JAVA基础类的一部分。</p><p>Swing包括了图形用户界面（GUI）器件如：文本框，按钮，分隔窗格和表。</p><p><a href="http://c.biancheng.net/view/1209.html">http://c.biancheng.net/view/1209.html</a></p><span id="more"></span><h1 id="JFrame"><a href="#JFrame" class="headerlink" title="JFrame"></a>JFrame</h1><p>JFrame 用来设计类似于 Windows 系统中窗口形式的界面。JFrame 是 Swing 组件的顶层容器，该类继承了 AWT 的 Frame 类，支持 Swing 体系结构的高级 GUI 属性。</p><table border="1">    <caption>        表1 JFrame类的常用方法</caption>    <tbody>        <tr>            <th>                方法名称</th>            <th>                概述</th>        </tr>        <tr>            <td>                getContentPane()</td>            <td>                返回此窗体的 contentPane 对象</td>        </tr>        <tr>            <td>                getDefaultCloseOperation()</td>            <td>                返回用户在此窗体上单击&ldquo;关闭&rdquo;按钮时执行的操作</td>        </tr>        <tr>            <td>                setContentPane(Container contentPane)</td>            <td>                设置 contentPane 属性</td>        </tr>        <tr>            <td>                setDefaultCloseOperation(int operation)</td>            <td>                设置用户在此窗体上单击&ldquo;关闭&rdquo;按钮时默认执行的操作</td>        </tr>        <tr>            <td>                setDefaultLookAndFeelDecorated (boolean<br />                defaultLookAndFeelDecorated)</td>            <td>                设置 JFrame 窗口使用的 Windows 外观（如边框、关<br />                闭窗口的 小部件、标题等）</td>        </tr>        <tr>            <td>                setIconImage(Image image)</td>            <td>                设置要作为此窗口图标显不的图像</td>        </tr>        <tr>            <td>                setJMenuBar( JMenuBar menubar)</td>            <td>                设置此窗体的菜单栏</td>        </tr>        <tr>            <td>                setLayout(LayoutManager manager)</td>            <td>                设置&nbsp;LayoutManager&nbsp;属性</td>        </tr>        <tr>            <td>                setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);</td>            <td>                设置用户在此窗体上发起 "close" 时默认执行的操作。必须指定以下选项之一：DO_NOTHING_ON_CLOSE（在 WindowConstants 中定义）：不执行任何操作；要求程序在已注册的WindowListener 对象的 windowClosing 方法中处理该操作。                HIDE_ON_CLOSE（在 WindowConstants 中定义）：调用任意已注册的 WindowListener 对象后自动隐藏该窗体。                DISPOSE_ON_CLOSE（在 WindowConstants 中定义）：调用任意已注册 WindowListener 的对象后自动隐藏并释放该窗体。                EXIT_ON_CLOSE（在 JFrame 中定义）：使用 System exit 方法退出应用程序。仅在应用程序中使用。            </td>        </tr>    </tbody></table><h1 id="JPanel"><a href="#JPanel" class="headerlink" title="JPanel"></a>JPanel</h1><p>JPanel 是一种中间层容器，它能容纳组件并将组件组合在一起，但它本身必须添加到其他容器中使用。JPanel 类的构造方法如下。</p><ol><li>JPanel()：使用默认的布局管理器创建新面板，默认的布局管理器为 FlowLayout。</li><li>JPanel(LayoutManagerLayout layout)：创建指定布局管理器的 JPanel 对象。</li></ol><table border="1">    <caption>        表2 JPanel类的常用方法</caption>    <tbody>        <tr>            <th>                方法名及返回值类型</th>            <th>                说明</th>        </tr>        <tr>            <td>                Component add(Component comp)</td>            <td>                将指定的组件追加到此容器的尾部</td>        </tr>        <tr>            <td>                void remove(Component comp)</td>            <td>                从容器中移除指定的组件</td>        </tr>        <tr>            <td>                void setFont(Font f)</td>            <td>                设置容器的字体</td>        </tr>        <tr>            <td>                void setLayout(LayoutManager mgr)</td>            <td>                设置容器的布局管理器</td>        </tr>        <tr>            <td>                void setBackground(Color c)</td>            <td>                设置组件的背景色</td>        </tr>    </tbody></table>wdas# xx3x<h1 id="布局管理器"><a href="#布局管理器" class="headerlink" title="布局管理器"></a>布局管理器</h1><h2 id="BorderLayout-边框布局管理器"><a href="#BorderLayout-边框布局管理器" class="headerlink" title="BorderLayout 边框布局管理器"></a>BorderLayout 边框布局管理器</h2><p>边框布局管理器将窗口分为 5 个区域：North、South、East、West 和 Center。<br>BorderLayout 布局管理器的构造方法如下所示。<br>BorderLayout()：创建一个 Border 布局，组件之间没有间隙。<br>BorderLayout(int hgap,int vgap)：创建一个 Border 布局，其中 hgap 表示组件之间的横向间隔；vgap 表示组件之间的纵向间隔，单位是像素。</p><h2 id="FlowLayout-流式布局管理器"><a href="#FlowLayout-流式布局管理器" class="headerlink" title="FlowLayout   流式布局管理器"></a>FlowLayout   流式布局管理器</h2><p>FlowLayout 布局管理器不限制它所管理组件的大小，而是允许它们有自己的最佳大小。<br>FlowLayout 布局管理器的构造方法如下。<br>FlowLayout()：创建一个布局管理器，使用默认的居中对齐方式和默认 5 像素的水平和垂直间隔。<br>FlowLayout(int align)：创建一个布局管理器，使用默认 5 像素的水平和垂直间隔。其中，align 表示组件的对齐方式，对齐的值必须是 FlowLayoutLEFT、FlowLayout.RIGHT 和 FlowLayout.CENTER，指定组件在这一行的位置是居左对齐、居右对齐或居中对齐。<br>FlowLayout(int align, int hgap,int vgap)：创建一个布局管理器，其中 align 表示组件的对齐方式；hgap 表示组件之间的横向间隔；vgap 表示组件之间的纵向间隔，单位是像素。</p><h2 id="CardLayout-卡片布局管理器"><a href="#CardLayout-卡片布局管理器" class="headerlink" title="CardLayout 卡片布局管理器"></a>CardLayout 卡片布局管理器</h2><p>CardLayout 布局管理器将容器分成许多层，每层的显示空间占据整个容器的大小，但是每层只允许放置一个组件。CardLayout 的构造方法如下。<br>CardLayout()：构造一个新布局，默认间隔为 0。<br>CardLayout(int hgap, int vgap)：创建布局管理器，并指定组件间的水平间隔（hgap）和垂直间隔（vgap）。</p><h2 id="GridLayout-网格布局管理器"><a href="#GridLayout-网格布局管理器" class="headerlink" title="GridLayout 网格布局管理器"></a>GridLayout 网格布局管理器</h2><p>GridLayout 布局管理器将组件分布在一个网格中，每个网格占据一个容器的尺寸。<br>GridLayout 的构造方法如下。<br>GridLayout()：创建一个新的网格布局，默认的行数为 1，默认的列数为 1，默认的水平间隔为 5 像素，默认的垂直间隔为 5 像素。<br>GridLayout(int rows, int cols,int hgap,int vgap)：创建一个新的网格布局，其中 rows 表示网格的行数，cols 表示网格的列数。并且可以指定组件之间横向（hgap）和纵向（vgap）的间隔，单位是像素。</p><h2 id="GridBagLayout-网格包布局管理器"><a href="#GridBagLayout-网格包布局管理器" class="headerlink" title="GridBagLayout 网格包布局管理器"></a>GridBagLayout 网格包布局管理器</h2><p>GridBagLayout 布局管理器将组件分布在一个网格中，每个网格占据一个容器的尺寸。GridBagLayout 不需要组件的尺寸一致，允许组件扩展到多行多列。<br>GridBagLayout 的构造方法如下。<br>GridBagLayout()：创建一个新的网格包布局，默认的行数为 1，默认的列数为 1，默认的水平间隔为 5 像素，默认的垂直间隔为 5 像素。</p><h2 id="BoxLayout-盒布局管理器"><a href="#BoxLayout-盒布局管理器" class="headerlink" title="BoxLayout 盒布局管理器"></a>BoxLayout 盒布局管理器</h2><p>BoxLayout 布局管理器将组件分布在一个盒子中，盒子的大小由组件的大小决定。<br>BoxLayout 的构造方法如下。<br>BoxLayout(int axis)：创建一个新的盒布局，其中 axis 表示组件的布局方向，对齐的值必须是 BoxLayout.X_AXIS 或 BoxLayout.Y_AXIS。</p><table border="1">    <caption>        表1 Box类设置组件间隔的静态方法</caption>    <tbody>        <tr>            <th>                网格包布局</th>            <th>                说明</th>        </tr>        <tr>            <td>                static Component createHorizontalGlue()</td>            <td>                创建一个不可见的、可以被水平拉伸和收缩的组件</td>        </tr>        <tr>            <td>                static Component createVerticalGlue()</td>            <td>                创建一个不可见的、可以被垂直拉伸和收缩的组件</td>        </tr>        <tr>            <td>                static Component createHorizontalStrut(int width)</td>            <td>                创建一个不可见的、固定宽度的组件</td>        </tr>        <tr>            <td>                static Component createVerticalStrut(int height)</td>            <td>                创建一个不可见的、固定高度的组件</td>        </tr>        <tr>            <td>                static Component createRigidArea(Dimension d)</td>            <td>                创建一个不可见的、总是具有指定大小的组件</td>        </tr>    </tbody></table><h1 id="标签组件"><a href="#标签组件" class="headerlink" title="标签组件"></a>标签组件</h1><p>JLabel()：创建无图像并且标题为空字符串的 JLabel。<br>JLabel(Icon image)：创建具有指定图像的 JLabel。<br>JLabel(String text)：创建具有指定文本的 JLabel。<br>JLabel(String textjcon image,int horizontalAlignment)：创建具有指定文本、图像和水平对齐方式的 JLabel，horizontalAlignment 的取值有 3 个，即 JLabel.LEFT、JLabel.RIGHT 和 JLabel.CENTER。</p><table border="1">    <caption>        表1 JLabel类的常用方法</caption>    <tbody>        <tr>            <th>                方法名称</th>            <th>                说明</th>        </tr>        <tr>            <td>                void setText(Stxing text)</td>            <td>                定义 JLabel 将要显示的单行文本</td>        </tr>        <tr>            <td>                void setIcon(Icon image)</td>            <td>                定义 JLabel 将要显示的图标</td>        </tr>        <tr>            <td>                void setIconTextGap(int iconTextGap)</td>            <td>                如果 JLabel 同时显示图标和文本，则此属性定义它们之间的间隔</td>        </tr>        <tr>            <td>                void setHorizontalTextPosition(int textPosition)</td>            <td>                设置 JLabel 的文本相对其图像的水平位置</td>        </tr>        <tr>            <td>                void setHorizontalAlignment(int alignment)</td>            <td>                设置标签内容沿 X 轴的对齐方式</td>        </tr>        <tr>            <td>                int getText()</td>            <td>                返回 JLabel 所显示的文本字符串</td>        </tr>        <tr>            <td>                Icon getIcon()</td>            <td>                返回 JLabel 显示的图形图像</td>        </tr>        <tr>            <td>                Component getLabelFor()</td>            <td>                获得将 JLabel 添加到的组件</td>        </tr>        <tr>            <td>                int getIconTextGap()</td>            <td>                返回此标签中显示的文本和图标之间的间隔量</td>        </tr>        <tr>            <td>                int getHorizontalTextPosition()</td>            <td>                返回 JLabel 的文本相对其图像的水平位置</td>        </tr>        <tr>            <td>                int getHorizontalAlignment()</td>            <td>                返回 JLabel 沿 X 轴的对齐方式</td>        </tr>    </tbody></table><h1 id="按钮组件"><a href="#按钮组件" class="headerlink" title="按钮组件"></a>按钮组件</h1><p>JButton()：创建一个无标签文本、无图标的按钮。<br>JButton(Icon icon)：创建一个无标签文本、有图标的按钮。<br>JButton(String text)：创建一个有标签文本、无图标的按钮。<br>JButton(String text,Icon icon)：创建一个有标签文本、有图标的按钮。</p><p><a href="http://c.biancheng.net/view/1217.html">http://c.biancheng.net/view/1217.html</a></p><h1 id="单行文本框组件"><a href="#单行文本框组件" class="headerlink" title="单行文本框组件"></a>单行文本框组件</h1><p>JTextField()：创建一个默认的文本框。<br>JTextField(String text)：创建一个指定初始化文本信息的文本框。<br>JTextField(int columns)：创建一个指定列数的文本框。<br>JTextField(String text,int columns)：创建一个既指定初始化文本信息，又指定列数的文本框。</p><h1 id="文本域组件"><a href="#文本域组件" class="headerlink" title="文本域组件"></a>文本域组件</h1><p>文本域与文本框的最大区别就是文本域允许用户输入多行文本信息。<br>JTextArea()：创建一个默认的文本域。<br>JTextArea(int rows,int columns)：创建一个具有指定行数和列数的文本域。<br>JTextArea(String text)：创建一个包含指定文本的文本域。<br>JTextArea(String text,int rows,int columns)：创建一个既包含指定文本，又包含指定行数和列数的多行文本域。</p><h1 id="选框组件"><a href="#选框组件" class="headerlink" title="选框组件"></a>选框组件</h1><p>JCheckBox()：创建一个默认的复选框，在默认情况下既未指定文本，也未指定图像，并且未被选择。<br>JCheckBox(String text)：创建一个指定文本的复选框。<br>JCheckBox(String text,boolean selected)：创建一个指定文本和选择状态的复选框。</p><p><strong>JRadioButton 通常位于一个 ButtonGroup 按钮组中，不在按钮组中的 JRadioButton 也就失去了单选按钮的意义。</strong><br>使用时先创建一个ButtonGroup实例，再将创建的JRadioButton加入到ButtonGroup中，这样就可以实现单选按钮的功能。</p><p>JRadioButton()：创建一个初始化为未选择的单选按钮，其文本未设定。<br>JRadioButton(Icon icon)：创建一个初始化为未选择的单选按钮，其具有指定的图像但无文本。<br>JRadioButton(Icon icon,boolean selected)：创建一个具有指定图像和选择状态的单选按钮，但无文本。<br>JRadioButton(String text)：创建一个具有指定文本但未选择的单选按钮。<br>JRadioButton(String text,boolean selected)：创建一个具有指定文本和选择状态的单选按钮。<br>JRadioButton(String text,Icon icon)：创建一个具有指定的文本和图像并初始化为未选择的单选按钮。<br>JRadioButton(String text,Icon icon,boolean selected)：创建一个具有指定的文本、图像和选择状态的单选按钮。</p><h1 id="下拉列表组件"><a href="#下拉列表组件" class="headerlink" title="下拉列表组件"></a>下拉列表组件</h1><p>JComboBox()：创建一个空的 JComboBox 对象。<br>JComboBox(ComboBoxModel aModel)：创建一个 JComboBox，其选项取自现有的 ComboBoxModel。<br>JComboBox(Object[] items)：创建包含指定数组中元素的 JComboBox。</p><p>JComboBox 能够响应 ItemEvent 事件和 ActionEvent 事件，其中 ItemEvent 触发的时机是当下拉列表框中的所选项更改时，ActionEvent 触发的时机是当用户在 JComboBox 上直接输入选择项并回车时。要处理这两个事件，需要创建相应的事件类并实现 ItemListener 接口和 ActionListener 接口。</p><h1 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h1><p>事件处理者（监听器）通常是一个类，该类如果能够处理某种类型的事件，就必须实现与该事件类型相对的接口。</p><h2 id="ActionEvent-动作事件监听器"><a href="#ActionEvent-动作事件监听器" class="headerlink" title="ActionEvent 动作事件监听器"></a>ActionEvent 动作事件监听器</h2><p>接口： ActionListener</p><p>方法</p><ol><li>addActionListener() 添加监听</li></ol><p>添加指定的动作侦听器，以接收发自此按钮的动作事件。当用户在此按钮上按下或释放鼠标时，发生动作事件。如果 l 为 null，则不抛出任何异常，也不执行任何动作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import javax.swing.*;</span><br><span class="line">import java.awt.*;</span><br><span class="line">import java.awt.event.*;</span><br><span class="line">public class FrameDemo</span><br><span class="line">&#123;</span><br><span class="line">    //定义该图形中所需的组件的引用</span><br><span class="line">    private Frame f;</span><br><span class="line">    private Button bt;</span><br><span class="line"></span><br><span class="line">    //方法</span><br><span class="line">    FrameDemo()//构造方法</span><br><span class="line">    &#123;</span><br><span class="line">        madeFrame();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void madeFrame()</span><br><span class="line">    &#123;</span><br><span class="line">        f = new Frame(&quot;My Frame&quot;);</span><br><span class="line"></span><br><span class="line">        //对Frame进行基本设置。</span><br><span class="line">        f.setBounds(300,100,600,500);//对框架的位置和大小进行设置</span><br><span class="line">        f.setLayout(new FlowLayout(FlowLayout.CENTER,5,5));//设计布局</span><br><span class="line"></span><br><span class="line">        bt = new Button(&quot;My Button&quot;);</span><br><span class="line"></span><br><span class="line">        //将组件添加到Frame中</span><br><span class="line">        f.add(bt);</span><br><span class="line"></span><br><span class="line">        //加载一下窗体上的事件</span><br><span class="line">        myEvent();</span><br><span class="line"></span><br><span class="line">        //显示窗体</span><br><span class="line">        f.setVisible(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void myEvent()</span><br><span class="line">    &#123;</span><br><span class="line">        f.addWindowListener(new WindowAdapter()//窗口监听</span><br><span class="line">        &#123;</span><br><span class="line">            public void windowClosing(WindowEvent e)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(&quot;窗体执行关闭！&quot;);</span><br><span class="line">                System.exit(0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        //让按钮具备关闭窗口的功能</span><br><span class="line">        bt.addActionListener(new ActionListener()</span><br><span class="line">        &#123;</span><br><span class="line">            public void actionPerformed(ActionEvent e)</span><br><span class="line">            &#123;</span><br><span class="line">                 System.out.println(&quot;按钮执行关闭窗口的功能&quot;);</span><br><span class="line">                 System.exit(0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] agrs)</span><br><span class="line">    &#123;</span><br><span class="line">        new FrameDemo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>removeActionListener() 删除监听</li></ol><h2 id="FocusEvent-焦点事件监听器"><a href="#FocusEvent-焦点事件监听器" class="headerlink" title="FocusEvent 焦点事件监听器"></a>FocusEvent 焦点事件监听器</h2><p>接口： FocusListener</p><p>FocusEvent 接口定义了两个方法，分别为 focusGained() 方法和 focusLost() 方法，其中 focusGained() 方法是在组件获得焦点时执行，focusLost() 方法是在组件失去焦点时执行。</p><p>方法</p><ol><li><p>addFocusListener() 添加监听</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">JTextField txtfield1 = new JTextField(20);</span><br><span class="line">txtfield1.addFocusListener(new FocusListener()</span><br><span class="line">&#123;</span><br><span class="line">@Override</span><br><span class="line">public void focusGained(FocusEvent arg0)</span><br><span class="line">&#123;</span><br><span class="line">// 获取焦点时执行此方法</span><br><span class="line">label.setText(&quot;文本框获得焦点，正在输入内容&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void focusLost(FocusEvent arg0)</span><br><span class="line">&#123;</span><br><span class="line">// 失去焦点时执行此方法</span><br><span class="line">label.setText(&quot;文本框失去焦点，内容输入完成&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>removeFocusListener() 删除监听</p></li></ol><h2 id="ListSelectionEvent-选择事件监听器"><a href="#ListSelectionEvent-选择事件监听器" class="headerlink" title="ListSelectionEvent 选择事件监听器"></a>ListSelectionEvent 选择事件监听器</h2><p>列表框控件 JList 会显示很多项供用户选择，通常在使用时会根据用户选择的列表项完成不同的操作.</p><p>接口： ListSelectionListener</p><ol><li><p>addListSelectionListener() 添加监听</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">JList list = new JList(new String[]&#123;&quot;Java&quot;, &quot;C++&quot;, &quot;C#&quot;, &quot;Python&quot;, &quot;PHP&quot;, &quot;JavaScript&quot;&#125;);</span><br><span class="line">list.addListSelectionListener(new ListSelectionListener()</span><br><span class="line">&#123;</span><br><span class="line">@Override</span><br><span class="line">public void valueChanged(ListSelectionEvent e)</span><br><span class="line">&#123;</span><br><span class="line">// 当选择项发生变化时执行此方法</span><br><span class="line">label.setText(&quot;选择了&quot; + list.getSelectedValue());</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>removeListSelectionListener() 删除监听</p></li></ol><h1 id="JSlider"><a href="#JSlider" class="headerlink" title="JSlider"></a>JSlider</h1><p>滑块（JSlider）是一个允许用户在有限区间内通过移动滑块来选择值的组件。</p><p><strong>JSlider(int min,int max,int value)</strong><br>用指定的最小值、最大值和初始值创建一个水平滑块。</p><h1 id="JProgressBar"><a href="#JProgressBar" class="headerlink" title="JProgressBar"></a>JProgressBar</h1><p>进度条（JProgressBar）是一种以可视化形式显示某些任务进度的组件。JProgressBar 类实现了一个用于为长时间的操作提供可视化指示器的 GUI 进度条。在任务的完成进度中，进度条显示该任务完成的百分比。</p><p>ProgressBar 类的常用构造方法和 JSlider 类的常用构造方法一样</p><h1 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h1><p>计时器（Timer）组件可以在指定时间间隔触发一个或多个 ActionEvent。</p><p>第一个参数为事件触发之间的间隔 单位为毫秒<br>第二个参数为ActionListener</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Timer timer = new Timer(1000, new ActionListener()</span><br><span class="line">&#123;</span><br><span class="line">@Override</span><br><span class="line">public void actionPerformed(ActionEvent e)</span><br><span class="line">&#123;</span><br><span class="line">// 每隔一秒执行一次</span><br><span class="line">label.setText(&quot;计时器触发了一次&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">timer.start();</span><br></pre></td></tr></table></figure><h1 id="JTable"><a href="#JTable" class="headerlink" title="JTable"></a>JTable</h1><p>JTable()：构造一个默认的 JTable，使用默认的数据模型、默认的列模型和默认的选择模型对其进行初始化。<br>JTable(int numRows,int numColumns)：使用 DefaultTableModel 构造具有 numRows 行和 numColumns 列个空单元格的 JTable。<br>JTable(Object[][] rowData,Object[] columnNames)：构造一个 JTable 来显示二 维数组 rowData 中的值，其列名称为 columnNames。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JTable table = new JTable(new Object[][]&#123;</span><br><span class="line">&#123;&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;&#125;,</span><br><span class="line">&#123;&quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;10&quot;&#125;&#125;,</span><br><span class="line">new Object[]&#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;&#125;);</span><br></pre></td></tr></table></figure><h1 id="其他组件"><a href="#其他组件" class="headerlink" title="其他组件"></a>其他组件</h1><h2 id="JMenu"><a href="#JMenu" class="headerlink" title="JMenu"></a>JMenu</h2><p>菜单由 Swing 中的 JMenu 类实现，可以包含多个菜单项和带分隔符的菜单。在菜单中，菜单项由 JMenuItem 类表示，分隔符由 JSeparator 类表示。</p><h2 id="弹出式菜单-JPopuMenu"><a href="#弹出式菜单-JPopuMenu" class="headerlink" title="弹出式菜单 JPopuMenu"></a>弹出式菜单 JPopuMenu</h2><p>弹出式菜单由 JPopupMenu 类实现，它是一个可弹出并显示一系列选项的小窗口。它还用于当用户选择菜单项并激活它时显示的“右拉式(pull-right)”菜单，可以在想让菜单显示的任何其他位置使用。</p><h2 id="JToolBar-工具栏组件"><a href="#JToolBar-工具栏组件" class="headerlink" title="JToolBar 工具栏组件"></a>JToolBar 工具栏组件</h2><p>工具栏提供了一个用来显示常用按钮和操作的组件</p><h2 id="JFileChooser-文件选择器"><a href="#JFileChooser-文件选择器" class="headerlink" title="JFileChooser 文件选择器"></a>JFileChooser 文件选择器</h2><p>文件选择器为用户能够操作系统文件提供了桥梁。swing 中使用 JFileChooser 类实现文件选择器，该类常用的构造方法如下。<br>JFileChooser()：创建一个指向用户默认目录的 JFileChooser。<br>JFileChooser(File currentDirectory)：使用指定 File 作为路径来创建 JFileChooser。<br>JFileChooser(String currentDirectoryPath)：创建一个使用指定路径的 JFileChooser。<br>JFileChooser(String currentDirectoryPath, FileSystemView fsv)：使用指定的当前目录路径和 FileSystem View 构造一个 JFileChooser。</p><h2 id="JColorChooser-颜色选择器"><a href="#JColorChooser-颜色选择器" class="headerlink" title="JColorChooser 颜色选择器"></a>JColorChooser 颜色选择器</h2><p>JColorChooser()：创建初始颜色为白色的颜色选取器窗格。<br>JColorChooser(Color initialColor)：创建具有指定初始颜色的颜色选取器窗格。<br>JColorChooser(ColorSelectionModel model)：创建具有指定 ColorSelectionModel 颜色选取器窗格。</p><h2 id="JOptionPane"><a href="#JOptionPane" class="headerlink" title="JOptionPane"></a>JOptionPane</h2><p>对话框通常用作从用户处接收附加信息，或者提供发生了某种事件的通知。Java 提供了 JOptionPane 类，用来创建标准对话框，也可以通过扩展 JDialog 类创建自定义的对话框。JOptionPane 类可以用来创建 4 种类型的标准对话框：确认对话框、消息对话框、输入对话框和选项对话框。</p><h2 id="JTabbedPane-选项卡组件"><a href="#JTabbedPane-选项卡组件" class="headerlink" title="JTabbedPane 选项卡组件"></a>JTabbedPane 选项卡组件</h2><p>使用选项卡可以在有限的布局空间内展示更多的内容。Swing 使用 JTabbedPane 类实现选项卡。</p><p>JTabbedPane 类创建的选项卡可以通过单击标题或者图标在选项卡之间进行切换。JTabbedPane 类的常用构造方法如下所示。<br>JTabbedPane()：创建一个具有默认 JTabbedPane.TOP 布局的空 TabbedPane。<br>JTabbedPane(int tabPlacement)：创建一个空的 TabbedPane，使其具有以下指定选项卡布局中的一种：JTabbedPane.TOP、JTabbedPane.BOTTOM、JTabbedPane.LEFT 或 JTabbedPane.RIGHT。</p><hr />         版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Swing 是一个为Java设计的GUI工具包。&lt;/p&gt;
&lt;p&gt;Swing是JAVA基础类的一部分。&lt;/p&gt;
&lt;p&gt;Swing包括了图形用户界面（GUI）器件如：文本框，按钮，分隔窗格和表。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://c.biancheng.net/view/1209.html&quot;&gt;http://c.biancheng.net/view/1209.html&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="http://akkaduilin.com/categories/Java/"/>
    
    
    <category term="Java - GUI" scheme="http://akkaduilin.com/tags/Java-GUI/"/>
    
  </entry>
  
  <entry>
    <title>关系代数</title>
    <link href="http://akkaduilin.com/2022/03/24/%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0/"/>
    <id>http://akkaduilin.com/2022/03/24/%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0/</id>
    <published>2022-03-24T13:34:27.000Z</published>
    <updated>2022-06-19T09:16:27.774Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>数据库笔记 ——  关系代数</p><span id="more"></span><h1 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h1><p><a href="https://sm.ms/image/6TerPQDAohzCOqf" target="_blank"><img src="https://s2.loli.net/2022/03/24/6TerPQDAohzCOqf.png" ></a></p><h2 id="传统运算"><a href="#传统运算" class="headerlink" title="传统运算"></a>传统运算</h2><ol><li><p>并：假设有两个关系 R1 和 R2,R1 和 R2 的并运算产生一个新关系 R3。R3 是 由属于关系 R1 或 R2 的所有不同元组所组成，记为 R3=R1∪R2。 </p></li><li><p>差：假设有两个关系 R1 和 R2，R1 和 R2 的差运算产生一个新关系 R3。R3 是由属于关系关系 R1，但不属于 R2 的元组组成，记为 R3=R1-R2。 </p></li><li><p>交：假设有两个关系 R1 和 R2，R1 和 R2 的交运算产生一个新关系 R3。R3 是由既属于关系 R1，同时又属于 R2 的元组组成，记为 R3=R1∩R2。</p></li><li><p>笛卡尔积：假设有两个关系 R1 和 R2，且 R1 为 m 元关系，R2 为 n 元关系， R1 和 R2 的笛卡尔积产生一个新关系 R3，记作 R3=R1✖R2。R3 是由 R1 和 R2 的所有元组连接而成的具有(m+n)个分量的元组组成。</p></li></ol><h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><p>关系代数中用符号 σ（西格玛，sigma）来描述选择语句。选择是根据某些条件对关系做水平切割<br>此外我们可以在 select 的同时，添加限制条件（即 where），使用例如下：</p><p><a href="https://sm.ms/image/fmZdWqKQ8Peuo6k" target="_blank"><img src="https://s2.loli.net/2022/03/24/fmZdWqKQ8Peuo6k.png" ></a></p><p>等价与</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from student where AGE=19;</span><br></pre></td></tr></table></figure><h2 id="投影"><a href="#投影" class="headerlink" title="投影"></a>投影</h2><p>投影与选择正好相反，是对关系的一种垂直切割</p><p>在关系代数中的投影语句相当于 SQL 中的字段筛选，可以选择特定的字段进行查询，格式如下：<br><a href="https://sm.ms/image/GuvKOoS2LVZQ8RF" target="_blank"><img src="https://s2.loli.net/2022/03/24/GuvKOoS2LVZQ8RF.png" ></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select sno, age, sname from student;</span><br></pre></td></tr></table></figure><p>当选择和投影连用时<br>可以和where联动 相当于一个完整的selec语句<br><a href="https://sm.ms/image/P5sA9udivbH7YRZ" target="_blank"><img src="https://s2.loli.net/2022/03/24/P5sA9udivbH7YRZ.png" ></a><br>select sname from student where AGE=19;</p><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><p><a href="https://sm.ms/image/DxoWVwcfCKZEYRm" target="_blank"><img src="https://s2.loli.net/2022/03/25/DxoWVwcfCKZEYRm.png" ></a><br>连接运算：从两个关系的笛卡尔积中选取属性间满足一定条件的元组，用(R ⋈ S）表示。<br>连接分为两种，<br>一种是等值连接(θ 为 = 关系)<br>另一种是自然连接 根据R与S共同的属性进行选择 结果中去掉重复属性列 自然联接是特殊的的等值联接</p><p><a href="https://sm.ms/image/HUV3amCqj2ngelx" target="_blank"><img src="https://s2.loli.net/2022/03/25/HUV3amCqj2ngelx.jpg" ></a></p><p>自然连接时，被舍弃的元组称为<strong>悬浮元组</strong>，如果将悬浮元组也保存在结果中，在其他属性保持空值，称为<strong>外连接</strong>，只保留左边R中的悬浮元组称为<strong>左外连接</strong>，只保留右边S中的悬浮元组称为<strong>右外连接</strong></p><p><a href="https://sm.ms/image/buEwmhMo6UJ7yN1" target="_blank"><img src="https://s2.loli.net/2022/03/28/buEwmhMo6UJ7yN1.jpg" ></a></p><h2 id="除运算"><a href="#除运算" class="headerlink" title="除运算"></a>除运算</h2><p><a href="https://sm.ms/image/NfL7kYnJmTgaA53" target="_blank"><img src="https://s2.loli.net/2022/03/23/NfL7kYnJmTgaA53.png" ></a></p><h3 id="象集"><a href="#象集" class="headerlink" title="象集"></a>象集</h3><p>象集：本质上是一次选择行的运算和一次选择列的运算。<br>求x1在表A中的象集，就是先选出所有x属性中x=x1的那些行，然后选择出不包含x1的那些列。</p><p>如A：<br>X     Y     Z<br>a1    b1    c2<br>a2    b3    c7<br>a3    b4    c6<br>a1    b2    c3<br>a4    b6    c6<br>a2    b2    c3<br>a1    b2    c1<br>a1在A中的象集为{(b1,c2),(b2,c3),(b2,c1)}</p><h3 id="除运算-1"><a href="#除运算-1" class="headerlink" title="除运算"></a>除运算</h3><p>设关系R除以关系S的结果为关系T，则T包含所有在R但是不在S中的属性及其值，且T的元组与S的元组的所有集合都在R中</p><p>R与S的除运算构成新的关系P(X),P是R中满足下列条件的元组在X属性列上的投影，元组在X上分量值x的象集Yx包含S在Y上投影的集合。</p><p><a href="https://sm.ms/image/JXj2BdQ31NFn4SE" target="_blank"><img src="https://s2.loli.net/2022/03/26/JXj2BdQ31NFn4SE.png" ></a></p><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数据库笔记 ——  关系代数&lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="http://akkaduilin.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="SQL" scheme="http://akkaduilin.com/tags/SQL/"/>
    
    <category term="数据库" scheme="http://akkaduilin.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="关系代数" scheme="http://akkaduilin.com/tags/%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>SQL数据查询</title>
    <link href="http://akkaduilin.com/2022/03/23/SQL%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2/"/>
    <id>http://akkaduilin.com/2022/03/23/SQL%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2/</id>
    <published>2022-03-23T01:59:50.000Z</published>
    <updated>2022-06-19T09:21:02.198Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>SQL的查询相关代码</p><p><a href="https://blog.csdn.net/weixin_44176696/article/details/112586831">https://blog.csdn.net/weixin_44176696/article/details/112586831</a></p><span id="more"></span><h1 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h1><h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><p>数据查询是数据库的核心操作，SQL 使用 SELECT 语句进行数据库的查询，其一般格式<br>为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT [ ALL｜DISTINCT ] &lt; 目标列表达式 &gt; [，&lt;目标列表达式 &gt; …] </span><br><span class="line">FROM &lt; 表名或视图名 &gt; [，&lt;表名或视图名&gt;… ] </span><br><span class="line">[ WHERE &lt; 条件表达式&gt; ]</span><br><span class="line">[ GROUP BY &lt; 列名列表&gt; [ HAVING &lt; 条件表达式&gt; ] ]</span><br><span class="line">[ ORDER BY &lt; 列名&gt; [ ASC ｜DESC ] ]；</span><br></pre></td></tr></table></figure><p>（1） []：表示[]中的内容是可选的，比如[ WHERE &lt; 条件表达式&gt; ]，表示可以使用 WHERE 也可以不使用</p><p>（2） &lt;&gt;：表示&lt;&gt;中的内容必须出现。比如&lt; 表名或视图名 &gt;，这个部分表示从哪个地方获取数据，是不可或缺的。</p><p>（3） ｜：表示选择其一，例如 &lt; 列名 2&gt; [ ASC ｜DESC ] ]，表示列名 2 后只能用ASC或者DESC其中之一来进行结果的排序，前者代表升序，后者代表降序。</p><p>（4） [，…]：表示括号中的内容可以重复出现 1 至多次。</p><p>（5） * 表示相应范围内的所有内容 select * 表示查找表中所有数据</p><h2 id="列操作"><a href="#列操作" class="headerlink" title="列操作"></a>列操作</h2><h3 id="查询列"><a href="#查询列" class="headerlink" title="查询列"></a>查询列</h3><p>在 SQL 语句中，用 FROM 子句指定要操纵的表，SELECT 子句给出要投影的列，对应的 SQL 语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select A,B </span><br><span class="line">from T_A</span><br><span class="line"></span><br><span class="line">select * </span><br><span class="line">from T_B</span><br></pre></td></tr></table></figure><p>SELECT 语句的执行结果是一个新表，这个表没有名字，是个临时表，它的关系模式由SELECT 子句里的属性列构成</p><p>select * 表示查找全部列</p><h3 id="列别名"><a href="#列别名" class="headerlink" title="列别名"></a>列别名</h3><p>有时候，我们希望查询结果中的某些列名不同于基本表中的列名，这时，可以在 SELECT<br>子句中增加列别名。<br>SQL 语句使用 AS 关键词对列设置“别名”。AS 使用格式如下：</p><p>旧名 AS 别名</p><p>eg：<br>查询曲库里的所有歌曲的详细信息，请把表中的各个列名：SongID，Name，Lyricist，Composer，Lang 分别替换成：歌曲编号、歌曲名称、词作者、曲作者、语言类别。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT SongID AS 歌曲编号, Name AS 歌曲名称, Lyricist AS 词作者,Composer AS 曲作者, Lang AS 语言类别</span><br><span class="line">FROM Songs;</span><br></pre></td></tr></table></figure><h3 id="查询计算列"><a href="#查询计算列" class="headerlink" title="查询计算列"></a>查询计算列</h3><p>SELECT 子句的&lt;目标列表达式&gt;不仅可以是表中真实存在的列，也可以是一个表达式。可以使用常量计算表达式或者函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT SongID, SingerID, Circulation*10000 as NewCirculation</span><br><span class="line">FROM Track</span><br><span class="line"></span><br><span class="line">SELECT Name as 姓名, Birth as 出生日期, 2012-Year（Birth） as 年龄</span><br><span class="line">FROM Singers</span><br></pre></td></tr></table></figure><h3 id="过滤重复列"><a href="#过滤重复列" class="headerlink" title="过滤重复列"></a>过滤重复列</h3><p>两条本来并不完全相同的元组，投影到某些列上后，可能变成相同的行了，可以用DISTINCT 关键字过滤它们。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT Style</span><br><span class="line">FROM Track;</span><br></pre></td></tr></table></figure><h2 id="where-子句"><a href="#where-子句" class="headerlink" title="where 子句"></a>where 子句</h2><p>WHERE 子句用于表达关系代数中选择运算的选择条件。<br><a href="https://sm.ms/image/dJUMtu5DN2VwaYr" target="_blank"><img src="https://s2.loli.net/2022/03/24/dJUMtu5DN2VwaYr.png" ></a></p><p>逻辑运算符 AND 和 OR 可以用来联结多个查询条件。<strong>AND 的优先级高于 OR</strong>，但用户可以用括号来改变优先级。</p><h3 id="确定范围"><a href="#确定范围" class="headerlink" title="确定范围"></a>确定范围</h3><p>比较运算符包括：=（等于），&gt;（大于），&lt;(小于)，&gt;=（大于等于），&lt;=（小于等于），!=<br>或者&lt;&gt;（不等于）。</p><p>谓词 BETWEEN…AND 用于查询列值在指定范围内]的元组，其中 BETWEEN 后面跟的<br>是范围下限，AND 后跟的是范围的上限。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT Name, Birth</span><br><span class="line">FROM Singers</span><br><span class="line">Where Birth&lt;1967</span><br><span class="line"></span><br><span class="line">求查询出生年份不在 1970~1980 之间的歌手的姓名与性别</span><br><span class="line">SELECT Name, Gender</span><br><span class="line">FROM Singers</span><br><span class="line">WHERE Birth NOT BETWEEN 1970 AND 1980;</span><br></pre></td></tr></table></figure><h3 id="字段匹配"><a href="#字段匹配" class="headerlink" title="字段匹配"></a>字段匹配</h3><p>谓词 LIKE 可以用来进行字符串的匹配。 其一般语法格式如下：</p><p>列名 [NOT] LIKE ‘&lt;匹配串&gt;’ [ESCAPE ‘&lt;换码字符&gt;’]</p><p>其含义是查找列值与&lt;匹配串&gt;相匹配的元组。通常，&lt;匹配串&gt;中可以使用通配符“%”（百分号）和“_”（下横线）。<br>其中：<br>%：代表任意长度（长度可以为 0）的字符串。例如，a%b 表示以 a 开头、以 b 结尾的<br>任意长度的字符串。字符串 ab、axb、agxb 都满足该匹配串。<br>_：代表任意单个字符。例如，a_b 表示以 a 开头，以 b 结尾，中间夹一个字符的任意字<br>符串。如 axb、a!b 等都满足要求。</p><p>如果用户要查询的字符串本身就含有%或_，这时就要使用’ESCAPE&lt;换码字符&gt;’对通配<br>符进行转义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">查询歌手编号以“GC”开头的歌手姓名、性别。</span><br><span class="line">SELECT Name, Gender</span><br><span class="line">FROM Singers</span><br><span class="line">WHERE SingerID like ‘GC%’</span><br><span class="line"></span><br><span class="line">查询以”John_”开头的歌手的详细信息。</span><br><span class="line">SELECT *</span><br><span class="line">FROM Singers</span><br><span class="line">WHERE Name like ‘John\_%’ ESCAPE ’\’;</span><br></pre></td></tr></table></figure><h3 id="确定集合-判空"><a href="#确定集合-判空" class="headerlink" title="确定集合/判空"></a>确定集合/判空</h3><p>谓词 IN 用来查找某个列值属于指定集合的元组，格式为：</p><p>列名 IN/NOTT IN 集合 (x , x , x , x )</p><p>谓词 IS NULL 用于判断某列的值是否为空值，格式如下：</p><p>列名 IS NULL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">查询曲目表中既不属于“乡村”、“爵士”也不是“摇滚”曲风的专辑详细信息。</span><br><span class="line">SELECT SongID, SingerID</span><br><span class="line">FROM Track</span><br><span class="line">WHERE Style NOT IN (‘乡村’, ‘爵士’ , ‘摇滚’);</span><br><span class="line"></span><br><span class="line">查询曲目表中缺少发行量信息的记录。</span><br><span class="line">SELECT *</span><br><span class="line">FROM Track</span><br><span class="line">WHERE Circulation IS NULL;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="order-by-子句"><a href="#order-by-子句" class="headerlink" title="order by 子句"></a>order by 子句</h2><p>由 SELECT-FROM-WHERE 构成的 SELECT 查询语句完成对表的选择和投影操作，得到一个新的结果表，还可以对得到的新表做进一步的操作。</p><p>ORDER BY 子句用于对查询结果进行排序。<strong>可以按照一个或者多个属性列进行升序（ASC）或者降序(DESC)排列</strong>，默认将按照升序排列。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">查询曲目表中的歌手编号、歌曲编号和曲风类别，将查询结果按照发行时间降序排列。</span><br><span class="line"></span><br><span class="line">SELECT SongID, SingerID, Style</span><br><span class="line">FROM Track</span><br><span class="line">ORDER BY PubYear DESC,SingerID ASC;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="聚集函数"><a href="#聚集函数" class="headerlink" title="聚集函数"></a>聚集函数</h2><p>AVG()：返回某列的平均值</p><p>COUNT()：返回某列的行数</p><p>MAX()：返回某列的最大值</p><p>MIN()：返回某列的最小值</p><p>SUM()：返回某列值之和<br>如果指定 DISTINCT 标识符，则表示计算时要取消指定列中的重复值。如果不指定DISTINCT 或指定 ALL（ALL 为缺省），则表示不取消重复值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">查询 Track 表中的记录总数，最早发行时间、最近发行时间和整个发行量的总和。</span><br><span class="line"></span><br><span class="line">SELECT Count(*) as 记录总数, MIN(PubYear) as ‘最早发行量’, MAX(PubYear) as ‘最近发行</span><br><span class="line">时间’, SUM(Circulation) as ‘发行量总和’</span><br><span class="line"></span><br><span class="line">FROM Track</span><br></pre></td></tr></table></figure><h2 id="group-by-子句"><a href="#group-by-子句" class="headerlink" title="group by 子句"></a>group by 子句</h2><p>聚合函数是对查询结果（一个元组集）中的值进行统计。在有的查询中，我们要把具有相同特征的元组分成若干子集，然后需要再对每个子集中的值进行统计，此时就要用到SELECT 句型中的分组子句“GROUP BY”，格式为:</p><p>GROUP BY &lt;列名列表&gt;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM access_log;</span><br><span class="line">+-----+---------+-------+------------+</span><br><span class="line">| aid | site_id | count | date       |</span><br><span class="line">+-----+---------+-------+------------+</span><br><span class="line">|   1 |       1 |    45 | 2016-05-10 |</span><br><span class="line">|   2 |       3 |   100 | 2016-05-13 |</span><br><span class="line">|   3 |       1 |   230 | 2016-05-14 |</span><br><span class="line">|   4 |       2 |    10 | 2016-05-14 |</span><br><span class="line">|   5 |       5 |   205 | 2016-05-14 |</span><br><span class="line">|   6 |       4 |    13 | 2016-05-15 |</span><br><span class="line">|   7 |       3 |   220 | 2016-05-15 |</span><br><span class="line">|   8 |       5 |   545 | 2016-05-16 |</span><br><span class="line">|   9 |       3 |   201 | 2016-05-17 |</span><br><span class="line">+-----+---------+-------+------------+</span><br><span class="line">9 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">统计 access_log 各个 site_id 的访问量：</span><br><span class="line">SELECT site_id, SUM(access_log.count) AS nums</span><br><span class="line">FROM access_log GROUP BY site_id;</span><br></pre></td></tr></table></figure><p>在用分组语句时，SELECT 后跟的列只能是聚集函数或者是出现在 GROUP BY 之后的分组列。</p><h2 id="having-子句"><a href="#having-子句" class="headerlink" title="having 子句"></a>having 子句</h2><p>在 SQL 中增加 HAVING 子句原因是，WHERE 关键字无法与聚合函数一起使用。</p><p>HAVING 子句可以让我们筛选分组后的各组数据。</p><p><a href="https://www.runoob.com/sql/sql-having.html">https://www.runoob.com/sql/sql-having.html</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT column_name, aggregate_function(column_name)</span><br><span class="line">FROM table_name</span><br><span class="line">WHERE column_name operator value</span><br><span class="line">GROUP BY column_name</span><br><span class="line">HAVING aggregate_function(column_name) operator value;</span><br></pre></td></tr></table></figure><h2 id="笛卡儿积和连接"><a href="#笛卡儿积和连接" class="headerlink" title="笛卡儿积和连接"></a>笛卡儿积和连接</h2><p>SQL 在一个查询中建立几个表的联系的方法非常简单，只要在 FROM 子句中列出所有<br>涉及到的表就可以了。从概念上讲，FROM 子句先对这些表做笛卡尔积操作，得到一个临<br>时表，以后的选择、投影等操作都是针对这个临时表，从而将多表查询转换为单表查询。</p><p>一般格式为</p><p><strong>[&lt;表名 1&gt;.]&lt;列名 1&gt; &lt;比较运算符&gt; [&lt;表名 2&gt;.]&lt;列名 2&gt;</strong></p><h2 id="join-子句"><a href="#join-子句" class="headerlink" title="join 子句"></a>join 子句</h2><p><a href="https://sm.ms/image/KJqzfrO1AQtiM9u" target="_blank"><img src="https://s2.loli.net/2022/03/30/KJqzfrO1AQtiM9u.jpg" ></a></p><h3 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h3><p>在非 ANSI 标准的实现中，连接是在 WHERE 子句中执行的（即在 WHERE 子句中指定表间的连接条件）；在 ANSI SQL-92 中，连接是在 JOIN 子句中执行的。前者称为Theta 连接，后者称为 ANSI 连接。</p><p>ANSI 内连接的语法格式：<br>FROM 表 1 [INNER] JOIN 表 2 ON &lt;连接条件&gt;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">eg ：列出曲库中所有演唱过歌曲的歌手名，歌曲名和发行量。</span><br><span class="line"></span><br><span class="line">Theta 方式的 SQL 语句：</span><br><span class="line">SELECT Songs.Name AS 歌曲名, Singers.Name AS 歌手名,Circulation AS 发行量</span><br><span class="line">FROM Songs,Track,Singers</span><br><span class="line">WHERE Songs.SongID=Track.SongID AND Track.SingerID=Singers.SingerID</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ANSI 方式的 SQL 语句为：</span><br><span class="line">SELECT Songs.Name AS 歌曲名, Singers.Name AS 歌手名,Circulation AS 发行量</span><br><span class="line">FROM Songs JOIN Track ON Songs.SongID=Track.SongID</span><br><span class="line">JOIN Singers ON Track.SingerID=Singers.SingerID</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="自身连接"><a href="#自身连接" class="headerlink" title="自身连接"></a>自身连接</h3><p><strong>连接操作不仅可以在两个表之间进行，也可以与其自身进行连接，称为表的自身连接。</strong></p><p>可以为表提供别名，其格式如下：<br>FROM &lt;源表名&gt; [AS] &lt;表别名&gt;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT FIRST.CNumber， SECOND.PCNumber</span><br><span class="line">FROM Course FIRST， Course SECOND</span><br><span class="line">WHERE FIRST.PCNumber=SECOND.CNumber；</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><p>外连接之限制一张表中的数据必须满足连接条件，而另一张表中的数据可以不满足连接<br>条件。</p><p>Theta 方式的外连接语法格式为：<br>左外连接：FROM 表 1，表 2 WHERE [表 1.]列名(+)=[表 2.]列名<br>右外连接：FROM 表 1，表 2 WHERE [表 1.]列名=[表 2.]列名(+)</p><p>ANSI 方式的外连接语法格式为：<br>FROM 表 1 LEFT | RIGHT JOIN [OUTER] 表 2 ON &lt;连接条件&gt;</p><p>SQL SERVER 支持 ANSI 方式的外连接，但 ORACLE 支持的是 Theta 方式的外连接。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT column_name(s)</span><br><span class="line">FROM table1</span><br><span class="line">FULL OUTER/RIGHT/LEFT JOIN table2</span><br><span class="line">ON table1.column_name=table2.column_name;</span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>在实际应用中，经常有一些 SELECT 语句需要使用其他 SELECT 语句的查询结果，此时就需要用到子查询。</p><h3 id="IN谓词子查询"><a href="#IN谓词子查询" class="headerlink" title="IN谓词子查询"></a>IN谓词子查询</h3><p>其格式如下：<br>SELECT &lt;列名&gt; [,&lt;列名&gt;] …<br>FROM &lt;表名&gt;<br>WHERE &lt;表达式&gt; &lt;[NOT] IN | 其它比较运算符&gt;<br>(<br>  SELECT &lt;列名&gt;<br>  FROM &lt;表名&gt;<br>  WHERE &lt;条件&gt;<br>）</p><p>NOT IN 执行的是集合运算 其他运算符执行比较运算</p><p>使用 IN 运算时，如果表达式的值与集合中的某个值相等，则此运算结果为真；如果表达式的值与集合中的所有值均不相等，则运算结果为假。由关键字 IN 引入的子查询的 SELECT 后的列名只允许有 1 项内容，即只能是一个列名或者是表达式。</p><p>使用子查询进行比较运算时，通过比较运算符（=、&lt;&gt;、&lt;、&gt;、&lt;=、&gt;=），将一个表达式的值与子查询返回的值进行比较。如果比较运算的结果为真，则比较运算返回 TRUE。使用子查询进行比较测试时，要求子查询语句必须是返回单值的查询语句。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">查询歌唱风格是“摇滚”的歌手信息。</span><br><span class="line"></span><br><span class="line">SELECT *</span><br><span class="line">FROM Singers</span><br><span class="line">WHERE SingerID IN</span><br><span class="line">(</span><br><span class="line">  SELECT DISTINCT SingerID</span><br><span class="line">  FROM Track</span><br><span class="line">  WHERE Style =’摇滚’ </span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="带有比较运算符的子查询"><a href="#带有比较运算符的子查询" class="headerlink" title="带有比较运算符的子查询"></a>带有比较运算符的子查询</h3><p>使用子查询进行比较运算时，通过比较运算符（=、&lt;&gt;、&lt;、&gt;、&lt;=、&gt;=），将一个表达式的值与子查询返回的值进行比较。如果比较运算的结果为真，则比较运算返回 TRUE。使用子查询进行比较测试时，要求子查询语句必须是返回单值的查询语句。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">查询年龄最大的歌手的信息</span><br><span class="line"></span><br><span class="line">SELECT *</span><br><span class="line">FROM Singers</span><br><span class="line">WHERE Birth =</span><br><span class="line">(</span><br><span class="line">  SELECT MAX(Birth)</span><br><span class="line">  FROM Singers</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="带有ANY或ALL谓词的子查询"><a href="#带有ANY或ALL谓词的子查询" class="headerlink" title="带有ANY或ALL谓词的子查询"></a>带有ANY或ALL谓词的子查询</h3><p><a href="https://sm.ms/image/UVIQPu9qDElgR6o" target="_blank"><img src="https://s2.loli.net/2022/03/30/UVIQPu9qDElgR6o.jpg" ></a></p><p><a href="https://blog.csdn.net/qq_38157534/article/details/108527994">https://blog.csdn.net/qq_38157534/article/details/108527994</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">【例】查询非计算机科学系中比计算机科学系任意一个学生年龄小的学生姓名和年龄</span><br><span class="line">select Sname，Sage </span><br><span class="line">from student</span><br><span class="line">where Sage &lt; ANY</span><br><span class="line">  ( select  Sage </span><br><span class="line">    from student </span><br><span class="line">    where Sdept  = &quot;CS&quot;) </span><br><span class="line">AND Sdept &lt;&gt; &quot;CS&quot;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="带有EXISTS谓词的子查询"><a href="#带有EXISTS谓词的子查询" class="headerlink" title="带有EXISTS谓词的子查询"></a>带有EXISTS谓词的子查询</h3><p>相关子查询通常使用 EXISTS 谓词，其形式为：<br>SELECT &lt;列名&gt; [,&lt;列名&gt;] …<br>FROM &lt;表名&gt;<br>WHERE<br>WHERE [NOT] EXISTS<br>(<br>  SELECT *<br>  FROM &lt;表名&gt;<br>  WHERE &lt;条件&gt;<br>)</p><p>带有 EXISTS 谓词的子查询不返回任何数据，只产生逻辑真值“true”或逻辑假值“false”：<br><em>若内层查询结果非空，则外层的 WHERE 子句返回真值</em><br><em>若内层查询结果为空，则外层的 WHERE 子句返回假值</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">查询歌唱风格是“摇滚”的歌手信息。</span><br><span class="line"></span><br><span class="line">SELECT *</span><br><span class="line">FROM Singers X</span><br><span class="line">WHERE EXISTS</span><br><span class="line">(</span><br><span class="line">SELECT *</span><br><span class="line">FROM Track</span><br><span class="line">WHERE Track.SingerID=X.SingerID and Style =’摇滚’ )</span><br></pre></td></tr></table></figure><h2 id="集合查询"><a href="#集合查询" class="headerlink" title="集合查询"></a>集合查询</h2><p>SELECT 查询操作的对象是集合，结果也是集合。集合操作主要包括并操作 UNION，交操作 INTERSECT 和差操作 EXCEPT。</p><p>注意： 参加集合操作的各查询结果的列数必须相同；对应项的数据类型也要相同。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">查询中国歌手和出生日期晚于 1960 年的歌手。</span><br><span class="line"></span><br><span class="line">SELECT *</span><br><span class="line">FROM Singers</span><br><span class="line">WHERE Nation=’中国’</span><br><span class="line">UNION</span><br><span class="line">SELECT *</span><br><span class="line">FROM Singers</span><br><span class="line">WHERE Birth&gt;=1960</span><br></pre></td></tr></table></figure><h1 id="xx3x"><a href="#xx3x" class="headerlink" title="xx3x"></a>xx3x</h1><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SQL的查询相关代码&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_44176696/article/details/112586831&quot;&gt;https://blog.csdn.net/weixin_44176696/article/details/112586831&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="http://akkaduilin.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="SQL" scheme="http://akkaduilin.com/tags/SQL/"/>
    
    <category term="数据库" scheme="http://akkaduilin.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="关系代数" scheme="http://akkaduilin.com/tags/%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0/"/>
    
  </entry>
  
</feed>
