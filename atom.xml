<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>咸鱼享乐，摸鱼快乐</title>
  
  
  <link href="http://akkaduilin.com/atom.xml" rel="self"/>
  
  <link href="http://akkaduilin.com/"/>
  <updated>2022-04-04T09:47:34.417Z</updated>
  <id>http://akkaduilin.com/</id>
  
  <author>
    <name>不对de林</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>节点选择</title>
    <link href="http://akkaduilin.com/2022/04/04/%E8%8A%82%E7%82%B9%E9%80%89%E6%8B%A9/"/>
    <id>http://akkaduilin.com/2022/04/04/%E8%8A%82%E7%82%B9%E9%80%89%E6%8B%A9/</id>
    <published>2022-04-04T09:39:27.000Z</published>
    <updated>2022-04-04T09:47:34.417Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>问题描述</p><p>有一棵 n 个节点的树，树上每个节点都有一个正整数权值。如果一个点被选择了，那么在树上和它相邻的点都不能被选择。求选出的点的权值和最大是多少？</p><span id="more"></span><p>输入格式<br>第一行包含一个整数 n 。<br>接下来的一行包含 n 个正整数，第 i 个正整数代表点 i 的权值。<br>接下来一共 n-1 行，每行描述树上的一条边。</p><p>输出格式<br>输出一个整数，代表选出的点的权值和的最大值。</p><p>样例输入<br>5<br>1 2 3 4 5<br>1 2<br>1 3<br>2 4<br>2 5</p><p>样例输出<br>12</p><p>样例说明<br>选择3、4、5号点，权值和为 3+4+5 = 12 。</p><p>数据规模与约定<br>对于20%的数据， n &lt;= 20。<br>对于50%的数据， n &lt;= 1000。<br>对于100%的数据， n &lt;= 100000。<br>权值均为不超过1000的正整数</p><p><a href="https://www.cnblogs.com/program-ccc/p/5221932.html">https://www.cnblogs.com/program-ccc/p/5221932.html</a></p><p>状态转移方程：</p><p>dp[x][1] = dp[x][1] + dp[u][0]  (u为x的子结点)</p><p>dp[x][0] = dp[x][0] + max{dp[u][0],dp[u][1]}(u为x的子结点)</p><figure class="highlight plaintext"><figcaption><span>[结点选择] [lang:C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN=8;</span><br><span class="line">int w[MAXN]; // 各点的权值</span><br><span class="line">vector&lt;int&gt; tree[MAXN]; // 数组下标对应的向量存贮该下标结点的邻接点</span><br><span class="line">int n;</span><br><span class="line">int dp[MAXN][2]; //dp[u][1] 存储 选了自己结点u的权值最大值 dp[u][0]存储不选结点u权值和</span><br><span class="line">int vis[MAXN]; // 判断是否遍历过</span><br><span class="line"></span><br><span class="line">void dfs(int u) // 结点u的dfs</span><br><span class="line">&#123;</span><br><span class="line">    vis[u]=1; </span><br><span class="line">    dp[u][0]=0;</span><br><span class="line">    dp[u][1]=w[u];</span><br><span class="line">    int s0=0,s1=0;</span><br><span class="line">    for(int i=0;i&lt;tree[u].size();i++) // 遍历结点u邻接结点v</span><br><span class="line">    &#123;</span><br><span class="line">        int v=tree[u][i]; </span><br><span class="line">        if(!vis[v])</span><br><span class="line">        &#123;</span><br><span class="line">            dfs(v); // 结点v的dfs</span><br><span class="line">            s0+=max(dp[v][0],dp[v][1]);</span><br><span class="line">            s1+=dp[v][0];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[u][0]+=s0;</span><br><span class="line">    dp[u][1]+=s1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;w[i]);</span><br><span class="line">    </span><br><span class="line">    for(int i=1;i&lt;=n-1;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int u,v;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;u,&amp;v);</span><br><span class="line">        tree[u].push_back(v);</span><br><span class="line">        tree[v].push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs(1);</span><br><span class="line">    </span><br><span class="line">    printf(&quot;%d\n&quot;,max(dp[1][0],dp[1][1]));</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;问题描述&lt;/p&gt;
&lt;p&gt;有一棵 n 个节点的树，树上每个节点都有一个正整数权值。如果一个点被选择了，那么在树上和它相邻的点都不能被选择。求选出的点的权值和最大是多少？&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="http://akkaduilin.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="树形DP" scheme="http://akkaduilin.com/categories/%E9%A2%98%E8%A7%A3/%E6%A0%91%E5%BD%A2DP/"/>
    
    
    <category term="C++" scheme="http://akkaduilin.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>归并排序实战——逆序对问题</title>
    <link href="http://akkaduilin.com/2022/04/04/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E9%80%86%E5%BA%8F%E5%AF%B9%E9%97%AE%E9%A2%98/"/>
    <id>http://akkaduilin.com/2022/04/04/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E9%80%86%E5%BA%8F%E5%AF%B9%E9%97%AE%E9%A2%98/</id>
    <published>2022-04-04T09:38:03.000Z</published>
    <updated>2022-04-08T13:21:33.336Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>关于逆序对问题的题解和思路</p><span id="more"></span><p><strong>归并排序原算法指路：</strong></p><a href="/2021/12/01/%E6%8E%92%E5%BA%8F/" title="五种排序">五种排序</a><a href="/2021/12/01/%E6%8E%92%E5%BA%8F/" title="排序">排序</a><p><strong>逆序对：设a[0…n]为包含n个不数的一个序列，如果n&lt;m，且a[n]&gt;a[m],则称(n,m)构成a中的一个逆序对；</strong></p><p><a href="https://www.jb51.net/article/55283.htm">https://www.jb51.net/article/55283.htm</a></p><p>归并排序思想，先递归分治至两个数组内再依次返回排序比较<br>注意若左边数组大于右边数组，总计数应加上 <strong>mid - index1 + 1</strong><br>因为右数组是有序的，当左指针移动时会出现多个逆序对的情况，所以加上中间指针下标减去右指针所在下标加上1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int array[] = &#123;3, 9, 7, 4, 5, 2&#125;;</span><br><span class="line">const int size = sizeof array / sizeof *array;</span><br><span class="line">int temp[size];</span><br><span class="line">//int numbers[size];</span><br><span class="line"></span><br><span class="line">int reversePair(int *numbers, int start, int last, int &amp;index, int &amp;count)</span><br><span class="line">&#123;</span><br><span class="line">  if(start == last)</span><br><span class="line">  return 0;</span><br><span class="line">  int mid = (last - start) / 2 + start;</span><br><span class="line">  //递归分治</span><br><span class="line">  reversePair(numbers, start, mid, index, count);</span><br><span class="line">  reversePair(numbers, mid + 1, last, index, count);</span><br><span class="line"></span><br><span class="line">  for(int i = start; i &lt;= last; i++)</span><br><span class="line">    temp[i] = numbers[i];</span><br><span class="line"></span><br><span class="line">  int index1 = start, index2 = mid + 1;</span><br><span class="line">  index = start;</span><br><span class="line">  while(index1 &lt;= mid &amp;&amp; index2 &lt;= last) &#123;</span><br><span class="line">    if(temp[index1] &gt; temp[index2]) &#123;</span><br><span class="line">      numbers[index] = temp[index2];//将值较小的优先排入数组，起到排序作用</span><br><span class="line">      count += mid - index1 + 1;</span><br><span class="line">      index++;</span><br><span class="line">      index2++;</span><br><span class="line">    &#125; </span><br><span class="line">    else if(temp[index1] == temp[index2]) &#123;</span><br><span class="line">      numbers[index] = temp[index1];</span><br><span class="line">      index++;</span><br><span class="line">      index1++;</span><br><span class="line">      index2++;</span><br><span class="line">    &#125; </span><br><span class="line">    else if(temp[index1] &lt; temp[index2]) &#123;</span><br><span class="line">      numbers[index] = temp[index1];</span><br><span class="line">      index++;</span><br><span class="line">      index1++;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(index1 &lt;= mid) &#123;</span><br><span class="line">      while(index1 &lt;= mid) &#123;</span><br><span class="line">        numbers[index] = temp[index1];</span><br><span class="line">        index++;</span><br><span class="line">        index1++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    else &#123;</span><br><span class="line">      while(index2 &lt;= last) &#123;</span><br><span class="line">        numbers[index] = temp[index2];</span><br><span class="line">        index++;</span><br><span class="line">        index2++;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">  int count = 0;</span><br><span class="line">  int index = 0;</span><br><span class="line">  reversePair(array, 0, size - 1, index, count);</span><br><span class="line">  cout &lt;&lt; &quot;count = &quot; &lt;&lt; count &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关于逆序对问题的题解和思路&lt;/p&gt;</summary>
    
    
    
    <category term="题解 - 归并排序" scheme="http://akkaduilin.com/categories/%E9%A2%98%E8%A7%A3-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    
    
    <category term="C++" scheme="http://akkaduilin.com/tags/C/"/>
    
    <category term="排序" scheme="http://akkaduilin.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>关系代数</title>
    <link href="http://akkaduilin.com/2022/03/24/%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0/"/>
    <id>http://akkaduilin.com/2022/03/24/%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0/</id>
    <published>2022-03-24T13:34:27.000Z</published>
    <updated>2022-03-28T06:08:04.563Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>数据库笔记 ——  关系代数</p><span id="more"></span><h1 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h1><p><a href="https://sm.ms/image/6TerPQDAohzCOqf" target="_blank"><img src="https://s2.loli.net/2022/03/24/6TerPQDAohzCOqf.png" ></a></p><h2 id="传统运算"><a href="#传统运算" class="headerlink" title="传统运算"></a>传统运算</h2><ol><li><p>并：假设有两个关系 R1 和 R2,R1 和 R2 的并运算产生一个新关系 R3。R3 是 由属于关系 R1 或 R2 的所有不同元组所组成，记为 R3=R1∪R2。 </p></li><li><p>差：假设有两个关系 R1 和 R2，R1 和 R2 的差运算产生一个新关系 R3。R3 是由属于关系关系 R1，但不属于 R2 的元组组成，记为 R3=R1-R2。 </p></li><li><p>交：假设有两个关系 R1 和 R2，R1 和 R2 的交运算产生一个新关系 R3。R3 是由既属于关系 R1，同时又属于 R2 的元组组成，记为 R3=R1∩R2。</p></li><li><p>笛卡尔积：假设有两个关系 R1 和 R2，且 R1 为 m 元关系，R2 为 n 元关系， R1 和 R2 的笛卡尔积产生一个新关系 R3，记作 R3=R1✖R2。R3 是由 R1 和 R2 的所有元组连接而成的具有(m+n)个分量的元组组成。</p></li></ol><h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><p>关系代数中用符号 σ（西格玛，sigma）来描述选择语句。选择是根据某些条件对关系做水平切割<br>此外我们可以在 select 的同时，添加限制条件（即 where），使用例如下：</p><p><a href="https://sm.ms/image/fmZdWqKQ8Peuo6k" target="_blank"><img src="https://s2.loli.net/2022/03/24/fmZdWqKQ8Peuo6k.png" ></a></p><p>等价与</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from student where AGE=19;</span><br></pre></td></tr></table></figure><h2 id="投影"><a href="#投影" class="headerlink" title="投影"></a>投影</h2><p>投影与选择正好相反，是对关系的一种垂直切割</p><p>在关系代数中的投影语句相当于 SQL 中的字段筛选，可以选择特定的字段进行查询，格式如下：<br><a href="https://sm.ms/image/GuvKOoS2LVZQ8RF" target="_blank"><img src="https://s2.loli.net/2022/03/24/GuvKOoS2LVZQ8RF.png" ></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select sno, age, sname from student;</span><br></pre></td></tr></table></figure><p>当选择和投影连用时<br>可以和where联动 相当于一个完整的selec语句<br><a href="https://sm.ms/image/P5sA9udivbH7YRZ" target="_blank"><img src="https://s2.loli.net/2022/03/24/P5sA9udivbH7YRZ.png" ></a><br>select sname from student where AGE=19;</p><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><p><a href="https://sm.ms/image/DxoWVwcfCKZEYRm" target="_blank"><img src="https://s2.loli.net/2022/03/25/DxoWVwcfCKZEYRm.png" ></a><br>连接运算：从两个关系的笛卡尔积中选取属性间满足一定条件的元组，用(R ⋈ S）表示。<br>连接分为两种，<br>一种是等值连接(θ 为 = 关系)<br>另一种是自然连接 根据R与S共同的属性进行选择 结果中去掉重复属性列 自然联接是特殊的的等值联接</p><p><a href="https://sm.ms/image/HUV3amCqj2ngelx" target="_blank"><img src="https://s2.loli.net/2022/03/25/HUV3amCqj2ngelx.jpg" ></a></p><p>自然连接时，被舍弃的元组称为<strong>悬浮元组</strong>，如果将悬浮元组也保存在结果中，在其他属性保持空值，称为<strong>外连接</strong>，只保留左边R中的悬浮元组称为<strong>左外连接</strong>，只保留右边S中的悬浮元组称为<strong>右外连接</strong></p><p><a href="https://sm.ms/image/buEwmhMo6UJ7yN1" target="_blank"><img src="https://s2.loli.net/2022/03/28/buEwmhMo6UJ7yN1.jpg" ></a></p><h2 id="除运算"><a href="#除运算" class="headerlink" title="除运算"></a>除运算</h2><p><a href="https://sm.ms/image/NfL7kYnJmTgaA53" target="_blank"><img src="https://s2.loli.net/2022/03/23/NfL7kYnJmTgaA53.png" ></a></p><h3 id="象集"><a href="#象集" class="headerlink" title="象集"></a>象集</h3><p>象集：本质上是一次选择行的运算和一次选择列的运算。<br>求x1在表A中的象集，就是先选出所有x属性中x=x1的那些行，然后选择出不包含x1的那些列。</p><p>如A：<br>X     Y     Z<br>a1    b1    c2<br>a2    b3    c7<br>a3    b4    c6<br>a1    b2    c3<br>a4    b6    c6<br>a2    b2    c3<br>a1    b2    c1<br>a1在A中的象集为{(b1,c2),(b2,c3),(b2,c1)}</p><h3 id="除运算-1"><a href="#除运算-1" class="headerlink" title="除运算"></a>除运算</h3><p>设关系R除以关系S的结果为关系T，则T包含所有在R但是不在S中的属性及其值，且T的元组与S的元组的所有集合都在R中</p><p>R与S的除运算构成新的关系P(X),P是R中满足下列条件的元组在X属性列上的投影，元组在X上分量值x的象集Yx包含S在Y上投影的集合。</p><p><a href="https://sm.ms/image/JXj2BdQ31NFn4SE" target="_blank"><img src="https://s2.loli.net/2022/03/26/JXj2BdQ31NFn4SE.png" ></a></p><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数据库笔记 ——  关系代数&lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="http://akkaduilin.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="笔记" scheme="http://akkaduilin.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="SQL" scheme="http://akkaduilin.com/tags/SQL/"/>
    
    <category term="数据库" scheme="http://akkaduilin.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="关系代数" scheme="http://akkaduilin.com/tags/%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>SQL数据查询</title>
    <link href="http://akkaduilin.com/2022/03/23/SQL%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2/"/>
    <id>http://akkaduilin.com/2022/03/23/SQL%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2/</id>
    <published>2022-03-23T01:59:50.000Z</published>
    <updated>2022-04-08T08:48:42.372Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>SQL的查询相关代码</p><p><a href="https://blog.csdn.net/weixin_44176696/article/details/112586831">https://blog.csdn.net/weixin_44176696/article/details/112586831</a></p><span id="more"></span><h1 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h1><h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><p>数据查询是数据库的核心操作，SQL 使用 SELECT 语句进行数据库的查询，其一般格式<br>为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT [ ALL｜DISTINCT ] &lt; 目标列表达式 &gt; [，&lt;目标列表达式 &gt; …] </span><br><span class="line">FROM &lt; 表名或视图名 &gt; [，&lt;表名或视图名&gt;… ] </span><br><span class="line">[ WHERE &lt; 条件表达式&gt; ]</span><br><span class="line">[ GROUP BY &lt; 列名列表&gt; [ HAVING &lt; 条件表达式&gt; ] ]</span><br><span class="line">[ ORDER BY &lt; 列名&gt; [ ASC ｜DESC ] ]；</span><br></pre></td></tr></table></figure><p>（1） []：表示[]中的内容是可选的，比如[ WHERE &lt; 条件表达式&gt; ]，表示可以使用 WHERE 也可以不使用</p><p>（2） &lt;&gt;：表示&lt;&gt;中的内容必须出现。比如&lt; 表名或视图名 &gt;，这个部分表示从哪个地方获取数据，是不可或缺的。</p><p>（3） ｜：表示选择其一，例如 &lt; 列名 2&gt; [ ASC ｜DESC ] ]，表示列名 2 后只能用ASC或者DESC其中之一来进行结果的排序，前者代表升序，后者代表降序。</p><p>（4） [，…]：表示括号中的内容可以重复出现 1 至多次。</p><p>（5） * 表示相应范围内的所有内容 select * 表示查找表中所有数据</p><h2 id="列操作"><a href="#列操作" class="headerlink" title="列操作"></a>列操作</h2><h3 id="查询列"><a href="#查询列" class="headerlink" title="查询列"></a>查询列</h3><p>在 SQL 语句中，用 FROM 子句指定要操纵的表，SELECT 子句给出要投影的列，对应的 SQL 语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select A,B </span><br><span class="line">from T_A</span><br><span class="line"></span><br><span class="line">select * </span><br><span class="line">from T_B</span><br></pre></td></tr></table></figure><p>SELECT 语句的执行结果是一个新表，这个表没有名字，是个临时表，它的关系模式由SELECT 子句里的属性列构成</p><p>select * 表示查找全部列</p><h3 id="列别名"><a href="#列别名" class="headerlink" title="列别名"></a>列别名</h3><p>有时候，我们希望查询结果中的某些列名不同于基本表中的列名，这时，可以在 SELECT<br>子句中增加列别名。<br>SQL 语句使用 AS 关键词对列设置“别名”。AS 使用格式如下：</p><p>旧名 AS 别名</p><p>eg：<br>查询曲库里的所有歌曲的详细信息，请把表中的各个列名：SongID，Name，Lyricist，Composer，Lang 分别替换成：歌曲编号、歌曲名称、词作者、曲作者、语言类别。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT SongID AS 歌曲编号, Name AS 歌曲名称, Lyricist AS 词作者,Composer AS 曲作者, Lang AS 语言类别</span><br><span class="line">FROM Songs;</span><br></pre></td></tr></table></figure><h3 id="查询计算列"><a href="#查询计算列" class="headerlink" title="查询计算列"></a>查询计算列</h3><p>SELECT 子句的&lt;目标列表达式&gt;不仅可以是表中真实存在的列，也可以是一个表达式。可以使用常量计算表达式或者函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT SongID, SingerID, Circulation*10000 as NewCirculation</span><br><span class="line">FROM Track</span><br><span class="line"></span><br><span class="line">SELECT Name as 姓名, Birth as 出生日期, 2012-Year（Birth） as 年龄</span><br><span class="line">FROM Singers</span><br></pre></td></tr></table></figure><h3 id="过滤重复列"><a href="#过滤重复列" class="headerlink" title="过滤重复列"></a>过滤重复列</h3><p>两条本来并不完全相同的元组，投影到某些列上后，可能变成相同的行了，可以用DISTINCT 关键字过滤它们。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT Style</span><br><span class="line">FROM Track;</span><br></pre></td></tr></table></figure><h2 id="where-子句"><a href="#where-子句" class="headerlink" title="where 子句"></a>where 子句</h2><p>WHERE 子句用于表达关系代数中选择运算的选择条件。<br><a href="https://sm.ms/image/dJUMtu5DN2VwaYr" target="_blank"><img src="https://s2.loli.net/2022/03/24/dJUMtu5DN2VwaYr.png" ></a></p><p>逻辑运算符 AND 和 OR 可以用来联结多个查询条件。<strong>AND 的优先级高于 OR</strong>，但用户可以用括号来改变优先级。</p><h3 id="确定范围"><a href="#确定范围" class="headerlink" title="确定范围"></a>确定范围</h3><p>比较运算符包括：=（等于），&gt;（大于），&lt;(小于)，&gt;=（大于等于），&lt;=（小于等于），!=<br>或者&lt;&gt;（不等于）。</p><p>谓词 BETWEEN…AND 用于查询列值在指定范围内]的元组，其中 BETWEEN 后面跟的<br>是范围下限，AND 后跟的是范围的上限。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT Name, Birth</span><br><span class="line">FROM Singers</span><br><span class="line">Where Birth&lt;1967</span><br><span class="line"></span><br><span class="line">求查询出生年份不在 1970~1980 之间的歌手的姓名与性别</span><br><span class="line">SELECT Name, Gender</span><br><span class="line">FROM Singers</span><br><span class="line">WHERE Birth NOT BETWEEN 1970 AND 1980;</span><br></pre></td></tr></table></figure><h3 id="字段匹配"><a href="#字段匹配" class="headerlink" title="字段匹配"></a>字段匹配</h3><p>谓词 LIKE 可以用来进行字符串的匹配。 其一般语法格式如下：</p><p>列名 [NOT] LIKE ‘&lt;匹配串&gt;’ [ESCAPE ‘&lt;换码字符&gt;’]</p><p>其含义是查找列值与&lt;匹配串&gt;相匹配的元组。通常，&lt;匹配串&gt;中可以使用通配符“%”（百分号）和“_”（下横线）。<br>其中：<br>%：代表任意长度（长度可以为 0）的字符串。例如，a%b 表示以 a 开头、以 b 结尾的<br>任意长度的字符串。字符串 ab、axb、agxb 都满足该匹配串。<br>_：代表任意单个字符。例如，a_b 表示以 a 开头，以 b 结尾，中间夹一个字符的任意字<br>符串。如 axb、a!b 等都满足要求。</p><p>如果用户要查询的字符串本身就含有%或_，这时就要使用’ESCAPE&lt;换码字符&gt;’对通配<br>符进行转义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">查询歌手编号以“GC”开头的歌手姓名、性别。</span><br><span class="line">SELECT Name, Gender</span><br><span class="line">FROM Singers</span><br><span class="line">WHERE SingerID like ‘GC%’</span><br><span class="line"></span><br><span class="line">查询以”John_”开头的歌手的详细信息。</span><br><span class="line">SELECT *</span><br><span class="line">FROM Singers</span><br><span class="line">WHERE Name like ‘John\_%’ ESCAPE ’\’;</span><br></pre></td></tr></table></figure><h3 id="确定集合-判空"><a href="#确定集合-判空" class="headerlink" title="确定集合/判空"></a>确定集合/判空</h3><p>谓词 IN 用来查找某个列值属于指定集合的元组，格式为：</p><p>列名 IN/NOTT IN 集合 (x , x , x , x )</p><p>谓词 IS NULL 用于判断某列的值是否为空值，格式如下：</p><p>列名 IS NULL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">查询曲目表中既不属于“乡村”、“爵士”也不是“摇滚”曲风的专辑详细信息。</span><br><span class="line">SELECT SongID, SingerID</span><br><span class="line">FROM Track</span><br><span class="line">WHERE Style NOT IN (‘乡村’, ‘爵士’ , ‘摇滚’);</span><br><span class="line"></span><br><span class="line">查询曲目表中缺少发行量信息的记录。</span><br><span class="line">SELECT *</span><br><span class="line">FROM Track</span><br><span class="line">WHERE Circulation IS NULL;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="order-by-子句"><a href="#order-by-子句" class="headerlink" title="order by 子句"></a>order by 子句</h2><p>由 SELECT-FROM-WHERE 构成的 SELECT 查询语句完成对表的选择和投影操作，得到一个新的结果表，还可以对得到的新表做进一步的操作。</p><p>ORDER BY 子句用于对查询结果进行排序。<strong>可以按照一个或者多个属性列进行升序（ASC）或者降序(DESC)排列</strong>，默认将按照升序排列。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">查询曲目表中的歌手编号、歌曲编号和曲风类别，将查询结果按照发行时间降序排列。</span><br><span class="line"></span><br><span class="line">SELECT SongID, SingerID, Style</span><br><span class="line">FROM Track</span><br><span class="line">ORDER BY PubYear DESC,SingerID ASC;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="聚集函数"><a href="#聚集函数" class="headerlink" title="聚集函数"></a>聚集函数</h2><p>AVG()：返回某列的平均值</p><p>COUNT()：返回某列的行数</p><p>MAX()：返回某列的最大值</p><p>MIN()：返回某列的最小值</p><p>SUM()：返回某列值之和<br>如果指定 DISTINCT 标识符，则表示计算时要取消指定列中的重复值。如果不指定DISTINCT 或指定 ALL（ALL 为缺省），则表示不取消重复值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">查询 Track 表中的记录总数，最早发行时间、最近发行时间和整个发行量的总和。</span><br><span class="line"></span><br><span class="line">SELECT Count(*) as 记录总数, MIN(PubYear) as ‘最早发行量’, MAX(PubYear) as ‘最近发行</span><br><span class="line">时间’, SUM(Circulation) as ‘发行量总和’</span><br><span class="line"></span><br><span class="line">FROM Track</span><br></pre></td></tr></table></figure><h2 id="group-by-子句"><a href="#group-by-子句" class="headerlink" title="group by 子句"></a>group by 子句</h2><p>聚合函数是对查询结果（一个元组集）中的值进行统计。在有的查询中，我们要把具有相同特征的元组分成若干子集，然后需要再对每个子集中的值进行统计，此时就要用到SELECT 句型中的分组子句“GROUP BY”，格式为:</p><p>GROUP BY &lt;列名列表&gt;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM access_log;</span><br><span class="line">+-----+---------+-------+------------+</span><br><span class="line">| aid | site_id | count | date       |</span><br><span class="line">+-----+---------+-------+------------+</span><br><span class="line">|   1 |       1 |    45 | 2016-05-10 |</span><br><span class="line">|   2 |       3 |   100 | 2016-05-13 |</span><br><span class="line">|   3 |       1 |   230 | 2016-05-14 |</span><br><span class="line">|   4 |       2 |    10 | 2016-05-14 |</span><br><span class="line">|   5 |       5 |   205 | 2016-05-14 |</span><br><span class="line">|   6 |       4 |    13 | 2016-05-15 |</span><br><span class="line">|   7 |       3 |   220 | 2016-05-15 |</span><br><span class="line">|   8 |       5 |   545 | 2016-05-16 |</span><br><span class="line">|   9 |       3 |   201 | 2016-05-17 |</span><br><span class="line">+-----+---------+-------+------------+</span><br><span class="line">9 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">统计 access_log 各个 site_id 的访问量：</span><br><span class="line">SELECT site_id, SUM(access_log.count) AS nums</span><br><span class="line">FROM access_log GROUP BY site_id;</span><br></pre></td></tr></table></figure><p>在用分组语句时，SELECT 后跟的列只能是聚集函数或者是出现在 GROUP BY 之后的分组列。</p><h2 id="having-子句"><a href="#having-子句" class="headerlink" title="having 子句"></a>having 子句</h2><p>在 SQL 中增加 HAVING 子句原因是，WHERE 关键字无法与聚合函数一起使用。</p><p>HAVING 子句可以让我们筛选分组后的各组数据。</p><p><a href="https://www.runoob.com/sql/sql-having.html">https://www.runoob.com/sql/sql-having.html</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT column_name, aggregate_function(column_name)</span><br><span class="line">FROM table_name</span><br><span class="line">WHERE column_name operator value</span><br><span class="line">GROUP BY column_name</span><br><span class="line">HAVING aggregate_function(column_name) operator value;</span><br></pre></td></tr></table></figure><h2 id="笛卡儿积和连接"><a href="#笛卡儿积和连接" class="headerlink" title="笛卡儿积和连接"></a>笛卡儿积和连接</h2><p>SQL 在一个查询中建立几个表的联系的方法非常简单，只要在 FROM 子句中列出所有<br>涉及到的表就可以了。从概念上讲，FROM 子句先对这些表做笛卡尔积操作，得到一个临<br>时表，以后的选择、投影等操作都是针对这个临时表，从而将多表查询转换为单表查询。</p><p>一般格式为</p><p><strong>[&lt;表名 1&gt;.]&lt;列名 1&gt; &lt;比较运算符&gt; [&lt;表名 2&gt;.]&lt;列名 2&gt;</strong></p><h2 id="join-子句"><a href="#join-子句" class="headerlink" title="join 子句"></a>join 子句</h2><p><a href="https://sm.ms/image/KJqzfrO1AQtiM9u" target="_blank"><img src="https://s2.loli.net/2022/03/30/KJqzfrO1AQtiM9u.jpg" ></a></p><h3 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h3><p>在非 ANSI 标准的实现中，连接是在 WHERE 子句中执行的（即在 WHERE 子句中指定表间的连接条件）；在 ANSI SQL-92 中，连接是在 JOIN 子句中执行的。前者称为Theta 连接，后者称为 ANSI 连接。</p><p>ANSI 内连接的语法格式：<br>FROM 表 1 [INNER] JOIN 表 2 ON &lt;连接条件&gt;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">eg ：列出曲库中所有演唱过歌曲的歌手名，歌曲名和发行量。</span><br><span class="line"></span><br><span class="line">Theta 方式的 SQL 语句：</span><br><span class="line">SELECT Songs.Name AS 歌曲名, Singers.Name AS 歌手名,Circulation AS 发行量</span><br><span class="line">FROM Songs,Track,Singers</span><br><span class="line">WHERE Songs.SongID=Track.SongID AND Track.SingerID=Singers.SingerID</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ANSI 方式的 SQL 语句为：</span><br><span class="line">SELECT Songs.Name AS 歌曲名, Singers.Name AS 歌手名,Circulation AS 发行量</span><br><span class="line">FROM Songs JOIN Track ON Songs.SongID=Track.SongID</span><br><span class="line">JOIN Singers ON Track.SingerID=Singers.SingerID</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="自身连接"><a href="#自身连接" class="headerlink" title="自身连接"></a>自身连接</h3><p><strong>连接操作不仅可以在两个表之间进行，也可以与其自身进行连接，称为表的自身连接。</strong></p><p>可以为表提供别名，其格式如下：<br>FROM &lt;源表名&gt; [AS] &lt;表别名&gt;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT FIRST.CNumber， SECOND.PCNumber</span><br><span class="line">FROM Course FIRST， Course SECOND</span><br><span class="line">WHERE FIRST.PCNumber=SECOND.CNumber；</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><p>外连接之限制一张表中的数据必须满足连接条件，而另一张表中的数据可以不满足连接<br>条件。</p><p>Theta 方式的外连接语法格式为：<br>左外连接：FROM 表 1，表 2 WHERE [表 1.]列名(+)=[表 2.]列名<br>右外连接：FROM 表 1，表 2 WHERE [表 1.]列名=[表 2.]列名(+)</p><p>ANSI 方式的外连接语法格式为：<br>FROM 表 1 LEFT | RIGHT JOIN [OUTER] 表 2 ON &lt;连接条件&gt;</p><p>SQL SERVER 支持 ANSI 方式的外连接，但 ORACLE 支持的是 Theta 方式的外连接。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT column_name(s)</span><br><span class="line">FROM table1</span><br><span class="line">FULL OUTER/RIGHT/LEFT JOIN table2</span><br><span class="line">ON table1.column_name=table2.column_name;</span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>在实际应用中，经常有一些 SELECT 语句需要使用其他 SELECT 语句的查询结果，此时就需要用到子查询。</p><h3 id="IN谓词子查询"><a href="#IN谓词子查询" class="headerlink" title="IN谓词子查询"></a>IN谓词子查询</h3><p>其格式如下：<br>SELECT &lt;列名&gt; [,&lt;列名&gt;] …<br>FROM &lt;表名&gt;<br>WHERE &lt;表达式&gt; &lt;[NOT] IN | 其它比较运算符&gt;<br>(<br>  SELECT &lt;列名&gt;<br>  FROM &lt;表名&gt;<br>  WHERE &lt;条件&gt;<br>）</p><p>NOT IN 执行的是集合运算 其他运算符执行比较运算</p><p>使用 IN 运算时，如果表达式的值与集合中的某个值相等，则此运算结果为真；如果表达式的值与集合中的所有值均不相等，则运算结果为假。由关键字 IN 引入的子查询的 SELECT 后的列名只允许有 1 项内容，即只能是一个列名或者是表达式。</p><p>使用子查询进行比较运算时，通过比较运算符（=、&lt;&gt;、&lt;、&gt;、&lt;=、&gt;=），将一个表达式的值与子查询返回的值进行比较。如果比较运算的结果为真，则比较运算返回 TRUE。使用子查询进行比较测试时，要求子查询语句必须是返回单值的查询语句。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">查询歌唱风格是“摇滚”的歌手信息。</span><br><span class="line"></span><br><span class="line">SELECT *</span><br><span class="line">FROM Singers</span><br><span class="line">WHERE SingerID IN</span><br><span class="line">(</span><br><span class="line">  SELECT DISTINCT SingerID</span><br><span class="line">  FROM Track</span><br><span class="line">  WHERE Style =’摇滚’ </span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="带有比较运算符的子查询"><a href="#带有比较运算符的子查询" class="headerlink" title="带有比较运算符的子查询"></a>带有比较运算符的子查询</h3><p>使用子查询进行比较运算时，通过比较运算符（=、&lt;&gt;、&lt;、&gt;、&lt;=、&gt;=），将一个表达式的值与子查询返回的值进行比较。如果比较运算的结果为真，则比较运算返回 TRUE。使用子查询进行比较测试时，要求子查询语句必须是返回单值的查询语句。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">查询年龄最大的歌手的信息</span><br><span class="line"></span><br><span class="line">SELECT *</span><br><span class="line">FROM Singers</span><br><span class="line">WHERE Birth =</span><br><span class="line">(</span><br><span class="line">  SELECT MAX(Birth)</span><br><span class="line">  FROM Singers</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="带有ANY或ALL谓词的子查询"><a href="#带有ANY或ALL谓词的子查询" class="headerlink" title="带有ANY或ALL谓词的子查询"></a>带有ANY或ALL谓词的子查询</h3><p><a href="https://sm.ms/image/UVIQPu9qDElgR6o" target="_blank"><img src="https://s2.loli.net/2022/03/30/UVIQPu9qDElgR6o.jpg" ></a></p><p><a href="https://blog.csdn.net/qq_38157534/article/details/108527994">https://blog.csdn.net/qq_38157534/article/details/108527994</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">【例】查询非计算机科学系中比计算机科学系任意一个学生年龄小的学生姓名和年龄</span><br><span class="line">select Sname，Sage </span><br><span class="line">from student</span><br><span class="line">where Sage &lt; ANY</span><br><span class="line">  ( select  Sage </span><br><span class="line">    from student </span><br><span class="line">    where Sdept  = &quot;CS&quot;) </span><br><span class="line">AND Sdept &lt;&gt; &quot;CS&quot;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="带有EXISTS谓词的子查询"><a href="#带有EXISTS谓词的子查询" class="headerlink" title="带有EXISTS谓词的子查询"></a>带有EXISTS谓词的子查询</h3><p>相关子查询通常使用 EXISTS 谓词，其形式为：<br>SELECT &lt;列名&gt; [,&lt;列名&gt;] …<br>FROM &lt;表名&gt;<br>WHERE<br>WHERE [NOT] EXISTS<br>(<br>  SELECT *<br>  FROM &lt;表名&gt;<br>  WHERE &lt;条件&gt;<br>)</p><p>带有 EXISTS 谓词的子查询不返回任何数据，只产生逻辑真值“true”或逻辑假值“false”：<br><em>若内层查询结果非空，则外层的 WHERE 子句返回真值</em><br><em>若内层查询结果为空，则外层的 WHERE 子句返回假值</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">查询歌唱风格是“摇滚”的歌手信息。</span><br><span class="line"></span><br><span class="line">SELECT *</span><br><span class="line">FROM Singers X</span><br><span class="line">WHERE EXISTS</span><br><span class="line">(</span><br><span class="line">SELECT *</span><br><span class="line">FROM Track</span><br><span class="line">WHERE Track.SingerID=X.SingerID and Style =’摇滚’ )</span><br></pre></td></tr></table></figure><h2 id="集合查询"><a href="#集合查询" class="headerlink" title="集合查询"></a>集合查询</h2><p>SELECT 查询操作的对象是集合，结果也是集合。集合操作主要包括并操作 UNION，交操作 INTERSECT 和差操作 EXCEPT。</p><p>注意： 参加集合操作的各查询结果的列数必须相同；对应项的数据类型也要相同。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">查询中国歌手和出生日期晚于 1960 年的歌手。</span><br><span class="line"></span><br><span class="line">SELECT *</span><br><span class="line">FROM Singers</span><br><span class="line">WHERE Nation=’中国’</span><br><span class="line">UNION</span><br><span class="line">SELECT *</span><br><span class="line">FROM Singers</span><br><span class="line">WHERE Birth&gt;=1960</span><br></pre></td></tr></table></figure><h1 id="xx3x"><a href="#xx3x" class="headerlink" title="xx3x"></a>xx3x</h1><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SQL的查询相关代码&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_44176696/article/details/112586831&quot;&gt;https://blog.csdn.net/weixin_44176696/article/details/112586831&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="http://akkaduilin.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="笔记" scheme="http://akkaduilin.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="SQL" scheme="http://akkaduilin.com/tags/SQL/"/>
    
    <category term="数据库" scheme="http://akkaduilin.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="关系代数" scheme="http://akkaduilin.com/tags/%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>自动机基础</title>
    <link href="http://akkaduilin.com/2022/03/10/%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    <id>http://akkaduilin.com/2022/03/10/%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%9F%BA%E7%A1%80/</id>
    <published>2022-03-10T08:00:34.000Z</published>
    <updated>2022-04-11T08:38:07.678Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>编译原理语法分析和自动机笔记</p><span id="more"></span><h1 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h1><ol><li>词法记号：由记号名和属性值构成的二元组，属性值不是必须项，记号名是语法分析的输入符号。</li><li>模式：一个记号的模式描述属于该记号的词法单元的形式。和一个给定模式匹配的字（字符串）的集合成为该模式的语言。</li><li>词法单元：是源程序中匹配一个记号模式的字符序列，由词法分析器识别为该记号的一个实例。<br><a href="https://sm.ms/image/uPWla5wI7JXTDYb" target="_blank"><img src="https://s2.loli.net/2022/04/10/uPWla5wI7JXTDYb.png" ></a></li></ol><h1 id="有限自动机"><a href="#有限自动机" class="headerlink" title="有限自动机"></a>有限自动机</h1><p>词法单元的识别<br><a href="https://sm.ms/image/gv2d78rL1SQahHc" target="_blank"><img src="https://s2.loli.net/2022/04/10/gv2d78rL1SQahHc.png" ></a></p><h2 id="状态转换图"><a href="#状态转换图" class="headerlink" title="状态转换图"></a>状态转换图</h2><ol><li>圆圈表示状态，开始状态由一条没有出发节点、标号为“开始”的边指明</li><li>双层圆圈表示接受状态，表示已识别一个记号</li><li>有向边表示从一个状态到另一状态</li><li>每条边的标号包含一个或多个符号，若离开状态s的某边上标号为other，则它表示离开s的其他边所指示的字符以外的任意字符</li><li>*表示输入指针必须回退的转态</li></ol><p><a href="https://sm.ms/image/Cwu4Y2OULmiG1IJ" target="_blank"><img src="https://s2.loli.net/2022/04/10/Cwu4Y2OULmiG1IJ.png" ></a></p><p>使用*installNum()*来获取要返回的记号名和属性</p><h2 id="不确定的有限自动机（NFA）"><a href="#不确定的有限自动机（NFA）" class="headerlink" title="不确定的有限自动机（NFA）"></a>不确定的有限自动机（NFA）</h2><p><em>不确定的含义是存在这样的状态，对于某个输入符号，存在不止一种的转换</em></p><p><a href="https://sm.ms/image/QKDBcj7fCsMP59F" target="_blank"><img src="https://s2.loli.net/2022/04/10/QKDBcj7fCsMP59F.png" ></a></p><p><strong>手工构造NFA</strong><br><a href="https://sm.ms/image/GJVDSbQnlEvoU34" target="_blank"><img src="https://s2.loli.net/2022/04/10/GJVDSbQnlEvoU34.png" ></a></p><p><strong>转换表表示在NFA输入是a时，状态i所能到达的状态集合。</strong></p><h2 id="确定的有限自动机（DFA）"><a href="#确定的有限自动机（DFA）" class="headerlink" title="确定的有限自动机（DFA）"></a>确定的有限自动机（DFA）</h2><p>是不确定自动机的特殊情况</p><ol><li>任何状态不存在空转换</li><li>对任何状态s和输入符号a，最多只有一条标记为a的边离开s，即转换函数move最多只有一个，并且可以是不分函数</li><li>如果用转换表来表示DFA，表中每个条目最多只有一个状态。</li></ol><p><a href="https://sm.ms/image/b2lZOW4RVk5xnBi" target="_blank"><img src="https://s2.loli.net/2022/04/10/b2lZOW4RVk5xnBi.png" ></a></p><p><a href="https://sm.ms/image/gQ5wBUqhaXrbkiR" target="_blank"><img src="https://s2.loli.net/2022/04/10/gQ5wBUqhaXrbkiR.png" ></a></p><h1 id="从正则表达式到NFA"><a href="#从正则表达式到NFA" class="headerlink" title="从正则表达式到NFA"></a>从正则表达式到NFA</h1><p><strong>MYT算法构造NFA</strong></p><h2 id="构造识别空和字母表中一个符号的NFA"><a href="#构造识别空和字母表中一个符号的NFA" class="headerlink" title="构造识别空和字母表中一个符号的NFA"></a>构造识别空和字母表中一个符号的NFA</h2><p><a href="https://sm.ms/image/S2cYgyePsK37BFZ" target="_blank"><img src="https://s2.loli.net/2022/04/11/S2cYgyePsK37BFZ.png" ></a></p><h2 id="构造识别主算符为选择正则式的NFA"><a href="#构造识别主算符为选择正则式的NFA" class="headerlink" title="构造识别主算符为选择正则式的NFA"></a>构造识别主算符为选择正则式的NFA</h2><p><a href="https://sm.ms/image/jl8qX65Q9fFSWDN" target="_blank"><img src="https://s2.loli.net/2022/04/11/jl8qX65Q9fFSWDN.png" ></a></p><h2 id="造识别主算符为闭包正则式的NFA"><a href="#造识别主算符为闭包正则式的NFA" class="headerlink" title="造识别主算符为闭包正则式的NFA"></a>造识别主算符为闭包正则式的NFA</h2><p><a href="https://sm.ms/image/oszIn5VJFXSbWRv" target="_blank"><img src="https://s2.loli.net/2022/04/11/oszIn5VJFXSbWRv.png" ></a></p><h1 id="从NFA到DFA"><a href="#从NFA到DFA" class="headerlink" title="从NFA到DFA"></a>从NFA到DFA</h1><p><strong>子集构造法</strong></p><p>从第一个状态集合{0} 开始，寻找通过对应的的输入符号所达到的新的状态集合</p><p><a href="https://sm.ms/image/dakmJMfp6csuWOS" target="_blank"><img src="https://s2.loli.net/2022/04/11/dakmJMfp6csuWOS.png" ></a></p><p><a href="https://sm.ms/image/f7G4CmQtKMcugVn" target="_blank"><img src="https://s2.loli.net/2022/04/11/f7G4CmQtKMcugVn.png" ></a></p><h1 id="DFA最简化"><a href="#DFA最简化" class="headerlink" title="DFA最简化"></a>DFA最简化</h1><p>D＇的开始状态是包含了D的开始状态的组的代表<br>D＇的接受状态是包含了D的接受状态的组的代表<br>如果D＇有死状态，则删除它<br>从开始状态不可达的状态也删除<br>从任何其他状态到死状态的转换都改成无定义</p><p>例：<br>为正则表达式(a|b)*a(a|b)(a|b)构造NFA。并将NFA转换为DFA<br><a href="https://sm.ms/image/cCKnjfMRz7u9bUy" target="_blank"><img src="https://s2.loli.net/2022/04/11/cCKnjfMRz7u9bUy.png" ></a></p><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;编译原理语法分析和自动机笔记&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="http://akkaduilin.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="基础知识" scheme="http://akkaduilin.com/categories/%E7%AC%94%E8%AE%B0/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="编译原理" scheme="http://akkaduilin.com/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    <category term="概念" scheme="http://akkaduilin.com/tags/%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>数据库完整性</title>
    <link href="http://akkaduilin.com/2022/03/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7/"/>
    <id>http://akkaduilin.com/2022/03/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7/</id>
    <published>2022-03-10T07:54:08.000Z</published>
    <updated>2022-03-24T07:54:07.805Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>SQL Server 为了保证数据完整性共提供了以下 6 种约束。</p><ol><li>非空（NOT NULL）约束</li><li>主键（PRIMARY KEY）约束</li><li>外键（FOREIGN KEY）约束</li><li>唯一性（UNIQUE）约束</li><li>检查（CHECK）约束</li><li>默认（DEFAULT）约束</li></ol><span id="more"></span><h1 id="实体完整性及其实现"><a href="#实体完整性及其实现" class="headerlink" title="实体完整性及其实现"></a>实体完整性及其实现</h1><h2 id="PRIMARY-KEY-约束"><a href="#PRIMARY-KEY-约束" class="headerlink" title="PRIMARY KEY 约束"></a>PRIMARY KEY 约束</h2><p>表通常具有包含唯一标识表中每一行值的一列或一组列，这样的一列或多列称为表的主键（PRIMARY KEY）。</p><p><strong>一个表只能有一个 PRIMARY KEY 约束，并且 PRIMARY KEY 约束中的列不能接受空值。</strong> </p><p><strong>如果对多列定义了 PRIMARY KEY 约束，则一列中的值可能会重复，但来自 PRIMARY KEY 约束定义中所有列的任何值组合必须唯一。</strong></p><p><strong>当定义主键约束时，SQL Server 在主键列上建立唯一聚簇索引，以加快查询速度。</strong></p><ol><li><p>单一主键的约束<br>CREATE TABLE 或 ALTER TABLE 中使用 PRIMARY KEY 关键字</p></li><li><p>组合主键的约束<br>PRIMARY KEY(列名1，列名2)</p></li></ol><p>代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CREATE TABLE Track</span><br><span class="line">(SongID CHAR(10) not null，</span><br><span class="line">SingerID CHAR(10) not null,</span><br><span class="line">Album VARCHAR(50),</span><br><span class="line">Style VARCHAR(20) default(&#x27;流行&#x27;), /*DEFAULT 约束*/</span><br><span class="line">Circulation INTEGER, PubYear INTEGER,</span><br><span class="line">PRIMARY KEY(SongID, SingerID)) /*主键约束，该约束是表级完整性约束*/</span><br><span class="line"></span><br><span class="line">ALTER TABLE Persons</span><br><span class="line">ADD PRIMARY KEY (P_Id)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="UNIQUE-约束"><a href="#UNIQUE-约束" class="headerlink" title="UNIQUE 约束"></a>UNIQUE 约束</h2><p>唯一约束被用来增强非主键列的唯一性。设置了唯一约束的列不能有重复值，可以但最<br>多允许一个 NULL 值。</p><p><strong>主键约束与唯一约束的异同：</strong><br>两者都要求约束的列不能有重复值；<br>主键约束要求主键列不能为空；唯一约束允许有空值，但只允许一个 NULL 值。</p><p><strong>在一个表上可以定义多个 UNIQUE 约束；</strong></p><p><strong>可以在多个列上定义一个 UNIQUE 约束，表示这些列组合起来不能有重复值。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CREATE TABLE Singer(</span><br><span class="line">-- 主键约束</span><br><span class="line">SingerID char(10) NOT NULL PRIMARY KEY,</span><br><span class="line">-- 唯一约束 </span><br><span class="line">Name varchar(50) NOT NULL UNIQUE, </span><br><span class="line">Gender varchar(2) NULL, Birth datetime NULL,</span><br><span class="line">Nation varchar(20) NULL)</span><br><span class="line"></span><br><span class="line">ALTER TABLE Persons</span><br><span class="line">ADD UNIQUE (P_Id)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="检查和违约"><a href="#检查和违约" class="headerlink" title="检查和违约"></a>检查和违约</h2><ol><li><p>检查主码值是否唯一，如果不唯一则拒绝插入或修改。</p></li><li><p>检查主码的各个属性是否为空，只要有一个为空就拒绝插入或修改。</p></li></ol><h1 id="用户定义完整性及实现"><a href="#用户定义完整性及实现" class="headerlink" title="用户定义完整性及实现"></a>用户定义完整性及实现</h1><p>用户定义的完整性是通过检查约束来实现的。<br>约束条件应是逻辑表达式，多个条件可以用 AND 或 OR 组合。<br>NUll<br>UNIQUE</p><h2 id="CHECK约束"><a href="#CHECK约束" class="headerlink" title="CHECK约束"></a>CHECK约束</h2><p>1） 列级的约束只能引用被约束的列上的值，一个列上可以有任意多个 CHECK 约束，<br>多个 CHECK 约束按创建顺序进行验证。<br>2） 可以在表上建立一个可以在多个列上使用的 CHECK 约束，但是表级约束只能引用<br>同一表中的列。<br>3） 不能在 text、ntext 或 image 列上定义 CHECK 约束。<br>4） CHECK 可以使用 IN、LIKE、BETWEEN 关键字。<br>5)  ADD CONSTRAINT CK_name 命名约束</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>常用约束</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CREATE TABLE Singer(</span><br><span class="line">SingerID char(10) NOT NULL PRIMARY KEY, /* 主键约束 */</span><br><span class="line">Name varchar(50) NOT NULL /* 非空约束 */</span><br><span class="line">UNIQUE, /* 唯一约束 */</span><br><span class="line">Gender varchar(2) NULL CHECK(Gender in(’男’,’女’)), /* 检查约束 */</span><br><span class="line">Birth datetime NULL, Nation varchar(20) NULL)</span><br><span class="line"></span><br><span class="line">WEIGHTNUMERIC(9,2) CHECK(WEIGHT&gt;0 AND WEIGHT&lt;=100 // 体重大于0小于100</span><br><span class="line">SSEXCHAR(2)CHECK(SSEX=&#x27;male&#x27; OR SSEX=&#x27;female&#x27;) // 性别男或女</span><br><span class="line">SAGESMALLINT CHECK(SAGE&gt;=15 AND SAGE&lt;=45)</span><br><span class="line"></span><br><span class="line">ALTER TABLE Persons ADD CONSTRAINT chk_Person CHECK (Id_P&gt;0 AND City=&#x27;Sandnes&#x27;) //命名约束</span><br><span class="line">ALTER TABLE Persons DROP CHECK chk_Person // 删除约束</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="检查和违约-1"><a href="#检查和违约-1" class="headerlink" title="检查和违约"></a>检查和违约</h2><p>当往表中插入元组或修改属性的值时，关系数据库管理系统将检查属性上的约束条件是否满足，不满足被拒绝执行</p><h1 id="参照完整性及实现"><a href="#参照完整性及实现" class="headerlink" title="参照完整性及实现"></a>参照完整性及实现</h1><p>参照完整性主要通过主键与外键的联系来实现的。主键所在的表称为主表，外键所在的<br>表称为子表。外键的取值参照主键的取值，即外键列的值有两种可能：一是等于主键的某个<br>值；二是为空值，否则将返回违反外键约束的错误信息。</p><h2 id="FOREIGN-KEY"><a href="#FOREIGN-KEY" class="headerlink" title="FOREIGN KEY"></a>FOREIGN KEY</h2><ol><li>FOREIGN KEY 约束只能引用同一个服务器上的同一数据库中的表。跨数据库的参照完整性必须通过触发器实现。</li><li>FOREIGN KEY 可引用同一个表中的其他列，这称为自引用。</li><li>FOREIGN KEY 约束并不仅仅可以与另一表的 PRIMARY KEY 约束相链接，它还可以定义为引用另一表的 UNIQUE 约束。</li><li>不能更改定义了 FOREIGN KEY 约束的列的长度，因为外键列和主键列的数据类型和长度需一致。</li></ol><p>利用 <strong>FOREIGN KEY……REFERENCES</strong> 关键字设置参照完整性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE Track</span><br><span class="line">(/*外键约束*/</span><br><span class="line">SongID CHAR(10) not null FOREIGN KEY REFERENCES Songs(SongID), </span><br><span class="line">/*外键约束*/</span><br><span class="line">SingerID CHAR(10) not null</span><br><span class="line">FOREIGN KEY REFERENCES Singers(SingerID),</span><br><span class="line">Album VARCHAR(50),</span><br><span class="line">Style VARCHAR(20) default(&#x27;流行&#x27;), /*DEFAULT 约束*/ </span><br><span class="line">Circulation INTEGER, PubYear INTEGER,</span><br><span class="line">PRIMARY KEY(SongID, SingerID) ) /*主键约束*/</span><br><span class="line"></span><br><span class="line">ALTER TABLE Orders</span><br><span class="line">ADD FOREIGN KEY (P_Id)</span><br><span class="line">REFERENCES Persons(P_Id)</span><br></pre></td></tr></table></figure><h2 id="ON-UPDATE-和-ON-DELETE"><a href="#ON-UPDATE-和-ON-DELETE" class="headerlink" title="ON UPDATE 和 ON DELETE"></a>ON UPDATE 和 ON DELETE</h2><p>SQL Server 2008 中 ，可以 在 CREATE TABLE 语 句和 ALTER TABLE 语 句的<br>REFERENCES 子句中使用 ON DELETE 子句和 ON UPDATE 子句来定义当用户试图删<br>除或更新现有外键指向的主键值时，SQL Server 执行的操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">REFERENCES referenced_table_name [ ( ref_column ) ]</span><br><span class="line">[ ON DELETE &#123; NO ACTION → CASCADE → SET NULL → SET DEFAULT &#125; ]</span><br><span class="line">[ ON UPDATE &#123; NO ACTION → CASCADE → SET NULL → SET DEFAULT &#125; ]</span><br><span class="line"></span><br><span class="line">//为 Track 表添加约束，且指定当主表进行 update 操作时，子表级联更新。</span><br><span class="line">alter table Track add foreign key(SongID) references Songs(Songid) on update cascade</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="检查和违约-2"><a href="#检查和违约-2" class="headerlink" title="检查和违约"></a>检查和违约</h2><p><a href="https://blog.csdn.net/weixin_43524214/article/details/122850808?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_ecpm_v1~rank_v31_ecpm-3-122850808.pc_agg_new_rank&amp;utm_term=%E8%BF%9D%E5%8F%8D%E5%8F%82%E7%85%A7%E5%AE%8C%E6%95%B4%E6%80%A7%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F&amp;spm=1000.2123.3001.4430">https://blog.csdn.net/weixin_43524214/article/details/122850808?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_ecpm_v1~rank_v31_ecpm-3-122850808.pc_agg_new_rank&amp;utm_term=%E8%BF%9D%E5%8F%8D%E5%8F%82%E7%85%A7%E5%AE%8C%E6%95%B4%E6%80%A7%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F&amp;spm=1000.2123.3001.4430</a></p><p><a href="https://sm.ms/image/bsyC7qtdueGkoQ4" target="_blank"><img src="https://s2.loli.net/2022/03/10/bsyC7qtdueGkoQ4.png"  style="width:80%"></a></p><p>（1） 拒绝（NO ACTION）执行<br>不允许该操作执行。该策略一般设置为默认策略<br>（2） 级联（CASCADE）操作<br>当删除或修改被参照表（Student）的一个元组造成了与参照表（SC）的不一致，则删除或修改参照表中的所有造成不一致的元组<br>（3）设置为空值（SET-NULL）<br>当删除或修改被参照表的一个元组时造成了不一致，则将参照表中的所有造成不一致的元组的对应属性设置为空值。</p><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SQL Server 为了保证数据完整性共提供了以下 6 种约束。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;非空（NOT NULL）约束&lt;/li&gt;
&lt;li&gt;主键（PRIMARY KEY）约束&lt;/li&gt;
&lt;li&gt;外键（FOREIGN KEY）约束&lt;/li&gt;
&lt;li&gt;唯一性（UNIQUE）约束&lt;/li&gt;
&lt;li&gt;检查（CHECK）约束&lt;/li&gt;
&lt;li&gt;默认（DEFAULT）约束&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="数据库" scheme="http://akkaduilin.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="笔记" scheme="http://akkaduilin.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="SQL" scheme="http://akkaduilin.com/tags/SQL/"/>
    
    <category term="数据库" scheme="http://akkaduilin.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>SQL基础</title>
    <link href="http://akkaduilin.com/2022/03/10/SQL%E5%9F%BA%E7%A1%80/"/>
    <id>http://akkaduilin.com/2022/03/10/SQL%E5%9F%BA%E7%A1%80/</id>
    <published>2022-03-10T07:47:30.000Z</published>
    <updated>2022-04-13T15:35:28.315Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p><strong>SQL学习笔记</strong></p><p><strong>持续更新ing</strong><br><a href="https://www.runoob.com/sql/sql-tutorial.htmlhttps://www.runoob.com/sql/sql-tutorial.html">https://www.runoob.com/sql/sql-tutorial.htmlhttps://www.runoob.com/sql/sql-tutorial.html</a><br><a href="https://www.liaoxuefeng.com/wiki/1177760294764384">https://www.liaoxuefeng.com/wiki/1177760294764384</a></p><span id="more"></span><h1 id="数据定义"><a href="#数据定义" class="headerlink" title="数据定义"></a>数据定义</h1><h2 id="数据库的定义"><a href="#数据库的定义" class="headerlink" title="数据库的定义"></a>数据库的定义</h2><h3 id="使用T-SQL创建"><a href="#使用T-SQL创建" class="headerlink" title="使用T-SQL创建"></a>使用T-SQL创建</h3><p>使用 SSMS 可以方便地创建数据库，但是，有些情况下不能使用图形化方式创建数据<br>库。比如在设计一个应用程序时，开发人员需要在程序代码中创建数据库及其他数据库对象，<br>而不用在制作应用程序安装包时再放置数据库或让用户自行创建，这就需要采用 T-SQL 语<br>句来创建数据库。</p><p>当使用 SSMS 向导创建数据库后，用户可以查看创建该数据库的 T-SQL 语句。方法是：<br>点击“对象资源管理器”→Music，点击右键快捷菜单中的“编写数据库脚本为”→“Create<br>到”→“新查询编辑器窗口”选项，在打开的查询编辑器窗口中，可以看到创建该数据库的<br>T-SQL 语句</p><p><strong>创建语句</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE database_name /* 指定数据库逻辑文件名*/</span><br><span class="line">[ON</span><br><span class="line">  [PRIMARY]</span><br><span class="line">  [&lt;filespec&gt; [1,…n]]</span><br><span class="line">  [,&lt;filegroup&gt; [1,…n]]</span><br><span class="line">]</span><br><span class="line">/* ON 子句指定数据库的数据文件属性和文件组属性；其中 PRIMARY 指定关联的&lt;filespec&gt;列表定义主文件，如果没有定义 PRIMARY, 则 CREATE DATABASE语句中列出的第一个文件成为主文件 */</span><br><span class="line"></span><br><span class="line">[LOG ON &#123;&lt;filespec&gt; [1,…n]&#125;] /* LOG ON 子句指定事务日志文件属性*/</span><br></pre></td></tr></table></figure><h3 id="修改数据库"><a href="#修改数据库" class="headerlink" title="修改数据库"></a>修改数据库</h3><p>在 SQL Server 中，可用 ALTER DATABASE 语句修改数据库</p><p>其中&lt; filespec &gt;的格式同 CREATE DATABASE 中的&lt; filespec &gt;。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">ALTER DATABASE database</span><br><span class="line"></span><br><span class="line">ADD FILE &lt; filespec &gt; [ ,...n ]</span><br><span class="line">/* 添加新的数据文件 */</span><br><span class="line">[ TO FILEGROUP filegroup_name ]</span><br><span class="line">/* 将要添加的数据文件添加到指</span><br><span class="line">定的文件组中 */</span><br><span class="line"></span><br><span class="line">ADD LOG FILE &lt; filespec &gt; [ ,...n ]</span><br><span class="line">/* 添加新的事务日志文件 */</span><br><span class="line">| REMOVE FILE logical_file_name</span><br><span class="line">/* 删除某一文件 */</span><br><span class="line"></span><br><span class="line">ADD FILEGROUP filegroup_name </span><br><span class="line">/* 添加一个文件组 */</span><br><span class="line"></span><br><span class="line">REMOVE FILEGROUP filegroup_name</span><br><span class="line">/* 删除一个文件组 */</span><br><span class="line"></span><br><span class="line">MODIFY FILE &lt; filespec &gt; </span><br><span class="line">/* 修改某个文件的属性 */</span><br><span class="line"></span><br><span class="line">MODIFY NAME = new_dbname </span><br><span class="line">/* 修改数据库的名字 */</span><br><span class="line"></span><br><span class="line">MODIFY FILEGROUP filegroup_name &#123;filegroup_property|NAME= new_filegroup_name &#125;</span><br><span class="line">/* 修改某个文件组的属性或为文件组定义一个新名字。文件组的属性有三种：READONLY（只读）、READWRITE（读写）、Default（默认） */</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><p>使用 DROP DATABASE 语句删除数据库的语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">DROP DATABASE database_name [,…n]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>创建 Employee 数据库，要求如下：<br>1）主数据库文件名为 Employee，物理文件名为 Employee.mdf，初始大小为 5MB，最大文件大小为100MB，增长幅度为 1MB；<br>2 ） 在 文 件 组 usergroup1 上 建 立 辅 助 数 据 文 件 Employee_dat ， 物 理 文 件 名 为<br>Employee_dat.ndf，初始大小为 3MB，最大为无限大，增幅为 1MB；<br>3）日志文件逻辑文件名和物理文件名均为 Employee_log，初始大小为 3MB，最大为<br>20MB，增幅为 10%。以上文件均存储在为 E:\mssql2008\data 文件夹中。<br>4）为Employee数据库的usergroup2文件组添加一个辅助数据文件Employee_dat2，<br>要求：文件存储在 E:\mssql2008\data 文件夹下，初始大小为 10MB，最大为 20MB，增<br>幅为 5MB<br>5）删除 Employee 数据库的文件组 usergroup2<br>6）修改 Employee 中的数据文件 Employee_dat,将其初始大小改为 10MB，最大容<br>量改为 20MB，增幅设为 2MB。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE Employee </span><br><span class="line">--定义主数据文件</span><br><span class="line">ON PRIMARY </span><br><span class="line">( NAME =Employee, FILENAME = &#x27;E:\mssql2008\data\Employee.mdf&#x27; , </span><br><span class="line">SIZE = 5, MAXSIZE = 100 , FILEGROWTH = 1KB ), </span><br><span class="line"></span><br><span class="line">--定义辅助数据文件</span><br><span class="line">FILEGROUP usergroup1 </span><br><span class="line">( NAME = Employee_dat, </span><br><span class="line">FILENAME = &#x27;E:\mssql2008\data\Employee_dat.ndf&#x27; , </span><br><span class="line">SIZE = 3 , MAXSIZE = UNLIMITED, FILEGROWTH = 1)</span><br><span class="line"></span><br><span class="line">--定义日志文件</span><br><span class="line">LOG ON </span><br><span class="line">(NAME = Employee_log, </span><br><span class="line">FILENAME = &#x27;E:\mssql2008\data\Employee_log.ldf&#x27; , </span><br><span class="line">SIZE = 3, MAXSIZE = 20, FILEGROWTH = 10%)</span><br><span class="line"></span><br><span class="line">--添加数据文件</span><br><span class="line">Alter DATABASE employee</span><br><span class="line">Add file ( NAME = employee_dat2,</span><br><span class="line">FILENAME=&#x27;E:\mssql2008\data\Employee_dat2.mdf&#x27;,</span><br><span class="line">SIZE = 10, MAXSIZE = 50, FILEGROWTH = 5) to filegroup usergroup2</span><br><span class="line"></span><br><span class="line">--删除文件组</span><br><span class="line">--删除文件组中的文件</span><br><span class="line">alter database employee remove file employee_dat2</span><br><span class="line">--删除文件组</span><br><span class="line">alter database employee remove filegroup usergroup2</span><br><span class="line"></span><br><span class="line">--修改数据文件</span><br><span class="line">AlTER DATABASE employee</span><br><span class="line">MODIFY FILE</span><br><span class="line">(NAME = Employee_dat, SIZE = 10, MAXSIZE = 20, FILEGROWTH = 2)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="基本表的定义"><a href="#基本表的定义" class="headerlink" title="基本表的定义"></a>基本表的定义</h2><p>SQL Server 中，可以从两种角度来对表进行分类。</p><ol><li><p>按照数据存储的时间分类：<br>1）永久表<br>表建立后，除非人工删除，否则一直保存。在 master、model、msdb 和用户数据库中建<br>立的表都是永久表。<br>2）临时表<br>临时表的数据只在数据库运行期间临时保存数据，临时表存储在 tempdb 中。</p></li><li><p>按照表的用途来分类<br>1）用户表<br>用户创建的，用于开发各种数据库应用系统的表。<br>2）系统表<br>维护 SQL Server 服务器和数据库正常工作的数据表。每个数据库都会建立很多系统表，<br>这些表不允许用户进行更改，只能由 DBMS 自行维护。<br>3）临时表<br>SQL Server 的临时表有两种类型：本地临时表和全局临时表。<br>本地临时表只对于创建者是可见的。当用户与 SQL Server 实例断开连接后，将删除本<br>地临时表。<br>全局临时表在创建后对任何用户和任何连接都是可见的，当引用该表的所有用户都与<br>SQL Server 实例断开连接后，将删除全局临时表。<br>如果 SQL Server 服务器关闭，则所有的本地和全局临时表都被清空、关闭。<br>从表名称上来看，本地临时表的名称前面有一个“#”符号；而全局临时表的名称前面<br>有两个“##”符号 。</p></li></ol><p><em>说明：临时表的作用——当对数据库执行大数据量的排序等操作时，要产生大量的中间运算结果，因此需要消耗大量的内存资源。如果内存资源不够用，那么 SQL Server 将在临时数据库 tempdb中创建临时表用于存放这些中间结果。</em><br> 4）分区表<br>当一个表中的数据量过于庞大时，可以使用分区表。分区表是将数据水平划分为多个单<br>元的表，这些单元可以分布到数据库中的多个文件组中。在维护整个集合的完整性时，使用<br>分区可以快速而有效地访问或管理数据子集，从而使大型表或索引更易于管理。</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><table><thead><tr><th align="left">序号</th><th align="left">数据类型</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">char(n)</td><td align="left">长度为n的定长字符串</td></tr><tr><td align="left">2</td><td align="left">varchar(n)</td><td align="left">最大程度为n的变长字符串</td></tr><tr><td align="left">3</td><td align="left">clob</td><td align="left">字符串大对象</td></tr><tr><td align="left">4</td><td align="left">blob</td><td align="left">二进制大对象</td></tr><tr><td align="left">5</td><td align="left">int</td><td align="left">长整数(4 字节)</td></tr><tr><td align="left">6</td><td align="left">smallint</td><td align="left">短整数(2 字节)</td></tr><tr><td align="left">7</td><td align="left">bigint</td><td align="left">大整数(8 字节)</td></tr><tr><td align="left">8</td><td align="left">Numeric(10,2)</td><td align="left">指字段是数字型,长度为10 小数为两位的</td></tr><tr><td align="left">9</td><td align="left">Date</td><td align="left">YYYY-mm-dd</td></tr><tr><td align="left">10</td><td align="left">time</td><td align="left">HH:ii:ss</td></tr><tr><td align="left">11</td><td align="left">Datetime</td><td align="left">YYYY-mm-dd HH:ii:ss</td></tr><tr><td align="left">12</td><td align="left">Timestamp</td><td align="left">时间戳类型 不为空 默认值为当前时间</td></tr><tr><td align="left">13</td><td align="left">float</td><td align="left">浮点型，含字节数为4，32bit，数值范围为-3.4E38~3.4E38（7个有效位）</td></tr><tr><td align="left">14</td><td align="left">double</td><td align="left">双精度实型，含字节数为8，64bit数值范围-1.7E308~1.7E308（15个有效位）</td></tr><tr><td align="left">15</td><td align="left">decimal</td><td align="left">数字型，128bit，不存在精度损失，常用于银行帐目计算。（28个有效位）</td></tr></tbody></table><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">create table &lt;表名&gt; (</span><br><span class="line">&lt;列名&gt;&lt;数据类型&gt;[列级完整性约束条件]，</span><br><span class="line">&lt;列名&gt;&lt;数据类型&gt;[列级完整性约束条件]，</span><br><span class="line">...</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>eg：<br><a href="https://sm.ms/image/ywXh2P7sROeGqfn" target="_blank"><img src="https://s2.loli.net/2022/03/10/ywXh2P7sROeGqfn.png" ></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE Singer(</span><br><span class="line">SingerID char(10) NOT NULL,</span><br><span class="line">Name varchar(50) NOT NULL,</span><br><span class="line">Gender varchar(2) NULL,</span><br><span class="line">Birth datetime NULL,</span><br><span class="line">Nation varchar(20) NULL</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="列属性的设置"><a href="#列属性的设置" class="headerlink" title="列属性的设置"></a>列属性的设置</h3><ol><li><p>NULL<br>NULL（空值）表示数值未知或将在以后添加的数据。</p></li><li><p>DEFAULT<br>默认值是指当向表中插入数据时，如果用户没有明确给出某列的值，SQL Server 自动为<br>该列添加的值。</p></li><li><p>IDENTITY<br>使用 IDENTITY 关键字定义的字段又称标识字段。开发人员可以为标识字段指定标识<br>种子（Identity Seed 属性）和标识增量（Identity Increment 属性），系统按照给定的种子和增<br>量自动生成标识号，该标识号是唯一的。<br>使用 IDENTITY 属性时要注意：<br>一个表只能有一个使用 IDENTITY 属性定义的列;<br>IDENTITY 只适用于 decimal（小数部分为 0）、int、numeric（小数部分为 0）、smallint、bigint 或 tinyint 数据类型；<br>标识种子和增量的默认值均为 1；  标识符列不能允许为空值，也不能包含 DEFAULT 定义或对象；<br>标识符列不能更新；<br>如果在经常进行删除操作的表中存在标识符列，那么标识值之间可能会出现断缺。</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">create table Student</span><br><span class="line">(</span><br><span class="line">sno int not null identity(201102001,1), /*设置 IDENTITY*/</span><br><span class="line">sname varchar(50) not null,</span><br><span class="line">sex varchar(2),</span><br><span class="line">hometown varchar(50) null default(&#x27;江苏&#x27;), /*设置默认值*/</span><br><span class="line">introuction varchar(50) null,</span><br><span class="line">birthdate datetime not null )</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="修改-删除表"><a href="#修改-删除表" class="headerlink" title="修改/删除表"></a>修改/删除表</h3><p>表建立好后，一般不会再修改，但随着应用环境和需求的变化，偶尔也要修改已建立好<br>的表，SQL 语言用 ALTER TABLE 语句修改表，其一般格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE &lt;表名&gt;</span><br><span class="line"></span><br><span class="line">[ ADD &lt;新列名&gt; &lt;数据类型&gt; &lt;完整性约束&gt;] /*增加新列*/</span><br><span class="line"></span><br><span class="line">[DROP COLUMN &lt;列名&gt;] /*删除列*/</span><br><span class="line"></span><br><span class="line">[ALTER COLUMN &lt;列名&gt; &lt;数据类型&gt;] /*修改列定义*/</span><br><span class="line"></span><br><span class="line">[ADD &lt;完整性约束&gt;] /*添加约束*/</span><br><span class="line"></span><br><span class="line">[DROP &lt;完整性约束&gt;] /*删除约束*/</span><br><span class="line"></span><br><span class="line">// 当某个表不再需要时，可以使用 DROP TABLE 语句删除它。其一般格式为：</span><br><span class="line"></span><br><span class="line">DROP TABLE &lt;表名&gt;</span><br></pre></td></tr></table></figure><p>其中&lt;表名&gt;是要修改的表，ADD 子句用于增加新列和新的完整性约束条件，DROP 子句用于删除指定的完整性约束条件，ALTER COLUMN 子句用于修改原有的列定义，包括修改列名和数据类型。</p><h2 id="数据完整性的实现"><a href="#数据完整性的实现" class="headerlink" title="数据完整性的实现"></a>数据完整性的实现</h2><a href="/2022/03/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7/" title="数据库完整性">数据库完整性</a><a href="/2022/03/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7/" title="数据库完整性">数据库完整性</a><h1 id="索引的建立"><a href="#索引的建立" class="headerlink" title="索引的建立"></a>索引的建立</h1><h1 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h1><a href="/2022/03/23/SQL%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2/" title="SQL数据查询">SQL数据查询</a><a href="/2022/03/23/SQL%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2/" title="SQL数据查询">SQL数据查询</a><h1 id="数据更新"><a href="#数据更新" class="headerlink" title="数据更新"></a>数据更新</h1><h2 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h2><p>元组插入语句的一般格式：<br>INSERT INTO &lt;表名&gt; ( &lt;列名 1&gt; [ , &lt;列名 2&gt;] …)<br>VALUES<br>(&lt;常量 1&gt; [, &lt;常量 2&gt; ]…)<br>(&lt;常量 11&gt; [, &lt;常量 22&gt; ]…)<br>(&lt;常量 111&gt; [, &lt;常量 222&gt; ]…)<br>或者<br>INSERT INTO &lt;表名&gt; ( &lt;列名 1&gt; [ , &lt;列名 2&gt;] …)<br>&lt;子查询&gt;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">假设另有一张歌手表 S，表结构与 Singer 一致，现在要求把 S 表中所有没有在</span><br><span class="line">Singer 表里出现过的男歌星加入到 Singer 表中。</span><br><span class="line"></span><br><span class="line">INSERT INTO Singers (SingerID, Name, Gender, Nation, Birth)</span><br><span class="line">(</span><br><span class="line">  SELECT (SingerID, Name, Gender, Nation, Birth)</span><br><span class="line">  FROM S</span><br><span class="line">  WHERE S.Gender=’男’ and NOT EXISTS (S.SingerID=Singers.SingerID)</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h2><p>SQL 删除语句的格式：</p><p>DELETE FROM &lt;表名&gt; ［WHERE &lt;条件&gt;］</p><p>如果没有 WHERE 子句，将会删除表中所有数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">删除歌手表中不是中国国籍的歌手</span><br><span class="line">DELETE FROM Singers</span><br><span class="line">WHERE Nation&lt;&gt;’中国’</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="修改操作"><a href="#修改操作" class="headerlink" title="修改操作"></a>修改操作</h2><p>当需要修改关系中元组的某些值时，可以用 UPDATE 语句实现。SQL 的 UPDATE 语句的<br>格式：</p><p>UPDATE &lt;表名&gt;<br>SET &lt;列名&gt;＝&lt;值表达式&gt;［，&lt;列名&gt;＝&lt;值表达式&gt;］… [WHERE &lt;条件&gt;］</p><p>如果省略 WHERE 子句，将会修改表中所有的元组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">将 Singers 表中歌手编号为“GC002”的 Birth 属性值修改为 1978。</span><br><span class="line"></span><br><span class="line">UPDATE Singers</span><br><span class="line">SET Birth＝1978</span><br><span class="line">WHERE SingerID＝&#x27; GC002</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="空值与视图"><a href="#空值与视图" class="headerlink" title="空值与视图"></a>空值与视图</h1><p><em>施工中</em></p><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SQL学习笔记&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;持续更新ing&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;https://www.runoob.com/sql/sql-tutorial.htmlhttps://www.runoob.com/sql/sql-tutorial.html&quot;&gt;https://www.runoob.com/sql/sql-tutorial.htmlhttps://www.runoob.com/sql/sql-tutorial.html&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/1177760294764384&quot;&gt;https://www.liaoxuefeng.com/wiki/1177760294764384&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="http://akkaduilin.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="笔记" scheme="http://akkaduilin.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="SQL" scheme="http://akkaduilin.com/tags/SQL/"/>
    
    <category term="数据库" scheme="http://akkaduilin.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Java面向对象</title>
    <link href="http://akkaduilin.com/2022/03/07/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>http://akkaduilin.com/2022/03/07/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</id>
    <published>2022-03-07T02:57:21.000Z</published>
    <updated>2022-03-08T12:32:27.817Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言</strong></p><p><strong>Java 面向对象编程 笔记</strong></p><p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1260451488854880">https://www.liaoxuefeng.com/wiki/1252599548343744/1260451488854880</a><br><a href="https://www.cnblogs.com/hellojava/archive/2013/02/27/2935450.html">https://www.cnblogs.com/hellojava/archive/2013/02/27/2935450.html</a><br><a href="https://www.runoob.com/java/java-tutorial.html">https://www.runoob.com/java/java-tutorial.html</a></p><span id="more"></span><h1 id="类的声明"><a href="#类的声明" class="headerlink" title="类的声明"></a>类的声明</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[public | protected | private ][abstract|final] class className [extends superclassName] [implements interfaceNameList]&#123;……&#125;</span><br></pre></td></tr></table></figure><p>其中，修饰符public,abstract,final 说明了类的属性，<br>className为类名，<br>superclassName为类的父类的名字，用于继承<br>interfaceNameList为类所实现的接口列表。</p><h2 id="abstract-抽象类"><a href="#abstract-抽象类" class="headerlink" title="abstract 抽象类"></a>abstract 抽象类</h2><p>如果一个class定义了方法，但没有具体执行代码，这个方法就是抽象方法<br>抽象类除了<strong>不能实例化对象</strong>之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。<br>可以用于继承，即定义新的类父类是一个抽象类</p><h1 id="成员变量和成员方法"><a href="#成员变量和成员方法" class="headerlink" title="成员变量和成员方法"></a>成员变量和成员方法</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class className&#123;</span><br><span class="line">    [public | protected | private ] [static] [final] [transient] [volatile] type variableName;//成员变量</span><br><span class="line">    [public | protected | private ] [static] [final | abstract] [native] [synchronized] returnType methodName([paramList]) [throws exceptionList]&#123;</span><br><span class="line">        statements</span><br><span class="line">    &#125;//成员方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>成员变量限定词的含义：</strong></p><p>static: 静态变量（类变量）<br>final: 常量；<br>transient: 暂时性变量，用于对象存档，用于对象的串行化<br>volatile: 贡献变量，用于并发线程的共享</p><p>方法的实现也包括两部分内容：方法声明和方法体。</p><p>方法声明</p><p><strong>方法声明中的限定词的含义：</strong></p><p>static: 类方法，可通过类名直接调用<br>abstract: 抽象方法，没有方法体<br>final: 方法不能被重写、继承<br>native: 集成其它语言的代码<br>synchronized: 控制多个并发线程的访问</p><h2 id="abstract-抽象方法"><a href="#abstract-抽象方法" class="headerlink" title="abstract 抽象方法"></a>abstract 抽象方法</h2><p>如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是让子类去覆写它，那么，可以把父类的方法声明为抽象方法</p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p><strong>this代表本类的对象</strong></p><p>没有在构造方法中初始化字段时，引用类型的字段默认是null，数值类型的字段用默认值，int类型默认值是0，布尔类型默认值是false</p><p>可以定义多个构造方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Person p1 = new Person(&quot;Xiao Ming&quot;, 15); // 既可以调用带参数的构造方法</span><br><span class="line">        Person p2 = new Person(); // 也可以调用无参数构造方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public Person() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Person(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = 12;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Person(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return this.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="面向对象的基本特征"><a href="#面向对象的基本特征" class="headerlink" title="面向对象的基本特征"></a>面向对象的基本特征</h1><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>在面向对象程式设计方法中，封装（英语：Encapsulation）是指一种将抽象性函式接口的实现细节部分包装、隐藏起来的方法。<br>封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。<br>要访问该类的代码和数据，必须通过严格的接口控制。<br>封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。<br>适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。</p><p><a href="https://www.runoob.com/java/java-encapsulation.html">https://www.runoob.com/java/java-encapsulation.html</a></p><p>private：类中限定为private的成员，只能被这个类本身访问。如果一个类的构造方法声明为private,则其它类不能生成该类的一个实例。<br>default：类中不加任何访问权限限定的成员属于缺省的（default）访问状态，可以被这个类本身和同一个包中的类所访问。<br>protected：类中限定为protected的成员，可以被这个类本身、它的子类（包括同一个包中以及不同包中的子类）和同一个包中的所有其他的类访问。<br>public：类中限定为public的成员，可以被所有的类访问。<br><a href="https://sm.ms/image/TKfdORlCGaQgJVD" target="_blank"><img src="https://s2.loli.net/2022/03/08/TKfdORlCGaQgJVD.jpg" ></a></p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>解决代码重复和便于维护</p><h3 id="继承格式"><a href="#继承格式" class="headerlink" title="继承格式"></a>继承格式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class 父类 &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class 子类 extends 父类 &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>子类拥有父类 <strong>非 private</strong> 的属性、方法。</p><p>子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。</p><p>子类可以用自己的方式实现父类的方法。</p><p><strong>Java支持多重继承，不支持多继承</strong><br><a href="https://sm.ms/image/lNnouWEYDSv2U13" target="_blank"><img src="https://s2.loli.net/2022/03/08/lNnouWEYDSv2U13.jpg" ></a></p><h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><p>我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">  void eat() &#123;</span><br><span class="line">    System.out.println(&quot;animal : eat&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line">  void eat() &#123;</span><br><span class="line">    System.out.println(&quot;dog : eat&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  void eatTest() &#123;</span><br><span class="line">    this.eat();   // this 调用自己的方法</span><br><span class="line">    super.eat();  // super 调用父类方法</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类是不继承父类的构造器（构造方法或者构造函数）的，它只是调用（隐式或显式）。如果父类的构造器带有参数，则必须在子类的构造器中显式地通过 super 关键字调用父类的构造器并配以适当的参数列表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class SuperClass &#123;</span><br><span class="line">  private int n;</span><br><span class="line">  SuperClass()&#123;</span><br><span class="line">    System.out.println(&quot;SuperClass()&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  SuperClass(int n) &#123;</span><br><span class="line">    System.out.println(&quot;SuperClass(int n)&quot;);</span><br><span class="line">    this.n = n;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// SubClass 类继承</span><br><span class="line">class SubClass extends SuperClass&#123;</span><br><span class="line">  private int n;</span><br><span class="line">  </span><br><span class="line">  SubClass()&#123; // 自动调用父类的无参数构造器</span><br><span class="line">    System.out.println(&quot;SubClass&quot;);</span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  public SubClass(int n)&#123;</span><br><span class="line">    super(300);  // 调用父类中带有参数的构造器</span><br><span class="line">    System.out.println(&quot;SubClass(int n):&quot;+n);</span><br><span class="line">    this.n = n;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class TestSuperSub&#123;</span><br><span class="line">  public static void main (String args[])&#123;</span><br><span class="line">    System.out.println(&quot;------SubClass 类继承------&quot;);</span><br><span class="line">    SubClass sc1 = new SubClass();</span><br><span class="line">    SubClass sc2 = new SubClass(100);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为<br>——SubClass 类继承——<br>SuperClass()<br>SubClass<br>SuperClass(int n)<br>SubClass(int n):100</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p><a href="https://sm.ms/image/z3q1aP4sbDHMUx8" target="_blank"><img src="https://s2.loli.net/2022/03/08/z3q1aP4sbDHMUx8.jpg" ></a><br>方法名相同、参数不同（数量不同、类型不同、顺序不同）、同一作用域。<br>返回值类型可以相同也可以不相同，无法以返回型别作为重载函数的区分标准。</p><h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><p>重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。<strong>即外壳不变，核心重写！</strong></p><p><strong>当需要在子类中调用父类的被重写方法时，要使用 super 关键字。</strong></p><p><strong>重写规则</strong></p><ol><li><p>参数列表与被重写方法的参数列表必须完全相同。</p></li><li><p>返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。</p></li><li><p>访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。</p></li><li><p>父类的成员方法只能被它的子类重写。</p></li><li><p>声明为 final 的方法不能被重写。</p></li><li><p>声明为 static 的方法不能被重写，但是能够被再次声明。</p></li><li><p>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。</p></li><li><p>子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。</p></li><li><p>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。</p></li><li><p>构造方法不能被重写。</p></li><li><p>如果不能继承一个类，则不能重写该类的方法。</p></li></ol><h3 id="重载重写区别"><a href="#重载重写区别" class="headerlink" title="重载重写区别"></a>重载重写区别</h3><ol><li><p>方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载(Overloading)。</p></li><li><p>方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写(Overriding)。</p></li><li><p>方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。</p></li></ol><p><a href="https://sm.ms/image/vecY2Ql85H7sOEk" target="_blank"><img src="https://s2.loli.net/2022/03/08/vecY2Ql85H7sOEk.jpg" ></a></p><h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><p>虚函数的存在是为了多态。<br>Java 中其实没有虚函数的概念，它的普通函数就相当于 C++ 的虚函数，动态绑定是Java的默认行为。如果 Java 中不希望某个函数具有虚函数特性，可以加上 final 关键字变成非虚函数。</p><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1260456790454816">https://www.liaoxuefeng.com/wiki/1252599548343744/1260456790454816</a></p><p>如果一个抽象类没有字段，所有方法全部都是抽象方法，就可以把该抽象类改写为接口：<strong>interface</strong></p><p>所谓interface，就是比抽象类还要抽象的纯抽象接口，因为它连字段都不能有。因为接口定义的所有方法默认都是<strong>public abstract</strong>的，所以这两个修饰符不需要写出来（写不写效果都一样）</p><h2 id="接口声明和实现"><a href="#接口声明和实现" class="headerlink" title="接口声明和实现"></a>接口声明和实现</h2><p>Interface关键字用来声明一个接口。</p><p>类使用implements关键字实现接口。在类声明中，Implements关键字放在class声明后面。<br>当类实现接口的时候，类要实现接口中所有的方法。否则，类必须声明为抽象的类。</p><p>类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    void run();</span><br><span class="line">    String getName();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student implements Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public Student(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(this.name + &quot; run&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口特性"><a href="#接口特性" class="headerlink" title="接口特性"></a>接口特性</h2><ol><li><p>接口文件保存在 .java 结尾的文件中，文件名使用接口名</p></li><li><p>当一个具体的class去实现一个interface时，需要使用<strong>implements</strong>关键字</p></li><li><p><strong>一个类可以实现多个interface</strong></p></li><li><p>接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。</p></li><li><p>接口中每一个方法也是隐式抽象</p></li><li><p>接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是 public，用 private 修饰会报编译错误）</p></li><li><p>一个接口能继承另一个接口，这和类之间的继承比较相似。接口的继承使用extends关键字 <strong>并且接口允许多继承</strong><br>eg: public interface int extends int1, int2</p></li></ol><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><h2 id="Inner-Class"><a href="#Inner-Class" class="headerlink" title="Inner Class"></a>Inner Class</h2><p>如果一个类定义在另一个类的内部，这个类就是Inner Class<br>Inner Class 不能单独存在，必须依附于一个实例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Outer outer = new Outer(&quot;Nested&quot;); // 实例化一个Outer</span><br><span class="line">        Outer.Inner inner = outer.new Inner(); // 实例化一个Inner</span><br><span class="line">        inner.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Outer &#123;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    Outer(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class Inner &#123;</span><br><span class="line">        void hello() &#123;</span><br><span class="line">            System.out.println(&quot;Hello, &quot; + Outer.this.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Anonymous-Class"><a href="#Anonymous-Class" class="headerlink" title="Anonymous Class"></a>Anonymous Class</h2><p>在方法内部，通过匿名类（Anonymous Class）来定义Inner Class</p><p>Runnable本身是接口，接口是不能实例化的，所以这里实际上是定义了一个实现了Runnable接口的匿名类，并且通过new实例化该匿名类，然后转型为Runnable</p><p>不关心类名，简化代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Outer outer = new Outer(&quot;Nested&quot;);</span><br><span class="line">        outer.asyncHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Outer &#123;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    Outer(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void asyncHello() &#123;</span><br><span class="line">        Runnable r = new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;Hello, &quot; + Outer.this.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        new Thread(r).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Static-Nested-Class"><a href="#Static-Nested-Class" class="headerlink" title="Static Nested Class"></a>Static Nested Class</h2><p>使用static修饰，静态内部类</p><p>用static修饰的内部类不再依附于Outer的实例，而是一个完全独立的类，因此无法引用Outer.this，但它可以访问Outer的private静态字段和静态方法。<br><strong>用途，可以访问private的方法和变量</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Outer.StaticNested sn = new Outer.StaticNested();</span><br><span class="line">        sn.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Outer &#123;</span><br><span class="line">    private static String NAME = &quot;OUTER&quot;;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    Outer(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class StaticNested &#123;</span><br><span class="line">        void hello() &#123;</span><br><span class="line">            System.out.println(&quot;Hello, &quot; + Outer.NAME);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="包"><a href="#包" class="headerlink" title="包+"></a>包+</h1><p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1260467032946976">https://www.liaoxuefeng.com/wiki/1252599548343744/1260467032946976</a></p><p>将功能相似或相关的类或者接口组织在同一个包中，方便查找和使用。<br>防止命名冲突</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">packsge package_name // 申明包名</span><br><span class="line"></span><br><span class="line">public cless Cless_name&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 导入包</span><br><span class="line">package ming;</span><br><span class="line"></span><br><span class="line">// 导入完整类名:</span><br><span class="line">import mr.jun.Arrays;</span><br><span class="line"></span><br><span class="line">// 导入mr.jun包的所有class</span><br><span class="line">import mr.jun.*;</span><br><span class="line"></span><br><span class="line">public class Person &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        Arrays arrays = new Arrays();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Java 面向对象编程 笔记&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/1252599548343744/1260451488854880&quot;&gt;https://www.liaoxuefeng.com/wiki/1252599548343744/1260451488854880&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.cnblogs.com/hellojava/archive/2013/02/27/2935450.html&quot;&gt;https://www.cnblogs.com/hellojava/archive/2013/02/27/2935450.html&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.runoob.com/java/java-tutorial.html&quot;&gt;https://www.runoob.com/java/java-tutorial.html&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="http://akkaduilin.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="笔记" scheme="http://akkaduilin.com/categories/%E7%BC%96%E7%A8%8B/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="http://akkaduilin.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>编译原理基础概念</title>
    <link href="http://akkaduilin.com/2022/03/01/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <id>http://akkaduilin.com/2022/03/01/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</id>
    <published>2022-03-01T09:29:16.000Z</published>
    <updated>2022-03-01T15:00:48.837Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言</strong></p><p><strong>编译原理笔记</strong></p><p>编译程序的组成及概念解释</p><p><a href="https://sm.ms/image/KEVZuPkjTrQ2UYa" target="_blank"><img src="https://s2.loli.net/2022/03/01/KEVZuPkjTrQ2UYa.jpg"  style="width:60%"></a></p><span id="more"></span><h1 id="语言处理系统"><a href="#语言处理系统" class="headerlink" title="语言处理系统"></a>语言处理系统</h1><p><a href="https://sm.ms/image/PDkWqNwRTOKUV9M" target="_blank"><img src="https://s2.loli.net/2022/03/01/PDkWqNwRTOKUV9M.jpg" style="width:60%"></a></p><h1 id="翻译器"><a href="#翻译器" class="headerlink" title="翻译器"></a>翻译器</h1><p>翻译器是能够完成从一种语言到另一种语言变换的软件</p><p><a href="https://sm.ms/image/LG9S8uT7lUOkjDi" target="_blank"><img src="https://s2.loli.net/2022/03/01/LG9S8uT7lUOkjDi.jpg" style="width:60%"></a></p><h1 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h1><p>编译器是指将<strong>源程序</strong>编译为目标<strong>可执行程序</strong>的系统</p><p>编译器的前端与后端<br>前端：只依赖于源语言<br>后端：依赖于目标机器，一般独立于源语言，与中间语言有关<br>前端+后端：组合<br>取一个编译器前端，重写它的后端以产生同一源语言在另一机器上的编译器<br>把几种不同的语言编译成同一种中间语言，让不同的前端使用同一后端，从而得到一台机器上的几个编译器<br>编译的几个阶段常用一趟/遍（pass）扫描来实现，一趟/遍扫描包括读一个输入文件和写一个输出文件</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><a href="https://sm.ms/image/yqvLdF9N1MsflIT" target="_blank"><img src="https://s2.loli.net/2022/03/01/yqvLdF9N1MsflIT.jpg" style="width:60%"></a></p><h2 id="分析部分-前端阶段任务"><a href="#分析部分-前端阶段任务" class="headerlink" title="分析部分(前端阶段任务)"></a>分析部分(前端阶段任务)</h2><p>前端：源程序 → 中间表示</p><ol><li><p><strong>词法分析</strong><br><a href="https://sm.ms/image/mLJdAs1lEK3IGeS" target="_blank"><img src="https://s2.loli.net/2022/03/01/mLJdAs1lEK3IGeS.jpg" style="width:60%"></a><br>识别最小语法单位并表示词性<br>逐个读构成源程序的字符，把它们组成词法单元(token)流</p></li><li><p><strong>语法分析</strong><br><a href="https://sm.ms/image/etIwzx8q5EZs3gu" target="_blank"><img src="https://s2.loli.net/2022/03/01/etIwzx8q5EZs3gu.jpg" style="width:60%"></a><br>根据单词词性分析语法<br>把词法记号流依照语言的语法结构按层次分组，以形成语法短语</p></li><li><p><strong>语义分析</strong><br>根据单词值分析语义是否正确<br>· 类型转换<br>· 类型检查<br>· 语法制导翻译</p></li><li><p><strong>中间代码生成</strong><br>生成中间代码<br>中间代码位于<strong>高级编程语言</strong>和<strong>机器语言</strong>（目标程序）之间</p></li></ol><h2 id="综合部分-后端阶段任务"><a href="#综合部分-后端阶段任务" class="headerlink" title="综合部分(后端阶段任务)"></a>综合部分(后端阶段任务)</h2><p>后端：中间表示 → 目标程序</p><ol><li><p><strong>代码优化</strong><br>对中间代码进行优化，以期产生更高效的目标代码。</p></li><li><p><strong>目标程序生成</strong><br>将中间代码转换成低级语言代码、机器代码或汇编码。</p></li><li><p><strong>符号表管理</strong><br>编译器的一项重要工作是记录源程序中使用的标识符，并收集每个标识符的各种属性。<br>符号表是为每个标识符保存一个记录的数据结构，记录的域是标识符的属性。</p></li><li><p><strong>出错管理</strong><br>每个阶段都可能发现源程序的错误。发现错误后，该阶段必须处理此错误，使得编译可以继续进行，以便进一步发现源程序的其他错误。</p></li></ol><h1 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h1><p>百度百科：<br>解释器（英语：Interpreter），又译为直译器，是一种电脑程序，能够把高级编程语言一行一行直接转译运行。解释器不会一次把整个程序转译出来，只像一位“中间人”，每次运行程序时都要先转成另一种语言再作运行，因此解释器的程序运行速度比较缓慢。它每转译一行程序叙述就立刻运行，然后再转译下一行，再运行，如此不停地进行下去。</p><p>编译器与解释器区别：</p><p>解释器不像编译器通过翻译来生成目标程序，而是直接执行源程序所指定的运算。</p><h1 id="混合编译器"><a href="#混合编译器" class="headerlink" title="混合编译器"></a>混合编译器</h1><p><a href="https://sm.ms/image/6qEwzlsM79CA1ki" target="_blank"><img src="https://s2.loli.net/2022/03/01/6qEwzlsM79CA1ki.jpg" style="width:60%"></a></p><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编译原理笔记&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;编译程序的组成及概念解释&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://sm.ms/image/KEVZuPkjTrQ2UYa&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://s2.loli.net/2022/03/01/KEVZuPkjTrQ2UYa.jpg&quot;  style=&quot;width:60%&quot;&gt;&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="编译原理" scheme="http://akkaduilin.com/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    <category term="基础知识" scheme="http://akkaduilin.com/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="编译原理" scheme="http://akkaduilin.com/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    <category term="概念" scheme="http://akkaduilin.com/tags/%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>Java文件操作ava 流(Stream)、文件(File)和IO</title>
    <link href="http://akkaduilin.com/2022/02/22/Java-io/"/>
    <id>http://akkaduilin.com/2022/02/22/Java-io/</id>
    <published>2022-02-22T09:19:12.000Z</published>
    <updated>2022-04-15T08:26:06.913Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>Java.io 包几乎包含了所有操作输入、输出需要的类。所有这些流类代表了输入源和输出目标。</p><p>Java.io 包中的流支持很多种格式，比如：基本类型、对象、本地化字符集等等。</p><p>一个流可以理解为一个数据的序列。输入流表示从一个源读取数据，输出流表示向一个目标写数据。</p><p>Java 为 I/O 提供了强大的而灵活的支持，使其更广泛地应用到文件传输和网络编程中。</p><span id="more"></span><h1 id="读取控制台"><a href="#读取控制台" class="headerlink" title="读取控制台"></a>读取控制台</h1><h2 id="读取输入"><a href="#读取输入" class="headerlink" title="读取输入"></a>读取输入</h2><p>Java 的控制台输入由 System.in 完成<br>可以封装在一个BufferedReader中<br>BufferedReader类从字符输入流中读取文本并缓冲字符，以便有效地读取字符，数组和行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">BufferedReader br = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">c = (char) br.read();</span><br><span class="line">System.out.println(c);</span><br><span class="line"></span><br><span class="line">str = br.readLine();</span><br><span class="line">System.out.println(str);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用 read() 方法从控制台读取一个字符，用 readLine() 方法读取一个字符串。</p><h2 id="控制台输出"><a href="#控制台输出" class="headerlink" title="控制台输出"></a>控制台输出</h2><p>控制台的输出由 print( ) 和 println() 完成,print()输出完毕后不换行，而println()输出完毕后会换行，<br>方法都由类 PrintStream 定义，System.out 是该类对象的一个引用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int b;</span><br><span class="line">b = &#x27;A&#x27;;</span><br><span class="line">System.out.println(b);</span><br><span class="line">System.out.println(&#x27;\n&#x27;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h1><h2 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h2><p>创建一个文件对象来创建一个输入流对象读取文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File f = new File(&quot;C:/java/hello&quot;);</span><br><span class="line">InputStream in = new FileInputStream(f);</span><br></pre></td></tr></table></figure><p>相关函数<br>|  序号 | 方法 | 描述 |<br>|:—–|:—–|:—–|<br>|     1  |    close()   |  关闭此文件输入流并释放与此流有关的所有系统资源     |<br>|     2  |    write(int r)   |  从 InputStream 对象读取指定字节的数据。返回为整数值，返回下一字节数据，如果已经到结尾则返回-1。     |<br>|     3  |    write(byte[] r)    |  从输入流读取r.length长度的字节。返回读取的字节数。如果是文件结尾则返回-1。     |</p><h2 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h2><p>创建一个文件并向文件中写数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OutputStream f = new FileOutputStream(&quot;C:/java/hello&quot;)</span><br></pre></td></tr></table></figure><p>相关函数<br>|  序号 | 方法 | 描述 |<br>|:—–|:—–|:—–|<br>|     1  |    close()   |  关闭此文件输入流并释放与此流有关的所有系统资源     |<br>|     2  |    write(int w)   |  写入指定字节的数据。 |<br>|     3  |    write(byte[] w)    |  写入w.length长度的字节。     |</p><h1 id="xx3x"><a href="#xx3x" class="headerlink" title="xx3x"></a>xx3x</h1><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Java.io 包几乎包含了所有操作输入、输出需要的类。所有这些流类代表了输入源和输出目标。&lt;/p&gt;
&lt;p&gt;Java.io 包中的流支持很多种格式，比如：基本类型、对象、本地化字符集等等。&lt;/p&gt;
&lt;p&gt;一个流可以理解为一个数据的序列。输入流表示从一个源读取数据，输出流表示向一个目标写数据。&lt;/p&gt;
&lt;p&gt;Java 为 I/O 提供了强大的而灵活的支持，使其更广泛地应用到文件传输和网络编程中。&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="http://akkaduilin.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="笔记" scheme="http://akkaduilin.com/categories/%E7%BC%96%E7%A8%8B/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="http://akkaduilin.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java 学习笔记(基础篇)</title>
    <link href="http://akkaduilin.com/2022/02/21/java-note/"/>
    <id>http://akkaduilin.com/2022/02/21/java-note/</id>
    <published>2022-02-21T03:04:51.000Z</published>
    <updated>2022-04-16T04:21:59.946Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>Java 学习笔记(基础篇)</p><p>2022.2.21 </p><p>持续更新</p><span id="more"></span><h1 id="内置数据结构"><a href="#内置数据结构" class="headerlink" title="内置数据结构"></a>内置数据结构</h1><ol><li><p>byte<br>最小值是 -128（-2^7）；<br>最大值是 127（2^7-1）；<br>默认值是 0；</p></li><li><p>short<br>最小值是 -32768（-2^15）；<br>最大值是 32767（2^15 - 1）；<br>Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一；<br>默认值是 0；</p></li><li><p>int<br>最小值是 -2,147,483,648（-2^31）；<br>最大值是 2,147,483,647（2^31 - 1）；<br>一般地整型变量默认为 int 类型；<br>默认值是 0 ；</p></li><li><p>long<br>最小值是 -9,223,372,036,854,775,808（-2^63）；<br>最大值是 9,223,372,036,854,775,807（2^63 -1）；<br>这种类型主要使用在需要比较大整数的系统上；<br>默认值是 0L；</p></li><li><p>float<br>float 数据类型是单精度、32位、符合IEEE 754标准的浮点数；<br>float 在储存大型浮点数组的时候可节省内存空间；<br>默认值是 0.0f；</p></li><li><p>double：<br>double 数据类型是双精度、64 位、符合 IEEE 754 标准的浮点数；<br>浮点数的默认类型为 double 类型；<br>double类型同样不能表示精确的值，如货币；<br>默认值是 0.0d；</p></li><li><p>boolean<br>1 = true<br>0 = false<br>默认值为false</p></li><li><p>char<br>储存任何字符</p></li></ol><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><ol><li><p>声明变量<br>type identifier [ = value][, identifier [= value] …] ;</p></li><li><p>局部变量<br>局部变量声明在方法、构造方法或者语句块中；</p></li></ol><p>局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁；</p><p>局部变量只在声明它的方法、构造方法或者语句块中可见；</p><ol start="3"><li>静态变量<br>类变量也称为静态变量，在类中以 static 关键字声明，但必须在方法之外。</li></ol><p>无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。</p><p>静态变量除了被声明为常量外很少使用，静态变量是指声明为 public/private，final 和 static 类型的变量。静态变量初始化后不可改变。</p><p>静态变量储存在静态存储区。经常被声明为常量，很少单独使用 static 声明变量。</p><p>静态变量在第一次被访问时创建，在程序结束时销毁。</p><p>静态变量可以通过：ClassName.VariableName的方式访问</p><ol start="4"><li>实例变量<br>实例变量声明在一个类中，但在方法、构造方法和语句块之外；</li></ol><p>当一个对象被实例化之后，每个实例变量的值就跟着确定；</p><p>实例变量在对象创建的时候创建，在对象被销毁的时候销毁；</p><p>实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息；</p><p>实例变量可以声明在使用前或者使用后；</p><p>。</p><h1 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h1><h2 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h2><p>public protected default private</p><h2 id="非访问修饰符"><a href="#非访问修饰符" class="headerlink" title="非访问修饰符"></a>非访问修饰符</h2><p>static 声明独立于对象的静态变量或者静态方法</p><p>final 变量一旦赋值后，不能被重新赋值<br>父类的final方法可以被子类继承，但不能被重写，final类不能被继承</p><p>abstract<br>抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。<br>抽象方法是一种没有任何实现的方法，该方法的具体实现由子类提供。</p><p>synchronized<br>关键字声明的方法同一时间只能被一个线程访问。synchronized 修饰符可以应用于四个访问修饰符。</p><p>transient </p><p>volatile</p><h1 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h1><p>variable x = (expression) ? value if true : value if false</p><h1 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h1><p>同C++写法</p><p>while( 布尔表达式 ) {<br>  //循环内容<br>}</p><p>do {<br>       //代码语句<br>}while(布尔表达式);</p><p>for(初始化; 布尔表达式; 更新) {<br>    //代码语句<br>}</p><p>break</p><p>continue</p><p><strong>增强for循环</strong> 主要用于数组</p><p>for(声明语句 : 表达式)<br>{<br>   //代码句子<br>}</p><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">   public static void main(String[] args)&#123;</span><br><span class="line">      int [] numbers = &#123;10, 20, 30, 40, 50&#125;;</span><br><span class="line"> </span><br><span class="line">      for(int x : numbers )&#123;</span><br><span class="line">         System.out.print( x );</span><br><span class="line">         System.out.print(&quot;,&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.print(&quot;\n&quot;);</span><br><span class="line">      String [] names =&#123;&quot;James&quot;, &quot;Larry&quot;, &quot;Tom&quot;, &quot;Lacy&quot;&#125;;</span><br><span class="line">      for( String name : names ) &#123;</span><br><span class="line">         System.out.print( name );</span><br><span class="line">         System.out.print(&quot;,&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h1><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">if(布尔表达式 1)&#123;</span><br><span class="line">   //如果布尔表达式 1的值为true执行代码</span><br><span class="line">&#125;else if(布尔表达式 2)&#123;</span><br><span class="line">   //如果布尔表达式 2的值为true执行代码</span><br><span class="line">&#125;else if(布尔表达式 3)&#123;</span><br><span class="line">   //如果布尔表达式 3的值为true执行代码</span><br><span class="line">&#125;else &#123;</span><br><span class="line">   //如果以上布尔表达式都不为true执行代码</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">switch(expression)&#123;</span><br><span class="line">    case value :</span><br><span class="line">       //语句</span><br><span class="line">       break; //可选</span><br><span class="line">    case value :</span><br><span class="line">       //语句</span><br><span class="line">       break; //可选</span><br><span class="line">    //你可以有任意数量的case语句</span><br><span class="line">    default : //可选</span><br><span class="line">       //语句</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Math-类"><a href="#Math-类" class="headerlink" title="Math 类"></a>Math 类</h1><table><thead><tr><th align="left">序号</th><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">xxxValue()</td><td align="left">将 Number 对象转换为xxx数据类型的值并返回。</td></tr><tr><td align="left">2</td><td align="left">equals()</td><td align="left">判断number对象是否与参数相等</td></tr><tr><td align="left">3</td><td align="left">valueOf()</td><td align="left">返回Number对象指定的内置数据类型</td></tr><tr><td align="left">4</td><td align="left">parseInt()</td><td align="left">将字符串解析为int类</td></tr><tr><td align="left">5</td><td align="left">toString()</td><td align="left">以字符串形式返回值</td></tr><tr><td align="left">6</td><td align="left">abs()</td><td align="left">返回参数的绝对值</td></tr><tr><td align="left">7</td><td align="left">ceil()</td><td align="left">返回大于等于给定参数的最小整数</td></tr><tr><td align="left">8</td><td align="left">floor()</td><td align="left">返回小于等于给定参数的最大整数</td></tr><tr><td align="left">9</td><td align="left">rint()</td><td align="left">返回与参数最接近的整数</td></tr><tr><td align="left">10</td><td align="left">round()</td><td align="left">四舍五入</td></tr><tr><td align="left">11</td><td align="left">max()/min()</td><td align="left">返回两个参数的最大/小值</td></tr><tr><td align="left">12</td><td align="left">exp()</td><td align="left">返回参数的自然数底数的对数值</td></tr><tr><td align="left">13</td><td align="left">log()</td><td align="left">返回参数的自然数底数的对数值</td></tr><tr><td align="left">14</td><td align="left">pow()</td><td align="left">x.pow(y) 返回 x的y次方</td></tr><tr><td align="left">15</td><td align="left">sqrt()</td><td align="left">求算术平方根</td></tr><tr><td align="left">16</td><td align="left">cos()/tan()/sin()/asin()</td><td align="left">三角函数相关</td></tr><tr><td align="left">17</td><td align="left">random()</td><td align="left">返回一个随机数</td></tr></tbody></table><h1 id="Character类"><a href="#Character类" class="headerlink" title="Character类"></a>Character类</h1><table><thead><tr><th align="left">序号</th><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">isLetter()</td><td align="left">是否为字母</td></tr><tr><td align="left">2</td><td align="left">isDigit()</td><td align="left">是否为数字字符</td></tr><tr><td align="left">3</td><td align="left">isWhitespace()</td><td align="left">是否为空白字符</td></tr><tr><td align="left">4</td><td align="left">isUpperCase()/isLowerCase()</td><td align="left">是否为大写/小写</td></tr><tr><td align="left">5</td><td align="left">toUpperCase()/toLowerCase()</td><td align="left">转换为大写/小写</td></tr></tbody></table><h1 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h1><p><a href="https://www.runoob.com/java/java-string.html">https://www.runoob.com/java/java-string.html</a></p><table><thead><tr><th align="left">序号</th><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">charAt(int index)</td><td align="left">返回指定索引处的char值</td></tr><tr><td align="left">2</td><td align="left">compareTo(String str)</td><td align="left">按字典顺序比较字符串 *Tip1</td></tr><tr><td align="left">3</td><td align="left">concat(String str)</td><td align="left">将指定字符串str连接到字符串末尾</td></tr><tr><td align="left">4</td><td align="left">endWith(startsWith)(String suffix)</td><td align="left">是否以指定后缀结束(开始)</td></tr><tr><td align="left">5</td><td align="left">equals(Object anObject)</td><td align="left">比较两个字符串的内容是否相等</td></tr><tr><td align="left">6</td><td align="left">indexOf(int ch(String str)， int fromIndex)</td><td align="left">返回指定字符在此字符串中第一次出现处的索引,从指定位置开始</td></tr><tr><td align="left">7</td><td align="left">lastIndexOf(int ch, int fromIndex)</td><td align="left">返回指定字符在此字符串中最后一次出现处的索引,从指定位置开始</td></tr><tr><td align="left">8</td><td align="left">length()</td><td align="left">返回字符串的长度</td></tr><tr><td align="left">9</td><td align="left">replace(char old, char new)</td><td align="left">返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的</td></tr><tr><td align="left">10</td><td align="left">replaceAll(replaceFirst)(String regex, String replacement)</td><td align="left">使用给定的 replacement 替换此字符串所有(第一个)匹配给定的正则表达式的子字符串</td></tr><tr><td align="left">11</td><td align="left">split(String regex)</td><td align="left">根据给定正则表达式的匹配拆分此字符串</td></tr><tr><td align="left">12</td><td align="left">substring(int beginIndex, int endIndex)</td><td align="left">返回字符串的子字符串 *Tip2</td></tr><tr><td align="left">13</td><td align="left">toUpperCase(toLowerCaes)(Locale locale)</td><td align="left">将字符串小(大)写字符转换为大(小)写</td></tr><tr><td align="left">14</td><td align="left">toCharArray()</td><td align="left">将此字符串转换为一个新的字符数组</td></tr><tr><td align="left">15</td><td align="left">isEmpty()</td><td align="left">判断字符串是否为空</td></tr></tbody></table><p>Tip1: 如果参数字符串等于此字符串，则返回值 0<br>如果此字符串小于字符串参数，则返回一个小于 0 的值；<br>如果此字符串大于字符串参数，则返回一个大于 0 的值。</p><p>Tip2:<br>beginIndex – 起始索引（包括）, 索引从 0 开始。<br>endIndex – 结束索引（不包括）</p><h2 id="判断字符串是否包含特殊字符"><a href="#判断字符串是否包含特殊字符" class="headerlink" title="判断字符串是否包含特殊字符"></a>判断字符串是否包含特殊字符</h2><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public static boolean isSpecialChar(String str) &#123;</span><br><span class="line">       String regEx = &quot;[ _`~!@#$%^&amp;*()+=|&#123;&#125;&#x27;:;&#x27;,\\[\\].&lt;&gt;/?~！@#￥%……&amp;*（）——+|&#123;&#125;【】‘；：”“’。，、？]|\n|\r|\t&quot;;</span><br><span class="line">       Pattern p = Pattern.compile(regEx);</span><br><span class="line">       Matcher m = p.matcher(str);</span><br><span class="line">       return m.find();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="StringBuffer-和-StringBuilder"><a href="#StringBuffer-和-StringBuilder" class="headerlink" title="StringBuffer 和 StringBuilder"></a>StringBuffer 和 StringBuilder</h1><p><a href="https://www.runoob.com/manual/jdk11api/java.base/java/lang/StringBuilder.html">https://www.runoob.com/manual/jdk11api/java.base/java/lang/StringBuilder.html</a><br><a href="https://www.runoob.com/java/java-stringbuffer.html">https://www.runoob.com/java/java-stringbuffer.html</a><br>对字符串进行修改时使用<br>能够被多次的修改并且不产生新的未使用对象</p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="声明、创建数组"><a href="#声明、创建数组" class="headerlink" title="声明、创建数组"></a>声明、创建数组</h2><ol><li><p>dataType[] arrayRefVar = {value0, value1, …, valuek}; </p></li><li><p>dataType[] arrayRefVar = new dataType[arraySize];</p></li></ol><h2 id="for-each-循环遍历"><a href="#for-each-循环遍历" class="headerlink" title="for each 循环遍历"></a>for each 循环遍历</h2><p>for (double element: myList) {<br>   System.out.println(element);<br>}</p><h1 id="Scanner"><a href="#Scanner" class="headerlink" title="Scanner"></a>Scanner</h1><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>通过创建Scanner类来获取用户的输入<br>通过next() nextLine() 接收字符串<br>通过 hasnext() hasNextLine() 判断是否有输入的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner; </span><br><span class="line"> </span><br><span class="line">public class ScannerDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner scan = new Scanner(System.in);</span><br><span class="line">        // 从键盘接收数据</span><br><span class="line"> </span><br><span class="line">        // next方式接收字符串</span><br><span class="line">        System.out.println(&quot;next方式接收：&quot;);</span><br><span class="line">        // 判断是否还有输入</span><br><span class="line">        if (scan.hasNext()) &#123;</span><br><span class="line">            String str1 = scan.next();</span><br><span class="line">            //String str2 = scan.nextLine();</span><br><span class="line">            System.out.println(&quot;输入的数据为：&quot; + str1);</span><br><span class="line">        &#125;</span><br><span class="line">        scan.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="next-与-nextLine-区别"><a href="#next-与-nextLine-区别" class="headerlink" title="next() 与 nextLine() 区别"></a>next() 与 nextLine() 区别</h2><p>next():</p><p>1、一定要读取到有效字符后才可以结束输入。<br>2、对输入有效字符之前遇到的空白，next() 方法会自动将其去掉。<br>3只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。<br>next() 不能得到带有空格的字符串。<br>nextLine()：</p><p>1、以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。<br>2、可以获得空白。</p><h1 id="文件操作、"><a href="#文件操作、" class="headerlink" title="文件操作、"></a>文件操作、</h1><a href="/2022/02/22/Java-io/" title="Java文件操作ava 流(Stream)、文件(File)和IO">Java文件操作ava 流(Stream)、文件(File)和IO</a><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p><a href="https://www.runoob.com/java/java-exceptions.html">https://www.runoob.com/java/java-exceptions.html</a></p><h2 id="遇到的报错记录"><a href="#遇到的报错记录" class="headerlink" title="遇到的报错记录"></a>遇到的报错记录</h2><h3 id="The-static-field-value-arr-should-be-accessed-in-a-static-way"><a href="#The-static-field-value-arr-should-be-accessed-in-a-static-way" class="headerlink" title="The static field value.arr should be accessed in a static way"></a>The static field value.arr should be accessed in a static way</h3><p>静态字段应以静态方式引用<br>接口中的变量前不需要加 this<br>关键字 this 是java为了区分本类属性与外部的冲突而引入的一个调用方式，<br>这个 this 严格意义上讲，应当是调用本类引用属性或方法时使用的，而静态字段更多的是一个常驻与内存中的不变量，所以没必要使用 this 这个关键字</p><h3 id="Cannot-make-a-static-reference-to-the-non-static-method"><a href="#Cannot-make-a-static-reference-to-the-non-static-method" class="headerlink" title="Cannot make a static reference to the non-static method"></a>Cannot make a static reference to the non-static method</h3><p><a href="https://blog.csdn.net/weixin_43914658/article/details/109262885">https://blog.csdn.net/weixin_43914658/article/details/109262885</a><br>main函数中只能调用静态函数，否则需要先实例化对象。</p><hr /><p>版权信息</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Java 学习笔记(基础篇)&lt;/p&gt;
&lt;p&gt;2022.2.21 &lt;/p&gt;
&lt;p&gt;持续更新&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="http://akkaduilin.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="笔记" scheme="http://akkaduilin.com/categories/%E7%BC%96%E7%A8%8B/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Java" scheme="http://akkaduilin.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>亦非亦林</title>
    <link href="http://akkaduilin.com/2022/01/26/her/"/>
    <id>http://akkaduilin.com/2022/01/26/her/</id>
    <published>2022-01-25T16:46:26.000Z</published>
    <updated>2022-03-22T07:30:00.907Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://sm.ms/image/AxWVizPOZgqN8cw" target="_blank"><img src="https://s2.loli.net/2021/12/24/AxWVizPOZgqN8cw.jpg" ></a> </p><p><strong>前言</strong></p><p><strong>对每一个男孩来说，总有一个女孩，会让你成长</strong></p><span id="more"></span><h1 id="最想让你看的"><a href="#最想让你看的" class="headerlink" title="最想让你看的"></a>最想让你看的</h1><h2 id="2022-1-21"><a href="#2022-1-21" class="headerlink" title="2022.1.21"></a>2022.1.21</h2><p>距离上次见面已经过去了四天了，我们可能谁都没法想到我们三周年的那一天会变成那个样子，种种三年积压下来的矛盾在那天之后一下子全部爆发了出来，在这几天，我想了很多很多，从在最开始的对你的愧疚，到对自己的反省，到理性的分析我们之间的关系。在当面你把你对我的种种不满一下子倾倒出来的时候，我脑子里真的一片空告，我没有想到在你眼里我竟然是那么的不堪，那么恶劣，在你眼里我竟然是自己最讨厌的那个样子，在那种情况之下，我能做到的就是对自己所做的愧疚，但等我回到家仔细分析的时候，我发现问题可能并不是我真的做的不好，所以我第一次向你说了异地这么长时间一直以来的想法，一直以来我都不愿意将我们之间的关系变成你的负担，这个世界对你已经很糟糕了，我想要给你的是一份陪伴，一份温暖。但是好像我做的一切改变在你眼里都微不足道，我开始反省自己，反思自己是不是应该这么做，那天我把你买的蛋糕带回家给妈妈，妈妈真的很开心，那一刻我真的发现原来这么长时间我对你的付出甚至比起家里至情之人都少了很多，哪怕只以金钱来衡量，在你身上的付出可能会比我这么多年对家里人总和都要多，可能在你看我做的微不足道的事情在妈妈眼里却能让她开心很久。只能说，只有至情之人才会无条件不求回报的对自己好啊。<br>这几天最大的感受就是，很多曾经只是听个调子的歌，现在竟然能一下子明白了其中歌词的含义，可能这就是成长吧。在最迷茫的时候，我甚至把我的想法发到了一个论坛里，得到的回复竟然都是劝我分手，可能是我的描述带有我的主观性吧，但是这清一色的回复还是让我挺难过的，这么长时间的坚持，到最后其实也就是世俗所能预料到的结果吗? 可能要不要分手这种想法在很早之前就有过了，在你复读的时候是想要陪着你坚持下去拿到本应属于你的成绩，在你去看心理医生的时候是想要一直一直坚持做你的后盾，可能每个时间段都会有能让我坚持下去的理由，哪怕到了现在，在你说你因为你爸妈的情况开始害怕爱情后我的理由都会是想要让你在我身上重新期待爱情，期待生活。因为我知道，你真的是一个特别特别好的女孩，如果因为这种事情而在你心里结下一个心结，对你来说是不公平的，也是我不想看到的。<br>我也意识到了，这次可能真的是目前为止我们最有可能分道扬镳的一次了，我们两个人真的有很多很多还需要解决的问题，不管是你我家庭的情况还是你我两个人对爱情的看法，可能在我看来爱情应该是平等的吧，所以在我一次次付出之后渐渐开始考虑做这件事的意义，在我付出了这些之后你会不会也会这样对我。可能对你来说你所希望的爱情是能让你能感受到在经历的是你心中的美好爱情吧，这么长时间你也从来没有和我说过对我有什么期望，希望的爱情是什么样子的，可能你现在真的不愿意去想爱情吧，如果我和你是朋友，是闺蜜，我们都不会有这些矛盾。你说做不好当下，怎么去谈未来，但我觉得，未来是为了让我们能更好的做好当下，没有一个目标，你为什么要做好当下呢? 我也很羡慕别人女朋友会给她的男孩买鞋子、织围巾，会陪她的男孩子一起玩游戏，一起听歌，但我觉得不能因为你没有做这些就说你是不好的，每个人的情况都是不一样的。所以我一直在等，等你说你真的也愿意为我们两个的未来努力，等你说你期望的未来是有我的。但是这么长时间了，我一直没有等到，甚至会感觉越来越等不到了，所以我选择和你好好聊一聊这些事情。在我看来我既然选择了要和你在一起，那就是为了以后，如果只是为了当下的快乐，那又何必选择这条崎岖的路呢。所以我哪怕觉得可能会出现现在的情况，也决定说出来这些。<br>其实之前那几次对我们之间的感情的怀疑最后都是感性占了上风，但这次我能感觉到自己真的理性了很多，我不会再觉得自己对你真的有我想象的那么重要，我想要的是你的回答，而不是我的一厢情愿。但是不管最后的结果怎么样，我都希望你能知道，和你的这三年真的让我成长了很多，我真的很感谢你的出现，可能在这段感情中，我收获的真的比你要多吧，所以我不会强求你什么，你是怎么想的我都会尊重你的想法。我不想再这么等下去了，继续还是分开，都会是上天给我们这段感情的安排吧。</p><p><em>你会不会偶尔想起，十几岁只图你感情的人？</em><br><a href="https://b23.tv/YTZymNu">https://b23.tv/YTZymNu</a></p><h1 id="一些小记"><a href="#一些小记" class="headerlink" title="一些小记"></a>一些小记</h1><h2 id="2021-12-2"><a href="#2021-12-2" class="headerlink" title="2021.12.2"></a>2021.12.2</h2><p>真的是，有那么一天晚上突然就破防了———— 记事本奉上<br><em>网易云那个点评</em><br><em>虽然只是数据的玩笑罢了（大概吧）可能这就是真的内在吧 哪怕做了三四遍结果也没能改变 现在的感觉就像小时候装作大人的样子，明明已经很努力的去付出改变了但好像最后也没得到什么…… 有时候也会想 明明自己也还稚嫩为什么要逼着自己成熟  想有人能给自己说一句你已经很棒了  而不是每天都在方方面面觉得自己不好  为什么内疚呢 会难过呢  因为自己又不满意了吗  怎样才能让你满意呢 不知道  只会做现在能做的的 害怕 害怕自己现在做的不够多会失去什么 害怕哪怕以后能做到却没了目标  这种明明做了很多还感觉自己不好 配不上现在的感觉也太可笑了  难道我感觉的不平 都是正常的吗  一边觉得自己做的这么好还得不到理解的不满  一边怀疑自己真的做好了的怀疑  一边害怕失去脑补各种结局的不安  不知道怎么办 也没有什么可以说的  说给谁呢  为什么不去说呢  你在怕什么  不知道  就是怕…  哦懂了  你害怕得到的答案是你这么做没感觉不对吗  你觉得你很好了吗？</em></p><p>内心挣扎后的现状(笑死 想这么多真就不想睡觉)：</p><p><em>好吧  说了  开始脑补结果了  真是闲</em></p><p><em>好了  什么都说了啊  早上能收到什么呢  不安</em></p><p>其实这种感觉好像也不止这一次了吧 总是能在晚上想到我们两个人以后怎么办 真正晚上想了这么多第二天也不知道该怎么和她去说 在一起真的以及快三年了啊<br>每次看到网上关于异地的评论都在一次次怀疑自己 每次和别人讨论起来基本没几个人能看好吧 说实话有时候觉得自己蛮累的 有时候觉得自己坚持不是为了自己 但是仔细静下心想想自己真的想要什么呢？ 可能就是那种哪怕忙了一天回家能和她一起做饭看电影的日子吧 是怕自己没有了了她真的会孤独吧 我还记得自己当时晚上因为一些小事泣不成声 感觉这么久了每次难过都和这份感情有联系 可能是自己喜欢多想 一遍遍强调自己要相信对方一次次还怀疑自己 可能这就是真正的爱吧 自从慢慢长大发现成年人的爱情真的很累啊 可能自己如果放弃这段感情真的会没有勇气去向前看吧 现在能想到的就只有坚持下去 可能变数真的很多 不安也有很多 那也只能这样了吧 </p><h2 id="2021-12-7"><a href="#2021-12-7" class="headerlink" title="2021.12.7"></a>2021.12.7</h2><p>好久没有打过视频了啊，看到屏幕对面几近崩溃的你真的有一种很无助的感觉，我不知道怎么能帮到现在的你，可能这种情况下你最需要的是一个深深的拥抱而已，但我却没有办法做到，这可能就是异地吧，明明是在最需要你的时候你却没有办法做任何事情，只能用你那笨拙的言语去安慰别人。有时候真的希望能出现在你的身边，大学几年越上越发现有些事情真的不是你想要能做到就能做到的。你学习的压力我已经能感觉快要压垮你了，我能怎么办呢，难道只能遥远的陪伴吗。。。我真的不知道，我害怕，又希望能出现比我更能照顾好你的人。可能对我来说，现在前进的动力是能让未来的我们过的更好。我总是喜欢往前看，这样就能忘记现在的难过。但是若现在的问题解决不了，未来又在哪里呢。。。。。。</p><h2 id="2021-12-19"><a href="#2021-12-19" class="headerlink" title="2021.12.19"></a>2021.12.19</h2><p>今天是该死大直男！<br>但是自己真的忘记了她最喜欢的明星是谁啊。。。。 说起来，这个事情也就是在之前逛街的时候随口提到了吧，只能说有点印象(再加上自己真对演艺明星认识的就少)。感觉好像哪怕在一起将近三年了对互相的了解也只是一点啊。可能和我们互相见面互相深入聊天的次数太少有关叭，好想找个时间可以一起好好聊一聊互相，聊一聊过去的自己。总有一天，会有这个机会吧。<br>记个笔记： 我们家小朋友最喜欢陈伟霆 记住名字！！！不要只认个脸 这么帅的脸你记不住吗？？？</p><h2 id="2022-1-1"><a href="#2022-1-1" class="headerlink" title="2022.1.1"></a>2022.1.1</h2><p>第一次断片，没想到会是因为这么一件小事，其实真的很想让你关心关心我吧，可是好像得到的就是简简单单的下次不要这样了。我真的没什么重要的。<br>补：<br>10月17号，你还会问我在干嘛，要不要打语音，我们还在吐槽身边的各种事情<br>18号，你安架子磨破了手，会怪我没有关心你，希望有人在你身边<br>24号，你叫我陪你一起听歌，会催我给你打视频，晚上会忙<br>26号，你说你有了同款礼物，好开心<br>27号，你很崩溃，我只能发几个抱抱，发消息安慰你，无助<br>31号，你说，你觉得给我发消息之后会猜到我说什么，我只能一遍一遍说我真的在乎你，距离真的会拉远两个人<br>11月1号，你会给我考试加加油，会在我考不好的时候安慰我<br>8号，你说2021所剩无几，时间流逝，我们还剩下什么?<br>16号，你被选上去见领导，参加那个形象大使比赛<br>21号，我帮你给视频消音，能帮到你真的很开心，原来，我在你心里也会很棒啊，<br>22号，你说你感觉你离我好远，我说，四年之后我会和你在一个城市，你给我发了一个爱心，那时的我，还坚定着自己的心<br>25号，你说你已经习惯了忙碌，我说，我们要一起加油<br>28号，你要我帮你领游戏，我们会有一起玩的机会吗？<br>29号，你说你不努力，你在疯狂的否定自己，但是在我心里，你一直都是最好的<br>12月1号，我给你发了网易云的截图，你说你承受了很多，我发了好多好多消息<br>2号，你说你梦到我了，你说我现在其实挺好的，原来付出是有回报的<br>5号，你开始在寝室喝酒，这一年你最忙的时间就要来了<br>6号，给你打视频你很崩溃，无助，胡思乱想<br>7号，你通过了初试，要去电视台参加复试<br>10号，帮你剪歌<br>11号，你上台表演了，并且很棒的进入了下一轮<br>14号，你收到了老师的贺卡，你真的好开心，如果我也能让你这么开心就好了<br>16号，你在否定自己，说自己不努力，真的有好多好多想说的，结果到最后就只有我一直都在而已<br>19号，我没能说出你最喜欢的明星，感觉自己真的对你了解有限，你给老猫说，我完全不懂你<br>22号，你说我在大学学到了很多，你什么都没学到<br>23号，你又在寝室喝酒，生活的压力逐渐把我们两个压垮，对我来说，这段感情最艰难的时候来了<br>24、25号，圣诞节，什么都没有收到，觉得自己很孤独，想要你陪陪我<br>26号，因为礼物寄的晚了所以记得要给你买个蛋糕补偿一下，那是，我还在期待今年会不会有礼物<br>28号，你被垃圾老师弄的很生气，你渐渐变得没有以前那样，你也会骂脏话，会和我狠狠的骂老师<br>29号，帮你弄题，我都不知道为什么自己会这么用心，可能，只是想让你知道我也是很重要的吧<br>30号，你看到了我给你写的信，你说你想了很多，说会和我好好聊一聊，我一直在等<br>31号，晚上你去看电影，说好要给我打电话，没等到，梦想中的礼物也不了了之，那天晚上我很难过，我不知道自己为什么要坚持下去，第一次喝酒到断片</p><h2 id="2022-1-6"><a href="#2022-1-6" class="headerlink" title="2022.1.6"></a>2022.1.6</h2><p>又是睡不着的一晚上，最近发生的事情太多了，有点不太能清楚分析了。<br>跨年夜那天断片的经历是人生第一次，我也不希望会有下一次，我依稀记得在电话里给zly说我到底为什么要坚持下去，说实话，哪怕是清醒的我也不知道，我到底是为了什么要像现在这样痛苦。或者说，我这样坚持是不是只是想知道自己会不会有那一个坚定的目标呢？我说不清楚，可能只是因为感觉自己真的找到心仪的她，或者是因为不愿意去再像现在这样用心去对一个人，现在能做的就是苦苦的继续坚持。为什么在这段感情里自己要处于这么卑微的一个状态呢，明明应该是双向奔赴的感情却好像总是自己的一厢情愿，有点累，有点无助。难道爱情就应该是现在这种感觉吗，这么长时间回想起来却没办法想到多少甜蜜的感觉，仔细想来真的有些好笑，值得吗？<br>最近真的感觉两个人有越走越远的感觉了，这次投票我能感觉到她背后的家庭是多么强大，我相比人家可能真的平平无奇，有时候会想自己要足够强大，这样才能配的上她，才能让人家家里人放心的将她的下半生交给我，但是仔细想想我能做到吗？或者说，我尽心尽力去做的能达到人家的要求吗，从来没有对我们未来的日子这么迷茫过，能想象到的只有很多很多的困难，会是我真的想多了吧，但是总感觉自己像是小说里的那个种平凡的男生，费尽心思追到想要伴随一生的人却因为种种原因没办法得到，这种天生的家庭差距会不会在未来真的变成我们两个之间的隔阂，我不想多想，明明当下都不知道怎么办为什么还要想那么多，我哪怕再怎么拉人能做到的也不及人家家里的百分之一，就这样的我真的能够和她在一起吗。我曾经也相信过爱情，相信走过高三那段时间就可以开始真正的恋爱，但哪怕到了现在我也没感受过什么叫甜蜜的爱，能感觉到的只有无尽的压力，我真的好羡慕那种可以天天一起打游戏，一起出去旅行，天天都能陪在身边的情侣，和他们相比感觉我这真的算是在恋爱吗……<br>说句实话，她一个学期和我发信息的语气渐渐变得没有以前的那种撒娇，就感觉只是普普通通的工作聊天，没有表情包，没有任何恋爱的感觉，以前真的不是这样的。我不知道是不是成熟的爱情就应该这样，每次和别人问我都说什么老夫老妻了这些不重要，但是问问自己的内心，真的不重要吗？可能真的是她很累了吧，但是我想要的真的是这样吗？<br>无助，迷茫，真的不知道感情到现在这个样子该怎么办，下定决心假期和她好好说这件事真的能说出来吗，要是没有任何进展的话自己还能坚持下去吗……我觉得可能不行了吧，我真的真的不喜欢这种压抑的感觉了，希望假期的见面真的能改变这种状态吧。<br>晚安，快去睡觉吧</p><p>补：<br>在我看来，两个人出现不合的情况有两种，一种是不爱了，一种是两个人爱的方式不一样了，第二种对我来说是可以接受的，但是需要两个人去交流，第一种就可以放手了，何必互相为难对方呢？<br>我相信，是第二种</p><h2 id="2022-1-11"><a href="#2022-1-11" class="headerlink" title="2022.1.11"></a>2022.1.11</h2><p>印象里上一次这么长时间没有收到回复是她爷爷去世的时候，也是从那时候开始，你渐渐变了，有一阵你可能真的有抑郁症的倾向，所以我选择一直陪着你，最近我们的交流少到可怜，以至于今天早上醒过来我甚至有一种没有过你的感觉，很恐怖，两个人的感情到了现在这个样子我真的不知道该怎么办了。可能你真的因为比赛很忙很忙，但是真的忙到连消息也看不到吗，我不知道，我不敢多想。<br>从来没用过这种怀疑自己的感觉，一时间我不知道我是不是还爱你，我仔细回想过来总是想不到有什么开心的事情，真的，要结束了吗？<br>今天又翻看以前的聊天记录，只能感觉到真的变了，是我的错觉吗，你是不是真的只是在敷衍我了？这是我这么长时间第一次有这种感觉，但好像又没有那么难过了，好像真的只有怅然了吧。我，尽力了吗？尽力了吧。</p><h2 id="2022-2-7"><a href="#2022-2-7" class="headerlink" title="2022.2.7"></a>2022.2.7</h2><p>在那次吵架之后，我真的平静了很多，但是不管自己怎么劝说自己不要去关心那么多，她的情况还是让我很担心，可能之前对我来说是在陪伴她，现在自己是真心想要去帮助她，在和她一起走出现在的困境的过程中自己成长，仔细想想，为什么我非得要去和她一起呢？她对我就那么重要？可能对我来说我只是不想她一个很好很好的女孩会因为现在这些事情变得堕落，变成我们最讨厌的样子吧。这个假期我真的能看到当一个倾听者的重要性，我一直在尝试变成她的倾听者，我相信她不会背叛我，现在对我来说，现在做这些的意义可能会是有一天她能真心真义的希望我能陪在她身边，一起面对这糟糕的生活。</p><h2 id="2022-2-19"><a href="#2022-2-19" class="headerlink" title="2022.2.19"></a>2022.2.19</h2><p>嘿 20岁的小朋友<br>说是小朋友，但是在我看来你真的已经不是那个我以前认识的王奕飞了，我也不是以前的那个我了，时间的痕迹渐渐的转变了我们俩的思想，改变着我们的关系。今天突然突发奇想翻看着曾经的相册，翻看我们20年那个夏天的聊天记录，原来从那个时候开始，我就已经让你失望了，那个时候的我，还不知道怎么样去关心自己爱的人，只知道疯狂的倾诉自己的想法，但那个时候的你，还爱着我，还会和我说喜欢我，会和我撒娇，会在我身边像一个小朋友。</p><p>看着曾经我们的爱情，我都在想如果当时自己想现在一样看清了一部分，你会不会已经走出了现在的困境，会不会变得开心一点。一个假期过去，我渐渐开始理解你的行为，会觉得我上次见你所说的是多幼稚的想法，其实我们都没有错，但是你经历的已经改变了你太多，我在努力的让自己成长，但是还是跟不上你的变化。可能是我曾经伤害了你太多，或者是你现在真的不想面对我们的感情，你开始对我关上了那扇爱情的门，藏起了对我喜欢的火苗，无止尽的黑暗笼罩在我们两个之间，我看不到你，也看不到我们的未来。我开始慌张，害怕你会在黑暗中迷失方向，被黑暗腐蚀变成我们两个最讨厌的样子，所以我想要为你指引道路，想要陪着你寻找那束光。虽然我也没有拥有那扇门的钥匙，我也不清楚光的位置，但是我一直觉得我有那个责任陪着你，但也只能陪着。</p><p>可是又有谁愿意一直坚持这种看不到结果的摸索呢，当我发现你甚至不愿意在黑暗中拉住我的手的时候，我真的好想放弃，会想没有我也有更好的人陪着你，可能他还有那把钥匙，不安和怀疑冲垮了我，所以我选择和你聊清关系，那怕付出的代价是分离。最后得到的结果虽然不是我想要的，但是也让我明白了这片黑暗比我想象中更难逃脱，对你的影响更大。再加上一个假期所经历的各种各样的事情，我才看清自己做了什么。你说你开始怀疑爱情，我又何尝不是呢，和你在一起的这几年里，我开始习惯没有联系，开始习惯独自的生活，开始失去对异性的兴趣，开始嘲笑那种纯洁的爱情。一个假期过去，我真的不想再因为你而整天抑郁不欢，因为没有你的回应而焦躁不安。</p><p>所有人都觉得我看起来已经很累很累了，我还能再坚持下去吗？这个假期我最大的收获一个是知道自己现在有多么幸福，另一个是知道对于身在困境的人来说不经意的支持是能够改变他的。有一天半夜那个曾经抑郁症的朋友对我说他要继续向前，他的后盾们有我在其中，我忽然明白能够帮到自己真的愿意帮的人是多幸福的事情。</p><p>所以我接受我们现在这种可能并不能称之为在恋爱的情况，我想要陪着你走过你这段困难的时刻，为了认识你的三年，也为了改变我这么多的曾经的你，我会在你需要我的时候陪在你的身边，可能我没有办法像以前那样爱你，如果有一天我能陪着你走出来，我希望我做到的能让你找回喜欢我的那微弱的火苗，在以后你能发现在我的陪伴下你能变成你想要的样子，记得有一个青涩少年在二十岁的时候为了不留下遗憾而坚定的陪在你的身边，记得我们在二十岁的年纪都对互相没有什么遗憾。</p><p>我相信只要一个人对每一段情感的付出投入是真诚的，那最后结果让人遗憾伤痛，也是没有办法。我希望对我们来说那怕我们之间结束了，我们这么长时间的爱情都不是失败的，都是有所收获的。我更希望你能从现在的琐事中走出来，想想自己的以后，不被各种各样负面的东西影响自己的本心，你要记住你身后有很多很多关心你的人，家人也好朋友也好，他们都是因为你的优秀才愿意和你站在一起，自信一点，至少在我眼里，你一直很棒，以后也会。</p><p>如果有一天在经历了这么多之后你能够很坚定的说出愿意和我一直在一起的话，是对我的努力的最大肯定。我也等着那天的到来。在那天之后，我要带你去旅行，去埃菲尔铁塔下面深深的吻你，去意大利街头的咖啡店看着你打盹，在世界的任何地方留下我们的回忆，去享受这个不完美的人生。</p><p>一起加油吧，要好好生活，为了我们身后的人，也为了我们自己。</p><p>生日快乐，我的小朋友</p><h2 id="2022-2-21"><a href="#2022-2-21" class="headerlink" title="2022.2.21"></a>2022.2.21</h2><p>朋友，恋人，我一时不知道我在期待着什么关系，当你真正对你自己爱的人说出我们之间不如朋友的时候，你是有多么累，多么无助，有些事情不是你想做就能得到的，生活就是这样，你最想抓住的，往往都会离你远去</p><h2 id="2022-3-12"><a href="#2022-3-12" class="headerlink" title="2022.3.12"></a>2022.3.12</h2><p>没想到最后竟然是这样草草结束了我们的寒假，这个寒假开始之前我曾对自己做出过承诺，如果没有解决我们两个之间的问题的话，就要狠下心来结束它，现在时间已至，可能真的想说的都说了吧，最终结果好像并没有什么变化，变化的只是我的心态，我疯狂的告诉自己不要再那么重视你，我们之间可以像现在这样的朋友关系，没有爱。但这样真的是对的吗？我不知道，现在的感觉就是没有什么意义继续下去，也没有什么理由去放弃，我能感觉到这样继续下去只会越来越远，但是我怎么忍心只是在网络上去和你道别呢……也许下一次见面，就是我放弃的时候吧。渐渐的我开始不去理会那不回复的消息，不去想以后会不会有你，但是有时候夜晚的梦还会是我们两个在一起的样子，醒来之后的落差真的让我很难过，我想要的不是现在的这个样子，当一段感情变不成你想要的样子，继续坚持下去又有什么意义呢？不管你的情况是不是真的这样，我都选择完完全全的相信，因为这样我可以少很多的难过，迷惑自己让自己以为还会好起来的。可能，我也不会再爱了吧，当那个火苗熄灭之后，我，还能找到自己想要的那个样子吗？现在这个情况继续下去，又有什么不好的吗？我已经不想让自己那么累了，我也不想因为这个伤害自己太多，真的不值得的。这个时代的人，还需要爱情吗？</p><h2 id="2022-3-22"><a href="#2022-3-22" class="headerlink" title="2022.3.22"></a>2022.3.22</h2><p>当你发现自己在不知不觉中没有以前那么关心她了，是好事还是坏事呢？现在真的没有在去想以后的我们了，心里会轻松好多，但是真的是对的吗？</p><p><a href="https://sm.ms/image/R7T8qibSgMwuhGY" target="_blank"><img src="https://s2.loli.net/2021/12/24/R7T8qibSgMwuhGY.jpg" ></a></p><p>未完待续。。。。。。</p><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://sm.ms/image/AxWVizPOZgqN8cw&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://s2.loli.net/2021/12/24/AxWVizPOZgqN8cw.jpg&quot; &gt;&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对每一个男孩来说，总有一个女孩，会让你成长&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="日常" scheme="http://akkaduilin.com/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
    <category term="想法" scheme="http://akkaduilin.com/tags/%E6%83%B3%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>matlab笔记</title>
    <link href="http://akkaduilin.com/2022/01/17/matlab/"/>
    <id>http://akkaduilin.com/2022/01/17/matlab/</id>
    <published>2022-01-17T03:17:51.000Z</published>
    <updated>2022-01-17T06:07:00.380Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://sm.ms/image/pstS2TFVXGEo71x" target="_blank"><img src="https://s2.loli.net/2022/01/17/pstS2TFVXGEo71x.jpg" ></a></p><p><strong>前言</strong></p><p>matlab笔记，备战美赛</p><p>冲鸭！！！</p><span id="more"></span><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="矩阵和数组"><a href="#矩阵和数组" class="headerlink" title="矩阵和数组"></a>矩阵和数组</h2><p>所有 MATLAB 变量都是多维数组，与数据类型无关。矩阵是指通常用来进行线性代数运算的二维数组。</p><h3 id="数组创建"><a href="#数组创建" class="headerlink" title="数组创建"></a>数组创建</h3><ol><li>用空格或者逗号(,)分隔数据<br>a = [1 2 3 4]</li><li>用分号;分隔多行数据<br>a = [1 3 5; 2 4 6; 7 8 10]</li><li>创建矩阵的另一种方法是使用 ones、zeros 或 rand 等函数。<br>zeros全部为零</li></ol><p>ones全部为 1</p><p>rand均匀分布的随机元素</p><p>randn正态分布的随机元素</p><p>z = zeros(5,1)</p><h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><ol><li><p>用单一运算符处理矩阵中的所有值<br><a href="https://sm.ms/image/uTdrzlhOf4jVIJq" target="_blank"><img src="https://s2.loli.net/2022/01/17/uTdrzlhOf4jVIJq.jpg" style="width:60%"></a></p></li><li><p>转置矩阵使用单引号<br>a’<br>撇号运算符（例如，A’）执行复共轭转置。它会围绕主对角线翻转矩阵，并且还会更改矩阵的任何复数元素的虚部符号。点撇号运算符 (A.’) 转置矩阵，但不会影响复数元素的符号。对于包含所有实数元素的矩阵，这两个运算符返回相同结果。</p></li><li><p>inv()<br>计算方阵x的逆矩阵</p></li><li><p>使用 * 执行矩阵乘法<br><a href="https://sm.ms/image/aZrP1lmifzCGKJM" target="_blank"><img src="https://s2.loli.net/2022/01/17/aZrP1lmifzCGKJM.jpg" style="width:60%" ></a></p></li><li><p>使用 format 命令可以显示更多小数位数<br>format long<br>format short</p></li><li><p>执行元素级乘法 .* 运算符<br>乘法、除法和幂的矩阵运算符分别具有执行元素级运算的对应数组运算符。</p></li><li><p>串联<br>连接数组以便形成更大数组的过程，成对的方括号 [] 即为串联运算符。<br><a href="https://sm.ms/image/QPu2vlSCEnIe15g" target="_blank"><img src="https://s2.loli.net/2022/01/17/QPu2vlSCEnIe15g.jpg" style="width:60%"></a></p></li><li><p>复数<br>表示虚部用 i j<br>c = [3+4i, 4+3j; -i, 10j]<br>c = 2×2 complex</p><p>3.0000 + 4.0000i   4.0000 + 3.0000i<br>0.0000 - 1.0000i   0.0000 +10.0000i</p></li><li><p>sum()<br>S = sum(A) 返回 A 沿大小不等于 1 的第一个数组维度的元素之和。</p></li></ol><p>如果 A 是向量，则 sum(A) 返回元素之和。</p><p>如果 A 是矩阵，则 sum(A) 将返回包含每列总和的行向量。</p><p>如果 A 是多维数组，则 sum(A) 沿大小不等于 1 的第一个数组维度计算，并将这些元素视为向量。此维度会变为 1，而所有其他维度的大小保持不变。</p><p>S = sum(A,dim) 沿维度 dim 返回总和。例如，如果 A 为矩阵，则 sum(A,2) 是包含每一行总和的列向量。</p><p>S = sum(A,’all’) 计算 A 的所有元素的总和。</p><p>使用 sum 和 diag 函数可以获取主对角线上的元素的总和：</p><p>sum(diag(A))</p><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>A = 4×4</p><pre><code> 1     2     3     4 5     6     7     8 9    10    11    1213    14    15    16</code></pre><ol><li><p>指定行和列下标<br>A(4,2)<br>ans = 14</p></li><li><p>单一下标按顺序向下遍历每一列<br>A(8)<br>ans = 14</p></li><li><p>要引用多个数组元素，请使用冒号运算符，这使您可以指定一个格式为 start:end 的范围<br>A(1:3,2)<br>ans = 3×1</p><p>  2<br>  6<br> 10<br>单独的冒号（没有起始值或结束值）指定该维中的所有元素。<br>A(3,:)<br>ans = 1×5</p><p>  9    10    11    12<br>冒号运算符还允许您使用较通用的格式 start:step:end 创建等间距向量值。默认步长为1<br>B = 0:10:100<br>B = 1×11</p><p>  0    10    20    30    40    50    60    70    80    90   100</p></li><li><p>包含冒号的下标表达式引用部分矩阵：<br>A(1:k,j)<br>表示 A 第 j 列中的前 k 个元素。因此，<br>sum(A(1:4,4)) 计算第四列的总和。<br>但是，执行此计算有一种更好的方法。冒号本身引用矩阵行或列中的所有元素，而关键字 end 引用最后一个行或列。<br>sum(A(:,end))</p></li><li><p>删除行和列<br>只需使用一对方括号即可从矩阵中删除行和列。首先<br>X = A<br>然后，要删除 X 的第二列，请使用<br>X(:,2) = []<br>这会将 X 更改为<br>X =<br> 16     2    13<br>  5    11     8<br>  9     7    12<br>  4    14     1<br>如果您删除矩阵中的单个元素，结果将不再是矩阵。因此，以下类似表达式<br>X(1,2) = []<br>将会导致错误。<br>但是，使用单一下标可以删除一个元素或元素序列，并将其余元素重构为一个行向量。因此<br>X(2:2:10) = []<br>生成<br>X =<br> 16     9     2     7    13    12     1</p></li></ol><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>结构体是多维 MATLAB 数组，包含可按文本字段标志符访问的元素。例如，<br>S.name = ‘Ed Plum’;<br>S.score = 83;<br>S.grade = ‘B+’<br>创建一个具有三个字段的标量结构体：<br>S =<br>     name: ‘Ed Plum’<br>    score: 83<br>    grade: ‘B+’<br>与 MATLAB 环境中的所有其他内容一样，结构体也为数组，因此可以插入其他元素。在本示例中，数组的每个元素都是一个具有若干字段的结构体。可以一次添加一个字段，<br>S(2).name = ‘Toni Miller’;<br>S(2).score = 91;<br>S(2).grade = ‘A-‘;<br>也可以使用一个语句添加整个元素：<br>S(3) = struct(‘name’,’Jerry Garcia’,… ‘score’,70,’grade’,’C’)</p><h2 id="工作区变量"><a href="#工作区变量" class="headerlink" title="工作区变量"></a>工作区变量</h2><p>使用<br>whos 查看工作区内容<br>save 保存数据 系统使用.mat拓展名将工作区保存在当前工作文件夹中一个名为 MAT 文件的压缩文件中<br>load 还原到工作区<br><a href="https://ww2.mathworks.cn/help/matlab/learn_matlab/workspace.html">https://ww2.mathworks.cn/help/matlab/learn_matlab/workspace.html</a></p><h2 id="字符串和文本"><a href="#字符串和文本" class="headerlink" title="字符串和文本"></a>字符串和文本</h2><p>处理文本时，将字符序列括在双引号中<br>strlength 函数求数组中每个字符串的长度<br>是个数组，每个元素包含单个字符<br><a href="https://ww2.mathworks.cn/help/matlab/learn_matlab/character-strings.html">https://ww2.mathworks.cn/help/matlab/learn_matlab/character-strings.html</a></p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>输入参数括在圆括号</p><p>存在多个输入参数，请使用逗号加以分隔</p><p>存在多个输出参数，请将其括在方括号中<br>[maxA,location] = max(A)<br>maxA = 5<br>location = 3</p><p>字符输入括在单引号中</p><p>有关初等数学函数的列表，请键入</p><p>help elfun<br>有关更多高等数学函数和矩阵函数的列表，请键入</p><p>help specfun<br>help elmat</p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="矩阵运算符"><a href="#矩阵运算符" class="headerlink" title="矩阵运算符"></a>矩阵运算符</h3><p>表达式使用大家熟悉的算术运算符和优先法则。</p><ul><li>加法</li></ul><ul><li>减法</li></ul><ul><li>乘法</li></ul><p>/ 除法</p><p>\ 左除</p><p>^ 幂</p><p>‘ 复共轭转置</p><p>( )指定计算顺序</p><h3 id="数组运算符"><a href="#数组运算符" class="headerlink" title="数组运算符"></a>数组运算符</h3><p>如果矩阵不用于线性代数运算，则成为二维数值数组。数组的算术运算按元素执行。这意味着，加法和减法运算对数组和矩阵都是相同的，但乘法运算不相同。MATLAB 的乘法数组运算表示法中包含点，也就是小数点。</p><p>运算符列表包括</p><ul><li>加法</li></ul><ul><li>减法</li></ul><p>.* 逐元素乘法</p><p>./ 逐元素除法</p><p>.\ 逐元素左除</p><p>.^ 逐元素幂</p><p>.’ 非共轭数组转置</p><h3 id="构建表"><a href="#构建表" class="headerlink" title="构建表"></a>构建表</h3><p>数组运算对构建表非常有用。假定 n 为列向量</p><p>n = (0:9)’;<br>然后，</p><p>pows = [n  n.^2  2.^n]<br>构建一个平方和 2 次幂的表：</p><p>pows =<br>     0     0     1<br>     1     1     2<br>     2     4     4<br>     3     9     8<br>     4    16    16<br>     5    25    32<br>     6    36    64<br>     7    49   128<br>     8    64   256<br>     9    81   512</p><h3 id="常用常量值"><a href="#常用常量值" class="headerlink" title="常用常量值"></a>常用常量值</h3><p>pi 3.14159265…</p><p>i 虚数单位 </p><p>j 与 i 相同</p><p>eps 浮点相对精度 ε=2^−52</p><p>realmin 最小浮点数 2^−1022</p><p>realmax 最大浮点数 (2−ε)2^1023</p><p>Inf 无穷</p><p>NaN 非数字</p><h2 id="二维图和三维图"><a href="#二维图和三维图" class="headerlink" title="二维图和三维图"></a>二维图和三维图</h2><p><a href="https://ww2.mathworks.cn/help/matlab/learn_matlab/basic-plotting-functions.html#responsive_offcanvas">https://ww2.mathworks.cn/help/matlab/learn_matlab/basic-plotting-functions.html#responsive_offcanvas</a></p><h3 id="线图"><a href="#线图" class="headerlink" title="线图"></a>线图</h3><p>要创建二维线图，请使用 plot 函数<br>plot(x,y,’r–’)</p><p>x 数据范围<br>x = 0:pi/100:2*pi;<br><em>0到2pi，中间以pi/100为间距取点</em><br><em>x分别取0，pi/100,2pi/100,3pi/100…….2pi</em></p><p>y 函数<br>y = sin(x);</p><p>‘r–’ 线条设定。每个设定可包含表示线条颜色、样式和标记的字符。</p><p>默认情况下，每次调用绘图函数、重置坐标区及其他元素以准备新绘图时，MATLAB® 都会清空图窗。</p><p>要将绘图添加到现有图窗中，请使用 hold on。在使用 hold off 或关闭窗口之前，当前图窗窗口中会显示所有绘图。</p><h3 id="三维绘图"><a href="#三维绘图" class="headerlink" title="三维绘图"></a>三维绘图</h3><p>surf(X,Y,Z)<br>z = f (x,y)<br>要计算 z，请首先使用 meshgrid 在此函数的域中创建一组 (x,y) 点。</p><p>[X,Y] = meshgrid(-2:.2:2);<br><em>.2表示0.2 (-2:.2:2)表示在-2到2的区间上以0.2的长度为间隔的向量</em><br>Z = X .* exp(-X.^2 - Y.^2);<br>然后，创建曲面图。</p><p>surf(X,Y,Z)<br>surf 函数及其伴随函数 mesh 以三维形式显示曲面图。surf 使用颜色显示曲面图的连接线和面。mesh 生成仅以颜色标记连接定义点的线条的线框曲面图。</p><h3 id="子图"><a href="#子图" class="headerlink" title="子图"></a>子图</h3><p>subplot 函数可以在同一窗口的不同子区域显示多个绘图<br>subplot 的前两个输入表示每行和每列中的绘图数。第三个输入指定绘图是否处于活动状态。</p><h2 id="编程和脚本"><a href="#编程和脚本" class="headerlink" title="编程和脚本"></a>编程和脚本</h2><h3 id="基本语言"><a href="#基本语言" class="headerlink" title="基本语言"></a>基本语言</h3><ol><li><p>创建脚本<br>edit name</p></li><li><p>注释 %</p></li><li><p>运行脚本 输入当前脚本名称</p></li></ol><h3 id="实时脚本"><a href="#实时脚本" class="headerlink" title="实时脚本"></a>实时脚本</h3><p>要使用 edit 命令创建新的实时脚本，请在文件名中包含 .mlx 扩展名：</p><p>edit newfile.mlx</p><h3 id="循环和条件语句"><a href="#循环和条件语句" class="headerlink" title="循环和条件语句"></a>循环和条件语句</h3><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">N = 100;</span><br><span class="line">f(1) = 1;</span><br><span class="line">f(2) = 1;</span><br><span class="line">%循环%</span><br><span class="line">for n = 3:N</span><br><span class="line">    f(n) = f(n-1) + f(n-2);</span><br><span class="line">end</span><br><span class="line">f(1:10)</span><br><span class="line">%条件%</span><br><span class="line">num = randi(100)</span><br><span class="line">if num &lt; 34</span><br><span class="line">   sz = &#x27;low&#x27;</span><br><span class="line">elseif num &lt; 67</span><br><span class="line">   sz = &#x27;medium&#x27;</span><br><span class="line">else</span><br><span class="line">   sz = &#x27;high&#x27;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="函数总结"><a href="#函数总结" class="headerlink" title="函数总结"></a>函数总结</h1><h2 id="magic-n"><a href="#magic-n" class="headerlink" title="magic(n)"></a>magic(n)</h2><p>M = magic(n) 返回由 1 到 n2 的整数构成并且总行数和总列数相等的 n×n 矩阵。n 的阶数必须是大于或等于 3 的标量才能创建有效的幻方矩阵。</p><h2 id="inv"><a href="#inv" class="headerlink" title="inv()"></a>inv()</h2><p>Y = inv(X) 计算方阵 X 的 逆矩阵。</p><h2 id="clc"><a href="#clc" class="headerlink" title="clc"></a>clc</h2><p>clc 函数清空命令行窗口。</p><h2 id="meshgrid-x-y"><a href="#meshgrid-x-y" class="headerlink" title="meshgrid(x,y)"></a>meshgrid(x,y)</h2><p>语法</p><p>[X,Y] = meshgrid(x,y)<br>[X,Y] = meshgrid(x)<br>[X,Y,Z] = meshgrid(x,y,z)<br>[X,Y,Z] = meshgrid(x)</p><p>说明<br>[X,Y] = meshgrid(x,y) 基于向量 x 和 y 中包含的坐标返回二维网格坐标。X 是一个矩阵，每一行是 x 的一个副本；Y 也是一个矩阵，每一列是 y 的一个副本。坐标 X 和 Y 表示的网格有 length(y) 个行和 length(x) 个列。</p><p>[X,Y] = meshgrid(x) 与 [X,Y] = meshgrid(x,x) 相同，并返回网格大小为 length(x)×length(x) 的方形网格坐标。</p><p>[X,Y,Z] = meshgrid(x,y,z) 返回由向量 x、y 和 z 定义的三维网格坐标。X、Y 和 Z 表示的网格的大小为 length(y)×length(x)×length(z)。</p><p>[X,Y,Z] = meshgrid(x) 与 [X,Y,Z] = meshgrid(x,x,x) 相同，并返回网格大小为 length(x)×length(x)×length(x) 的三维网格坐标。</p><h2 id="exp-x"><a href="#exp-x" class="headerlink" title="exp(x)"></a>exp(x)</h2><p>Y = exp(X) 为数组 X 中的每个元素返回指数 ex。 </p><h2 id="cylinder"><a href="#cylinder" class="headerlink" title="cylinder()"></a>cylinder()</h2><p>创建圆柱<br>[X,Y,Z] = cylinder 返回三个 2×21 矩阵，其中包含圆柱的 x、y 和 z 坐标，但不对其绘图。圆柱的半径为 1，圆周上有 20 个等间距点。底面平行于 xy 平面。</p><p>要绘制圆柱，请将 X、Y 和 Z 传递给 surf 或 mesh 函数。<br><a href="https://ww2.mathworks.cn/help/matlab/ref/cylinder.html?searchHighlight=cylinder&amp;s_tid=srchtitle_cylinder_1">https://ww2.mathworks.cn/help/matlab/ref/cylinder.html?searchHighlight=cylinder&amp;s_tid=srchtitle_cylinder_1</a></p><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://sm.ms/image/pstS2TFVXGEo71x&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://s2.loli.net/2022/01/17/pstS2TFVXGEo71x.jpg&quot; &gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;matlab笔记，备战美赛&lt;/p&gt;
&lt;p&gt;冲鸭！！！&lt;/p&gt;</summary>
    
    
    
    <category term="数据分析" scheme="http://akkaduilin.com/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
    <category term="matlab" scheme="http://akkaduilin.com/tags/matlab/"/>
    
  </entry>
  
  <entry>
    <title>前中后缀表达式</title>
    <link href="http://akkaduilin.com/2022/01/08/%E5%89%8D%E4%B8%AD%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://akkaduilin.com/2022/01/08/%E5%89%8D%E4%B8%AD%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2022-01-07T16:08:41.000Z</published>
    <updated>2022-01-08T03:52:55.608Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>栈的应用，四则运算表达式求值</p><span id="more"></span><h1 id="后缀表达式计算结果"><a href="#后缀表达式计算结果" class="headerlink" title="后缀表达式计算结果"></a>后缀表达式计算结果</h1><p>遍历每个数字和符号，遇到数字就进栈，遇到符号，将处于栈顶的两个数字出栈，运算后将结果进栈，直到得到最终结果</p><p>例：<br>   后缀表达式为：9 3 1 - 3 * + 10 2 / +</p><p>   规则为：从左到右遍历表达式的每个数字和符号，遇到是数字就进栈，遇到是符号，就将处于栈顶两个数字出栈，进行运算，运算结果进栈，一直到最终获得结果。</p><p>   a.初始化一个空栈。此栈用来对要运算的数字进行进出使用。</p><p>   b.后缀表达式中前三个是、都是数字，所以9 3 1 进栈。</p><p>   c.接下来是“-”，所以将栈中的1出栈作为减数，3出栈作为被减数，并运算3-1得到2，再讲2进栈。</p><p>   d.接着是数字3进栈。</p><p>   e.后面是“*”，也就意味着栈中3和2出栈，2与3相乘，得到6，并将6进栈。</p><p>   f.下面是“+”，所以栈中6和9出栈，9和6相加，得到15，将15进栈。</p><p>   g.接着是10和2两数字进栈。</p><p>   h.接下来是符号“/”，因此，栈顶的2与10出栈，10与2相除，得到5，将5进栈。</p><p>   i.最后一个是符号“+”，所以15与5出栈并相加，得到20，讲20进栈。</p><p>   j.结果是20出栈，栈变为空。</p><h1 id="中缀表达式转后缀表达式"><a href="#中缀表达式转后缀表达式" class="headerlink" title="中缀表达式转后缀表达式"></a>中缀表达式转后缀表达式</h1><p>遍历每个数字和符号，遇到数字就输出，若是符号则判断其与栈顶符号的优先级。是右括号或优先级不高于栈顶符号的则将栈顶元素依次出栈并输出，之后将当前符号进栈，直到得到最终结果</p><p>例：<br>　　以中缀表达式“9+（（3*2）+（3-1））/2”的转化为例介绍栈s1和栈s2的情况：</p><p>　　注：数字和符号的顺序是按在栈中的顺序排列的。</p><p>　　（1）遍历到字符“9”时：</p><p>　　　　栈s1：9 ；</p><p>　　　　栈s2：空 ；</p><p>　　（1）遍历到符号“+”时：</p><p>　　　　栈s1：9 ；</p><p>　　　　栈s2：+ ；</p><p>　　（1）遍历到符号“(”时：</p><p>　　　　栈s1：9 ；</p><p>　　　　栈s2：( + ；</p><p>　　（2）遍历到符号“(”时：</p><p>　　　　栈s1：9 ；</p><p>　　　　栈s2：( ( + ；</p><p>　　（3）遍历到字符“3”时：</p><p>　　　　栈s1：3 9 ；</p><p>　　　　栈s2：( ( +；</p><p>　　（4）遍历到符号“*”时：</p><p>　　　　栈s1：3 9 ；</p><p>　　　　栈s2：* ( ( + ；</p><p>　　（5）遍历到字符“2”时：</p><p>　　　　栈s1：2 3 9 ；</p><p>　　　　栈s2：* ( ( + ；</p><p>　　（6）遍历到符号“)”时：</p><p>　　　　栈s1：2 3 9 ；</p><p>　　　　栈s2：* ( ( + ；</p><p>　　　　此时开始比较，比较之后：</p><p>　　　　栈s1：* 2 3 9 ；</p><p>　　　　栈s2：( + ；</p><p>　　（7）遍历到符号“+”时：</p><p>　　　　栈s1：* 2 3 9 ；</p><p>　　　　栈s2：+ ( +；</p><p>　　（8）遍历到符号“(”时：</p><p>　　　　栈s1：* 2 3 9 ；</p><p>　　　　栈s2：( + ( + ；</p><p>　　（9）遍历到字符“3”时：</p><p>　　　　栈s1：3 * 2 3 9 ；</p><p>　　　　栈s2：( + ( + ；</p><p>　　（10）遍历到符号“-”时：</p><p>　　　　栈s1：3 * 2 3 9 ；</p><p>　　　　栈s2：- ( + ( + ；</p><p>　　（11）遍历到字符“1”时：</p><p>　　　　栈s1：1 3 * 2 3 9 ；</p><p>　　　　栈s2：- ( + ( + ；</p><p>　　（12）遍历到符号“)”时：</p><p>　　　　栈s1：1 3 * 2 3 9 ；</p><p>　　　　栈s2：- ( + ( + ；</p><p>　　　　此时开始比较，比较之后：</p><p>　　　　栈s1：- 1 3 * 2 3 9 ；</p><p>　　　　栈s2：+ ( +；</p><p>　　（13）遍历到符号“)”时：</p><p>　　　　栈s1：- 1 3 * 2 3 9 ；</p><p>　　　　栈s2：+ ( +；</p><p>　　　　此时开始比较，比较之后：</p><p>　　　　栈s1：+ - 1 3 * 2 3 9 ；</p><p>　　　　栈s2：+；</p><p>　　（14）遍历到符号“/”时：</p><p>　　　　栈s1：+ - 1 3 * 2 3 9 ；</p><p>　　　　栈s2：/ + ；</p><p>　　（15）遍历到字符“2”时：</p><p>　　　　栈s1：2 + - 1 3 * 2 3 9 ；</p><p>　　　　栈s2：/ + ；</p><p>　　（16）遍历结束，但栈s2中还有符号，所以将栈s2中的符号全部依次压入栈s1中，此时：</p><p>　　　　栈s1：+ / 2 + - 1 3 * 2 3 9 ；</p><p>　　　　栈s2：空；</p><p>　　　所以后缀表达式为：9 3 2 * 3 1 - + 2 / + ；</p><h1 id="xx3x"><a href="#xx3x" class="headerlink" title="xx3x"></a>xx3x</h1><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;栈的应用，四则运算表达式求值&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="http://akkaduilin.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="题解" scheme="http://akkaduilin.com/categories/%E7%BC%96%E7%A8%8B/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="C++" scheme="http://akkaduilin.com/tags/C/"/>
    
    <category term="栈" scheme="http://akkaduilin.com/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>字符串</title>
    <link href="http://akkaduilin.com/2022/01/07/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://akkaduilin.com/2022/01/07/%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2022-01-07T09:19:55.000Z</published>
    <updated>2022-03-08T12:32:53.126Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>串和简单模式匹配算法KMP算法</p><span id="more"></span><h1 id="字符串基本概念"><a href="#字符串基本概念" class="headerlink" title="字符串基本概念"></a>字符串基本概念</h1><p><a href="https://sm.ms/image/r348tomKAB6kvcN" target="_blank"><img src="https://s2.loli.net/2022/01/08/r348tomKAB6kvcN.jpg" ></a></p><h1 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h1><p>在查找字符串前先对查找字符串做一个分析</p><h2 id="求next数组"><a href="#求next数组" class="headerlink" title="求next数组"></a>求next数组</h2><p>转载自B站视频<br><a href="https://www.bilibili.com/video/BV1nF411e7gq?from=search&amp;seid=2280439246733213375&amp;spm_id_from=333.337.0.0">https://www.bilibili.com/video/BV1nF411e7gq?from=search&amp;seid=2280439246733213375&amp;spm_id_from=333.337.0.0</a></p><p><a href="https://sm.ms/image/UY2CGIdsinNZjXA" target="_blank"><img src="https://s2.loli.net/2022/01/08/UY2CGIdsinNZjXA.jpg" ></a></p><h2 id="nexval数组"><a href="#nexval数组" class="headerlink" title="nexval数组"></a>nexval数组</h2><p><a href="https://sm.ms/image/2DZzaKm4sRT35dc" target="_blank"><img src="https://s2.loli.net/2022/01/08/2DZzaKm4sRT35dc.jpg" ></a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/* 通过计算返回子串T的next数组。 */</span><br><span class="line">void get_next(String T, int *next) </span><br><span class="line">&#123;</span><br><span class="line">int i,k;</span><br><span class="line">  i=1;</span><br><span class="line">  k=0;</span><br><span class="line">  next[1]=0;</span><br><span class="line">  while (i&lt;T[0])  /* 此处T[0]表示串T的长度 */</span><br><span class="line"> &#123;</span><br><span class="line">    if(k==0 || T[i]== T[k]) </span><br><span class="line">&#123;</span><br><span class="line">      ++i;  </span><br><span class="line">++k;  </span><br><span class="line">next[i] = k;</span><br><span class="line">    &#125; </span><br><span class="line">else </span><br><span class="line">k= next[k];/* 若字符不相同，则k值回溯 */</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 返回子串T在主串S中第pos个字符之后的位置。若不存在，则函数返回值为0。 */</span><br><span class="line">/*  T非空，1≤pos≤StrLength(S)。 */</span><br><span class="line">int Index_KMP(String S, String T, int pos) </span><br><span class="line">&#123;</span><br><span class="line">int i = pos;/* i用于主串S中当前位置下标值，若pos不为1，则从pos位置开始匹配 */</span><br><span class="line">int j = 1;/* j用于子串T中当前位置下标值 */</span><br><span class="line">int next[255];/* 定义一next数组 */</span><br><span class="line">get_next(T, next);/* 对串T作分析，得到next数组 */</span><br><span class="line">while (i &lt;= S[0] &amp;&amp; j &lt;= T[0]) /* 若i小于S的长度并且j小于T的长度时，循环继续 */</span><br><span class="line">&#123;</span><br><span class="line">if (j==0 || S[i] == T[j]) /* 两字母相等则继续，与朴素算法增加了j=0判断 */</span><br><span class="line">      &#123;</span><br><span class="line">         ++i;</span><br><span class="line">         ++j; </span><br><span class="line">      &#125; </span><br><span class="line">      else /* 指针后退重新开始匹配 */</span><br><span class="line">       j = next[j];/* j退回合适的位置，i值不变 */</span><br><span class="line">&#125;</span><br><span class="line">if (j &gt; T[0]) </span><br><span class="line">return i-T[0];</span><br><span class="line">else </span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 求模式串T的next函数修正值并存入数组nextval */</span><br><span class="line">void get_nextval(String T, int *nextval) </span><br><span class="line">&#123;</span><br><span class="line">  int i,k;</span><br><span class="line">  i=1;</span><br><span class="line">  k=0;</span><br><span class="line">  nextval[1]=0;</span><br><span class="line">  while (i&lt;T[0])  /* 此处T[0]表示串T的长度 */</span><br><span class="line"> &#123;</span><br><span class="line">    if(k==0 || T[i]== T[k]) /* T[i]表示后缀的单个字符，T[k]表示前缀的单个字符 */</span><br><span class="line">&#123;</span><br><span class="line">      ++i;  </span><br><span class="line">++k;  </span><br><span class="line">if (T[i]!=T[k])      /* 若当前字符与前缀字符不同 */</span><br><span class="line">nextval[i] = k;/* 则当前的j为nextval在i位置的值 */</span><br><span class="line">      else </span><br><span class="line">nextval[i] = nextval[k];/* 如果与前缀字符相同，则将前缀字符的 */</span><br><span class="line">/* nextval值赋值给nextval在i位置的值 */</span><br><span class="line">    &#125; </span><br><span class="line">else </span><br><span class="line">k= nextval[k];/* 若字符不相同，则k值回溯 */</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Index_KMP1(String S, String T, int pos) </span><br><span class="line">&#123;</span><br><span class="line">int i = pos;/* i用于主串S中当前位置下标值，若pos不为1，则从pos位置开始匹配 */</span><br><span class="line">int j = 1;/* j用于子串T中当前位置下标值 */</span><br><span class="line">int next[255];/* 定义一next数组 */</span><br><span class="line">get_nextval(T, next);/* 对串T作分析，得到next数组 */</span><br><span class="line">while (i &lt;= S[0] &amp;&amp; j &lt;= T[0]) /* 若i小于S的长度并且j小于T的长度时，循环继续 */</span><br><span class="line">&#123;</span><br><span class="line">if (j==0 || S[i] == T[j]) /* 两字母相等则继续，与朴素算法增加了j=0判断 */</span><br><span class="line">      &#123;</span><br><span class="line">         ++i;</span><br><span class="line">         ++j; </span><br><span class="line">      &#125; </span><br><span class="line">      else /* 指针后退重新开始匹配 */</span><br><span class="line">       j = next[j];/* j退回合适的位置，i值不变 */</span><br><span class="line">&#125;</span><br><span class="line">if (j &gt; T[0]) </span><br><span class="line">return i-T[0];</span><br><span class="line">else </span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;串和简单模式匹配算法KMP算法&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="http://akkaduilin.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="数据结构" scheme="http://akkaduilin.com/categories/%E7%BC%96%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="字符串" scheme="http://akkaduilin.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="KMP" scheme="http://akkaduilin.com/tags/KMP/"/>
    
  </entry>
  
  <entry>
    <title>线性表</title>
    <link href="http://akkaduilin.com/2022/01/04/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <id>http://akkaduilin.com/2022/01/04/%E7%BA%BF%E6%80%A7%E8%A1%A8/</id>
    <published>2022-01-04T12:31:29.000Z</published>
    <updated>2022-01-07T09:16:30.679Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>总结一些线性表有关的知识点和代码<br>参考博客:<br><a href="https://blog.csdn.net/weixin_38984030/article/details/86076074">https://blog.csdn.net/weixin_38984030/article/details/86076074</a><br><a href="https://sm.ms/image/eaOZdNzFQPDE5hl" target="_blank"><img src="https://s2.loli.net/2022/01/07/eaOZdNzFQPDE5hl.jpg" ></a></p><span id="more"></span><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>线性表是最基本、最简单、也是最常用的一种数据结构。线性表（linear list）是数据结构的一种，一个线性表是n个具有相同特性的数据元素的有限序列。</p><p>特点：</p><p>1．集合中必存在唯一的一个“第一元素”。</p><p>2．集合中必存在唯一的一个 “最后元素” 。</p><p>3．除最后一个元素之外，均有唯一的后继(后件)。</p><p>4．除第一个元素之外，均有唯一的前驱(前件)。</p><p>线性表、包括顺序表和链表，顺序表里面元素的地址是连续的。链表里面节点的地址不是连续的，是通过指针连起来的。</p><h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><p>线性表除第一个元素外，每个元素有且仅有一个直接 前驱 ， 除最后一个元素外，每个元素有且仅有一个直接 后继 。</p><h2 id="顺序储存"><a href="#顺序储存" class="headerlink" title="顺序储存"></a>顺序储存</h2><p>占用一片连续的存储单元<br>数组实现<br>插入操作原理为将第i个元素及其后的所有元素右移一个位置，并在空的位置插入新元素<br><a href="https://sm.ms/image/qWOwAFaJUh6EumR" target="_blank"><img src="https://s2.loli.net/2022/01/07/qWOwAFaJUh6EumR.jpg" style="width:80%"></a><br>最坏时间复杂度为O(n)</p><h2 id="链式储存"><a href="#链式储存" class="headerlink" title="链式储存"></a>链式储存</h2><p><a href="https://sm.ms/image/qhQrPEnkX8IWeG2" target="_blank"><img src="https://s2.loli.net/2022/01/07/qhQrPEnkX8IWeG2.jpg" style="width:80%"></a><br>头指针和头结点<br>头节点数据域无信息，指针域指向线性表第一个元素，方便运算的实现<br>头指针来指示一个单链表，指向链表的第一个结点</p><p>插入/删除<br><a href="https://sm.ms/image/Vn6sfuehNIzb4Xv" target="_blank"><img src="https://s2.loli.net/2022/01/07/Vn6sfuehNIzb4Xv.jpg" style="width:80%"></a><br><a href="https://sm.ms/image/ZJb9WkBKsoXzTiE" target="_blank"><img src="https://s2.loli.net/2022/01/07/ZJb9WkBKsoXzTiE.jpg" style="width:80%"></a></p><h2 id="不引用新节点实现逆置"><a href="#不引用新节点实现逆置" class="headerlink" title="不引用新节点实现逆置"></a>不引用新节点实现逆置</h2><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void inversionList(LNode *L)&#123;</span><br><span class="line">LNode *p,*q;</span><br><span class="line">p = L-&gt;next;//记录节点信息 </span><br><span class="line">L-&gt;next = NULL;//将头结点置为空作为新的头节点</span><br><span class="line">//将链表中原有的元素作为新元素头插法插入到链表中 </span><br><span class="line">while(p != NULL)&#123;</span><br><span class="line">q = p-&gt;next;//q用来记录下一个节点信息 </span><br><span class="line">p-&gt;next = L-&gt;next;</span><br><span class="line">L-&gt;next = p;</span><br><span class="line">p = q;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h2><p>定义<br><a href="https://sm.ms/image/XbTEpZahBcMCfRt" target="_blank"><img src="https://s2.loli.net/2022/01/07/XbTEpZahBcMCfRt.jpg" style="width:80%"></a><br>插入删除<br><a href="https://sm.ms/image/j3LxdU6hsKwE2BZ" target="_blank"><img src="https://s2.loli.net/2022/01/07/j3LxdU6hsKwE2BZ.jpg" style="width:80%"></a></p><h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><p>每一个元素都有后继<br>最后一个结点的后继为头节点<br><a href="https://sm.ms/image/5NCF8SyT93ijn7X" target="_blank"><img src="https://s2.loli.net/2022/01/07/5NCF8SyT93ijn7X.jpg" style="width:80%"></a></p><h1 id="顺序储存结构代码"><a href="#顺序储存结构代码" class="headerlink" title="顺序储存结构代码"></a>顺序储存结构代码</h1><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#define MAXSIZE 20          /* 存储空间初始分配量 */</span><br><span class="line">typedef int ElemType;       /* ElemType类型根据实际情况而定，这里假设为int */</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    ElemType data[MAXSIZE]; /* 数组，存储数据元素 */</span><br><span class="line">    int length;             /* 线性表当前长度 */</span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line">typedef int Status;         /* Status是函数的类型,其值是函数结果状态代码，如OK等 */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Status visit(ElemType c)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;%d &quot;,c);</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 初始化顺序线性表 */</span><br><span class="line">Status InitList(SqList *L) </span><br><span class="line">&#123; </span><br><span class="line">    L-&gt;length=0;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 初始条件：顺序线性表L已存在。操作结果：若L为空表，则返回TRUE，否则返回FALSE */</span><br><span class="line">Status ListEmpty(SqList L)</span><br><span class="line">&#123; </span><br><span class="line">if(L.length==0)</span><br><span class="line">return TRUE;</span><br><span class="line">else</span><br><span class="line">return FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 初始条件：顺序线性表L已存在。操作结果：将L重置为空表 */</span><br><span class="line">Status ClearList(SqList *L)</span><br><span class="line">&#123; </span><br><span class="line">    L-&gt;length=0;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 初始条件：顺序线性表L已存在。操作结果：返回L中数据元素个数 */</span><br><span class="line">int ListLength(SqList L)</span><br><span class="line">&#123;</span><br><span class="line">return L.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) */</span><br><span class="line">/* 操作结果：用e返回L中第i个数据元素的值,注意i是指位置，第1个位置的数组是从0开始 */</span><br><span class="line">Status GetElem(SqList L,int i,ElemType *e)</span><br><span class="line">&#123;</span><br><span class="line">    if(L.length==0 || i&lt;1 || i&gt;L.length)</span><br><span class="line">            return ERROR;</span><br><span class="line">    *e=L.data[i-1];</span><br><span class="line"></span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 初始条件：顺序线性表L已存在 */</span><br><span class="line">/* 操作结果：返回L中第1个与e满足关系的数据元素的位序。 */</span><br><span class="line">/* 若这样的数据元素不存在，则返回值为0 */</span><br><span class="line">int LocateElem(SqList L,ElemType e)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    if (L.length==0)</span><br><span class="line">            return 0;</span><br><span class="line">    for(i=0;i&lt;L.length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">            if (L.data[i]==e)</span><br><span class="line">                    break;</span><br><span class="line">    &#125;</span><br><span class="line">    if(i&gt;=L.length)</span><br><span class="line">            return 0;</span><br><span class="line"></span><br><span class="line">    return i+1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* 初始条件：顺序线性表L已存在,1≤i≤ListLength(L)， */</span><br><span class="line">/* 操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1 */</span><br><span class="line">Status ListInsert(SqList *L,int i,ElemType e)</span><br><span class="line">&#123; </span><br><span class="line">int k;</span><br><span class="line">if (L-&gt;length==MAXSIZE)  /* 顺序线性表已经满 */</span><br><span class="line">return ERROR;</span><br><span class="line">if (i&lt;1 || i&gt;L-&gt;length+1)/* 当i比第一位置小或者比最后一位置后一位置还要大时 */</span><br><span class="line">return ERROR;</span><br><span class="line"></span><br><span class="line">if (i&lt;=L-&gt;length)        /* 若插入数据位置不在表尾 */</span><br><span class="line">&#123;</span><br><span class="line">for(k=L-&gt;length-1;k&gt;=i-1;k--)  /* 将要插入位置之后的数据元素向后移动一位 */</span><br><span class="line">L-&gt;data[k+1]=L-&gt;data[k];</span><br><span class="line">&#125;</span><br><span class="line">L-&gt;data[i-1]=e;          /* 将新元素插入 */</span><br><span class="line">L-&gt;length++;</span><br><span class="line"></span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) */</span><br><span class="line">/* 操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1 */</span><br><span class="line">Status ListDelete(SqList *L,int i,ElemType *e) </span><br><span class="line">&#123; </span><br><span class="line">    int k;</span><br><span class="line">    if (L-&gt;length==0)               /* 线性表为空 */</span><br><span class="line">return ERROR;</span><br><span class="line">    if (i&lt;1 || i&gt;L-&gt;length)         /* 删除位置不正确 */</span><br><span class="line">        return ERROR;</span><br><span class="line">    *e=L-&gt;data[i-1];</span><br><span class="line">    if (i&lt;L-&gt;length)                /* 如果删除不是最后位置 */</span><br><span class="line">    &#123;</span><br><span class="line">        for(k=i;k&lt;L-&gt;length;k++)/* 将删除位置后继元素前移 */</span><br><span class="line">L-&gt;data[k-1]=L-&gt;data[k];</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;length--;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 初始条件：顺序线性表L已存在 */</span><br><span class="line">/* 操作结果：依次对L的每个数据元素输出 */</span><br><span class="line">Status ListTraverse(SqList L)</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">    for(i=0;i&lt;L.length;i++)</span><br><span class="line">            visit(L.data[i]);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*将所有的在线性表Lb中但不在La中的数据元素插入到La中*/</span><br><span class="line">void unionL(SqList *La,SqList Lb)</span><br><span class="line">&#123;</span><br><span class="line">int La_len,Lb_len,i;</span><br><span class="line">ElemType e;                        /*声明与La和Lb相同的数据元素e*/</span><br><span class="line">La_len=ListLength(*La);            /*求线性表的长度 */</span><br><span class="line">Lb_len=ListLength(Lb);</span><br><span class="line">for (i=1;i&lt;=Lb_len;i++)</span><br><span class="line">&#123;</span><br><span class="line">GetElem(Lb,i,&amp;e);              /*取Lb中第i个数据元素赋给e*/</span><br><span class="line">if (!LocateElem(*La,e))        /*La中不存在和e相同数据元素*/</span><br><span class="line">ListInsert(La,++La_len,e); /*插入*/</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="链式储存结构"><a href="#链式储存结构" class="headerlink" title="链式储存结构"></a>链式储存结构</h1><h2 id="单链表代码"><a href="#单链表代码" class="headerlink" title="单链表代码"></a>单链表代码</h2><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#define MAXSIZE 20 /* 存储空间初始分配量 */</span><br><span class="line"></span><br><span class="line">typedef int Status;/* Status是函数的类型,其值是函数结果状态代码，如OK等 */</span><br><span class="line">typedef int ElemType;/* ElemType类型根据实际情况而定，这里假设为int */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Status visit(ElemType c)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;%d &quot;,c);</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">typedef struct Node</span><br><span class="line">&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    struct Node *next;</span><br><span class="line">&#125;Node;</span><br><span class="line">typedef struct Node *LinkList; /* 定义LinkList */</span><br><span class="line"></span><br><span class="line">/* 初始化链式线性表 */</span><br><span class="line">Status InitList(LinkList *L) </span><br><span class="line">&#123; </span><br><span class="line">    *L=(LinkList)malloc(sizeof(Node)); /* 产生头结点,并使L指向此头结点 */</span><br><span class="line">    if(!(*L)) /* 存储分配失败 */</span><br><span class="line">            return ERROR;</span><br><span class="line">    (*L)-&gt;next=NULL; /* 指针域为空 */</span><br><span class="line"></span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 初始条件：链式线性表L已存在。操作结果：若L为空表，则返回TRUE，否则返回FALSE */</span><br><span class="line">Status ListEmpty(LinkList L)</span><br><span class="line">&#123; </span><br><span class="line">    if(L-&gt;next)</span><br><span class="line">            return FALSE;</span><br><span class="line">    else</span><br><span class="line">            return TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 初始条件：链式线性表L已存在。操作结果：将L重置为空表 */</span><br><span class="line">Status ClearList(LinkList *L)</span><br><span class="line">&#123; </span><br><span class="line">LinkList p,q;</span><br><span class="line">p=(*L)-&gt;next;           /*  p指向第一个结点 */</span><br><span class="line">while(p)                /*  没到表尾 */</span><br><span class="line">&#123;</span><br><span class="line">q=p-&gt;next;</span><br><span class="line">free(p);</span><br><span class="line">p=q;</span><br><span class="line">&#125;</span><br><span class="line">(*L)-&gt;next=NULL;        /* 头结点指针域为空 */</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 初始条件：链式线性表L已存在。操作结果：返回L中数据元素个数 */</span><br><span class="line">int ListLength(LinkList L)</span><br><span class="line">&#123;</span><br><span class="line">    int i=0;</span><br><span class="line">    LinkList p=L-&gt;next; /* p指向第一个结点 */</span><br><span class="line">    while(p)                        </span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 初始条件：链式线性表L已存在，1≤i≤ListLength(L) */</span><br><span class="line">/* 操作结果：用e返回L中第i个数据元素的值 */</span><br><span class="line">Status GetElem(LinkList L,int i,ElemType *e)</span><br><span class="line">&#123;</span><br><span class="line">int j;</span><br><span class="line">LinkList p;/* 声明一结点p */</span><br><span class="line">p = L-&gt;next;/* 让p指向链表L的第一个结点 */</span><br><span class="line">j = 1;/*  j为计数器 */</span><br><span class="line">while (p &amp;&amp; j&lt;i)  /* p不为空或者计数器j还没有等于i时，循环继续 */</span><br><span class="line">&#123;   </span><br><span class="line">p = p-&gt;next;  /* 让p指向下一个结点 */</span><br><span class="line">++j;</span><br><span class="line">&#125;</span><br><span class="line">if ( !p || j&gt;i ) </span><br><span class="line">return ERROR;  /*  第i个元素不存在 */</span><br><span class="line">*e = p-&gt;data;   /*  取第i个元素的数据 */</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 初始条件：链式线性表L已存在 */</span><br><span class="line">/* 操作结果：返回L中第1个与e满足关系的数据元素的位序。 */</span><br><span class="line">/* 若这样的数据元素不存在，则返回值为0 */</span><br><span class="line">int LocateElem(LinkList L,ElemType e)</span><br><span class="line">&#123;</span><br><span class="line">    int i=0;</span><br><span class="line">    LinkList p=L-&gt;next;</span><br><span class="line">    while(p)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">        if(p-&gt;data==e) /* 找到这样的数据元素 */</span><br><span class="line">                return i;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* 初始条件：链式线性表L已存在,1≤i≤ListLength(L)， */</span><br><span class="line">/* 操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1 */</span><br><span class="line">Status ListInsert(LinkList *L,int i,ElemType e)</span><br><span class="line">&#123; </span><br><span class="line">int j;</span><br><span class="line">LinkList p,s;</span><br><span class="line">p = *L;   </span><br><span class="line">j = 1;</span><br><span class="line">while (p &amp;&amp; j &lt; i)     /* 寻找第i个结点 */</span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">++j;</span><br><span class="line">&#125; </span><br><span class="line">if (!p || j &gt; i) </span><br><span class="line">return ERROR;   /* 第i个元素不存在 */</span><br><span class="line">s = (LinkList)malloc(sizeof(Node));  /*  生成新结点(C语言标准函数) */</span><br><span class="line">s-&gt;data = e;  </span><br><span class="line">s-&gt;next = p-&gt;next;      /* 将p的后继结点赋值给s的后继  */</span><br><span class="line">p-&gt;next = s;          /* 将s赋值给p的后继 */</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 初始条件：链式线性表L已存在，1≤i≤ListLength(L) */</span><br><span class="line">/* 操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1 */</span><br><span class="line">Status ListDelete(LinkList *L,int i,ElemType *e) </span><br><span class="line">&#123; </span><br><span class="line">int j;</span><br><span class="line">LinkList p,q;</span><br><span class="line">p = *L;</span><br><span class="line">j = 1;</span><br><span class="line">while (p-&gt;next &amp;&amp; j &lt; i)/* 遍历寻找第i个元素 */</span><br><span class="line">&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        ++j;</span><br><span class="line">&#125;</span><br><span class="line">if (!(p-&gt;next) || j &gt; i) </span><br><span class="line">    return ERROR;           /* 第i个元素不存在 */</span><br><span class="line">q = p-&gt;next;</span><br><span class="line">p-&gt;next = q-&gt;next;/* 将q的后继赋值给p的后继 */</span><br><span class="line">*e = q-&gt;data;               /* 将q结点中的数据给e */</span><br><span class="line">free(q);                    /* 让系统回收此结点，释放内存 */</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 初始条件：链式线性表L已存在 */</span><br><span class="line">/* 操作结果：依次对L的每个数据元素输出 */</span><br><span class="line">Status ListTraverse(LinkList L)</span><br><span class="line">&#123;</span><br><span class="line">    LinkList p=L-&gt;next;</span><br><span class="line">    while(p)</span><br><span class="line">    &#123;</span><br><span class="line">        visit(p-&gt;data);</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*  随机产生n个元素的值，建立带表头结点的单链线性表L（头插法） */</span><br><span class="line">void CreateListHead(LinkList *L, int n) </span><br><span class="line">&#123;</span><br><span class="line">LinkList p;</span><br><span class="line">int i;</span><br><span class="line">srand(time(0));                         /* 初始化随机数种子 */</span><br><span class="line">*L = (LinkList)malloc(sizeof(Node));</span><br><span class="line">(*L)-&gt;next = NULL;                      /*  先建立一个带头结点的单链表 */</span><br><span class="line">for (i=0; i&lt;n; i++) </span><br><span class="line">&#123;</span><br><span class="line">p = (LinkList)malloc(sizeof(Node)); /*  生成新结点 */</span><br><span class="line">p-&gt;data = rand()%100+1;             /*  随机生成100以内的数字 */</span><br><span class="line">p-&gt;next = (*L)-&gt;next;    </span><br><span class="line">(*L)-&gt;next = p;/*  插入到表头 */</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*  随机产生n个元素的值，建立带表头结点的单链线性表L（尾插法） */</span><br><span class="line">void CreateListTail(LinkList *L, int n) </span><br><span class="line">&#123;</span><br><span class="line">LinkList p,r;</span><br><span class="line">int i;</span><br><span class="line">srand(time(0));                      /* 初始化随机数种子 */</span><br><span class="line">*L = (LinkList)malloc(sizeof(Node)); /* L为整个线性表 */</span><br><span class="line">r=*L;                                /* r为指向尾部的结点 */</span><br><span class="line">for (i=0; i&lt;n; i++) </span><br><span class="line">&#123;</span><br><span class="line">p = (Node *)malloc(sizeof(Node)); /*  生成新结点 */</span><br><span class="line">p-&gt;data = rand()%100+1;           /*  随机生成100以内的数字 */</span><br><span class="line">r-&gt;next=p;                        /* 将表尾终端结点的指针指向新结点 */</span><br><span class="line">r = p;                            /* 将当前的新结点定义为表尾终端结点 */</span><br><span class="line">&#125;</span><br><span class="line">r-&gt;next = NULL;                       /* 表示当前链表结束 */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;总结一些线性表有关的知识点和代码&lt;br&gt;参考博客:&lt;br&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_38984030/article/details/86076074&quot;&gt;https://blog.csdn.net/weixin_38984030/article/details/86076074&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://sm.ms/image/eaOZdNzFQPDE5hl&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://s2.loli.net/2022/01/07/eaOZdNzFQPDE5hl.jpg&quot; &gt;&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="http://akkaduilin.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="数据结构" scheme="http://akkaduilin.com/categories/%E7%BC%96%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="C++" scheme="http://akkaduilin.com/tags/C/"/>
    
    <category term="线性表" scheme="http://akkaduilin.com/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>栈和队列</title>
    <link href="http://akkaduilin.com/2022/01/04/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <id>http://akkaduilin.com/2022/01/04/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</id>
    <published>2022-01-04T12:27:51.000Z</published>
    <updated>2022-01-07T15:36:42.500Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>栈与队列<br>期末秃头人限定<br><a href="https://sm.ms/image/Yd5sbtuagm9RUSA" target="_blank"><img src="https://s2.loli.net/2022/01/07/Yd5sbtuagm9RUSA.jpg"  style="width:80%"></a></p><span id="more"></span><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>栈是只允许在一端进行插入或删除的线性表。</strong><br><strong>先进后出</strong></p><h2 id="储存结构"><a href="#储存结构" class="headerlink" title="储存结构"></a>储存结构</h2><p><strong>先移动指针再入栈</strong><br><strong>先出栈再移动指针</strong></p><h3 id="顺序储存"><a href="#顺序储存" class="headerlink" title="顺序储存"></a>顺序储存</h3><p><strong>利用一组地址连续的储存单元存放自栈底到栈顶的数据元素</strong><br><strong>附设一个top指针指向栈顶元素</strong></p><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#define OK 1</span><br><span class="line">#define ERROR 0</span><br><span class="line">#define TRUE 1</span><br><span class="line">#define FALSE 0</span><br><span class="line">#define MAXSIZE 20 /* 存储空间初始分配量 */</span><br><span class="line"></span><br><span class="line">typedef int Status; </span><br><span class="line">typedef int SElemType; /* SElemType类型根据实际情况而定，这里假设为int */</span><br><span class="line"></span><br><span class="line">/* 顺序栈结构 */</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">        SElemType data[MAXSIZE];</span><br><span class="line">        int top; /* 用于栈顶指针 */</span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line">Status visit(SElemType c)</span><br><span class="line">&#123;</span><br><span class="line">        printf(&quot;%d &quot;,c);</span><br><span class="line">        return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*  构造一个空栈S */</span><br><span class="line">Status InitStack(SqStack *S)</span><br><span class="line">&#123; </span><br><span class="line">        /* S.data=(SElemType *)malloc(MAXSIZE*sizeof(SElemType)); */</span><br><span class="line">        S-&gt;top=-1;</span><br><span class="line">        return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 把S置为空栈 */</span><br><span class="line">Status ClearStack(SqStack *S)</span><br><span class="line">&#123; </span><br><span class="line">        S-&gt;top=-1;</span><br><span class="line">        return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 若栈S为空栈，则返回TRUE，否则返回FALSE */</span><br><span class="line">Status StackEmpty(SqStack S)</span><br><span class="line">&#123; </span><br><span class="line">        if (S.top==-1)</span><br><span class="line">                return TRUE;</span><br><span class="line">        else</span><br><span class="line">                return FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 返回S的元素个数，即栈的长度 */</span><br><span class="line">int StackLength(SqStack S)</span><br><span class="line">&#123; </span><br><span class="line">        return S.top+1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 若栈不空，则用e返回S的栈顶元素，并返回OK；否则返回ERROR */</span><br><span class="line">Status GetTop(SqStack S,SElemType *e)</span><br><span class="line">&#123;</span><br><span class="line">        if (S.top==-1)</span><br><span class="line">                return ERROR;</span><br><span class="line">        else</span><br><span class="line">                *e=S.data[S.top];</span><br><span class="line">        return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 插入元素e为新的栈顶元素 */</span><br><span class="line">Status Push(SqStack *S,SElemType e)</span><br><span class="line">&#123;</span><br><span class="line">        if(S-&gt;top == MAXSIZE -1) /* 栈满 */</span><br><span class="line">        &#123;</span><br><span class="line">                return ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">        S-&gt;top++;/* 栈顶指针增加一 */</span><br><span class="line">        S-&gt;data[S-&gt;top]=e;  /* 将新插入元素赋值给栈顶空间 */</span><br><span class="line">        return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR */</span><br><span class="line">Status Pop(SqStack *S,SElemType *e)</span><br><span class="line">&#123; </span><br><span class="line">        if(S-&gt;top==-1)</span><br><span class="line">                return ERROR;</span><br><span class="line">        *e=S-&gt;data[S-&gt;top];/* 将要删除的栈顶元素赋值给e */</span><br><span class="line">        S-&gt;top--;/* 栈顶指针减一 */</span><br><span class="line">        return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 从栈底到栈顶依次对栈中每个元素显示 */</span><br><span class="line">Status StackTraverse(SqStack S)</span><br><span class="line">&#123;</span><br><span class="line">        int i;</span><br><span class="line">        i=0;</span><br><span class="line">        while(i&lt;=S.top)</span><br><span class="line">        &#123;</span><br><span class="line">                visit(S.data[i++]);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">        return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="链式储存"><a href="#链式储存" class="headerlink" title="链式储存"></a>链式储存</h3><p><strong>单链表实现</strong><br><strong>规定所有操作都是在栈顶实现</strong></p><p>没有头结点</p><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">#define OK 1</span><br><span class="line">#define ERROR 0</span><br><span class="line">#define TRUE 1</span><br><span class="line">#define FALSE 0</span><br><span class="line">#define MAXSIZE 20 /* 存储空间初始分配量 */</span><br><span class="line"></span><br><span class="line">typedef int Status; </span><br><span class="line">typedef int SElemType; /* SElemType类型根据实际情况而定，这里假设为int */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* 链栈结构 */</span><br><span class="line">typedef struct StackNode</span><br><span class="line">&#123;</span><br><span class="line">        SElemType data;</span><br><span class="line">        struct StackNode *next;</span><br><span class="line">&#125;StackNode,*LinkStackPtr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">        LinkStackPtr top;</span><br><span class="line">        int count;</span><br><span class="line">&#125;LinkStack;</span><br><span class="line"></span><br><span class="line">Status visit(SElemType c)</span><br><span class="line">&#123;</span><br><span class="line">        printf(&quot;%d &quot;,c);</span><br><span class="line">        return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*  构造一个空栈S */</span><br><span class="line">Status InitStack(LinkStack *S)</span><br><span class="line">&#123; </span><br><span class="line">        S-&gt;top = (LinkStackPtr)malloc(sizeof(StackNode));</span><br><span class="line">        if(!S-&gt;top)</span><br><span class="line">                return ERROR;</span><br><span class="line">        S-&gt;top=NULL;</span><br><span class="line">        S-&gt;count=0;</span><br><span class="line">        return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 把S置为空栈 */</span><br><span class="line">Status ClearStack(LinkStack *S)</span><br><span class="line">&#123; </span><br><span class="line">        LinkStackPtr p,q;</span><br><span class="line">        p=S-&gt;top;</span><br><span class="line">        while(p)</span><br><span class="line">        &#123;  </span><br><span class="line">                q=p;</span><br><span class="line">                p=p-&gt;next;</span><br><span class="line">                free(q);</span><br><span class="line">        &#125; </span><br><span class="line">        S-&gt;count=0;</span><br><span class="line">        return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 若栈S为空栈，则返回TRUE，否则返回FALSE */</span><br><span class="line">Status StackEmpty(LinkStack S)</span><br><span class="line">&#123; </span><br><span class="line">        if (S.count==0)</span><br><span class="line">                return TRUE;</span><br><span class="line">        else</span><br><span class="line">                return FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 返回S的元素个数，即栈的长度 */</span><br><span class="line">int StackLength(LinkStack S)</span><br><span class="line">&#123; </span><br><span class="line">        return S.count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 若栈不空，则用e返回S的栈顶元素，并返回OK；否则返回ERROR */</span><br><span class="line">Status GetTop(LinkStack S,SElemType *e)</span><br><span class="line">&#123;</span><br><span class="line">        if (S.top==NULL)</span><br><span class="line">                return ERROR;</span><br><span class="line">        else</span><br><span class="line">                *e=S.top-&gt;data;</span><br><span class="line">        return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 插入元素e为新的栈顶元素 */</span><br><span class="line">Status Push(LinkStack *S,SElemType e)</span><br><span class="line">&#123;</span><br><span class="line">        LinkStackPtr s=(LinkStackPtr)malloc(sizeof(StackNode)); </span><br><span class="line">        s-&gt;data=e; </span><br><span class="line">        s-&gt;next=S-&gt;top;/* 把当前的栈顶元素赋值给新结点的直接后继，见图中① */</span><br><span class="line">        S-&gt;top=s;         /* 将新的结点s赋值给栈顶指针，见图中② */</span><br><span class="line">        S-&gt;count++;</span><br><span class="line">        return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR */</span><br><span class="line">Status Pop(LinkStack *S,SElemType *e)</span><br><span class="line">&#123; </span><br><span class="line">        LinkStackPtr p;</span><br><span class="line">        if(StackEmpty(*S))</span><br><span class="line">                return ERROR;</span><br><span class="line">        *e=S-&gt;top-&gt;data;</span><br><span class="line">        p=S-&gt;top;/* 将栈顶结点赋值给p，见图中③ */</span><br><span class="line">        S-&gt;top=S-&gt;top-&gt;next;    /* 使得栈顶指针下移一位，指向后一结点，见图中④ */</span><br><span class="line">        free(p);                    /* 释放结点p */        </span><br><span class="line">        S-&gt;count--;</span><br><span class="line">        return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Status StackTraverse(LinkStack S)</span><br><span class="line">&#123;</span><br><span class="line">        LinkStackPtr p;</span><br><span class="line">        p=S.top;</span><br><span class="line">        while(p)</span><br><span class="line">        &#123;</span><br><span class="line">                 visit(p-&gt;data);</span><br><span class="line">                 p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">        return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="共享栈"><a href="#共享栈" class="headerlink" title="共享栈"></a>共享栈</h2><p><a href="https://sm.ms/image/7aPM3FTuXfAI1JH" target="_blank"><img src="https://s2.loli.net/2022/01/07/7aPM3FTuXfAI1JH.jpg" ></a></p><h2 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h2><p>数据逆置算法、括号匹配的判断、后缀表达式求值算法</p><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p><strong>在表的一端经行输入，在另一端经行输出</strong></p><h2 id="储存结构-1"><a href="#储存结构-1" class="headerlink" title="储存结构"></a>储存结构</h2><h3 id="顺序储存-1"><a href="#顺序储存-1" class="headerlink" title="顺序储存"></a>顺序储存</h3><p><strong>分配一块连续的储存空间</strong><br><strong>两个指针一个指向指向队头(front),一个指向队尾(rear)</strong></p><p>入栈操作<br><strong>队不满时，先送值到队尾，再将队尾指针加1</strong></p><p>出栈操作<br><strong>队不空时，先取队头元素，在将队头指针加1</strong></p><p>队空条件<br><strong>Q.front == Q.rear == 0</strong></p><h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p><a href="https://sm.ms/image/qkyF3WwiMEUSGfJ" target="_blank"><img src="https://s2.loli.net/2022/01/07/qkyF3WwiMEUSGfJ.jpg" ></a></p><p>代码:</p><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#define OK 1</span><br><span class="line">#define ERROR 0</span><br><span class="line">#define TRUE 1</span><br><span class="line">#define FALSE 0</span><br><span class="line">#define MAXSIZE 20 /* 存储空间初始分配量 */</span><br><span class="line"></span><br><span class="line">typedef int Status; </span><br><span class="line">typedef int QElemType; /* QElemType类型根据实际情况而定，这里假设为int */</span><br><span class="line"></span><br><span class="line">/* 循环队列的顺序存储结构 */</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">QElemType data[MAXSIZE];</span><br><span class="line">int front;    /* 头指针 */</span><br><span class="line">int rear;/* 尾指针，若队列不空，指向队列尾元素的下一个位置 */</span><br><span class="line">&#125;SqQueue;</span><br><span class="line"></span><br><span class="line">Status visit(QElemType c)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d &quot;,c);</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 初始化一个空队列Q */</span><br><span class="line">Status InitQueue(SqQueue *Q)</span><br><span class="line">&#123;</span><br><span class="line">Q-&gt;front=0;</span><br><span class="line">Q-&gt;rear=0;</span><br><span class="line">return  OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 将Q清为空队列 */</span><br><span class="line">Status ClearQueue(SqQueue *Q)</span><br><span class="line">&#123;</span><br><span class="line">Q-&gt;front=Q-&gt;rear=0;</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 若队列Q为空队列,则返回TRUE,否则返回FALSE */</span><br><span class="line">Status QueueEmpty(SqQueue Q)</span><br><span class="line">&#123; </span><br><span class="line">if(Q.front==Q.rear) /* 队列空的标志 */</span><br><span class="line">return TRUE;</span><br><span class="line">else</span><br><span class="line">return FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 返回Q的元素个数，也就是队列的当前长度 */</span><br><span class="line">int QueueLength(SqQueue Q)</span><br><span class="line">&#123;</span><br><span class="line">return  (Q.rear-Q.front+MAXSIZE)%MAXSIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 若队列不空,则用e返回Q的队头元素,并返回OK,否则返回ERROR */</span><br><span class="line">Status GetHead(SqQueue Q,QElemType *e)</span><br><span class="line">&#123;</span><br><span class="line">if(Q.front==Q.rear) /* 队列空 */</span><br><span class="line">return ERROR;</span><br><span class="line">*e=Q.data[Q.front];</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 若队列未满，则插入元素e为Q新的队尾元素 */</span><br><span class="line">Status EnQueue(SqQueue *Q,QElemType e)</span><br><span class="line">&#123;</span><br><span class="line">if ((Q-&gt;rear+1)%MAXSIZE == Q-&gt;front)/* 队列满的判断 */</span><br><span class="line">return ERROR;</span><br><span class="line">Q-&gt;data[Q-&gt;rear]=e;/* 将元素e赋值给队尾 */</span><br><span class="line">Q-&gt;rear=(Q-&gt;rear+1)%MAXSIZE;/* rear指针向后移一位置， */</span><br><span class="line">/* 若到最后则转到数组头部 */</span><br><span class="line">return  OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 若队列不空，则删除Q中队头元素，用e返回其值 */</span><br><span class="line">Status DeQueue(SqQueue *Q,QElemType *e)</span><br><span class="line">&#123;</span><br><span class="line">if (Q-&gt;front == Q-&gt;rear)/* 队列空的判断 */</span><br><span class="line">return ERROR;</span><br><span class="line">*e=Q-&gt;data[Q-&gt;front];/* 将队头元素赋值给e */</span><br><span class="line">Q-&gt;front=(Q-&gt;front+1)%MAXSIZE;/* front指针向后移一位置， */</span><br><span class="line">/* 若到最后则转到数组头部 */</span><br><span class="line">return  OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 从队头到队尾依次对队列Q中每个元素输出 */</span><br><span class="line">Status QueueTraverse(SqQueue Q)</span><br><span class="line">&#123; </span><br><span class="line">int i;</span><br><span class="line">i=Q.front;</span><br><span class="line">while((i+Q.front)!=Q.rear)</span><br><span class="line">&#123;</span><br><span class="line">visit(Q.data[i]);</span><br><span class="line">i=(i+1)%MAXSIZE;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链式储存-1"><a href="#链式储存-1" class="headerlink" title="链式储存"></a>链式储存</h3><p><strong>同时带有队头指针和队尾指针的单链表</strong></p><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#define OK 1</span><br><span class="line">#define ERROR 0</span><br><span class="line">#define TRUE 1</span><br><span class="line">#define FALSE 0</span><br><span class="line">#define MAXSIZE 20 /* 存储空间初始分配量 */</span><br><span class="line"></span><br><span class="line">typedef int Status; </span><br><span class="line"></span><br><span class="line">typedef int QElemType; /* QElemType类型根据实际情况而定，这里假设为int */</span><br><span class="line"></span><br><span class="line">typedef struct QNode/* 结点结构 */</span><br><span class="line">&#123;</span><br><span class="line">   QElemType data;</span><br><span class="line">   struct QNode *next;</span><br><span class="line">&#125;QNode,*QueuePtr;</span><br><span class="line"></span><br><span class="line">typedef struct/* 队列的链表结构 */</span><br><span class="line">&#123;</span><br><span class="line">   QueuePtr front,rear; /* 队头、队尾指针 */</span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br><span class="line">Status visit(QElemType c)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d &quot;,c);</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 构造一个空队列Q */</span><br><span class="line">Status InitQueue(LinkQueue *Q)</span><br><span class="line">&#123; </span><br><span class="line">Q-&gt;front=Q-&gt;rear=(QueuePtr)malloc(sizeof(QNode));</span><br><span class="line">if(!Q-&gt;front)</span><br><span class="line">exit(OVERFLOW);</span><br><span class="line">Q-&gt;front-&gt;next=NULL;</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 销毁队列Q */</span><br><span class="line">Status DestroyQueue(LinkQueue *Q)</span><br><span class="line">&#123;</span><br><span class="line">while(Q-&gt;front)</span><br><span class="line">&#123;</span><br><span class="line"> Q-&gt;rear=Q-&gt;front-&gt;next;</span><br><span class="line"> free(Q-&gt;front);</span><br><span class="line"> Q-&gt;front=Q-&gt;rear;</span><br><span class="line">&#125;</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 将Q清为空队列 */</span><br><span class="line">Status ClearQueue(LinkQueue *Q)</span><br><span class="line">&#123;</span><br><span class="line">QueuePtr p,q;</span><br><span class="line">Q-&gt;rear=Q-&gt;front;</span><br><span class="line">p=Q-&gt;front-&gt;next;</span><br><span class="line">Q-&gt;front-&gt;next=NULL;</span><br><span class="line">while(p)</span><br><span class="line">&#123;</span><br><span class="line"> q=p;</span><br><span class="line"> p=p-&gt;next;</span><br><span class="line"> free(q);</span><br><span class="line">&#125;</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 若Q为空队列,则返回TRUE,否则返回FALSE */</span><br><span class="line">Status QueueEmpty(LinkQueue Q)</span><br><span class="line">&#123; </span><br><span class="line">if(Q.front==Q.rear)</span><br><span class="line">return TRUE;</span><br><span class="line">else</span><br><span class="line">return FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 求队列的长度 */</span><br><span class="line">int QueueLength(LinkQueue Q)</span><br><span class="line">&#123; </span><br><span class="line">int i=0;</span><br><span class="line">QueuePtr p;</span><br><span class="line">p=Q.front;</span><br><span class="line">while(Q.rear!=p)</span><br><span class="line">&#123;</span><br><span class="line"> i++;</span><br><span class="line"> p=p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">return i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 若队列不空,则用e返回Q的队头元素,并返回OK,否则返回ERROR */</span><br><span class="line">Status GetHead(LinkQueue Q,QElemType *e)</span><br><span class="line">&#123; </span><br><span class="line">QueuePtr p;</span><br><span class="line">if(Q.front==Q.rear)</span><br><span class="line">return ERROR;</span><br><span class="line">p=Q.front-&gt;next;</span><br><span class="line">*e=p-&gt;data;</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* 插入元素e为Q的新的队尾元素 */</span><br><span class="line">Status EnQueue(LinkQueue *Q,QElemType e)</span><br><span class="line">&#123; </span><br><span class="line">QueuePtr s=(QueuePtr)malloc(sizeof(QNode));</span><br><span class="line">if(!s) /* 存储分配失败 */</span><br><span class="line">exit(OVERFLOW);</span><br><span class="line">s-&gt;data=e;</span><br><span class="line">s-&gt;next=NULL;</span><br><span class="line">Q-&gt;rear-&gt;next=s;/* 把拥有元素e的新结点s赋值给原队尾结点的后继，见图中① */</span><br><span class="line">Q-&gt;rear=s;/* 把当前的s设置为队尾结点，rear指向s，见图中② */</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 若队列不空,删除Q的队头元素,用e返回其值,并返回OK,否则返回ERROR */</span><br><span class="line">Status DeQueue(LinkQueue *Q,QElemType *e)</span><br><span class="line">&#123;</span><br><span class="line">QueuePtr p;</span><br><span class="line">if(Q-&gt;front==Q-&gt;rear)</span><br><span class="line">return ERROR;</span><br><span class="line">p=Q-&gt;front-&gt;next;/* 将欲删除的队头结点暂存给p，见图中① */</span><br><span class="line">*e=p-&gt;data;/* 将欲删除的队头结点的值赋值给e */</span><br><span class="line">Q-&gt;front-&gt;next=p-&gt;next;/* 将原队头结点的后继p-&gt;next赋值给头结点后继，见图中② */</span><br><span class="line">if(Q-&gt;rear==p)/* 若队头就是队尾，则删除后将rear指向头结点，见图中③ */</span><br><span class="line">Q-&gt;rear=Q-&gt;front;</span><br><span class="line">free(p);</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 从队头到队尾依次对队列Q中每个元素输出 */</span><br><span class="line">Status QueueTraverse(LinkQueue Q)</span><br><span class="line">&#123;</span><br><span class="line">QueuePtr p;</span><br><span class="line">p=Q.front-&gt;next;</span><br><span class="line">while(p)</span><br><span class="line">&#123;</span><br><span class="line"> visit(p-&gt;data);</span><br><span class="line"> p=p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;栈与队列&lt;br&gt;期末秃头人限定&lt;br&gt;&lt;a href=&quot;https://sm.ms/image/Yd5sbtuagm9RUSA&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://s2.loli.net/2022/01/07/Yd5sbtuagm9RUSA.jpg&quot;  style=&quot;width:80%&quot;&gt;&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="http://akkaduilin.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="数据结构" scheme="http://akkaduilin.com/categories/%E7%BC%96%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="C++" scheme="http://akkaduilin.com/tags/C/"/>
    
    <category term="栈" scheme="http://akkaduilin.com/tags/%E6%A0%88/"/>
    
    <category term="队列" scheme="http://akkaduilin.com/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>不正经的2021总结</title>
    <link href="http://akkaduilin.com/2021/12/31/2021%E6%80%BB%E7%BB%93/"/>
    <id>http://akkaduilin.com/2021/12/31/2021%E6%80%BB%E7%BB%93/</id>
    <published>2021-12-31T04:18:37.000Z</published>
    <updated>2021-12-31T07:06:09.110Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://sm.ms/image/ghyrXm5CScL4RJN" target="_blank"><img src="https://s2.loli.net/2021/12/31/ghyrXm5CScL4RJN.jpg" ></a></p><p><strong>前言</strong></p><p>这是一篇不太正经的年度总结呢！</p><span id="more"></span><h1 id="很喜欢的一张画"><a href="#很喜欢的一张画" class="headerlink" title="很喜欢的一张画"></a>很喜欢的一张画</h1><p><a href="https://sm.ms/image/C3VqX8gh4vlpxUc" target="_blank"><img src="https://s2.loli.net/2021/12/31/C3VqX8gh4vlpxUc.jpg" style="width:50%"></a></p><h1 id="1-21"><a href="#1-21" class="headerlink" title="1.21"></a>1.21</h1><p>和小朋友在一起两年啦<br>假期有和她一起出去玩<br><a href="https://sm.ms/image/qFNkLcW1VgaA2O3" target="_blank"><img src="https://s2.loli.net/2021/12/31/qFNkLcW1VgaA2O3.jpg" style="width:50%"></a></p><h1 id="一些春天的照片"><a href="#一些春天的照片" class="headerlink" title="一些春天的照片"></a>一些春天的照片</h1><p>春天的雨后晚上和春天的园林<br>苏州在春天的时候会有很多古装小姐姐逛园子哦<br><a href="https://sm.ms/image/9dawstyPgzmK4nV" target="_blank"><img src="https://s2.loli.net/2021/12/31/9dawstyPgzmK4nV.jpg" style="width:50%"></a><br><a href="https://sm.ms/image/dYrW7meOPQGftgs" target="_blank"><img src="https://s2.loli.net/2021/12/31/dYrW7meOPQGftgs.jpg" style="width:50%"></a><br><a href="https://sm.ms/image/b8yfcjrSmlDZ3WX" target="_blank"><img src="https://s2.loli.net/2021/12/31/b8yfcjrSmlDZ3WX.jpg" style="width:50%"></a><br><a href="https://sm.ms/image/CVPFJioXN8ctRjq" target="_blank"><img src="https://s2.loli.net/2021/12/31/CVPFJioXN8ctRjq.jpg" style="width:50%"></a></p><h1 id="学期内"><a href="#学期内" class="headerlink" title="学期内"></a>学期内</h1><p><a href="https://sm.ms/image/Apa1b2NBndxcRKm" target="_blank"><img src="https://s2.loli.net/2021/12/31/Apa1b2NBndxcRKm.jpg" style="width:50%"></a><br>王者之志<br>见到了好多学校的专业运动员，见到了丹总</p><p><a href="https://sm.ms/image/sFOdqiKUSkh5BDm" target="_blank"><img src="https://s2.loli.net/2021/12/31/sFOdqiKUSkh5BDm.jpg" style="width:50%"></a></p><p>去LNG比赛现场志愿者*2<br>LNG 打 RNG 在现场，那种现场观赛的感觉超棒<br>更加喜欢lol，喜欢电竞<br><a href="https://sm.ms/image/zs6WRAciIYOwEPD" target="_blank"><img src="https://s2.loli.net/2021/12/31/zs6WRAciIYOwEPD.jpg"  style="width:50%"></a></p><h1 id="5-1-太湖"><a href="#5-1-太湖" class="headerlink" title="5.1 太湖"></a>5.1 太湖</h1><p>贴上今年最喜欢的照片之一<br>环太湖骑行是这几年最喜欢的骑行了<br>日落真的很好看，以后一定要带小朋友来看</p><p><a href="https://sm.ms/image/eihKcnoBGJ8DEjy" target="_blank"><img src="https://s2.loli.net/2021/12/31/eihKcnoBGJ8DEjy.jpg" style="width:80%"></a><br><a href="https://sm.ms/image/iBzvp7dA8KwOcDJ" target="_blank"><img src="https://s2.loli.net/2021/12/31/iBzvp7dA8KwOcDJ.jpg" style="width:80%"></a></p><h1 id="5-21-5-26"><a href="#5-21-5-26" class="headerlink" title="5.21 5.26"></a>5.21 5.26</h1><p>收到小朋友送的花花！</p><p><a href="https://sm.ms/image/CSvOKWcXdlRxoEe" target="_blank"><img src="https://s2.loli.net/2021/12/31/CSvOKWcXdlRxoEe.jpg" style="width:50%"></a></p><p>又长大了一岁！<br>有猫猫陪伴</p><p><a href="https://sm.ms/image/BIPhyqadpMwJzT7" target="_blank"><img src="https://s2.loli.net/2021/12/31/BIPhyqadpMwJzT7.jpg" style="width:50%"></a></p><h1 id="暑假"><a href="#暑假" class="headerlink" title="暑假"></a>暑假</h1><p>有初步学习微信小程序并且写了一个不太完整的demo(为了一个比赛来着，不过好像被咕了)<br>一定一定要记得不要参加那些不官方的比赛了</p><p>和好朋友们出去 玩玩玩</p><p>给小朋友们代课</p><p>科目三挂了。。。。。。。艹</p><p>开始习惯于自己做饭，厨艺渐长<br><a href="https://sm.ms/image/dfJ9EokF5tpLasI" target="_blank"><img src="https://s2.loli.net/2021/12/31/dfJ9EokF5tpLasI.jpg" style="width:50%"></a></p><h1 id="去四川"><a href="#去四川" class="headerlink" title="去四川"></a>去四川</h1><p>很长时间没有去旅行了，趁着放假的延长去了一次四川，不仅仅是去找她，还是为完成自己多年的愿望。<br>去了发现自己真的很喜欢四川的生活，饮食风格也好，生活节奏也好，这个城市可能是更适合我的吧<br>第一次一个人的旅行，过程中有时候会觉得自己很孤独，但是自己还是很喜欢这种自由自在的旅行<br>和小朋友过了过简单的二人世界，虽然没有去什么景点，就只是在自己租的民宿一起刷B站，去买菜做饭(虽然翻车了),去就近的电影院看电影，但是确能感到很开心，可能自己就喜欢这种过小日子的感觉吧<br><a href="https://sm.ms/image/QbgVYoi2FWeTkyt" target="_blank"><img src="https://s2.loli.net/2021/12/31/QbgVYoi2FWeTkyt.jpg" style="width:50%"></a><br><a href="https://sm.ms/image/EOaIyociGHZ93Vk" target="_blank"><img src="https://s2.loli.net/2021/12/31/EOaIyociGHZ93Vk.jpg" style="width:50%"></a><br><a href="https://sm.ms/image/6ZnBIAylVDHTFbh" target="_blank"><img src="https://s2.loli.net/2021/12/31/6ZnBIAylVDHTFbh.jpg" style="width:50%"></a><br><a href="https://sm.ms/image/GDEcbOs25CK7LYa" target="_blank"><img src="https://s2.loli.net/2021/12/31/GDEcbOs25CK7LYa.jpg" style="width:50%"></a><br><a href="https://sm.ms/image/ELhwWSACO4js5bo" target="_blank"><img src="https://s2.loli.net/2021/12/31/ELhwWSACO4js5bo.jpg" style="width:50%"></a><br><a href="https://sm.ms/image/PcLiplS8oO6aTEQ" target="_blank"><img src="https://s2.loli.net/2021/12/31/PcLiplS8oO6aTEQ.jpg" style="width:50%"></a></p><h1 id="大二下"><a href="#大二下" class="headerlink" title="大二下"></a>大二下</h1><p>大二下的一年里渐渐习惯晚上喝一两杯再睡觉，也可能是因为自己日常的压力逐渐增大，和其他人的关系也渐渐固化，不愿意去进行多余的交际，晚上总是会莫名其妙的难过，喝两杯，会舒服很多</p><p><a href="https://sm.ms/image/XwqzyhJcQtMIGOT" target="_blank"> <img src="https://s2.loli.net/2021/12/31/XwqzyhJcQtMIGOT.jpg" style="width:50%"></a></p><p>举办校赛，真的很忙很累，这种300+人参加的全校活动是第一次举办，详情转至博客</p><a href="/2021/12/06/thinking1/" title="一些胡思乱想">一些胡思乱想</a><a href="/2021/12/06/thinking1/" title="一些胡思乱想">一些胡思乱想</a><p>秋天的苏大，很美，但是一直是一个人<br><a href="https://sm.ms/image/jPNA9VfO5L1MKxr" target="_blank"><img src="https://s2.loli.net/2021/12/31/jPNA9VfO5L1MKxr.jpg" style="width:50%"></a></p><p>喜欢在学习的时候听爵士。</p><p>拿到了教练员证！</p><p>开始学习怎么写博客，学着记录自己的生活</p><p>认识了加油站，很有意思的音乐社团，大家都和很喜欢音乐，太喜欢那种弹吉他一起唱歌的感觉了</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>一些没用的年度总结</p><table>  <tr>      <td ><center><img src="https://s2.loli.net/2021/12/31/jgQIlwob5YHhnps.jpg" style="width:50%"> </center></td>      <td ><center><img src="https://s2.loli.net/2021/12/31/jheYux8wvbH7iZk.jpg" style="width:70%"> </center></td>  </tr>    <tr>      <td ><center><img src="https://s2.loli.net/2021/12/31/NRKzIqCEX7ktwyB.jpg" style="width:50%"> </center></td>      <td ><center><img src="https://s2.loli.net/2021/12/31/j5hR2guETlsADf7.jpg" style="width:80%"> </center></td>  </tr>    <tr>      <td ><center><img src="https://s2.loli.net/2021/12/31/tQA18sTuNSWyxCZ.jpg" style="width:50%"> </center></td>  </tr></table><p>2021身边的事情发生了太多太多，全球形势也好，网络舆论也好，给人的感觉是这一年负面情绪太多了，以至于现在的人们对于新的一年的期望远远没有之前更高，可能是疫情的原因吧，也可能是逐渐成年的原因，自己已经感觉不到那种跨年的喜悦，对于过年的渴望了，身边的人都在抱怨自己的生活怎样差劲，感觉在大学一年过去了什么都没有发生改变，但仔细一总结还是有很多收获的，有认识新的朋友圈子，有学习新的知识，有完成自己的小小心愿，虽然难过很多，崩溃常有，但是已经都过去了，负面情绪就让他在时间的长河中流逝，能留下来的，才是最珍贵的。</p><p>新的一年，继续加油吧！</p><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://sm.ms/image/ghyrXm5CScL4RJN&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://s2.loli.net/2021/12/31/ghyrXm5CScL4RJN.jpg&quot; &gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是一篇不太正经的年度总结呢！&lt;/p&gt;</summary>
    
    
    
    <category term="年度总结" scheme="http://akkaduilin.com/categories/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="日常" scheme="http://akkaduilin.com/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>最小生成树问题</title>
    <link href="http://akkaduilin.com/2021/12/24/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    <id>http://akkaduilin.com/2021/12/24/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</id>
    <published>2021-12-23T17:16:29.000Z</published>
    <updated>2022-01-08T03:51:05.293Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>实现生成最小生成树的原理和代码</p><p><em>普里姆(Prim)算法</em></p><p><em>克鲁斯卡尔(Kruskal)算法</em></p><span id="more"></span><h1 id="普里姆-Prim-算法"><a href="#普里姆-Prim-算法" class="headerlink" title="普里姆(Prim)算法"></a>普里姆(Prim)算法</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>每次迭代选择代价最小的边对应的点，加入到最小生成树中。算法从某一个顶点s开始，逐渐长大覆盖整个连通网的所有顶点。</p><p><a href="https://sm.ms/image/cJoNn5OkyBbvM1K" target="_blank"><img src="https://s2.loli.net/2021/12/24/cJoNn5OkyBbvM1K.jpg" style="width:80%"></a><br><a href="https://sm.ms/image/r2hfNoOITXntadm" target="_blank"><img src="https://s2.loli.net/2021/12/24/r2hfNoOITXntadm.jpg" style="width:80%"></a></p><h2 id="代码解读"><a href="#代码解读" class="headerlink" title="代码解读"></a>代码解读</h2><p>v表示从哪个结点开始</p><p>用有权的邻接矩阵实现</p><p>若两边不相邻，设为Infinty</p><p>定义两个数组</p><p>adjvex 存储lowcost中对应下标元素是从哪个结点为起点的</p><p>lowcost 中元素意思为现有的存在于最小生成树的结点到此下标结点的最小距离 当值为0时表示此元素以及存在于最小生成树中</p><p>定义函数  MinEdge 寻找lowcost中距离最小的下标 下标带入adjvex中找到结点的值</p><p>当寻找到最小下标时，将此结点写入最小生成树中，并遍历此结点所连接的边，若能到达的结点边权值小于lowcost中储存的，更新</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MaxSize = 10;</span><br><span class="line">const int Infinty = 10000;</span><br><span class="line"></span><br><span class="line">template&lt;typename DataType&gt; </span><br><span class="line">class MGraph&#123;</span><br><span class="line">public:</span><br><span class="line">    MGraph(DataType a[ ],int n, int e);</span><br><span class="line">    ~MGraph()&#123;&#125;;</span><br><span class="line">    void Prim(int v);</span><br><span class="line">    int MinEdge(int lowcost[],int vertexNum);</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    DataType vertex[MaxSize];</span><br><span class="line">    int edge[MaxSize][MaxSize];</span><br><span class="line">    int visited[MaxSize] = &#123;0&#125;;</span><br><span class="line">    int vertexNum,edgeNum;//结点数，边数</span><br><span class="line">    void clear()&#123;</span><br><span class="line">        for(int i=0;i&lt;MaxSize;i++)&#123;</span><br><span class="line">            visited[i] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename DataType&gt; </span><br><span class="line">MGraph&lt;DataType&gt;::MGraph(DataType a[ ],int n, int e)&#123;</span><br><span class="line">    int i,j,k,v;</span><br><span class="line">    vertexNum = n;</span><br><span class="line">    edgeNum = e;</span><br><span class="line">    for(i=0;i&lt;vertexNum;i++)&#123;</span><br><span class="line">        vertex[i] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for(i=0;i&lt;vertexNum;i++)&#123;</span><br><span class="line">        for(j=0;j&lt;vertexNum;j++)&#123;</span><br><span class="line">            edge[i][j] = Infinty;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(k=0;k&lt;edgeNum;k++)&#123;</span><br><span class="line">        cin &gt;&gt; i &gt;&gt; j &gt;&gt; v;</span><br><span class="line">        edge[i][j] = v;</span><br><span class="line">        edge[j][i] = v;</span><br><span class="line">    &#125;</span><br><span class="line">    for(k=0;k&lt;edgeNum;k++)&#123;</span><br><span class="line">        edge[k][k] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">template&lt;typename DataType&gt; </span><br><span class="line">void MGraph&lt;DataType&gt; :: Prim(int v)&#123;</span><br><span class="line">    int i,j,k;</span><br><span class="line">    int adjvex[MaxSize],lowcost[MaxSize];</span><br><span class="line">    // adjvex 存储lowcost中对应下标元素是从哪个结点为起点的</span><br><span class="line">    // lowcost 中元素意思为现有的存在于最小生成树的结点到此下标结点的最小距离</span><br><span class="line">    for( i =0;i&lt;vertexNum;i++)&#123; </span><br><span class="line">        adjvex[i] = v;</span><br><span class="line">        lowcost[i] = edge[v][i];</span><br><span class="line">    &#125;</span><br><span class="line">    // 初始化 adjvex lowcost</span><br><span class="line">    lowcost[v] = 0;</span><br><span class="line">    // lowcost[v] = 0 指下标为v的顶点已经在最小生成树中</span><br><span class="line"></span><br><span class="line">    for(k = 1;k&lt;vertexNum;k++)&#123;</span><br><span class="line">        j = MinEdge(lowcost,vertexNum);//寻找lowcost中最小权值结点的下标</span><br><span class="line">        cout &lt;&lt; adjvex[j] &lt;&lt;&#x27;-&#x27;&lt;&lt; j &lt;&lt;endl;</span><br><span class="line">        lowcost[j] =  0;// 写入最小生成树</span><br><span class="line">        for( i =0;i&lt;vertexNum;i++)&#123;</span><br><span class="line">            if(edge[j][i]&lt;lowcost[i] &amp;&amp; edge[j][i]&gt;0)&#123;</span><br><span class="line">                lowcost[i] = edge[j][i];</span><br><span class="line">                adjvex[i] = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">template&lt;typename DataType&gt; </span><br><span class="line">int MGraph&lt;DataType&gt; ::MinEdge(int lowcost[],int vertexNum)&#123;</span><br><span class="line">    int step = 0;</span><br><span class="line">    for(int j = 0;j&lt;vertexNum;j++)&#123;</span><br><span class="line">        if(lowcost[j]!=0)&#123;</span><br><span class="line">            step = j;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;vertexNum;i++)&#123;</span><br><span class="line">        if(lowcost[i]&lt;lowcost[step] &amp;&amp; lowcost[i]&gt;0)&#123;</span><br><span class="line">            step = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return step;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="克鲁斯卡尔-Kruskal-算法"><a href="#克鲁斯卡尔-Kruskal-算法" class="headerlink" title="克鲁斯卡尔(Kruskal)算法"></a>克鲁斯卡尔(Kruskal)算法</h1><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>先将权值最短的边挑出来，如果这条边两边的结点都已经连通，则跳过，知道最小生成树完成。</p><p><a href="https://sm.ms/image/zkfAPwc4WxG9KqN" target="_blank"><img src="https://s2.loli.net/2021/12/25/zkfAPwc4WxG9KqN.jpg" style="width:80%"></a><br><a href="https://sm.ms/image/nmRqi1F4GUvYocj" target="_blank"><img src="https://s2.loli.net/2021/12/25/nmRqi1F4GUvYocj.jpg" style="width:80%"></a></p><h2 id="代码解读-1"><a href="#代码解读-1" class="headerlink" title="代码解读"></a>代码解读</h2><p>定义边结构Edge出度结点入度结点边的权值</p><p>将邻接矩阵转化为边集数组edges并按权值大小排序</p><p>定义parent数组判断是否形成环</p><p>若parent数组下标所指示的元素不为0，表示此顶点已经在生成树中，所对应的元素值为此下标指向的结点</p><p>Find函数从结点f开始寻找连线顶点的尾部下标</p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">struct Edge&#123;</span><br><span class="line">    int begin;</span><br><span class="line">    int end;</span><br><span class="line">    int weight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void Kruskal(MGraph G)&#123;</span><br><span class="line">    int i,n m;</span><br><span class="line">    Edge edge[MAXEDGE];</span><br><span class="line">    int parent[MAXVEX];</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    此处省略将邻接矩阵G转化为边集数组edges并按权值大小排序代码</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    for(i=0;i&lt;G.vertexNum;i++)&#123;</span><br><span class="line">        parent[i] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    for(i=0;i&lt;G.edgeNum;i++)&#123;</span><br><span class="line">        n = Find(parent,edge[i].begin);</span><br><span class="line">        m = Find(parent,edge[i].end);</span><br><span class="line">        if(m!=n)&#123;</span><br><span class="line">            //  m，n不等，说明此边没有与现有生成树形成环路</span><br><span class="line">            parent[n] = m;</span><br><span class="line">            printf(edge[i].begin,edge[i].end)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Find(int *parent,int f)&#123;</span><br><span class="line">    while( parent[f]&gt;0)&#123;</span><br><span class="line">        f = parent[f];</span><br><span class="line">    &#125;</span><br><span class="line">    return f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;实现生成最小生成树的原理和代码&lt;/p&gt;
&lt;p&gt;&lt;em&gt;普里姆(Prim)算法&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;克鲁斯卡尔(Kruskal)算法&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="http://akkaduilin.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="算法" scheme="http://akkaduilin.com/categories/%E7%BC%96%E7%A8%8B/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="图论" scheme="http://akkaduilin.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="Prim" scheme="http://akkaduilin.com/tags/Prim/"/>
    
    <category term="Kruskal" scheme="http://akkaduilin.com/tags/Kruskal/"/>
    
  </entry>
  
  <entry>
    <title>判断图是否为树/是否成环</title>
    <link href="http://akkaduilin.com/2021/12/22/%E5%88%A4%E6%96%AD%E5%9B%BE%E6%98%AF%E5%90%A6%E4%B8%BA%E6%A0%91-%E6%98%AF%E5%90%A6%E6%88%90%E7%8E%AF/"/>
    <id>http://akkaduilin.com/2021/12/22/%E5%88%A4%E6%96%AD%E5%9B%BE%E6%98%AF%E5%90%A6%E4%B8%BA%E6%A0%91-%E6%98%AF%E5%90%A6%E6%88%90%E7%8E%AF/</id>
    <published>2021-12-21T17:40:22.000Z</published>
    <updated>2022-01-08T03:50:46.657Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>总结一下关于判断图是否成环的问题</p><p>参考博客:<br><a href="https://www.cnblogs.com/wangkundentisy/p/9320499.html">https://www.cnblogs.com/wangkundentisy/p/9320499.html</a><br><a href="https://blog.csdn.net/weixin_45697774/article/details/109528240">https://blog.csdn.net/weixin_45697774/article/details/109528240</a></p><span id="more"></span><h1 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h1><h2 id="利用DFS经行判断"><a href="#利用DFS经行判断" class="headerlink" title="利用DFS经行判断"></a>利用DFS经行判断</h2><ol><li>若在深搜的过程中遇到已经遍历过的边，则为环<br>可以定义visited数组，一个结点对应三种状态<br>x = 0 表示没有被访问过<br>x = 1 表示正在被访问<br>x = 2 表示生成树上的所有的子孙节点都已经访问完</li></ol><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class Graph</span><br><span class="line">&#123;</span><br><span class="line">    public:</span><br><span class="line">    int vertexNum;//顶点个数</span><br><span class="line">    int arcNum;//弧的个数</span><br><span class="line">    int vertex[MAX_NUM];//顶点表</span><br><span class="line">    int arc[MAX_NUM][MAX_NUM];//弧信息表</span><br><span class="line">&#125;;</span><br><span class="line">int visited[MAX_NUM];//顶点访问表</span><br><span class="line">int father[MAX_NUM];//父节点表</span><br><span class="line">void DFS(int v,Graph G)</span><br><span class="line">&#123;</span><br><span class="line">    visited[v] = 1;</span><br><span class="line">    for(int i = 0 ; i &lt; G.vertexNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(i != v &amp;&amp; G.arc[v][i] != INF)//邻接矩阵中节点v的邻接点</span><br><span class="line">        &#123;</span><br><span class="line">            if(visited[i] == 1 &amp;&amp; father[v] != i)//vi不是父节点，而且还访问过(而且为状态1，说明不是回溯过来的顶点)，说明存在环(判断i不是v的父节点)</span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;&quot;图存在环&quot;;</span><br><span class="line">                int temp = v;</span><br><span class="line">                while(temp != i)</span><br><span class="line">                &#123;</span><br><span class="line">                    cout&lt;&lt;temp&lt;&lt;&quot;&lt;-&quot;;//输出环</span><br><span class="line">                    temp = father[temp];</span><br><span class="line">                &#125;</span><br><span class="line">                cout&lt;&lt;temp&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                if(visited[i] == 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    father[i] = v;//更新father数组</span><br><span class="line">                    DFS(i,G);</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[v] = 2;//遍历完所有的邻接点才变为状态2</span><br><span class="line">&#125;</span><br><span class="line">void DFSTraverse(Graph G)</span><br><span class="line">&#123;</span><br><span class="line">    memset(visited,0,sizeof(visited));</span><br><span class="line">    memset(father,-1,sizeof(father));</span><br><span class="line">    for(int i = 0 ; i &lt; G.vertexNum; i++)</span><br><span class="line">        if(!visited[i])</span><br><span class="line">            DFS(i,G);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h1><ol><li>拓扑排序判断是否成环 <a href="/2021/12/22/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/" title="拓扑排序">拓扑排序</a> <a href="/2021/12/22/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/" title="拓扑排序">拓扑排序</a></li></ol><h1 id="是否为树"><a href="#是否为树" class="headerlink" title="是否为树"></a>是否为树</h1><h2 id="无向图-1"><a href="#无向图-1" class="headerlink" title="无向图"></a>无向图</h2><p>对无向图来说，若连通且不成环，则为树<br>可以用定义来判断，即边数=结点数-1，并且在深度遍历整个图后所有边都被遍历过</p><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">int DFTraverse(int v,int edge[MaxSize][MaxSize],int vertexNum)&#123;</span><br><span class="line">    int sum_edge = 0;</span><br><span class="line">    visited[v] = 1;</span><br><span class="line">    for(int j = 0;j&lt;vertexNum;j++)&#123;</span><br><span class="line">        if(edge[v][j] == 1 &amp;&amp; visited[j] == 0) &#123;</span><br><span class="line">            sum_edge = sum_edge + DFTraverse(j,edge,vertexNum) +1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum_edge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void judge_tree(int edge[MaxSize][MaxSize],int vertexNum)</span><br><span class="line">&#123;</span><br><span class="line">    int edge_count = DFTraverse(0,edge,vertexNum);</span><br><span class="line">    int sum_edge = 0;</span><br><span class="line">    int node_count = vertexNum;</span><br><span class="line">    bool flag = true;</span><br><span class="line">    for(int i =0;i&lt;node_count;i++)&#123;</span><br><span class="line">        if(visited[i]==0)&#123;</span><br><span class="line">            flag = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int m =0;m&lt;node_count;m++)&#123;</span><br><span class="line">        for(int n =0;n&lt;node_count;n++)&#123;</span><br><span class="line">            if(edge[m][n]==1)&#123;</span><br><span class="line">                sum_edge++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(edge_count == node_count-1 &amp;&amp; flag &amp;&amp;sum_edge/2==edge_count)&#123;</span><br><span class="line">        cout &lt;&lt; &quot;is tree&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        cout &lt;&lt; &quot;is not tree&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="有向图-1"><a href="#有向图-1" class="headerlink" title="有向图"></a>有向图</h2><ol><li><p>若有一个结点的入度大于1，则不为树</p></li><li><p>同无向图判断成环，不成环为树</p></li></ol><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int Find(int x)</span><br><span class="line">&#123;</span><br><span class="line">    if(fa[x] == x)return x;</span><br><span class="line">    return fa[x] = Find(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool unions(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">    int fx = Find(x);</span><br><span class="line">    int fy = Find(y);</span><br><span class="line">    if(fx != fy)&#123;</span><br><span class="line">        fa[fy] = fx;//注意合并的是原来的点</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;//有环，不是树</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>详细代码见参考博客</p><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;总结一下关于判断图是否成环的问题&lt;/p&gt;
&lt;p&gt;参考博客:&lt;br&gt;&lt;a href=&quot;https://www.cnblogs.com/wangkundentisy/p/9320499.html&quot;&gt;https://www.cnblogs.com/wangkundentisy/p/9320499.html&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_45697774/article/details/109528240&quot;&gt;https://blog.csdn.net/weixin_45697774/article/details/109528240&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="http://akkaduilin.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="题解" scheme="http://akkaduilin.com/categories/%E7%BC%96%E7%A8%8B/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="DFS" scheme="http://akkaduilin.com/tags/DFS/"/>
    
    <category term="图论" scheme="http://akkaduilin.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
</feed>
