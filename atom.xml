<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>咸鱼享乐，摸鱼快楽</title>
  
  
  <link href="http://akkaduilin.com/atom.xml" rel="self"/>
  
  <link href="http://akkaduilin.com/"/>
  <updated>2022-09-08T01:43:38.754Z</updated>
  <id>http://akkaduilin.com/</id>
  
  <author>
    <name>不对de林</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计算机网络-物理层</title>
    <link href="http://akkaduilin.com/2022/09/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%89%A9%E7%90%86%E5%B1%82/"/>
    <id>http://akkaduilin.com/2022/09/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%89%A9%E7%90%86%E5%B1%82/</id>
    <published>2022-09-08T01:17:07.000Z</published>
    <updated>2022-09-08T01:43:38.754Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><span id="more"></span><h1 id="通信系统的模型"><a href="#通信系统的模型" class="headerlink" title="通信系统的模型"></a>通信系统的模型</h1><p>源点<br>发送机<br>接收器<br>终点</p><p>目的：传送消息<br>数据是实体</p><h1 id="信道"><a href="#信道" class="headerlink" title="信道"></a>信道</h1><p>信道：一般用来表示向某一方向传送信息的媒体</p><p>单向通信(单工通信)：只能有一个方向的通信，无反向交互</p><p>双向交替通信(半双工通信) ：双方不能同时发送/接收</p><p>双向同时通信(全双工通信)：双方可以同时发送和接收信息</p><p>基带信号：<br>来自信源的信号<br>包含低频和直流</p><p>调制：<br>基带调制<br>带通调制</p><h1 id="传输媒体"><a href="#传输媒体" class="headerlink" title="传输媒体"></a>传输媒体</h1><h2 id="导引型"><a href="#导引型" class="headerlink" title="导引型"></a>导引型</h2><ol><li>双绞线</li><li>同轴电缆</li><li>光缆</li></ol><p>非导引型</p><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="计算机网络" scheme="http://akkaduilin.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="数据通信" scheme="http://akkaduilin.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机网络-概论</title>
    <link href="http://akkaduilin.com/2022/09/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%AE%BA/"/>
    <id>http://akkaduilin.com/2022/09/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%AE%BA/</id>
    <published>2022-09-08T01:15:28.000Z</published>
    <updated>2022-09-08T02:00:33.535Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><span id="more"></span><h1 id="xx0x"><a href="#xx0x" class="headerlink" title="xx0x"></a>xx0x</h1><h1 id="xx2x"><a href="#xx2x" class="headerlink" title="xx2x"></a>xx2x</h1><h1 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h1><p>1、速率</p><p>数据量单位 数据率单位</p><p>8 比特 = 1 字节 比特/秒(b/s,bps)</p><p>KB = 2^10 B kb/s = 10^3 b/s</p><p>MB = 2^20 B Mb/s = 10^6 b/s</p><p>GB = 2^30 B Gb/s = 10^9 b/s</p><p>2、带宽</p><p>用来表示网络的通信线路所能传送数据的能力，因此网络带宽表示在单位时间内从网络中的某一点到另一点所能通过的“最高数据率” (单位：b/s,kb/s ，Mb/s……)</p><p>在模拟信号系统中的意义：信号所包含的各种不同频率成分所占据的频率范围。单位：HZ\KHZ\MHZ</p><p>3、吞吐量</p><p>表示在单位时间内通过某个网络（或信道、接口）的数据量。 受网络的带宽或额定速率的限制</p><p>4、时延</p><p>发送时延、传播时延、处理时延</p><p>5、时延带宽积</p><p>时延带宽积 = 传播时延 * 带宽</p><p>6、往返时间(RTT)</p><p>双向通信的往返时间</p><p>7、利用率</p><p>信道利用率：用来表示某信道由百分之几的时间是被利用的（由数据通过）。其并非越高越好</p><p>网络利用率：全网络的信道利用率加权平均</p><p>8、丢包率</p><p>即分组丢失率，是指在一一定时间范围内，传输过程中丢失的分组数量与总分组数量的比率。</p><p>分为：接口丢包率、结点丢包率、链路丢包率、路径丢包率、网络丢包率</p><p>误码、网络拥塞时会出现分组丢失。</p><h1 id="xx3x"><a href="#xx3x" class="headerlink" title="xx3x"></a>xx3x</h1><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="计算机网络" scheme="http://akkaduilin.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="概论" scheme="http://akkaduilin.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%A6%82%E8%AE%BA/"/>
    
    
    <category term="计算机网络" scheme="http://akkaduilin.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-概论</title>
    <link href="http://akkaduilin.com/2022/08/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%AE%BA/"/>
    <id>http://akkaduilin.com/2022/08/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%AE%BA/</id>
    <published>2022-08-29T05:34:01.000Z</published>
    <updated>2022-09-12T02:36:36.704Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>操作系统概论/操作系统结构</p><span id="more"></span><h1 id="操作系统设计目标"><a href="#操作系统设计目标" class="headerlink" title="操作系统设计目标"></a>操作系统设计目标</h1><p>操作系统是管理计算机硬件的程序， 为应用程序提供基础， 并且充当计算机硬件和计算机用户的中介。</p><p>运行用户程序 —— 核心目标</p><p>系统面向用户 —— 方便解决用户问题，使计算机方便使用</p><p>面向系统 —— 高效方式使用计算机硬件</p><p>资源分配器 —— 管理资源、分配资源</p><p>控制程序 —— 管理用户程序的运行</p><p>CPU管理 内存管理 文件管理 设备管理</p><h1 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h1><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>计算机开始运行的时候，通常需要运行一个初始化程序/引导程序(bootstrap program)，通常位于 ROM 或 EEPROM 中，称为计算机硬件中的固件。</p><p>它负责初始化系统中的所有部分，包括：CPU 寄存器， 设备控制器， 内存内容。它必须知道如果装入系统并开始执行系统，定位操作系统内核并把他装入内存，然后操作系统就开始初始化。</p><p><strong>中断</strong></p><p>现在的操作系统都是以中断为驱动的。</p><p>事件的发生通常通过硬件或软件中断(interrupt)来表示，硬件可以随时通过系统总线向 CPU 发出信号，触发中断，而软件通过执行特别操作如系统调用(system call)/监视器调用(monitor call)</p><p>中断是计算机结构的重要组成部分。中断必须将控制转移到合适的中断处理程序，简单的方法就是调用一个通用的子程序检查中断信息，然后调用对应的中断处理程序。</p><h2 id="批处理系统"><a href="#批处理系统" class="headerlink" title="批处理系统"></a>批处理系统</h2><p>一次运行称为作业</p><p>一批无需人机交互的作业批量运行称为批处理</p><p>在批处理系统中，用户所提交的作业都先存放在外存上并排成一个队列，称为“后备队列”。然后，由作业调度程序按一定的算法从后备队列中选择若干个作业调入内存，使它们共享CPU和系统中的各种资源。</p><p>简单批处理系统-系统对作业的处理是成批进行的，但内存中始终保持一道作业。</p><p>多道程序系统-在内存中同时存放多个作业，一个时刻只有一个作业运行，使得CPU总有一个作业可执行，这些作业共享CPU和外部设备等资源。</p><p>目的：使得CPU和设备在所有时间内尽可能忙碌，从而提高CPU和设备的利用率，充分发挥计算机系统各个部件的并行性</p><p><strong>并行和并发</strong><br>并行： 两个或多个作业在同一时刻运行<br>并发： 两个或多个作业在同一时间间隔内依次运行</p><h2 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a>分时系统</h2><p>时间片： 一段CPU时间按固定单位分割，每个分割的时间段为一个时间片</p><p>在一段把时间内，每个作业依次轮流运行一个时间片</p><p>·多路性：系统允许将多台终端同时连接到一台主机上，并按分时原则为每个终端分配系统资源，提高资源利用率，降低使用费用。</p><p>·独立性：各终端之间相互独立，互不干扰，每个用户都感觉像一人独占主机一样。</p><p>·及时性：用户的请求能在很短的时间内就得到响应。</p><p>·交互性：用户可通过终端与系统进行人机对话，例如请求多方面的服务。</p><p><em>平均响应速度</em><br><a href="https://www.programminghunter.com/article/79041754246/">https://www.programminghunter.com/article/79041754246/</a><br>进程响应时间：<br>单个进程从用户提交到系统首次响应所用的时间</p><h2 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h2><h1 id="计算机系统体系结构"><a href="#计算机系统体系结构" class="headerlink" title="计算机系统体系结构"></a>计算机系统体系结构</h1><ol><li>单处理器系统</li></ol><p>只有一个通用 CPU<br>还包含其他特定目的微处理器， 用来克服主 CPU 超载问题</p><ol start="2"><li>多处理器系统(并行系统 Parallel system, 紧耦合系统 tightly coupled system)</li></ol><p>拥有多个紧密通信的 CPU，共享计算机总线，时钟，内存和外设</p><p>优点：<br><strong>增加吞吐量</strong><br><strong>规模经济</strong><br><strong>增加可靠性</strong><br>计算机系统不断增加的可靠性是很关键的，这种能提供与正常工作的硬件成正比的服务的能力称为适度退化(graceful degradation)。超出适度退化的能力被称为容错(fault tolerant)</p><p>多处理器系统主要分为</p><p>非对称多处理(asymmetric multiprocessing) ： 主从处理器</p><p>对称多处理(symmetric multiprocessing， SMP) 现代多数操作系统支持</p><p>概念： 刀片服务器(blade server) 每个刀片处理器独立启动并运行各自的系统</p><ol start="3"><li>集群系统：</li></ol><p><strong>由两个或多个独立的系统耦合起来的</strong></p><p>松耦合系统</p><p>通过局域网连接或更快的内部连接(InfiniBand)<br>用途： 提供高可用性(high availability)服务</p><p>分类：对称与非对称</p><p>非对称集群(asymmetric clustering)中， 一台机器处于热备份状态(hot standby mode)，另一台运行程序。</p><p>对称集群(symmetric clustering)，两个或多个主机都运行程序并互相监视。</p><p>还有并行集群和 WAN 集群。</p><p>并行集群中通常需要分布式锁管理器(distributed lock manager， DLM)</p><h2 id="双重模式操作"><a href="#双重模式操作" class="headerlink" title="双重模式操作"></a>双重模式操作</h2><p><strong>区分操作系统代码和用户自定义代码的执行</strong>，通常提供硬件支持以允许区分各种执行模式(在计算机硬件增加一个模式位(mode bit)来区分)</p><p>用户模式(user mode)<br>内核模式：监督程序模式(monitor mode)[也称为管理模式(supervisor mode)]、系统模式(system mode)或特权模式(privileged mode)<br>只要操作系统获得了对计算机的控制，就处于内核模式。</p><p>某些特权指令(privileged instruction)只能在内核模式执行。</p><p>特权指令：可以引起损害的机器指令，如切换到用户模式、I/O 的控制、定时器的管理和中断管理</p><p>系统调用通常采用陷阱到中断向量中的一个指定位置的方式。</p><p><strong>双重模式为操作系统提供了保护手段，以防止操作系统和用户程序受到错误用户程序的影响。</strong></p><p><strong>定时器</strong> 设置为在指定周期后中断计算机</p><h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><p>进程：处于执行中的程序</p><p>需要一定的资源</p><p>程序本身不是进程，程序时被动的实体。</p><p>单线程进程具有一个程序计数器来明确下一个执行的指令，这样程序的执行必须时连续的。</p><p>进程时系统工作的单元。系统由多个进程组成，其中一些事操作系统进程，其他是用户进程。</p><p>操作系统需要负责：</p><p>创建和删除用户进程和系统进程<br>挂起和重启进程<br>提供进程同步机制<br>提供进程通讯机制<br>提供死锁处理机制</p><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>内存是现代计算机操作系统的中心，是 CPU 和 I/O 设备共同快速访问的数据仓库，通常也是 CPU 可以直接寻址和访问的唯一大容量存储器。 </p><p>操作系统负责下列有关的内存管理的活动：</p><p>记录内存的哪部分正在被使用和被谁使用<br>当有内存空间是，决定哪些进程可以装入内存<br>根据需要分配和释放内存空间</p><h1 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h1><h2 id="文件系统管理"><a href="#文件系统管理" class="headerlink" title="文件系统管理"></a>文件系统管理</h2><p>操作系统负责：<br>创建和删除文件<br>创建和删除目录来组织文件<br>提供操作文件和目录的原语<br>将文件映射到二级存储上<br>在稳定存储介质上备份文件</p><h2 id="大容量存储器管理"><a href="#大容量存储器管理" class="headerlink" title="大容量存储器管理"></a>大容量存储器管理</h2><p>操作系统负责：<br>空闲空间管理<br>存储空间分配<br>硬盘调度</p><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;操作系统概论/操作系统结构&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://akkaduilin.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="概论" scheme="http://akkaduilin.com/tags/%E6%A6%82%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>Git</title>
    <link href="http://akkaduilin.com/2022/08/29/Git/"/>
    <id>http://akkaduilin.com/2022/08/29/Git/</id>
    <published>2022-08-29T03:27:33.000Z</published>
    <updated>2022-08-30T07:58:07.952Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>Git/Github 相关学习笔记</p><p>git协同开发流程</p><p>参考博客：<br><a href="https://www.jiyik.com/w/git">https://www.jiyik.com/w/git</a></p><p><a href="https://www.cnblogs.com/failymao/p/14929004.html#step-3%E6%8A%8A%E8%87%AA%E5%B7%B1%E5%BC%80%E5%8F%91%E8%80%85%E4%BB%93%E5%BA%93clone%E5%88%B0%E6%9C%AC%E5%9C%B0">https://www.cnblogs.com/failymao/p/14929004.html#step-3%E6%8A%8A%E8%87%AA%E5%B7%B1%E5%BC%80%E5%8F%91%E8%80%85%E4%BB%93%E5%BA%93clone%E5%88%B0%E6%9C%AC%E5%9C%B0</a></p><span id="more"></span><h1 id="仓库操作"><a href="#仓库操作" class="headerlink" title="仓库操作"></a>仓库操作</h1><p>一个Git仓库是项目的一个虚拟存储。它允许您保存代码的版本，可以在需要时访问这些版本。</p><p>Git 有一个额外的保存机制，称为“ stash ”。stash 是一个临时存储区域，用于存储尚未准备好提交的更改。</p><table><thead><tr><th align="left">序号</th><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">git init</td><td align="left">创建新仓库</td></tr><tr><td align="left">2</td><td align="left">git clone <repo> <directory></td><td align="left">创建仓库副本 –branch 克隆特定标签</td></tr><tr><td align="left">3</td><td align="left">git add</td><td align="left">将修改添加到暂存区  可以是文件和文件夹</td></tr><tr><td align="left">4</td><td align="left">git commit</td><td align="left">将暂存提交到项目历史记录 -am 立即创建所有暂存更改的提交并附加提交消息</td></tr><tr><td align="left">5</td><td align="left">git stash</td><td align="left">时搁置（或隐藏）对工作副本所做的更改</td></tr><tr><td align="left">6</td><td align="left">git diff</td><td align="left">比较更改</td></tr><tr><td align="left">7</td><td align="left">git status</td><td align="left">显示工作目录和暂存区的状态</td></tr><tr><td align="left">8</td><td align="left">git log</td><td align="left">显示已提交的快照的所有的历史信息</td></tr><tr><td align="left">8</td><td align="left">git tag</td><td align="left">标签 -a 添加注释 -m -f更新 -d删除</td></tr></tbody></table><h1 id="撤销更改"><a href="#撤销更改" class="headerlink" title="撤销更改"></a>撤销更改</h1><p>先使用 git log –oneline 查看修订的ID</p><ol><li>使用 git checkout ID  查看此ID的提交 检出特定的提交将使仓库处于“分离 HEAD ”状态</li></ol><p>从分离的HEAD 状态，我们可以执行git checkout -b new_branch_jiyik 命令。 这将创建一个名为 new_branch_jiyik 的新分支并切换到该状态。</p><ol start="2"><li>git revert HEAD</li></ol><p>撤消对仓库提交历史的更改</p><p>创建一个与上次提交相反的新提交</p><ol start="3"><li>git reset</li></ol><ol start="4"><li> <a href="https://blog.csdn.net/weixin_44137575/article/details/108142088">https://blog.csdn.net/weixin_44137575/article/details/108142088</a><br>git clean 清理仓库</li></ol><p>git clean 从你的工作目录中删除所有没有 tracked，没有被管理过的文件。</p><p>n ：显示将要被删除的文件</p><p>d ：删除未被添加到 git 路径中的文件（将 .gitignore 文件标记的文件全部删除）</p><p>f ：强制运行</p><p>x ：删除没有被 track 的文件</p><h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><ol><li><p>git remote<br>git remote 命令本质上是一个接口，用于管理存储在仓库的 ./.git/config 文件中的远程条目列表。</p></li><li><p>git fetch <remote><br>从仓库中获取所有分支。 这还会从其他仓库下载所有必需的提交和文件。</p></li></ol><p>git fetch <remote> <branch><br>与上面的命令相同，但仅获取指定的分支。</p><p>git fetch –all<br>获取所有已注册远程分支</p><p>git fetch –dry-run<br>–dry-run 选项将执行命令的演示运行。 它将输出在获取期间将采取的操作示例，但不应用它们。</p><ol start="3"><li>git push <remote> <branch><br>将指定的分支以及所有必要的提交和内部对象推送到远程仓库的分支 。 这会在目标仓库中创建一个本地分支。 为了防止你覆盖提交，当发现推送的分支的提交不是最新的提交，也就是慢于远程分支的提交时，Git 不会让你推送。</li></ol><p>git push <remote> –force<br>该命令上面的命令相同，但是它是强制推送，即使当前要推送的分支的提交慢于远程仓库的提交版本。除非你绝对确定自己知道自己在做什么，否则不要使用 –force 选项。</p><p>git push <remote> –all<br>将所有的本地分支推送到远程。</p><p>git push <remote> –tags<br>当推送分支或者使用 –all 选项时，Git 并不会对本地的标签（tag）进行推送。如果要将本地的标签推送的远程仓库，则需要–tags 选项。</p><ol start="4"><li>git pull <remote><br>获取当前分支的指定远程分支并立即将其合并到本地分支中。 这与 git fetch <remote> 后再执行 git merge origin/<current-branch> 相同。</li></ol><p>git pull –no-commit <remote><br>与默认调用类似，获取远程内容但不创建新的合并提交。</p><p>git pull –rebase <remote><br>与上一个 pull 相同，单不是使用 git merge 将远程分支与本地分支合并，而是使用 git rebase。</p><p>git pull –verbose<br>显示在拉取期间的下载的内容和合并的详细信息。</p><h1 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h1><p>git中，分支操作则是每个开发人员日常工作流。<br>每个开发者的仓库都有自己的分支路线，而这些分支路线会通过代码汇总映射到源仓库中去。</p><p>分为</p><ol><li><p>永久性分支<br>master branch：主分支<br>develop branch：开发分支 每个开发者的仓库相当于源仓库的一个镜像<br>开发者把功能做好以后，是存放到自己的develop中，当测试完以后，可以向管理者发起一个pull request，请求把自己仓库的develop分支合并到源仓库的develop中。</p></li><li><p>临时性分支<br>feature branch：功能分支 用于开发项目的功能的分支 该分支上进行功能的开发，开发完成以后再合并到develop分支上 命名一般为feature-*<br>release branch：预发布分支<br>hotfix branch：bug修复分支</p></li></ol><h2 id="git-branch-常见选项"><a href="#git-branch-常见选项" class="headerlink" title="git branch 常见选项"></a>git branch 常见选项</h2><ol><li><p>git branch<br>或者<br>git branch –list<br>列出仓库中的所有分支。</p></li><li><p>git branch <branch><br>创建一个名为<branch>的新分支。这并没有检出新的分支。</p></li><li><p>git branch -d <branch><br>删除指定的分支。这是一个“安全”操作，因为 Git 会阻止我们删除具有未合并更改的分支。</p></li><li><p>git branch -D <branch><br>强制删除指定的分支，即使它有未合并的更改。如果想永久丢弃与特定开发线相关的所有提交，则可以使用此命令。</p></li><li><p>git branch -m <branch><br>将当前分支重命名为<branch>。</p></li><li><p>git branch -a<br>列出所有远程分支。</p></li></ol><h2 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h2><p>git checkout 在分支上使用时会改变 HEAD 引用的目标。 它可用于创建分支、切换分支和检出远程分支。</p><ol><li><p>切换分支 git checkout branch_id</p></li><li><p>创建分支并切换 git checkout -b <new-branch></p></li></ol><h2 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h2><p>将多个提交序列合并为一个统一的历史记录</p><p><a href="https://www.jiyik.com/w/git/git-merge">https://www.jiyik.com/w/git/git-merge</a></p><h1 id="git协同开发"><a href="#git协同开发" class="headerlink" title="git协同开发"></a>git协同开发</h1><p><a href="https://developer.aliyun.com/article/604633">https://developer.aliyun.com/article/604633</a></p><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Git/Github 相关学习笔记&lt;/p&gt;
&lt;p&gt;git协同开发流程&lt;/p&gt;
&lt;p&gt;参考博客：&lt;br&gt;&lt;a href=&quot;https://www.jiyik.com/w/git&quot;&gt;https://www.jiyik.com/w/git&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/failymao/p/14929004.html#step-3%E6%8A%8A%E8%87%AA%E5%B7%B1%E5%BC%80%E5%8F%91%E8%80%85%E4%BB%93%E5%BA%93clone%E5%88%B0%E6%9C%AC%E5%9C%B0&quot;&gt;https://www.cnblogs.com/failymao/p/14929004.html#step-3%E6%8A%8A%E8%87%AA%E5%B7%B1%E5%BC%80%E5%8F%91%E8%80%85%E4%BB%93%E5%BA%93clone%E5%88%B0%E6%9C%AC%E5%9C%B0&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Git" scheme="http://akkaduilin.com/categories/Git/"/>
    
    <category term="Github" scheme="http://akkaduilin.com/categories/Git/Github/"/>
    
    
    <category term="Git" scheme="http://akkaduilin.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>汇编代码</title>
    <link href="http://akkaduilin.com/2022/08/01/x86-64%E6%B1%87%E7%BC%96/"/>
    <id>http://akkaduilin.com/2022/08/01/x86-64%E6%B1%87%E7%BC%96/</id>
    <published>2022-08-01T08:22:24.000Z</published>
    <updated>2022-08-31T00:26:03.949Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>汇编代码和原始的C代码相差比较大，一些通常对C语言程序员隐蔽的处理器状态是可见的：</p><p>程序计数器(PC，用 %eip 表示)指示将要执行的下一条指令在存储器中的地址。<br>整数寄存器文件包含 8 个命名的位置，分别存储 32 位的值。这些寄存器可以存储地址(对应于 C 语言的指针)或证书数据。有的寄存器被用来记录某些重要的程序状态，而其他的寄存器则用来保存临时数据。<br>条件码(codition code)寄存器保存着最近执行的算术或逻辑指令的状态信息。它们用来实现控制或数据流中的条件变化。<br>一组浮点寄存器存放浮点数据。</p><span id="more"></span><h1 id="CPU基本功能"><a href="#CPU基本功能" class="headerlink" title="CPU基本功能"></a>CPU基本功能</h1><ol><li>执行机器指令</li><li>暂存少量数据</li><li>访问存储器</li></ol><h1 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h1><p><a href="https://sm.ms/image/JV4Sr8Dpyq9HzZx" target="_blank"><img src="https://s2.loli.net/2022/08/02/JV4Sr8Dpyq9HzZx.png" ></a></p><h1 id="操作数指示符"><a href="#操作数指示符" class="headerlink" title="操作数指示符"></a>操作数指示符</h1><p>大多数指令有一个或多个操作数(operand)，指示出执行一个操作中要引用的源数据值，以及放置结果的目标位置。操作数可能被分为三种类型：</p><ol><li>立即数(immediate)，也就是常数值</li><li>寄存器(register)，表示某个寄存器的内容</li><li>存储器(memory)引用，它会根据计算出来的地址访问某个存储器位置</li></ol><p><a href="https://sm.ms/image/bJ84KYTCsHigZP7" target="_blank"><img src="https://s2.loli.net/2022/08/02/bJ84KYTCsHigZP7.png" ></a></p><h1 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h1><p><a href="https://sm.ms/image/jLvqNehi8JEPsUr" target="_blank"><img src="https://s2.loli.net/2022/08/02/jLvqNehi8JEPsUr.png" ></a></p><h1 id="算术逻辑操作"><a href="#算术逻辑操作" class="headerlink" title="算术逻辑操作"></a>算术逻辑操作</h1><p><a href="https://sm.ms/image/JV4Sr8Dpyq9HzZx" target="_blank"><img src="https://s2.loli.net/2022/08/02/JV4Sr8Dpyq9HzZx.png" ></a></p><h1 id="xx2x"><a href="#xx2x" class="headerlink" title="xx2x"></a>xx2x</h1><h1 id="xx3x"><a href="#xx3x" class="headerlink" title="xx3x"></a>xx3x</h1><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;汇编代码和原始的C代码相差比较大，一些通常对C语言程序员隐蔽的处理器状态是可见的：&lt;/p&gt;
&lt;p&gt;程序计数器(PC，用 %eip 表示)指示将要执行的下一条指令在存储器中的地址。&lt;br&gt;整数寄存器文件包含 8 个命名的位置，分别存储 32 位的值。这些寄存器可以存储地址(对应于 C 语言的指针)或证书数据。有的寄存器被用来记录某些重要的程序状态，而其他的寄存器则用来保存临时数据。&lt;br&gt;条件码(codition code)寄存器保存着最近执行的算术或逻辑指令的状态信息。它们用来实现控制或数据流中的条件变化。&lt;br&gt;一组浮点寄存器存放浮点数据。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>计算机组成原理-储存系统</title>
    <link href="http://akkaduilin.com/2022/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%82%A8%E5%AD%98%E7%B3%BB%E7%BB%9F/"/>
    <id>http://akkaduilin.com/2022/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%82%A8%E5%AD%98%E7%B3%BB%E7%BB%9F/</id>
    <published>2022-06-15T03:21:44.000Z</published>
    <updated>2022-06-25T06:40:22.609Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p><a href="https://sm.ms/image/GqxMmSXHt5fobK4" target="_blank"><img src="https://s2.loli.net/2022/06/25/GqxMmSXHt5fobK4.png" ></a></p><p>三级存储结构：高速缓冲存储器、内存、外存</p><p><a href="https://sm.ms/image/fAi3R8N9DSa1dTz" target="_blank"><img src="https://s2.loli.net/2022/06/24/fAi3R8N9DSa1dTz.png" ></a> </p><span id="more"></span><h1 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h1><p>Cache：高速缓冲存储器<br>容量小：几百KB~几MB<br>cache采用静态存储器技术，每位至少需要6个晶体管，直接用触发器方式维持固定的逻辑，所以不需要刷新<br>与内核紧密相连，采用高速同步运行</p><h1 id="执行原理"><a href="#执行原理" class="headerlink" title="执行原理"></a>执行原理</h1><p><a href="https://sm.ms/image/1IScn824AOelkrE" target="_blank"><img src="https://s2.loli.net/2022/06/24/1IScn824AOelkrE.png" ></a></p><p>CPU从内存访问第一条指令<br>同时将第一条指令所在的页内容复制到cache中</p><p>CPU从cache中查找下一条要执行的指令<br>查找到(命中)，从cache中取指令，执行</p><p>查找不到，从内存中取指令<br>同时将该指令所在的页内容复制到cache中</p><p><a href="https://sm.ms/image/71bFwBuyXfI3aOg" target="_blank"><img src="https://s2.loli.net/2022/06/24/71bFwBuyXfI3aOg.png" ></a></p><h1 id="访问原理"><a href="#访问原理" class="headerlink" title="访问原理"></a>访问原理</h1><h2 id="直接映射"><a href="#直接映射" class="headerlink" title="直接映射"></a>直接映射</h2><p><a href="https://sm.ms/image/DcJoZ5kjd9bfMNK" target="_blank"><img src="https://s2.loli.net/2022/06/24/DcJoZ5kjd9bfMNK.png" ></a></p><p>把主存的每一块映射到一个固定的Cache槽中。<br>j=i mod 2c，<br>j为Cache槽号<br>i为主存的块号，<br>2c为Cache的槽数。<br>优点：实现简单、花费少。<br>缺点：Cache利用率不高。</p><h2 id="全相联"><a href="#全相联" class="headerlink" title="全相联"></a>全相联</h2><p>通过允许每个主存块装入到Cache的任何一槽中来克服直接映射的缺点</p><h2 id="组相联映射"><a href="#组相联映射" class="headerlink" title="组相联映射"></a>组相联映射</h2><p><a href="https://sm.ms/image/JtmLc9T6D3MbCrv" target="_blank"><img src="https://s2.loli.net/2022/06/24/JtmLc9T6D3MbCrv.png" ></a><br>上述两种方案的折中。<br>按号分组 组内随意放<br>把Cache分成2C’组<br>每组有2r个槽<br>2C =2C’×2r<br>j=(i mod 2C’)* 2r +k<br>(k=0，1，…，2r-1)</p><h1 id="替换算法"><a href="#替换算法" class="headerlink" title="替换算法"></a>替换算法</h1><p><a href="https://sm.ms/image/KEGcbyUmNiJzu7Y" target="_blank"><img src="https://s2.loli.net/2022/06/24/KEGcbyUmNiJzu7Y.png" ></a></p><p><a href="https://sm.ms/image/GubwWY1dnm85Dr2" target="_blank"><img src="https://s2.loli.net/2022/06/24/GubwWY1dnm85Dr2.png" ></a></p><p><a href="https://sm.ms/image/KtrxRQVGBmcWay5" target="_blank"><img src="https://s2.loli.net/2022/06/24/KtrxRQVGBmcWay5.png" ></a></p><h1 id="写策略"><a href="#写策略" class="headerlink" title="写策略"></a>写策略</h1><p>主存和cache中数据一致性问题的解决办法：<br>  写通过（Write through）：所有的写操作对主存和Cache同时进行。<br>  <strong>直写法不需要维护位</strong></p><p>  回写（write back）：只在Cache中修改，当进行修改时，设置与槽有关的修改位。因此，当某个块被替换时，当且仅当修改位被设置时，才将它写回主存。<br>  <strong>写回法需要一位的维护位</strong></p><p>当系统中存在多个Cache时，解决多个Cache中数据的一致性问题的方法：<br>  总线监视法<br>  硬件监视法<br>  划出不可高速缓存存储区法</p><h1 id="虚拟储存器"><a href="#虚拟储存器" class="headerlink" title="虚拟储存器"></a>虚拟储存器</h1><p>虚拟存储器指的是“主存-辅存”层次，它能使计算机具有辅存的容量，接近于主存的速度和辅存的每位成本。使程序员可以按比主存大得多的空间来编制程序，即按虚存空间编址。</p><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://sm.ms/image/GqxMmSXHt5fobK4&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://s2.loli.net/2022/06/25/GqxMmSXHt5fobK4.png&quot; &gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;三级存储结构：高速缓冲存储器、内存、外存&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://sm.ms/image/fAi3R8N9DSa1dTz&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://s2.loli.net/2022/06/24/fAi3R8N9DSa1dTz.png&quot; &gt;&lt;/a&gt; &lt;/p&gt;</summary>
    
    
    
    <category term="计算机组成原理" scheme="http://akkaduilin.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机组成原理-中央处理器</title>
    <link href="http://akkaduilin.com/2022/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/"/>
    <id>http://akkaduilin.com/2022/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/</id>
    <published>2022-06-15T03:21:24.000Z</published>
    <updated>2022-06-27T09:30:04.765Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p><a href="https://sm.ms/image/q3H5Q21hRClFuIp" target="_blank"><img src="https://s2.loli.net/2022/06/23/q3H5Q21hRClFuIp.png" ></a></p><p><a href="https://www.bilibili.com/video/BV1BE411D7">https://www.bilibili.com/video/BV1BE411D7</a></p><span id="more"></span><h1 id="中央处理器的功能和组成"><a href="#中央处理器的功能和组成" class="headerlink" title="中央处理器的功能和组成"></a>中央处理器的功能和组成</h1><p>指令控制：程序的顺序控制<br>操作控制：一条指令有若干操作信号实现<br>时间控制：指令各个操作实施时间的定时<br>数据加工：算术运算和逻辑运算</p><p><strong>运算器：</strong><br>数据加工 </p><p><strong>控制器：</strong><br>①取指令 ②翻译指令 ③发送信号执行指令</p><p><strong>根本任务就是从应用程序中取指令并执行。</strong></p><h1 id="运算器-控制器"><a href="#运算器-控制器" class="headerlink" title="运算器/控制器"></a>运算器/控制器</h1><p><a href="https://sm.ms/image/ZGMEuWvyVO1irja" target="_blank"><img src="https://s2.loli.net/2022/06/23/ZGMEuWvyVO1irja.png" ></a></p><h2 id="运算器基本结构"><a href="#运算器基本结构" class="headerlink" title="运算器基本结构"></a>运算器基本结构</h2><p>定点运算器是数据的加工处理部件，<br>是CPU的重要组成部分。</p><p>包括：ALU算术/逻辑单元 ，阵列乘法器、阵列除法器、移位电路、寄存器组、选择电路、数据总线（内部总线），…… 等逻辑电路构成。</p><p><a href="https://sm.ms/image/hQplsKOZ7uGRHTv" target="_blank"><img src="https://s2.loli.net/2022/06/23/hQplsKOZ7uGRHTv.png" ></a></p><h2 id="控制器基本结构"><a href="#控制器基本结构" class="headerlink" title="控制器基本结构"></a>控制器基本结构</h2><p>控制器的功能：<br>        取指令<br>        分析指令<br>        执行指令<br>        控制程序和数据的输入与输出<br>        对异常和请求进行处理</p><p>控制器的组成：<br>        程序计数器（PC）<br>        指令寄存器（IR）<br>        地址寄存器（MAR）<br>        数据缓冲寄存器（MDR）<br>        指令译码器（I-decoder）<br>        脉冲源和启停线路<br>        时序控制信号形成部件</p><p><a href="https://sm.ms/image/5UuHYnQ68s4WNdV" target="_blank"><img src="https://s2.loli.net/2022/06/23/5UuHYnQ68s4WNdV.png" ></a></p><p><a href="https://sm.ms/image/V9IBsav6ljLkRXh" target="_blank"><img src="https://s2.loli.net/2022/06/27/V9IBsav6ljLkRXh.png" ></a></p><h1 id="指令的执行过程"><a href="#指令的执行过程" class="headerlink" title="指令的执行过程"></a>指令的执行过程</h1><p><a href="https://sm.ms/image/eWaRlAn9srFwpt1" target="_blank"><img src="https://s2.loli.net/2022/06/23/eWaRlAn9srFwpt1.png" ></a></p><p><a href="https://sm.ms/image/58InB7T3ZFapjNu" target="_blank"><img src="https://s2.loli.net/2022/06/23/58InB7T3ZFapjNu.png" ></a></p><h1 id="微程序"><a href="#微程序" class="headerlink" title="微程序"></a>微程序</h1><p>微指令：由同时发出的控制信号所执行的一组微操作。<br>    例如：<br>加法指令的执行可分为：取指、计算地址、取操作数和加法运算四步，每一步都由一组微操作实现。这一组能同时执行的微操作就构成一条微指令。</p><p>微程序：一组微指令的集合。这样：<br>程序由一组指令组成<br>指令由一个微程序实现<br>微程序由一组微指令实现<br>微指令由一组微操作实现</p><p><a href="https://sm.ms/image/byHGVLgcBQqlJuM" target="_blank"><img src="https://s2.loli.net/2022/06/23/byHGVLgcBQqlJuM.png" ></a></p><ol><li>将每个控制信号用1bit表示，当该位为1时，表示有控制信号；为0时，表示无控制信号。</li><li>对M/IO#、W/R#，则当该位为1时，分别表示访问存储器和写；当该位为0时，分别表示IO访问和读。</li><li> 每条微指令执行完后，需要给出下条微指令执行的地址。</li></ol><p><strong>基本结构</strong><br><a href="https://sm.ms/image/yWT27H4VsfIvw1S" target="_blank"><img src="https://s2.loli.net/2022/06/23/yWT27H4VsfIvw1S.png" ></a></p><p><strong>格式</strong><br><a href="https://sm.ms/image/OD6Fxvcz7U1IsuP" target="_blank"><img src="https://s2.loli.net/2022/06/23/OD6Fxvcz7U1IsuP.png" ></a></p><p><strong>编码方式</strong></p><p><a href="https://sm.ms/image/bO2VIUrWYnGfBTl" target="_blank"><img src="https://s2.loli.net/2022/06/23/bO2VIUrWYnGfBTl.png" ></a></p><p><a href="https://sm.ms/image/EFtsVHRleOXjYGz" target="_blank"><img src="https://s2.loli.net/2022/06/23/EFtsVHRleOXjYGz.png" ></a></p><p><a href="https://sm.ms/image/FnYSmG6Th1Dy7OX" target="_blank"><img src="https://s2.loli.net/2022/06/23/FnYSmG6Th1Dy7OX.png" ></a></p><p><a href="https://sm.ms/image/lBfQGSecj1xbRir" target="_blank"><img src="https://s2.loli.net/2022/06/23/lBfQGSecj1xbRir.png" ></a></p><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://sm.ms/image/q3H5Q21hRClFuIp&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://s2.loli.net/2022/06/23/q3H5Q21hRClFuIp.png&quot; &gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1BE411D7&quot;&gt;https://www.bilibili.com/video/BV1BE411D7&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="计算机组成原理" scheme="http://akkaduilin.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机组成原理-指令系统</title>
    <link href="http://akkaduilin.com/2022/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"/>
    <id>http://akkaduilin.com/2022/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/</id>
    <published>2022-06-15T03:21:02.000Z</published>
    <updated>2022-06-22T15:46:36.810Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>指令：要求计算机完成某种操作的命令。<br><strong>指令系统：1台计算机所能执行的全部指令的集合。</strong></p><p>计算机的性能与它所设置的指令系统有很大关系，而指令系统的设置又与机器的硬件结构密切相关。<br>机器指令的基本要素：<br>操作码<br>操作数的地址<br>操作结果的存储地址<br>下一条指令的地址</p><p><a href="https://sm.ms/image/ZBzuHGcbDaMfi3v" target="_blank"><img src="https://s2.loli.net/2022/06/22/ZBzuHGcbDaMfi3v.png" ></a></p><span id="more"></span><h1 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h1><p>计算机的指令格式与机器的字长、存储器的容量及指令的功能都有很大关系。</p><p>从机器指令的基本要素可知，一条指令包括两种信息：<strong>操作码和地址码</strong>。</p><p>操作码（operation code）：用来表示指令所要完成的操作(如加、减、乘、除、数据传送等)，其长度取决于指令系统中指令的条数。</p><p>地址码：用来描述指令的操作对象。或者直接给出操作数、或者指出操作数的存储地址或寄存器地址(即寄存器名)。</p><p><a href="https://sm.ms/image/xWrsiaveQNfA6E7" target="_blank"><img src="https://s2.loli.net/2022/06/21/xWrsiaveQNfA6E7.png" ></a></p><p>n位操作码可以定义2^n 条指令</p><h1 id="拓展操作码"><a href="#拓展操作码" class="headerlink" title="拓展操作码"></a>拓展操作码</h1><p>器字长位16位，用15/15/15扩展法可以设计一个具有15条三地址指令、15条双地址指令、15条单地址指令和16条零地址指令的指令系统</p><p><a href="https://sm.ms/image/nKU4ZgGrDqh1bBW" target="_blank"><img src="https://s2.loli.net/2022/06/21/nKU4ZgGrDqh1bBW.png" ></a></p><p>拓展思路：<br>设地址长度为n<br>上一层留出m种状态，下一层可拓展m*2^n种状态</p><p><a href="https://sm.ms/image/EDqNY35sZ9AWUi1" target="_blank"><img src="https://s2.loli.net/2022/06/21/EDqNY35sZ9AWUi1.png" ></a></p><h1 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h1><p>方式                 算法                 优点                     缺点           访存次数(执行期间)<br>立即               操作数=A           无存储器访问            操作数大小受限          0<br>直接               EA=A                   简单                   地址范围有限        1<br>间接               EA=(A)             大的地址范围            多重存储器访问          2<br>寄存器             EA=R                无存储器访问             地址范围有限          0<br>寄存器间接          EA=(R)              大的地址范围            额外地址访问           1<br>偏移               EA=A+(R)               灵活                    复杂               1<br>堆栈               EA=栈顶              无存储器访问              应用有限</p><p><a href="https://sm.ms/image/k6ZWhsAXx7BjClS" target="_blank"><img src="https://s2.loli.net/2022/06/22/k6ZWhsAXx7BjClS.png" ></a></p><p><a href="https://sm.ms/image/nS9tfvlFGAdrmiN" target="_blank"><img src="https://s2.loli.net/2022/06/22/nS9tfvlFGAdrmiN.png" ></a></p><p><a href="https://sm.ms/image/TBQYOV3H1s7cod9" target="_blank"><img src="https://s2.loli.net/2022/06/22/TBQYOV3H1s7cod9.png" ></a></p><p><a href="https://sm.ms/image/pjioez9wXZJ37Em" target="_blank"><img src="https://s2.loli.net/2022/06/22/pjioez9wXZJ37Em.png" ></a></p><p><a href="https://sm.ms/image/pqOaijgm4QP1BWk" target="_blank"><img src="https://s2.loli.net/2022/06/22/pqOaijgm4QP1BWk.png" ></a></p><p><a href="https://sm.ms/image/SHP3uXbOAWslLq1" target="_blank"><img src="https://s2.loli.net/2022/06/22/SHP3uXbOAWslLq1.png" ></a></p><p><a href="https://sm.ms/image/Lu76NVml8rbAItc" target="_blank"><img src="https://s2.loli.net/2022/06/22/Lu76NVml8rbAItc.png" ></a></p><p><a href="https://sm.ms/image/75dqoFezIgmlTZ8" target="_blank"><img src="https://s2.loli.net/2022/06/22/75dqoFezIgmlTZ8.png" ></a></p><h1 id="CISC-和-RISC"><a href="#CISC-和-RISC" class="headerlink" title="CISC 和 RISC"></a>CISC 和 RISC</h1><p>1、CISC计算机<br>CISC：复杂指令系统(集)计算机 (complex instruction set computer)的缩写。<br>一条指令完成一个复杂的功能<br>  DEC公司的VAX11/780计算机、Intel公司的80x86微处理器、IBM公司的大、中型计算机都是CISC。<br>2、RISC计算机<br>   RISC：精简指令系统(集)计算机 (reduced instruction set computer)的缩写。<br>   一条指令完成一个基本动作 多条指令组合完成一个复杂的基本功能</p><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;指令：要求计算机完成某种操作的命令。&lt;br&gt;&lt;strong&gt;指令系统：1台计算机所能执行的全部指令的集合。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;计算机的性能与它所设置的指令系统有很大关系，而指令系统的设置又与机器的硬件结构密切相关。&lt;br&gt;机器指令的基本要素：&lt;br&gt;操作码&lt;br&gt;操作数的地址&lt;br&gt;操作结果的存储地址&lt;br&gt;下一条指令的地址&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://sm.ms/image/ZBzuHGcbDaMfi3v&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://s2.loli.net/2022/06/22/ZBzuHGcbDaMfi3v.png&quot; &gt;&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="计算机组成原理" scheme="http://akkaduilin.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>数据库-关系数据</title>
    <link href="http://akkaduilin.com/2022/06/15/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE/"/>
    <id>http://akkaduilin.com/2022/06/15/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE/</id>
    <published>2022-06-15T03:18:26.000Z</published>
    <updated>2022-06-26T07:56:20.757Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>关系：笛卡尔积的一个子集，是一张二维表。没有重复的元组。</p><p>关系模式：用于定义关系，记作 [公式] 。<br>R：关系名，U：属性名集合，D：属性的域（的集合？)，DOM属性向域的映象集合（？什么鬼，是指属性和域的对应关系吗？），F：属性间数据依赖关系的集合（数据依赖后文会定义）。</p><p>关系数据库：基于关系模型的数据库，形式上由一组关系组成。</p><p>关系数据库模式：定义这组关系的关系模式全体，关系模式的集合。</p><p>数据依赖：包括函数依赖和多值依赖</p><p><strong>函数依赖：某个属性集决定另一个属性集时，称另一属性集依赖于该属性集。</strong></p><span id="more"></span><h1 id="码"><a href="#码" class="headerlink" title="码"></a>码</h1><p>候选码、主属性、非主属性、全码、主码：</p><p>被整个属性组完全函数依赖的属性组是候选码。</p><p>候选码包含的属性就是主属性，反之为非主属性。</p><p>全码：整个属性组都是候选码。</p><p>主码：候选码里选一个喜欢的当主码。</p><p>可以当主码的就是候选码，属于候选码的属性是主属性</p><h1 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h1><p><a href="https://blog.csdn.net/lqiqil/article/details/102801521?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-102801521-blog-124936003.pc_relevant_downloadblacklistv1&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3">https://blog.csdn.net/lqiqil/article/details/102801521?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-102801521-blog-124936003.pc_relevant_downloadblacklistv1&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3</a></p><h2 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h2><p>部分函数依赖：设X,Y是关系R的两个属性集合，存在X→Y，若X’是X的真子集，存在X’→Y，则称Y部分函数依赖于X。</p><p>完全函数依赖：设X,Y是关系R的两个属性集合，X’是X的真子集，存在X→Y，但对每一个X’都有X’!→Y，则称Y完全函数依赖于X。</p><p>传递函数依赖：设X,Y,Z是关系R中互不相同的属性集合，存在X→Y(Y !→X),Y→Z，则称Z传递函数依赖于X。</p><h2 id="四个范式"><a href="#四个范式" class="headerlink" title="四个范式"></a>四个范式</h2><p>1NF：如果一个关系模式R的所有属性都是不可分的基本数据项，则R∈1NF。可能存在增删改异常和数据冗余。</p><p>2NF：若关系模式R∈1NF，并且每一个非主属性都完全函数依赖于R的候选码，则R∈2NF。可能存在增删改异常和数据冗余。</p><p>3NF：若关系模式R∈2NF，并且非主属性都不传递依赖于R的候选码。基本上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。可能存在增删改异常和数据冗余。</p><p>BCNF：若关系模式R∈3NF，并且主属性也不传递依赖或部分依赖于R的候选码。每个属性都不部分依赖于候选码也不传递依赖于候选码，那么R是BC范式 。</p><h1 id="xx3x"><a href="#xx3x" class="headerlink" title="xx3x"></a>xx3x</h1><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关系：笛卡尔积的一个子集，是一张二维表。没有重复的元组。&lt;/p&gt;
&lt;p&gt;关系模式：用于定义关系，记作 [公式] 。&lt;br&gt;R：关系名，U：属性名集合，D：属性的域（的集合？)，DOM属性向域的映象集合（？什么鬼，是指属性和域的对应关系吗？），F：属性间数据依赖关系的集合（数据依赖后文会定义）。&lt;/p&gt;
&lt;p&gt;关系数据库：基于关系模型的数据库，形式上由一组关系组成。&lt;/p&gt;
&lt;p&gt;关系数据库模式：定义这组关系的关系模式全体，关系模式的集合。&lt;/p&gt;
&lt;p&gt;数据依赖：包括函数依赖和多值依赖&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;函数依赖：某个属性集决定另一个属性集时，称另一属性集依赖于该属性集。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="http://akkaduilin.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库" scheme="http://akkaduilin.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="关系数据" scheme="http://akkaduilin.com/tags/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>数据库设计</title>
    <link href="http://akkaduilin.com/2022/06/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/"/>
    <id>http://akkaduilin.com/2022/06/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/</id>
    <published>2022-06-15T03:17:34.000Z</published>
    <updated>2022-06-26T09:25:46.047Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>•按照规范设计法，考虑数据库及其应用系统开发全过<br>程，可将数据库设计分为以下六个阶段：<br>• 需求分析阶段<br>  分析用户数据需求与处理需求。<br>• 概念结构设计阶级<br>  对用户需求进行综合、归纳与抽象，形成独立于<br>  具体DBMS的概念模型(E-R图)<br>• 逻辑结构设计阶段<br>  首先将E-R图转换成具体的DBMS支持的数据模型，如关系模型，形成数据库逻辑模式<br>  •然后根据用户处理的要求、安全性的考虑，在基本表的基础上再建立必要的视图(View)，形成数据的外模式<br>• 物理结构设计阶段<br>  为逻辑数据模型选取一个最适合应用环境的物理结构（包括存储结构和存取方法）<br>• 数据库实施阶段<br>  设计人员运用DBMS提供的数据语言及宿主语言，根据逻辑设计和物理设计的结果<br>  •建立数据库<br>  •编制与调试应用程序<br>  •组织数据入库<br>  •并进行试运行<br>• 数据库运行和维护阶段<br>  数据库应用系统经过试运行后即可投入正式运行，在数据库系统运行过程中不断进行评价、调整、修改等维护工作。<br>•需求分析和概念设计独立于任何数据库管理系统<br>•逻辑设计和物理设计与选用的DBMS密切相关</p><span id="more"></span><h1 id="ER模型"><a href="#ER模型" class="headerlink" title="ER模型"></a>ER模型</h1><p>三要素：<br>•实体<br>•联系<br>•属性</p><h2 id="模型结构"><a href="#模型结构" class="headerlink" title="模型结构"></a>模型结构</h2><p>（1） 实体集用矩形框表示，矩形框内写上实体名。</p><p>（2） 实体的属性用椭圆框表示，框内写上属性名，并用无向边与其实体集相连。</p><p>（3） 实体间的联系用菱形框表示，联系以适当的含义命名，名字写在菱形框中，用无向连线将参加联系的实体矩形框分别与菱形框相连，并在连线上标明联系的类型，即1—1、1—N或M—N。</p><p>（4）主键的名称下加实线</p><p><a href="https://sm.ms/image/6V4iWbL7QKJMmYO" target="_blank"><img src="https://s2.loli.net/2022/06/26/6V4iWbL7QKJMmYO.png" ></a></p><p><a href="https://sm.ms/image/XQFPUhOfybRjTu6" target="_blank"><img src="https://s2.loli.net/2022/06/26/XQFPUhOfybRjTu6.png" ></a></p><p><a href="https://sm.ms/image/3wh6u7oJRtpGZOm" target="_blank"><img src="https://s2.loli.net/2022/06/26/3wh6u7oJRtpGZOm.png" ></a></p><h2 id="弱实体和强实体"><a href="#弱实体和强实体" class="headerlink" title="弱实体和强实体"></a>弱实体和强实体</h2><p>弱实体：一个实体必须依赖于另一个实体存在，那么前者是弱实体，后者是强实体，弱实体必须依赖强实体存在，例如学生实体和成绩单实体，成绩单依赖于学生实体而存在，因此学生是强实体，而成绩单是弱实体。</p><p>弱实体和强实体的联系必然只有1：N或者1：1，这是由于弱实体完全依赖于强实体，强实体不存在，那么弱实体就不存在，所以弱实体是完全参与联系的，<strong>因此弱实体与联系之间的联系也是用的双线菱形</strong>。</p><p>复合实体：复合实体也称联合实体或桥接实体，常常用于实现两个或多个实体间的M：N联系，它由每个关联实体的主玛组成，用长方体内加一个菱形来表示</p><p><a href="https://sm.ms/image/AtzIeaLgbcdrNxX" target="_blank"><img src="https://s2.loli.net/2022/06/26/AtzIeaLgbcdrNxX.png" ></a></p><h1 id="xx2x"><a href="#xx2x" class="headerlink" title="xx2x"></a>xx2x</h1><h1 id="xx3x"><a href="#xx3x" class="headerlink" title="xx3x"></a>xx3x</h1><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;•按照规范设计法，考虑数据库及其应用系统开发全过&lt;br&gt;程，可将数据库设计分为以下六个阶段：&lt;br&gt;• 需求分析阶段&lt;br&gt;  分析用户数据需求与处理需求。&lt;br&gt;• 概念结构设计阶级&lt;br&gt;  对用户需求进行综合、归纳与抽象，形成独立于&lt;br&gt;  具体DBMS的概念模型(E-R图)&lt;br&gt;• 逻辑结构设计阶段&lt;br&gt;  首先将E-R图转换成具体的DBMS支持的数据模型，如关系模型，形成数据库逻辑模式&lt;br&gt;  •然后根据用户处理的要求、安全性的考虑，在基本表的基础上再建立必要的视图(View)，形成数据的外模式&lt;br&gt;• 物理结构设计阶段&lt;br&gt;  为逻辑数据模型选取一个最适合应用环境的物理结构（包括存储结构和存取方法）&lt;br&gt;• 数据库实施阶段&lt;br&gt;  设计人员运用DBMS提供的数据语言及宿主语言，根据逻辑设计和物理设计的结果&lt;br&gt;  •建立数据库&lt;br&gt;  •编制与调试应用程序&lt;br&gt;  •组织数据入库&lt;br&gt;  •并进行试运行&lt;br&gt;• 数据库运行和维护阶段&lt;br&gt;  数据库应用系统经过试运行后即可投入正式运行，在数据库系统运行过程中不断进行评价、调整、修改等维护工作。&lt;br&gt;•需求分析和概念设计独立于任何数据库管理系统&lt;br&gt;•逻辑设计和物理设计与选用的DBMS密切相关&lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="http://akkaduilin.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库" scheme="http://akkaduilin.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="数据库设计" scheme="http://akkaduilin.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>数据库-事务</title>
    <link href="http://akkaduilin.com/2022/06/13/%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/"/>
    <id>http://akkaduilin.com/2022/06/13/%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/</id>
    <published>2022-06-13T08:08:54.000Z</published>
    <updated>2022-06-26T09:26:18.885Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>把多条语句作为一个整体进行操作的功能，被称为数据库事务。数据库事务可以确保该事务范围内的所有操作都可以全部成</p><p>功或者全部失败。如果事务失败，那么效果就和没有执行这些SQL一样，不会对数据库数据有任何改动。</p><p><a href="https://blog.csdn.net/qq_42192693/article/details/109963032">https://blog.csdn.net/qq_42192693/article/details/109963032</a></p><span id="more"></span><h1 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h1><p>数据库事务具有ACID这4个特性：</p><p>A：Atomic，原子性，将所有SQL作为原子工作单元执行，要么全部执行，要么全部不执行；<br>C：Consistent，一致性，事务完成后，所有数据的状态都是一致的，即A账户只要减去了100，B账户则必定加上了100；<br>I：Isolation，隔离性，如果有多个事务并发执行，每个事务作出的修改必须与其他事务隔离；<br>D：Duration，持久性，即事务完成后，对数据库数据的修改被持久化存储。</p><p>对于单条SQL语句，数据库系统自动将其作为一个事务执行，这种事务被称为<strong>隐式事务</strong>。</p><p>要手动把多条SQL语句作为一个事务执行，使用BEGIN开启一个事务，使用COMMIT提交一个事务，这种事务被称为<strong>显式事务</strong></p><h1 id="rollback-commit"><a href="#rollback-commit" class="headerlink" title="rollback/commit"></a>rollback/commit</h1><ol><li><p>使用 <strong>begin + transaction_name</strong> 来创建一个事务</p></li><li><p>commit 指提交事务，即尝试将事务内的SQL做出的修改尝试保存。</p></li><li><p>rollback 指回滚，主动让事务失败，事务内的SQL语句不生效</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BEGIN TRANsaction </span><br><span class="line">     Update student set sage=sage+1 where sno=’0001’</span><br><span class="line">     Select * from student where sno=’0002’</span><br><span class="line"></span><br><span class="line">ROLLBACK  TRANsaction</span><br><span class="line"></span><br><span class="line">commit transaction</span><br></pre></td></tr></table></figure><h1 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h1><p>事务是并发控制的基本单位</p><h2 id="封锁协议"><a href="#封锁协议" class="headerlink" title="封锁协议"></a>封锁协议</h2><p><a href="https://blog.csdn.net/weixin_40448140/article/details/115269643">https://blog.csdn.net/weixin_40448140/article/details/115269643</a></p><p>S锁 - 排他锁、写锁 只允许读取事务和修改数据对象</p><p>X锁 - 共享锁、读锁 只允许读取数据对象但不能修改数据对象</p><p><strong>第一类封锁协议</strong><br>第一类封锁协议指的是在对数据进行修改操作时需要对数据添加X锁.第一类封锁协议相当于把数据的读取和修改看成一个整体,在事务完成之前其他事务都不能对数据进行修改操作.</p><p><strong>第二类封锁协议</strong><br>第二类封锁协议是在第一类封锁协议的基础上加入了S锁.在读取数据前需要对数据添加S锁, 当数据读取完成后释放S锁 .如果一个事务读取数据并添加了S锁,另一个事务添加了X锁,那么添加X锁的那个事务必须等待添加了S锁的事务释放S锁后才能对数据进行修改操作.</p><p><strong>第三类封锁协议</strong><br>第三类封锁协议是在第一类封锁协议的基础上加入了S锁,在读取数据前需要对数据添加S锁, <strong>当事务结束后释放S锁</strong>.第三类封锁协议同时解决了数据的修改丢失,不可重复读和读脏数据问题.</p><h2 id="活锁-死锁"><a href="#活锁-死锁" class="headerlink" title="活锁/死锁"></a>活锁/死锁</h2><p><a href="https://sm.ms/image/DzEbiMu4OVh8XWm" target="_blank"><img src="https://s2.loli.net/2022/06/15/DzEbiMu4OVh8XWm.png" ></a></p><p>避免活锁：采用先来先服务的策略；当多个事务请求封锁同一数据对象时，按请求封锁的先后次序对这些事务排队，该数据对象上的锁一旦释放，首先批准申请队列中第一个事务获得锁。</p><p><a href="https://sm.ms/image/3OpRzWXJSKM4YoP" target="_blank"><img src="https://s2.loli.net/2022/06/15/3OpRzWXJSKM4YoP.png" ></a></p><p>解决死锁方法： 预防死锁（一次性封锁法和顺序封锁法）、诊断死锁并解除（超时法和等待图法）。<br>一次性封锁法：每个事务必须将所要求的数据对象全部上锁后才能执行读写操作，否则释放占用的资源。<br>顺序封锁法：对所有数据对象规定一个封锁顺序，所有事务均按这个顺序实行封锁。</p><h2 id="可串行性"><a href="#可串行性" class="headerlink" title="可串行性"></a>可串行性</h2><p><strong>可串行化调度</strong>：多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行这些事务时的结果相同。</p><p>可串行性是并发事务正确调度的准则，一个给定的并发调度，当且仅当它是可串行化的，才认为是正确调度。对若干个事务，不同的并发调度策略其最终的执行结果不一定完全相同。但只要它们的调度是可串行化的，则都是正确调度。                                                           </p><p><strong>冲突操作</strong>：是指不同的事务对同一数据的读写操作和写写操作。</p><p>一个调度Sc在保证冲突操作的次序不变的情况下，通过交换两个事务不冲突操作的次序得到另一个调度Sc’，如果Sc’是串行的，称调度Sc是<strong>冲突可串行化的调度</strong>。</p><p><strong>冲突可串行化调度是可串行化调度的充分条件</strong>，不是必要条件。还有不满足冲突可串行化条件的可串行化调度。</p><h2 id="两段锁协议"><a href="#两段锁协议" class="headerlink" title="两段锁协议"></a>两段锁协议</h2><p>数据库管理系统普遍采用两段锁协议的方法实现并发调度的可串行性，从而保证调度的正确性</p><p>两段封锁协议（也称两相上锁协议，简写2PL）指所有事务必须分两个阶段对数据项加锁和解锁。</p><p>（1）在对任何数据进行读、写操作之前，事务首先要申请并获得对该数据的封锁（读时S锁，写时X锁）；</p><p>（2）在释放一个封锁之后，事务不再申请和获得新的封锁。</p><p> “两段”锁的含义是事务分为两个阶段</p><p>第一阶段是获得封锁，也称为扩展阶段事务可以申请获得任何数据项上的任何类型的锁，但是不能释放任何锁<br>第二阶段是释放封锁，也称为收缩阶段事务可以释放任何数据项上的任何类型的锁，但是不能再申请任何锁<br>若所有事务都遵守两段封锁协议，则对这些事务的任何并发调度策略都是可串行化的。</p><h2 id="粒度"><a href="#粒度" class="headerlink" title="粒度"></a>粒度</h2><p>封锁的粒度：封锁对象的大小。可以是数据库、表、记录、字段等。</p><p>封锁粒度与系统的并发度和并发控制的开销密切相关。封锁的粒度越大，数据库所能够封锁的数据单元就越少，并发度就越小，系统开销也越小；封锁的粒度越小，并发度较高，但系统开销也就越大。</p><h1 id="数据库恢复"><a href="#数据库恢复" class="headerlink" title="数据库恢复"></a>数据库恢复</h1><p>计算机硬件故障<br>软件的错误<br>操作员的失误<br>恶意的破坏<br>故障的影响<br>运行事务非正常中断，影响数据库中数据的正确性<br>破坏数据库；全部或部分丢失数据</p><h2 id="数据库的恢复"><a href="#数据库的恢复" class="headerlink" title="数据库的恢复"></a>数据库的恢复</h2><p>数据库管理系统必须具有把数据库从错误状态恢复到某一已知的正确状态（亦称为一致状态或完整状态）的功能，这就是数据库的恢复管理系统对故障的对策</p><p>恢复子系统是数据库管理系统的一个重要组成部分<br>恢复技术是衡量系统优劣的重要指标</p><h2 id="故障的种类"><a href="#故障的种类" class="headerlink" title="故障的种类"></a>故障的种类</h2><ol><li>事务内部的故障</li></ol><p>有的是可以通过事务程序本身发现的（转账事务的例子）。有的是非预期的，不能由事务程序处理的。（如运算溢出、并发事务发生死锁而被选中撤销该事务、违反了某些完整性限制等）</p><ol start="2"><li>系统故障</li></ol><p>称为软故障，是指造成系统停止运转的任何事件，使得系统要重新启动。如：整个系统的正常运行突然被破坏、所有正在运行的事务都非正常终止、不破坏数据库、内存中数据库缓冲区的信息全部丢失。常见原因：特定类型的硬件错误（如CPU故障）、操作系统故障、DBMS代码错误、系统断电等。</p><ol start="3"><li>介质故障</li></ol><p>称为硬故障，指外存故障，如：磁盘损坏、磁头碰撞、操作系统的某种潜在错误、瞬时强磁场干扰。介质故障破坏数据库或部分数据库，并影响正在存取这部分数据的所有事务。</p><p>介质故障比前两类故障的可能性小得多，但破坏性大得多。</p><ol start="4"><li>计算机病毒</li></ol><p>一种人为的故障或破坏，是一些恶作剧者研制的一种计算机程序。可以繁殖和传播，造成对计算机系统包括数据库的危害。</p><h2 id="恢复的实现技术"><a href="#恢复的实现技术" class="headerlink" title="恢复的实现技术"></a>恢复的实现技术</h2><p>恢复操作的基本原理：冗余</p><p>利用存储这系统其他地方的冗余数据来重建数据库中已被破坏或不正确的那部分数据</p><p>恢复的实现技术：复杂</p><p>一个大型数据库产品，恢复子系统的代码要占全部代码的10%以上</p><p>恢复机制涉及的关键问题</p><p>如何建立冗余数据（恢复方式）</p><p>数据转储（backup）转储是指DBA将整个数据库复制到磁带或另一个磁盘上保存起来的过程</p><p>备用的数据文本称为后备副本或后援副本</p><p><strong>登录日志文件（logging）日志文件（log）是用来记录事务对数据库的更新操作的文件</strong></p><p>如何利用这些冗余数据实施数据库恢复</p><h2 id="恢复策略"><a href="#恢复策略" class="headerlink" title="恢复策略"></a>恢复策略</h2><ol><li>事务故障：事务在运行至正常终止点前被终止。</li></ol><p>恢复策略：由恢复子系统利用日志文件撤消（ UNDO ）此事务已对数据库进行的修改，使得该事务像根本没有启 动过一样。</p><p>事务故障的恢复由系统自动完成，对用户是透明的，不需要用户干预</p><ol start="2"><li>系统故障 造成数据库不一致状态的原因：</li></ol><p>①未完成事务对数据库的更新已写入数据库</p><p>②已提交事务对数据库的更新还留 在 缓冲区没来得及写入数据库。</p><p>恢复策略：</p><p>①Undo 故障发生时未完成的事务</p><p>②Redo 已完成的事务 系统故障的恢复由系统在 重新启动时 自动完成，不需要用户干预</p><ol start="3"><li>介质故障: 称为硬故障，指外存故障，如：磁盘损坏、磁头碰撞、操作系统的某种潜在错误、瞬时强磁场干扰。</li></ol><p>恢复策略：</p><p>①重装数据库</p><p>②重做已完成的事务</p><p>介质故障的恢复需要 DBA 介入，DBA 的工作</p><p>①重装最近转储的数据库副本和有关的各日志文件副本</p><p>②执行系统 提供的恢复命令。具体的恢复操作仍由 DBMS 完成。</p><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;把多条语句作为一个整体进行操作的功能，被称为数据库事务。数据库事务可以确保该事务范围内的所有操作都可以全部成&lt;/p&gt;
&lt;p&gt;功或者全部失败。如果事务失败，那么效果就和没有执行这些SQL一样，不会对数据库数据有任何改动。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_42192693/article/details/109963032&quot;&gt;https://blog.csdn.net/qq_42192693/article/details/109963032&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="http://akkaduilin.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="SQL" scheme="http://akkaduilin.com/tags/SQL/"/>
    
    <category term="数据库" scheme="http://akkaduilin.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="事务" scheme="http://akkaduilin.com/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>语法制导的翻译</title>
    <link href="http://akkaduilin.com/2022/06/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%9A%84%E7%BF%BB%E8%AF%91/"/>
    <id>http://akkaduilin.com/2022/06/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%9A%84%E7%BF%BB%E8%AF%91/</id>
    <published>2022-06-07T01:19:19.000Z</published>
    <updated>2022-06-19T09:16:15.297Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>将语义分析和中间代码生成统称为语义翻译，而语义翻译和语法分析统称为语法制导翻译</p><p><a href="https://blog.csdn.net/qq_33414271/article/details/95333962">https://blog.csdn.net/qq_33414271/article/details/95333962</a></p><span id="more"></span><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><ol><li>语法制导定义SDD：上下文无关文法+属性+规则</li></ol><p><strong>属性：和文法符号相关联</strong><br>每个文法符号都有一个相关的属性集，属性可以代表任何对象：字符串、数字、类型、内存单元或其他对象。<br>与这些属性相关的信息，即属性值可以在语法分析过程中计算和传递。属性加工的过程即语义的处理过程。</p><p><strong>规则：和产生式相关联</strong></p><ol start="2"><li><p>语法制导翻译方案SDT：文法产生式和语义规则交错<br>把语义规则用{}括起来，插入到规则右部的合适位置上，指明了语义规则的计算顺序，以便说明某些实现细节<br>高效、适合用于翻译的实现，一个语义动作在产生式中的位置决定了这个动作的执行时间<br>可以看作是对SDD的一种补充，是SDD的具体实施方案<br>显式地指明了语义规则的计算顺序，以便说明某些实现细节</p></li><li><p>综合属性<br>在分析树结点N上的非终结符A的综合属性只能通过N的子结点或N本身的属性值来定义<br>产生式 E → E1 + T<br>语义规则 E.val =E1.val + T.val<br><a href="https://sm.ms/image/hF23EsDWfGvrqBH" target="_blank"><img src="https://s2.loli.net/2022/06/17/hF23EsDWfGvrqBH.png" ></a></p></li><li><p>继承属性<br>在分析树结点N上的非终结符A的继承属性只能通过 N的父结点、N的兄弟结点或N本身的属性值来定义 。<br>产生式 D →T L<br>语义规则 L.inh= T.typeL<br><a href="https://sm.ms/image/ZkPwGbjzvAaRChV" target="_blank"><img src="https://s2.loli.net/2022/06/17/ZkPwGbjzvAaRChV.png" ></a><br>终结符没有继承属性。终结符从词法分析器处获得的属性值被归为综合属性值。</p></li><li><p>属性依赖图<br>给定一棵语法分析树和一个SDD，我们在各个语法分析树结点所关联的属性实例之间画上边，以指明位于边的头部的属性值要根据位于边的尾部的属性值计算得到。</p></li></ol><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将语义分析和中间代码生成统称为语义翻译，而语义翻译和语法分析统称为语法制导翻译&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_33414271/article/details/95333962&quot;&gt;https://blog.csdn.net/qq_33414271/article/details/95333962&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="编译原理" scheme="http://akkaduilin.com/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="语法制导翻译" scheme="http://akkaduilin.com/tags/%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>编译原理-语法分析</title>
    <link href="http://akkaduilin.com/2022/06/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/"/>
    <id>http://akkaduilin.com/2022/06/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/</id>
    <published>2022-06-07T01:18:47.000Z</published>
    <updated>2022-06-19T09:16:17.732Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><span id="more"></span><h1 id="上下文无关文法定义"><a href="#上下文无关文法定义" class="headerlink" title="上下文无关文法定义"></a>上下文无关文法定义</h1><p><a href="https://sm.ms/image/PNZyGmSsribpeCa" target="_blank"><img src="https://s2.loli.net/2022/06/17/PNZyGmSsribpeCa.png" ></a></p><p>由上下文无关文法生成的语言是上下文无关语言(CFL)。</p><h2 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h2><p><a href="https://sm.ms/image/PSjsKY7DxWOFQG2" target="_blank"><img src="https://s2.loli.net/2022/06/17/PSjsKY7DxWOFQG2.png" ></a></p><h1 id="语法错误处理机制"><a href="#语法错误处理机制" class="headerlink" title="语法错误处理机制"></a>语法错误处理机制</h1><p>一个文法，如果存在某个句子不止一棵分析树，或者说这个句子存在不止一种最左（最右）推导，那么称这个文法是二义的。</p><p><strong>消除二义性</strong></p><p>改写二义文法的关键步骤：</p><p>划分优先级和结合性<br>引入一个新的非终结符，增加一个子结构并提高一级优先级（优先级的判断）；<br>递归非终结符在终结符左边，运算具有左结合性，否则具有右结合性。</p><p><a href="https://sm.ms/image/t2vFunjK5AhaDVQ" target="_blank"><img src="https://s2.loli.net/2022/06/17/t2vFunjK5AhaDVQ.png" ></a></p><h2 id="消除左递归"><a href="#消除左递归" class="headerlink" title="消除左递归"></a>消除左递归</h2><p><a href="https://blog.csdn.net/qq2071114140/article/details/102787831">https://blog.csdn.net/qq2071114140/article/details/102787831</a></p><p>一个文法是左递归的，如果它有非终结符A，对某个串α，存在推导A =&gt; +Aα。</p><p>自顶向下语法分析不能处理左递归的方法，因此需要一个转换方法消除左递归。</p><p><a href="https://sm.ms/image/Wh7RnfweOJlZzpa" target="_blank"><img src="https://s2.loli.net/2022/06/17/Wh7RnfweOJlZzpa.png" ></a></p><p><a href="https://sm.ms/image/rj9nEzqmkOSKJif" target="_blank"><img src="https://s2.loli.net/2022/06/17/rj9nEzqmkOSKJif.png" ></a></p><p>不是之间左递归则转换为直接左递归</p><p>eg：<br>S → Aa | b<br>A → Aad | bd | ε</p><p>S → Aa | b<br>A → bdA’ | A’<br>A’→ adA’ | ε</p><h1 id="自顶向下语法分析"><a href="#自顶向下语法分析" class="headerlink" title="自顶向下语法分析"></a>自顶向下语法分析</h1><h2 id="first-follow集"><a href="#first-follow集" class="headerlink" title="first/follow集"></a>first/follow集</h2><p><a href="https://blog.csdn.net/RENSRM/article/details/111595754">https://blog.csdn.net/RENSRM/article/details/111595754</a></p><p>FIRST(α)被定义为可从α推导得到的串的首符号的集合，其中α是任意的文法符号串<br><a href="https://sm.ms/image/Cr9wlYHtuSze1da" target="_blank"><img src="https://s2.loli.net/2022/06/17/Cr9wlYHtuSze1da.png" ></a><br><a href="https://sm.ms/image/DzglIiXdoB2QhMH" target="_blank"><img src="https://s2.loli.net/2022/06/17/DzglIiXdoB2QhMH.png" ></a></p><p>FOLLOW(A)被定义为可能在某些举行中紧跟在 A 右边的终结符号的集合。<br><a href="https://sm.ms/image/FjSOXfoWsV6iDPv" target="_blank"><img src="https://s2.loli.net/2022/06/17/FjSOXfoWsV6iDPv.png" ></a><br><a href="https://sm.ms/image/wXo9DnCaky1Kh2E" target="_blank"><img src="https://s2.loli.net/2022/06/17/wXo9DnCaky1Kh2E.png" ></a></p><h2 id="构造预测分析表"><a href="#构造预测分析表" class="headerlink" title="构造预测分析表"></a>构造预测分析表</h2><ol><li>当非终结符遇到其First集中的终结符时填入相应候选式</li><li>当非终结符的First集中含有ε元素时，遇到其Follow集中的终结符时填入 非终结符→ ε </li></ol><p><a href="https://sm.ms/image/DC9vnpNFqImTRGi" target="_blank"><img src="https://s2.loli.net/2022/06/17/DC9vnpNFqImTRGi.png" ></a><br><a href="https://sm.ms/image/3Co6gEQvVdpUfNS" target="_blank"><img src="https://s2.loli.net/2022/06/17/3Co6gEQvVdpUfNS.png" ></a></p><h1 id="自底向上语法分析"><a href="#自底向上语法分析" class="headerlink" title="自底向上语法分析"></a>自底向上语法分析</h1><p><a href="https://blog.csdn.net/qq_44202160/article/details/123145144">https://blog.csdn.net/qq_44202160/article/details/123145144</a><br><a href="https://blog.csdn.net/qq_30225253/article/details/106078803">https://blog.csdn.net/qq_30225253/article/details/106078803</a></p><p><a href="https://sm.ms/image/DEBv1YPoQe8LKRW" target="_blank"><img src="https://s2.loli.net/2022/06/17/DEBv1YPoQe8LKRW.png" ></a></p><h2 id="LR语法分析算法"><a href="#LR语法分析算法" class="headerlink" title="LR语法分析算法"></a>LR语法分析算法</h2><p>输入：一个输入串w和一个LR语法分析表。</p><p>输出：如果w在L(G)中，输出w的自底向上语法分析过程中的归约步骤；否则给出错误提示。</p><p>方法：最初，语法分析器栈中的内容为初试状态S0，输入缓冲区的内容为w $。然后，执行语法分析程序。</p><p><a href="https://sm.ms/image/3CDQ4lIWgakO78G" target="_blank"><img src="https://s2.loli.net/2022/06/17/3CDQ4lIWgakO78G.png" ></a><br><a href="https://sm.ms/image/SjPTMxwNdVRAKlz" target="_blank"><img src="https://s2.loli.net/2022/06/17/SjPTMxwNdVRAKlz.png" ></a></p><p>在当前状态(编号)下, 面对当前文法符号时, 该采取什么动作</p><p>ACTION表指明动作, GOTO表仅用于归约时的状态转换</p><p><a href="https://sm.ms/image/vc3yGxOuZDXCiTd" target="_blank"><img src="https://s2.loli.net/2022/06/17/vc3yGxOuZDXCiTd.png" ></a></p><h2 id="SLR分析表"><a href="#SLR分析表" class="headerlink" title="SLR分析表"></a>SLR分析表</h2><p>在右部的某个地方加点的产生式<br>加点的目的是用来表示分析过程中的状态</p><p>例，从A·XYZ文法可得到如下四个项目;<br>A ·XYZ<br>A -&gt; X·YZ<br>A -&gt; XY·Z<br>A -&gt; XYZ·</p><p>拓广文法<br>如果G是一个以S为开始符号的文法, 那么G的拓广文法G’就是在G中加上新开始符号S’和产生式S’ -&gt; S而得到的文法。</p><p>项集闭包的求法<br>如果I是文法G的一个项集，那么CLOSURE(I)就是根据下面的两个规则从I构造得到的项集:：</p><p>一开始，将I中的各个项加入到CLOSURE(I)中。<br>如果A -&gt; α•Bβ在CLOSURE(I)中，B-&gt;γ是一个产生式，并且B-&gt;•γ不在CLOSURE(I)中，就将这个项加入其中。不断应用这个规则，直至没有新项添加。（大概意思就是如果闭包里如果没有希望识别γ的状态，就添加这个状态）</p><p>构造SLR分析表</p><ol><li>构造LR(0)项目核心规范族</li></ol><p>从增广文法添加的那个文法开始求闭包得到 I0</p><p>在接收符号后 · 向后移一位 得到核心项目 非核心项目通过对核心项目求闭包得到 In</p><p><a href="https://sm.ms/image/5uY9VglcPLXp3D7" target="_blank"><img src="https://s2.loli.net/2022/06/17/5uY9VglcPLXp3D7.png" ></a><br><a href="https://sm.ms/image/yciMVDXSqOn7Qdh" target="_blank"><img src="https://s2.loli.net/2022/06/17/yciMVDXSqOn7Qdh.png" ></a></p><ol start="2"><li>构造分析表<br><a href="https://sm.ms/image/wZS4KlgcLC7FHbU" target="_blank"><img src="https://s2.loli.net/2022/06/17/wZS4KlgcLC7FHbU.png" ></a></li></ol><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="编译原理" scheme="http://akkaduilin.com/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="语法分析" scheme="http://akkaduilin.com/tags/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/"/>
    
    <category term="编译原理" scheme="http://akkaduilin.com/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Java ArrayList</title>
    <link href="http://akkaduilin.com/2022/05/23/ArrayList/"/>
    <id>http://akkaduilin.com/2022/05/23/ArrayList/</id>
    <published>2022-05-23T08:01:07.000Z</published>
    <updated>2022-06-19T09:19:05.631Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>Java ArrayList 方法</p><p>sort函数的一些理解</p><p>Comparator接口的用法</p><span id="more"></span><h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><p>ArrayList是实现List接口的，底层采用数组实现。</p><p>ArrayList 实现了Cloneable接口，即覆盖了函数clone()，能被克隆。</p><p>ArrayList 实现java.io.Serializable接口，这意味着ArrayList支持序列化，能通过序列化去传输。</p><p>头文件<br>import java.util.ArrayList;</p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p><a href="https://blog.csdn.net/ly0724ok/article/details/117966154/">https://blog.csdn.net/ly0724ok/article/details/117966154/</a></p><p><a href="https://sm.ms/image/fOX4cxyuBvkgrKb" target="_blank"><img src="https://s2.loli.net/2022/05/23/fOX4cxyuBvkgrKb.png" ></a></p><h1 id="sort自定义排序"><a href="#sort自定义排序" class="headerlink" title="sort自定义排序"></a>sort自定义排序</h1><p>方法原型<br>void java.util.ArrayList.sort(Comparator&lt;? super Contury&gt; c)</p><p>Comparator接口具有比较的功能，接口注重容器<br>而Comparator接口中必须要实现的compare(T o1,T o2)有两个参数</p><p><strong>在数组sort中实现Comparator接口的重写</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">table.sort( new Comparator&lt;Contury&gt;() &#123;</span><br><span class="line">  @Override</span><br><span class="line">  // compare重写</span><br><span class="line">  public int compare(Contury c1,Contury c2)&#123;</span><br><span class="line">      if(c1.gold&gt;c2.gold)&#123;</span><br><span class="line">          return 0;</span><br><span class="line">      &#125;</span><br><span class="line">      else return -1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>直接重写Comparator接口</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class StudentComparator implements Comparator&lt;Student&gt;&#123;  </span><br><span class="line">    @Override  </span><br><span class="line">    public int compare(Student o1, Student o2) &#123;  </span><br><span class="line">        // TODO Auto-generated method stub  </span><br><span class="line">        if(o1.getScore()&gt;o2.getScore())  </span><br><span class="line">            return -1;  </span><br><span class="line">        else if(o1.getScore()&lt;o2.getScore())  </span><br><span class="line">            return 1;  </span><br><span class="line">        else&#123;  </span><br><span class="line">            if(o1.getAge()&gt;o2.getAge())  </span><br><span class="line">                return 1;  </span><br><span class="line">            else if(o1.getAge()&lt;o2.getAge())  </span><br><span class="line">                return -1;  </span><br><span class="line">            else   </span><br><span class="line">                return 0;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p><a href="https://blog.51cto.com/u_15338614/3582482">https://blog.51cto.com/u_15338614/3582482</a></p><h1 id="xx3x"><a href="#xx3x" class="headerlink" title="xx3x"></a>xx3x</h1><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Java ArrayList 方法&lt;/p&gt;
&lt;p&gt;sort函数的一些理解&lt;/p&gt;
&lt;p&gt;Comparator接口的用法&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="http://akkaduilin.com/categories/Java/"/>
    
    
    <category term="Java - ArrayList - Comparator" scheme="http://akkaduilin.com/tags/Java-ArrayList-Comparator/"/>
    
  </entry>
  
  <entry>
    <title>SQL-触发器</title>
    <link href="http://akkaduilin.com/2022/05/16/SQL-%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
    <id>http://akkaduilin.com/2022/05/16/SQL-%E8%A7%A6%E5%8F%91%E5%99%A8/</id>
    <published>2022-05-16T13:33:46.000Z</published>
    <updated>2022-08-21T11:13:35.324Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>触发器与存储过程非常相似，触发器也是 SQL 语句集，它是通过事件进行触发而被执行的，不能用 EXECUTE 语句调用；而存储过程可以通过存储过程名字而被直接调用。当对某一表进行诸如 UPDATE、INSERT、DELETE 这些操作时，SQL Server 就会自动执行触发器所定义的 SQL 语句，从而确保对数据的处理必须符合由这些 SQL 语句所定义的规则。</p><span id="more"></span><h1 id="DML触发器"><a href="#DML触发器" class="headerlink" title="DML触发器"></a>DML触发器</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ol><li><p>AFTER 触发器<br>又称后触发器。在执行了 INSERT、UPDATE 或 DELETE 语句操作之后执行 AFTER<br>触发器。如果仅指定 FOR 关键字，则 AFTER 为默认值。AFTER 触发器只能在表上指定，<br>可以为任何一个 DML 操作定义多个 AFTER 触发器</p></li><li><p>INSTEAD OF 触发器<br>又称替代触发器。INSTEAD OF 触发器在数据变动之前被触发，代替引起触发器执行<br>的 T-SQL 语句，即 INSTEAD OF 触发器执行时并不执行所定义的 INSERT、UPDATE 或<br>DELETE 操作，而仅执行触发器本身。</p></li></ol><h2 id="相关的逻辑表"><a href="#相关的逻辑表" class="headerlink" title="相关的逻辑表"></a>相关的逻辑表</h2><p>Inserted 表用于存储 INSERT 和 UPDATE 语句所影响的行的副本。在插入或更新事务<br>期间，新行将同时被添加到 Inserted 表和触发器表（即对其尝试执行了用户操作的表）。<br>Inserted 表中的行是触发器表中的新行的副本。<br>Deleted 表用于存储 DELETE 和 UPDATE 语句所影响的行的副本。在执行 DELETE<br>或 UPDATE 语句的过程中，行从触发器表中删除，并传输到 Deleted 表中。Deleted 表和触<br>发器表通常没有相同的行。</p><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER trigger_name </span><br><span class="line">ON &#123; OBJECT NAME &#125; </span><br><span class="line">&#123; FOR → AFTER → INSTEAD OF &#125; </span><br><span class="line">&#123;[INSERT][,][UPFATE][,][DELETE]&#125; </span><br><span class="line"> AS </span><br><span class="line">&#123; sql_statement [ ...n ] &#125;</span><br></pre></td></tr></table></figure><p>1） trigger_name ：指定触发器名称<br>2） OBJECT NAME ：要对其执行 DML 触发器的表或视图<br>3） { FOR → AFTER → INSTEAD OF } ：指定触发器的类型，如果仅指定 FOR 关键<br>字，则 AFTER 是默认值<br>4） {[INSERT][,][UPDATE][,][DELETE]} ：指定激活触发器的数据修改语句，必须至少<br>指定一项，在触发器定义中允许使用上述选项的任意顺序组合。<br>5） sql_statement：指定触发器所指定的 T-SQL 语句。<br>6） 在 DML 触发器中不允许使用下列 Transact-SQL 语句：CREATE /ALTER/ DROP<br>DATABASE、CREATE/DROP INDEX、DROP TABLE；用于执行以下操作的 ALTER TABLE：<br>添加、修改或删除列、添加或删除 PRIMARY KEY 或 UNIQUE 约束。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>创建一个触发器，在修改 SC 表中的 grade 列时，判断平均成绩是否大于 80，<br>如果大于 80，拒绝该修改操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER trgUpdateSC ON dbo.SC</span><br><span class="line">FOR UPDATE</span><br><span class="line">AS</span><br><span class="line">begin</span><br><span class="line">  IF UPDATE (Grade)</span><br><span class="line">    BEGIN</span><br><span class="line">    --判断平均 grade 是否大于 80，如果大于 80，回滚</span><br><span class="line">    if(select avg(Grade) from dbo.SC)&gt;80</span><br><span class="line">      begin</span><br><span class="line">      print &#x27;The average value of Grade cannot be more than 80&#x27;</span><br><span class="line">      rollback</span><br><span class="line">      end</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h1 id="DDL触发器"><a href="#DDL触发器" class="headerlink" title="DDL触发器"></a>DDL触发器</h1><p>DDL 触发器当服务器或者数据库中发生数据定义语言（DDL，CREATE、ALTER 和<br>DROP）事件时将被触发。</p><h2 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER trigger_name </span><br><span class="line">ON &#123; ALL SERVER → DATABASE &#125; </span><br><span class="line">[ WITH &lt;ddl_trigger_option&gt; [ ,...n ] ]</span><br><span class="line">&#123; FOR → AFTER &#125; &#123; event_type → event_group &#125; [ ,...n ]</span><br><span class="line">AS &#123; sql_statement [ ; ] [ ,...n ]&#125;</span><br></pre></td></tr></table></figure><p>1） DATABASE :将 DDL 触发器的作用域应用于当前数据库。如果指定了此参数，则<br>只要当前数据库中出现 event_type 或 event_group，就会激发该触发器。<br>2） ALL SERVER :将 DDL 触发器的作用域应用于当前服务器。如果指定了此参数，<br>则只要当前服务器中的任何位置上出现 event_type 或 event_group，就会激发该触发器。<br>3） event_type ：执行之后将导致激发 DDL 触发器的 T-SQL 语言事件的名称。<br>4） event_group ：预定义的 T-SQL 语言事件分组的名称。执行任何属于 event_group<br>的 T-SQL 语言事件之后，都将激发 DDL 触发器。</p><h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h2><p>为“Music”数据库创建 DDL 触发器，用于禁止对数据库中的表进行删除和修改操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER trg_safe ON DATABASE </span><br><span class="line">FOR DROP_TABLE, ALTER_TABLE </span><br><span class="line">AS </span><br><span class="line">PRINT &#x27;You must disable Trigger &quot; trg_safe&quot; to drop or alter tables!&#x27; </span><br><span class="line">ROLLBACK</span><br></pre></td></tr></table></figure><h1 id="管理触发器"><a href="#管理触发器" class="headerlink" title="管理触发器"></a>管理触发器</h1><h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec sp_helptext trg_delete</span><br></pre></td></tr></table></figure><h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ALTER TRIGGER trigger_name</span><br><span class="line">ON &#123; table → view &#125;</span><br><span class="line">&#123; &#123; FOR → AFTER → INSTEAD OF &#125;</span><br><span class="line">&#123; [DELETE] [,] [INSERT] [,] [UPDATE] &#125;</span><br><span class="line">AS</span><br><span class="line">&#123;sql_statement&#125;&#125;</span><br></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TRIGGER Trg_delete</span><br></pre></td></tr></table></figure><h2 id="禁用"><a href="#禁用" class="headerlink" title="禁用"></a>禁用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1）禁用对表的 DML 触发器</span><br><span class="line">DISABLE TRIGGER trg_delete ON Songs</span><br><span class="line"></span><br><span class="line">2）禁用对数据库的 DDL 触发器</span><br><span class="line">DISABLE TRIGGER trig_DDL ON DATABASE</span><br><span class="line"></span><br><span class="line">3）禁用以同一作用域定义的所有触发器</span><br><span class="line">DISABLE TRIGGER ALL ON ALL SERVER</span><br></pre></td></tr></table></figure><p>禁用之后的启用操作，应该使用语句 ENABLE TRIGGER，该语句的参数与对应的禁用语句相同。</p><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;触发器与存储过程非常相似，触发器也是 SQL 语句集，它是通过事件进行触发而被执行的，不能用 EXECUTE 语句调用；而存储过程可以通过存储过程名字而被直接调用。当对某一表进行诸如 UPDATE、INSERT、DELETE 这些操作时，SQL Server 就会自动执行触发器所定义的 SQL 语句，从而确保对数据的处理必须符合由这些 SQL 语句所定义的规则。&lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="http://akkaduilin.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="SQL" scheme="http://akkaduilin.com/tags/SQL/"/>
    
    <category term="数据库" scheme="http://akkaduilin.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Transact-SQL</title>
    <link href="http://akkaduilin.com/2022/05/13/Transact-SQL/"/>
    <id>http://akkaduilin.com/2022/05/13/Transact-SQL/</id>
    <published>2022-05-13T10:52:21.000Z</published>
    <updated>2022-06-19T10:34:12.106Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>SQL Server 在支持标准 SQL 语言的同时，对其进行了扩充，引入了 T-SQL，即 Transact-SQL。通过 T-SQL，可以定义变量、使用流控制语句、自定义函数和存储过程，极大地扩展了 SQL Server 的功能。</p><span id="more"></span><h1 id="语法约定"><a href="#语法约定" class="headerlink" title="语法约定"></a>语法约定</h1><p><a href="https://sm.ms/image/ul2WgxJFGmYLaAs" target="_blank"><img src="https://s2.loli.net/2022/05/13/ul2WgxJFGmYLaAs.png" ></a></p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>注释语句不是可执行语句，不参与程序的编译、注释语句通常是用来说明代码的功能或<br>者对代码的实现方式给出简单的解释和提示。<br>在 T-SQL 中可使用两类注释符：</p><ol><li>“–”用于单行注释；</li><li>“/* */”用于多行注释。“/<em>”用于注释文字的开头，“</em>/”用于注释文字的结束。</li></ol><h1 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h1><p>SQL Server 有两类标识符：<br>1）常规标识符：符合标识符的格式规则。在 T-SQL 语句中使用常规标识符时不用将其<br>分隔开。<br><strong>常规标识符的定义规则如下：</strong><br>  1） 名称的长度可以从 1 到 128（对于本地临时表，标识符最多可以有 116 个字符）。<br>  2） 名称的第一个字符必须是一个字母或者“_”、“@”和“#”中的任意字符。<br>  3） 在中文版 SQL Server 中，可以直接使用中文名称。<br>  4） 名称中不能有空格<br>  5） 不允许使用 SQL Server 的保留字。<br>2）分隔标识符：在 T-SQL 中，不符合常规标识符定义规则的标识符必须用分隔符双引<br>号 (“) 或者方括号 ([ ])分隔，称为分隔标识符。例如：Select * from [my table]中，因为“my<br>table”中间含有空格，不符合常规标识符的定义规则，因此必须用分隔符 ([ ])进行分隔。</p><p><strong>使用</strong><br>[[[server.][database].][owner_name].] object_name<br>1）server：本地服务器；<br>2）database：当前数据库；<br>3）owner_name：在数据库中与当前连接会话登录标识相关联的数据库用户名或数据库<br>所有者（dbo）。<br>例如，需要引用 customer 数据库中 employee 表的 telephone 列，可指定 customer..<br>employee.telephone。</p><h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><ol><li><p>字符串<br>单引号内</p></li><li><p>Unicode字符串<br>与普通字符串类似，前面有N标识</p></li><li><p>二进制常量<br>前有 0x 标识</p></li><li><p>datetime 常量<br>datetime 常量使用特定格式的字符日期值来表示，并被单引号括起来。<br>下面是 datetime 常量的示例：<br>‘December 5, 1985’； ‘5 December, 1985’； ‘12/5/98’<br>‘851205’（其中的 0 不能省略）<br>下面是时间常量的示例：’14:30:24’； ‘04:24 PM’</p></li><li><p>int<br>不包含小数</p></li><li><p>decimal<br>包含小数点的数字</p></li><li><p>float/real<br>科学计数法表示</p></li><li><p>money<br>money 常量以前缀为可选的小数点和可选的货币符号的数字字符串来表示。money 常<br>量不使用引号括起。money 常量的示例：$542023.14，￥30。</p></li></ol><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>声明变量：<br>DECLARE @变量名 变量类型[,@变量名 变量类型…]</p><p>赋值：<br>SET @变量名=表达式<br>或：SELECT @局部变量=变量值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DECLARE @no varchar(10) </span><br><span class="line">--变量赋值</span><br><span class="line">SET @no=&#x27;Bj10001&#x27; </span><br><span class="line">--显示指定学生学号、姓名 </span><br><span class="line">SELECT Sid,Sname FROM student WHERE SID=@no</span><br></pre></td></tr></table></figure><p>全局变量是 SQL Server 系统内部使用的变量，其作用范围并不局限于某一程序，而是<br>任何程序均可随时调用。<br>格式：@@变量名。<br><a href="https://sm.ms/image/muU79kRgsFht4bn" target="_blank"><img src="https://s2.loli.net/2022/05/13/muU79kRgsFht4bn.png" alt="image.png"></a></p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><ol><li><p>ASCII 函数<br>函数格式：<br>ASCII（character_expression）<br>功能：求 character_expression（char 或 varchar 类型）左端第一个字符的 ASCII 码。<br>返回值数据类型：int。例如：<br>Select ASCII（’abcd’） –结果为字符 a 的 ASCII 码 97。</p></li><li><p>CHAR 函数<br>函数格式：<br>CHAR（integer_expression）<br>功能：求 ASCII 码 integer_expression 对应的字符，<br>integer_expression 的有效范围为[0,255]，如果超出范围，则返<br>回值 NULL。<br>返回值数据类型：CHAR。例如：<br>Select CHAR（97） –结果为’a’。<br>CHAR 可用于将控制字符插入字符串中。表 9- 8 显示了<br>一些常用的控制字符。<br>例9- 6: 使用回车符。<br>select ‘<strong>‘+char(13)+’</strong>*’<br>结果如图 9- 1 所示（注意，显示该结果时，在查询编辑器中，<br>需在查询工具栏选择“以文本格式显示结果”）。</p></li><li><p>UNICODE 函数<br>语法:<br>UNICODE ( ‘ncharacter_expression’ )<br>功能：按照 Unicode 标准的定义，返回输入表达式的第一个字<br>符的整数值。<br>返回类型：int。例如：<br>Select unicode(N’kerge’) –返回字符 k 的 unicode 值 107</p></li><li><p>NCHAR 函数<br>语法：NCHAR ( integer_expression )<br>功能: 根据 Unicode 标准所进行的定义，用给定整数代码返回 Unicode 字符。<br>integer_expression 介于 0 与 65535 之间的所有正整数。如果指定了超出此范围的值，将返<br>回 NULL。<br>返回类型：nchar(1)。例如：<br>select nchar(107) –返回 unicode 字符 k</p></li><li><p>CHARINDEX 函数<br>函数格式：<br>CHARINDEX（expression1, expression2[,start]）<br>功能：在 expression2 中由 start 指定的位置开始查找 expression1 第一次出现的位置，如<br>表 9- 8 控制字符及值<br>控制字符 值<br>制表符 CHAR(9)<br>换行符 CHAR(10)<br>回车 CHAR(13)<br>图 9- 1 char 函数示例<br>果没有找到，则返回 0。如果省略 start，或 start≤0，则从 expression2 的第一个字符开始。<br>返回类型：int。例如：<br>Select CHARINDEX(‘ab’, ‘123abc123abc’) –结果为 4。</p></li><li><p>LEFT 函数<br>函数格式：<br>LEFT（expression1,n）<br>功能：返回字符串 expression1 从左边开始 n 个字符组成的字符串。如果 n=0，则返回一<br>个空字符串。<br>返回类型：varchar。例如：<br>LEFT(‘abcde’, 3) –结果为’abc’。 例 9- 7：找出 dbo.student 中名字以’刘’开头的学生信息。<br>select sno,sname from dbo.student where left(sname,1)=’刘’</p></li><li><p>RIGHT 函数<br>函数格式：<br>RIGHT（expression1,n）<br>功能：返回字符串 expression1 从右边开始 n 个字符组成的字符串。如果 n=0，则返回一<br>个空字符串。<br>返回类型：varchar。例如：<br>Select RIGHT(‘abcde’, 3) –结果为’cde’。</p></li><li><p>SUBSTRING 函数<br>函数格式：<br>SUBSTRING（expression1,start,length）<br>功能：返回 expression1（数据类型为字符串、binary、text 或 image）中从 start 开始长<br>度为 length 个字符或字节的子串。<br>返回值：数据类型与 expression1 数据类型相同，但 text 类型返回值为 varchar，image 类<br>型返回值为 varbinary，next 类型返回值为 nvarchar。例如：<br>Select SUBSTRING(‘abcde123’,3,4) –结果为’cde1’。 例 9- 7 也可以写成：<br>select sno,sname from dbo.student where substring(sname,1,1)=’刘’</p></li><li><p>LEN 函数<br>函数格式：<br>LEN（expression1）<br>功能：返回字符串 expression1 中的字符个数，不包括字符串末尾的空格。<br>返回类型：int。例如：<br>Select LEN(‘abcde ‘) –结果为 5。<br>select len(‘刘’) –结果为 1。</p></li><li><p>DATALENGTH 函数<br>DATALENGTH ( expression )<br>功能：返回用于表示任何表达式的字节数。<br>返回类型：int。例如：<br>Select DATALENGTH(‘abcde ‘) –结果为 8（含 3 个空格）。<br>select DATALENGTH(‘刘’) –结果为 2。</p></li><li><p>LOWER 函数<br>函数格式：<br>LOWER（expression1）<br>功能：将字符串 expression1 中的大写字母替换为小写字母。<br>返回类型：varchar。例如：<br>Select LOWER(‘12ABC45*%^def’) –结果为’12abc45*%^def’。</p></li><li><p>UPPER 函数<br>函数格式：<br>UPPER（expression1）<br>功能：将字符串 expression1 中的小写字母替换为大写字母。<br>返回类型：varchar。例如：<br>Select UPPER(‘12ABC45*%^def’) –结果为’12ABC45 *%^DEF’。</p></li><li><p>LTRIM 函数<br>函数格式：<br>LTRIM（expression1）<br>功能：删除字符串 expression1 左端的空格。<br>返回类型：varchar。例如：<br>Select LTRIM(‘ 12AB’) –结果为’12AB’。</p></li><li><p>RTRIM 函数<br>函数格式：<br>RTRIM（expression1）<br>功能：删除字符串 expression1 末尾的空格。<br>返回类型：varchar。例如：<br>Select RTRIM(LTRIM(‘ 12AB ‘)) –结果为’12AB’。</p></li><li><p>REPLACE 函数<br>函数格式：<br>REPLACE（expression1, expression2, expression3）<br>功能：将字符串 expression1 中所有的子字符串 expression2 替换为 expression3。<br>返回值数据类型：varchar。例如：<br>Select REPLACE(‘abcde’,’de’,’12’) –结果为’abc12’。</p></li><li><p>STUFF 函数<br>语法:<br>STUFF (character_expression,start,length,character_expression )<br>功能：删除指定长度的字符并在指定的起始点插入另一组字符。<br>返回类型:如果 character_expression 是一个支持的字符数据类型，则返回字符数据。<br>例如：<br>Select STUFF(‘abcde’,4,2,’12’) –结果为’abc12’。</p></li><li><p>REVERSE 函数<br>函数格式：<br>REVERSE（expression1）<br>功能：按相反顺序返回字符串 expression1 中的字符。<br>返回值数据类型：varchar。例如：<br>Select REVERSE (‘edcba’) –结果为 abcde。</p></li><li><p>SPACE 函数<br>函数格式：<br>SPACE（n）<br>功能：返回包含 n 个空格的字符串，如果 n 为负数，则返回一个空字符串。<br>返回值数据类型：char。</p></li><li><p>STR 函数<br>函数格式：<br>STR（expression1[,length[,decimal]]）<br>功能：将数字数据转换为字符数据。length 为转换得到的字符串总长度，包括符号、小<br>数点、数字或空格。如果数字长度不够，则在左端加入空格补足长度，如果小数部分超过总<br>长度，则进行四舍五入，length 的默认值为 10，decimal 为小数位位数。<br>返回值数据类型：char。例如：<br>select str(123,6) –结果为’ 123’<br>select str(123.456,5) –结果为’ 123’<br>select str(123.456,5,2) –结果为’123.5’<br>select str(123.456,8,2) –结果为’ 123.46’</p></li><li><p>REPLICATE(character_expression,times)<br>语法：<br>REPLICATE(character_expression,times)<br>功能：返回多次复制后的字符表达式。times 参数的计算结果必须为整数。例如：<br>select replicate(‘<em>‘,3) –返回‘</em><em><em>’ 例 9- 8：以“</em>”方式输出菱形。<br>输出结果见 图 9- 2（在查询编辑器中以文本格式显示结果）。<br>declare @i int<br>set @i=1<br>while @i&lt;=4<br>begin<br>print space(4-@i)+<br>replicate(‘<em>‘,2</em>@i-1)<br>set @i=@i+1<br>end<br>set @i=1<br>while @i&lt;=3<br>begin<br>print space(@i)+replicate(‘*’,7-2</em>@i)<br>set @i=@i+1<br>end</p></li><li><p>CAST 函数<br>功能：将一种数据类型的表达式转换为另一种数据类型的表达式。<br>语法：<br>CAST ( expression AS data_type [ (length ) ])<br>例：</p></li></ol><p>–将日期时间类型转换为 char 类型<br>select cast(‘2010-3-2’ as char(10))</p><ol start="22"><li><p>CONVERT 函数<br>CONVERT 函数将一种数据类型的表达式转换为另一种数据类型的表达式。<br>语法：<br>CONVERT ( data_type [ ( length ) ] , expression [ , style ] )</p></li><li><p>ISDATE 函数<br>语法：<br>ISDATE( expression )<br>功能：如果 expression 是 datetime 或 smalldatetime 数据类型的有效日期或时间值，则<br>返回 1；否则，返回 0。例如：<br>select ISDATE(‘2009/2/29’) –返回 0</p></li><li><p>ISNULL ( check_expression , replacement_value )<br>语法：<br>ISNULL ( check_expression , replacement_value )<br>功能：如果 check_expression 不为 NULL，则返回它的值；否则，在将 replacement_value<br>隐式转换为 check_expression 的类型（如果这两个类型不同）后，则返回前者。例如：</p></li></ol><p>–如果成绩为 NULL，替换为 0<br>select grade as 成绩,ISNULL(grade,0) as ISNULL_结果 from sc</p><ol start="25"><li><p>NULLIF 函数<br>NULLIF ( expression , expression )<br>功能：如果两个指定的表达式相等，则返回空值。</p></li><li><p>ISNUMERIC 函数<br>语法：<br>ISNUMERIC ( expression )<br>功能：确定表达式是否为有效的数值类型。</p></li></ol><h2 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h2><ol><li>GETDATE 函数<br>函数格式：<br>图 9- 2 输出菱形<br>GETDATE（）<br>功能：按 SQL Server 内部标准格式返回系统日期和时间。<br>返回值数据类型：datetime。例如：<br>Select getdate() –结果为 2012-08-13 21:51:32.390</li><li>YEAR 函数<br>函数格式：<br>YEAR（date）<br>功能：返回指定日期 date 中年的整数。<br>返回值数据类型：int。例如：<br>Select year(‘2004-3-5’) –结果为 2004<br>例 9- 9：返回学生表中学生的年龄。<br>select sname as 学号, BirthDate as 出生日期,<br>YEAR(getdate())-YEAR(birthdate) as 年龄<br>from dbo.student<br>结果见图 9- 3 所示。</li><li>MONTH 函数<br>函数格式：<br>MONTH（date）<br>功能：返回指定日期 date 中月份的整数。<br>返回值数据类型：int。例如：<br>Select month(‘2004-3-5’) –结果为 3</li><li>DAY 函数<br>函数格式：<br>DAY（date）<br>功能：返回指定日期 date 中天的整数。<br>返回值数据类型：int。例如：<br>Select day(‘2004-3-5’) –结果为 5</li><li>DATENAME 函数<br>函数格式：<br>DATENAME（datepart,date）<br>功能：返回日期 date 中由 datepart 指定的日期部分的字符串。<br>返回类型：nvarchar。</li><li>DATEPART 函数<br>函数格式：<br>DATEPART（dateprrt,date）<br>功能：与 DATENAME 类似，只是返回值为整数。<br>返回值数据类型：int。</li><li>DATEADD 函数<br>函数格式：<br>DATEADD（dateprrt,n,date）<br>功能：在 date 指定日期时间的 datepart 部分加上 n，得到一个新的日期时间值。<br>返回值数据类型：datetime，如果参数 date 为 smalldatetime，则返回值为 smalldatetime<br>类型。参数 datepart 可以使用如表 9- 9 所示中的短语或缩写。例如：<br>Select dateadd(yy,2,’2012-3-4’) –结果为’2014-03-04 00:00:00.000’<br>Select dateadd(m,2,’2012-3-4’) –结果为’2012-05-04 00:00:00.000’<br>Select dateadd(d,2,’2012-3-4’) –结果为’2012-03-06 00:00:00.000’</li><li>DATEDIFF 函数<br>格式：<br>DATEDIFF ( datepart , startdate , enddate )<br>功能：返回指定的 startdate 和 enddate 之间所跨的指定 datepart 边界的计数（带符号<br>的整数）。<br>例 9- 9：返回学生表中学生的年龄。<br>select sname as 学号, BirthDate as 出生日期,<br>DATEDIFF(yy, birthdate,getdate()) as 年龄 from dbo.student</li></ol><p>datepart可选参数<br>日期部分 缩写 日期部分 缩写<br>年份 yy、yyyy 工作日 dw<br>季度 qq、q 小时 hh<br>月份 mm、m 分钟 mi、n<br>每年的某一日 dy、y 秒 ss、s<br>图 9- 3 YEAR 函数示例<br>日期 dd、d 毫秒 ms<br>星期 wk、ww 工作日 dw</p><h1 id="批处理和流程控制语句"><a href="#批处理和流程控制语句" class="headerlink" title="批处理和流程控制语句"></a>批处理和流程控制语句</h1><h2 id="IF…ELSE-语句"><a href="#IF…ELSE-语句" class="headerlink" title="IF…ELSE 语句"></a>IF…ELSE 语句</h2><ol><li>如果满足条件，则在 IF 关键字及其条件之后执行<br>T-SQL 语句。可选的 ELSE 关键字引入另一个 T-SQL 语句，当不满足 IF 条件时就执行该<br>语句。</li><li>在实际程序中，IF…ELSE 语句中不止包含一条语句，而是一组的 SQL 语句。为了可以<br>一次执行一组 SQL 语句，这时就需要使用 BEGIN…END 语句将多条语句封闭起来。</li></ol><p>eg 查找学号为 200215121 的成绩。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">DECLARE @message varchar(255),@grade_num int</span><br><span class="line">--得到 200215121 号同学的选修课程的数目</span><br><span class="line">SELECT @grade_num=COUNT(grade) FROM sc </span><br><span class="line">WHERE sno=&#x27;200215121&#x27;</span><br><span class="line">IF @grade_num=0</span><br><span class="line"> BEGIN</span><br><span class="line">  SET @message= &#x27;没有学生 200215121 的成绩&#x27;</span><br><span class="line">  PRINT @message</span><br><span class="line"> END</span><br><span class="line">ELSE</span><br><span class="line"> BEGIN</span><br><span class="line">  SET @message= &#x27;有学生 200215121 的&#x27;</span><br><span class="line">  + convert(char(2),@grade_num)+ &#x27;门课程的成绩。&#x27;</span><br><span class="line">  PRINT @message</span><br><span class="line"> END</span><br><span class="line">SET @message=&#x27;课程号查询完毕&#x27;</span><br><span class="line">PRINT @message</span><br><span class="line">GO</span><br></pre></td></tr></table></figure><h2 id="CASE-分支语句"><a href="#CASE-分支语句" class="headerlink" title="CASE 分支语句"></a>CASE 分支语句</h2><p>CASE 关键字可根据表达式的真假来确定是否返回某个值，可在允许使用表达式的任意<br>位置使用这一关键字。<br>eg 为学生表的每个院系添加说明。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT sname AS 学号,sdept AS 院系, &#x27;院系说明&#x27;=</span><br><span class="line">CASE sdept</span><br><span class="line">  --分别为各个院系添加说明</span><br><span class="line">  WHEN &#x27;IS&#x27; THEN &#x27;属于信息系&#x27;</span><br><span class="line">  WHEN &#x27;MA&#x27; THEN &#x27;属于数学院&#x27;</span><br><span class="line">  WHEN &#x27;CS&#x27; THEN &#x27;属于计算机科学与技术学院&#x27;</span><br><span class="line">ELSE &#x27;其他院系&#x27;</span><br><span class="line">END </span><br><span class="line">FROM student ORDER BY sname --按照姓名排序</span><br></pre></td></tr></table></figure><h2 id="WHILE-语句"><a href="#WHILE-语句" class="headerlink" title="WHILE 语句"></a>WHILE 语句</h2><p>设置重复执行 SQL 语句或语句块的条件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">WHILE 逻辑表达式</span><br><span class="line">Begin</span><br><span class="line"> T-SQL 语句组</span><br><span class="line">[break] /*终止整个语句的执行*/</span><br><span class="line">[continue] /*结束一次循环体的执行*/</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p>eg 求 1 到 10 之间偶数的和。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">DECLARE @i smallint,@sum smallint</span><br><span class="line">SET @i=0</span><br><span class="line">SET @sum=0</span><br><span class="line">WHILE @i&gt;=0</span><br><span class="line">BEGIN</span><br><span class="line"> SET @i=@i+1</span><br><span class="line"> IF @i&gt;10</span><br><span class="line"> BEGIN</span><br><span class="line">SELECT &#x27;1 到之间偶数的和&#x27;=@sum</span><br><span class="line"> BREAK</span><br><span class="line"> END</span><br><span class="line"> IF (@i%2)!=0</span><br><span class="line"> CONTINUE</span><br><span class="line"> ELSE</span><br></pre></td></tr></table></figure><h2 id="GOTO-语句"><a href="#GOTO-语句" class="headerlink" title="GOTO 语句"></a>GOTO 语句</h2><p>GOTO 语句将执行语句无条件跳转到标签处，并从标签位置继续处理。GOTO 语句和标<br>签可在过程、批处理或语句块中的任何位置使用。其语法格式为：<br>GOTO label</p><h2 id="WAITFOR-语句"><a href="#WAITFOR-语句" class="headerlink" title="WAITFOR 语句"></a>WAITFOR 语句</h2><p>WAITFOR 语句，称为延迟语句，就是暂停执行一个指定的时间间隔或者到一个指定的时间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">WAITFOR </span><br><span class="line">&#123; </span><br><span class="line">DELAY &#x27;time_to_pass&#x27; /* 设定等待时间 */</span><br><span class="line"></span><br><span class="line">| TIME &#x27;time_to_execute&#x27; /* 设定等待到某一时刻 */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">延迟 30 秒执行查询。</span><br><span class="line">WAITFOR DELAY &#x27;00:00:30&#x27;</span><br><span class="line">SELECT * FROM student</span><br></pre></td></tr></table></figure> <h2 id="TRY-CATCH"><a href="#TRY-CATCH" class="headerlink" title="TRY-CATCH"></a>TRY-CATCH</h2><p>TRY 块包含一组 T-SQL 语句。如果 TRY 块的语句中发生任何错误，控制将传递给CATCH 块。CATCH 块包含另外一组语句，这些语句在错误发生时执行。如果 TRY 块中没有错误，控制将传递到关联的 END CATCH 语句后紧跟的语句。如果 END CATCH 语句是存储过程或触发器中的最后一条语句，控制将传递到调用该存储过程或触发器的语句。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">BEGIN TRY </span><br><span class="line">&#123; sql_statement | statement_block &#125; </span><br><span class="line">END TRY</span><br><span class="line">BEGIN CATCH </span><br><span class="line">&#123; sql_statement | statement_block &#125; </span><br><span class="line">END CATCH [ ; ]</span><br><span class="line"></span><br></pre></td></tr></table></figure> <h2 id="Raiserror"><a href="#Raiserror" class="headerlink" title="Raiserror"></a>Raiserror</h2><p>有时会遇到 SQL SERVER 实际并不知道的一些错误，但我们希望能在客户端产生运行错误，而客户端使用的时候能够唤醒异常处理并进行相应的处理。RAISERROR 生成的错误与数据库引擎代码生成的错误的运行方式相同。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">RAISERROR(&lt;message ID | message_string&gt;, &lt;severity #级别 &gt;,&lt;state #状态 &gt; [,&lt;argument&gt; </span><br><span class="line">[,&lt;…n&gt;]]) </span><br><span class="line">[WITH option[,…n]]</span><br></pre></td></tr></table></figure><h1 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h1><p>游标（Cursor）是一种从包括多条数据记录的结果集中每次提取一条记录以便处理的机<br>制，可以看做是查询结果的记录指针。<br><strong>游标的作用：</strong><br>1） 允许定位在结果集的特定行。<br>2） 从结果集的当前位置检索一行或一部分行。<br>3） 支持对结果集中当前位置的行进行数据修改。<br>4） 为由其他用户对显示在结果集中的数据所做的更改提供不同级别的可见性支持。<br>5） 提供脚本、存储过程和触发器中用于访问结果集中的数据的 T-SQL 语句。</p><p><strong>@@FETCH_STATUS 全局变量</strong>返回上次执行 FETCH 命令的状态。在每次用 FETCH 从<br>游标中读取数据时，都应检查该变量，以确定上次 FETCH 操作是否成功，来决定如何进行<br>下一步处理。@@FETCH_STATUS 变量有三个不同的返回值: 1）返回值为 0，说明 FETCH 语句成功。<br>2）返回值为-1，说明 FETCH 语句失败或行不在结果集中。<br>3）返回值为-2，说明提取的行不存在。</p><p>利用游标将成绩表（SC）中不及格的成绩改为 60 分。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">--声明变量</span><br><span class="line">declare @v_sno varchar(10),</span><br><span class="line">@v_cno varchar(10),@v_grade int</span><br><span class="line">--声明游标</span><br><span class="line">declare cur scroll cursor</span><br><span class="line">for select sno,cno,grade from sc</span><br><span class="line">--打开游标</span><br><span class="line">open cur</span><br><span class="line">--取出第一行记录</span><br><span class="line">fetch next from cur into @v_sno,@v_cno,@v_grade</span><br><span class="line">--循环取值</span><br><span class="line">while @@FETCH_STATUS=0</span><br><span class="line">begin</span><br><span class="line">--判断当前记录的成绩值</span><br><span class="line">if @v_grade&lt;60</span><br><span class="line"> begin </span><br><span class="line">--显示修改前的成绩</span><br><span class="line"> select sno as 学号,cno as 课程号,grade as 更改前的成绩</span><br><span class="line"> from sc where sno=@v_sno and cno=@v_cno</span><br><span class="line">--修改游标所在行的成绩</span><br><span class="line">update sc set grade=60 where current of cur</span><br><span class="line">--显示修改后的成绩</span><br><span class="line"> select sno as 学号,cno as 课程号,grade as 更改后的成绩</span><br><span class="line"> from sc where sno=@v_sno and cno=@v_cno</span><br><span class="line"> end</span><br><span class="line">--取下一行记录</span><br><span class="line">fetch next from cur into @v_sno,@v_cno,@v_grade</span><br><span class="line">end</span><br><span class="line">--关闭游标</span><br><span class="line">close cur</span><br><span class="line">--释放游标</span><br><span class="line">deallocate cur</span><br></pre></td></tr></table></figure><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SQL Server 在支持标准 SQL 语言的同时，对其进行了扩充，引入了 T-SQL，即 Transact-SQL。通过 T-SQL，可以定义变量、使用流控制语句、自定义函数和存储过程，极大地扩展了 SQL Server 的功能。&lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="http://akkaduilin.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="SQL" scheme="http://akkaduilin.com/tags/SQL/"/>
    
    <category term="数据库" scheme="http://akkaduilin.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理-运算方法</title>
    <link href="http://akkaduilin.com/2022/04/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/"/>
    <id>http://akkaduilin.com/2022/04/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/</id>
    <published>2022-04-24T06:25:34.000Z</published>
    <updated>2022-06-19T09:17:19.612Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>计算机组成与结构课程笔记</p><span id="more"></span><h1 id="原码、反码、补码"><a href="#原码、反码、补码" class="headerlink" title="原码、反码、补码"></a>原码、反码、补码</h1><ol><li>原码<br>原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:</li></ol><p>[+1]原 = 0000 0001</p><p>[-1]原 = 1000 0001</p><p>第一位是符号位. 因为第一位是符号位, 所以8位二进制数的取值范围就是:</p><p>[1111 1111 , 0111 1111]</p><p>即</p><p>[-127 , 127]</p><p>原码是人脑最容易理解和计算的表示方式.</p><ol start="2"><li>反码<br>反码的表示方法是:</li></ol><p>正数的反码是其本身</p><p>负数的反码是在其原码的基础上, 符号位不变，其余各个位取反.</p><p>[+1] = [00000001]原 = [00000001]反</p><p>[-1] = [10000001]原 = [11111110]反</p><p>可见如果一个反码表示的是负数, 人脑无法直观的看出来它的数值. 通常要将其转换成原码再计算.</p><ol start="3"><li>补码<br>补码的表示方法是:</li></ol><p>正数的补码就是其本身</p><p>负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)</p><p>[+1] = [00000001]原 = [00000001]反 = [00000001]补</p><p>[-1] = [10000001]原 = [11111110]反 = [11111111]补</p><p>对于负数, 补码表示方式也是人脑无法直观看出其数值的. 通常也需要转换成原码在计算其数值.</p><h1 id="加减法溢出处理"><a href="#加减法溢出处理" class="headerlink" title="加减法溢出处理"></a>加减法溢出处理</h1><p><a href="https://sm.ms/image/nNip3D4zq6t8CIX" target="_blank"><img src="https://s2.loli.net/2022/04/25/nNip3D4zq6t8CIX.png" ></a></p><p>fa fb 两操作数的符号位<br>Cf 为符号位的进位<br>C 为数值最高位的进位</p><ol><li>符号相同，结果符号位与加数符号位不同，溢出</li><li>任意符号两数相加，Cf 不等于 C 溢出</li><li>双符号位f1 f2 正数为00 负数为11 符号位参与运算 结果 f1 f2 不相等，溢出<br><a href="https://sm.ms/image/Mc7uPzleO1vfNSR" target="_blank"><img src="https://s2.loli.net/2022/04/25/Mc7uPzleO1vfNSR.png" ></a></li></ol><h1 id="乘法、除法"><a href="#乘法、除法" class="headerlink" title="乘法、除法"></a>乘法、除法</h1><h2 id="定点乘法"><a href="#定点乘法" class="headerlink" title="定点乘法"></a>定点乘法</h2><ol><li><p>手工算法<br><a href="https://sm.ms/image/OYLmCwtvenBGKX4" target="_blank"><img src="https://s2.loli.net/2022/04/25/OYLmCwtvenBGKX4.png" ></a></p></li><li><p>定点原码一位乘法<br><a href="https://sm.ms/image/4VhK8T6pauRebyw" target="_blank"><img src="https://s2.loli.net/2022/04/25/4VhK8T6pauRebyw.png" ></a></p></li><li><p>定点补码一位乘法<br>布斯算法<br><a href="https://blog.csdn.net/qq_41844076/article/details/109594076">https://blog.csdn.net/qq_41844076/article/details/109594076</a></p></li></ol><h2 id="定点除法"><a href="#定点除法" class="headerlink" title="定点除法"></a>定点除法</h2><ol><li><p>手工算法<br><a href="https://sm.ms/image/5KX1bTh2tz9Ovj4" target="_blank"><img src="https://s2.loli.net/2022/04/25/5KX1bTh2tz9Ovj4.png" ></a></p></li><li><p>加减交替法<br><a href="https://sm.ms/image/w9F68ncKEaPxBUg" target="_blank"><img src="https://s2.loli.net/2022/04/25/w9F68ncKEaPxBUg.png" ></a></p></li></ol><h1 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h1><p><a href="http://kaito-kidd.com/2018/08/08/computer-system-float-point/">http://kaito-kidd.com/2018/08/08/computer-system-float-point/</a></p><p><a href="https://sm.ms/image/LiutGTOhM2p89Pq" target="_blank"><img src="https://s2.loli.net/2022/04/25/LiutGTOhM2p89Pq.png" ></a></p><p>Ms 为符号位 0正1负<br>E 为阶码 8位以2为底，阶码 = 阶码真值 + 127<br>M 为尾数 23位，采用隐含尾数最高位1的表示方法，<br>实际尾数24位，尾数真值 = 1 + 尾数</p><p>单精度浮点数 float：32 位，符号位 Ms 占 1 bit，指数 E 占 8 bit，尾数 M 占 23 bit<br>双精度浮点数 float：64 位，符号位 Ms 占 1 bit，指数 E 占 11 bit，尾数 M 占 52 bit</p><p><a href="https://sm.ms/image/wSd3TPiebLayWMI" target="_blank"><img src="https://s2.loli.net/2022/04/25/wSd3TPiebLayWMI.png" ></a></p><h2 id="移码"><a href="#移码" class="headerlink" title="移码"></a>移码</h2><p>阶码采用移码<br>尾数采用原码或补码</p><p>移码：<br><strong>补码的符号位取反</strong><br>最高位为符号位<br>只执行加减运算，加以2^n的修正量<br><a href="https://sm.ms/image/2o4zguAIMrUP7lN" target="_blank"><img src="https://s2.loli.net/2022/04/25/2o4zguAIMrUP7lN.png" ></a><br><a href="https://sm.ms/image/IAx7zFtaqHSn4TP" target="_blank"><img src="https://s2.loli.net/2022/04/26/IAx7zFtaqHSn4TP.png" ></a></p><h2 id="精度、范围"><a href="#精度、范围" class="headerlink" title="精度、范围"></a>精度、范围</h2><p><a href="https://blog.csdn.net/l1028386804/article/details/113065755">https://blog.csdn.net/l1028386804/article/details/113065755</a></p><p><a href="https://sm.ms/image/UG82NABqjEu1tKp" target="_blank"><img src="https://s2.loli.net/2022/04/25/UG82NABqjEu1tKp.png" ></a></p><p>单精度浮点数 32 位<br>符号位1位，阶码8位，尾数23位。<br>精度24位，范围 -2^127 - (1-(2^-23))*2^127</p><h2 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h2><ol><li><p>对阶</p></li><li><p>尾数的计算(加减乘除)</p></li><li><p>规格化处理<br>如果<strong>结果的两个符号位的值不同</strong>,表示运算尾数结果溢出,应“右规”,即尾数结果右移一位,阶码+1。</p></li></ol><p>如果<strong>最高数值位与符号位相同</strong>,应“左规”,此时尾数连续左移,直到最高数值位与符号位的值不同为止;同时从阶码中减去移位的位数。</p><ol start="4"><li><p>舍入<br>截断处理:无条件地丢掉正常尾数最低位之后的全部数值<br>舍入处理:运算过程中保留右移中移出的若干高位的值,然而再按某种规则用这些位上的值修正尾数</p></li><li><p>判断溢出</p></li></ol><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;计算机组成与结构课程笔记&lt;/p&gt;</summary>
    
    
    
    <category term="计算机组成原理" scheme="http://akkaduilin.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="运算方法" scheme="http://akkaduilin.com/tags/%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成笔记-主存储器</title>
    <link href="http://akkaduilin.com/2022/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E7%AC%94%E8%AE%B0-%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8/"/>
    <id>http://akkaduilin.com/2022/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E7%AC%94%E8%AE%B0-%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8/</id>
    <published>2022-04-23T07:59:21.000Z</published>
    <updated>2022-06-19T09:17:01.448Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>计算机组成原理</p><p>主存储器</p><p><a href="https://sm.ms/image/UQvDjshEwNZuA92" target="_blank"><img src="https://s2.loli.net/2022/04/23/UQvDjshEwNZuA92.jpg" ></a></p><span id="more"></span><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><a href="https://sm.ms/image/nJjHB8GmbpCu14X" target="_blank"><img src="https://s2.loli.net/2022/04/23/nJjHB8GmbpCu14X.jpg" alt="Screenshot 2022-04-12 144845.jpg"></a></p><ol><li><p>主要指标：主存容量、储存器存储时间(启动一次读写操作到完成该操作的时间)、存储周期(连续启动两次独立的储存器操作所需间隔的最小时间)</p></li><li><p>一个字节 = 8个二进制位</p></li><li><p>总线：地址总线、数据总线、控制总线 连接主存储器和CPU</p></li><li><p>AR(地址寄存器)K位 DR(数码寄存器)n位 允许主存包含2^K个可寻址的字节 在一个存储周期内，CPU和主存通过总线进行n位数据传送。</p></li></ol><h1 id="RAM"><a href="#RAM" class="headerlink" title="RAM"></a>RAM</h1><p>半导体读/写存储器按存储元件在运行中能否长时间保存信息来分为静态存储器（SRAM）和动态存储器（DRAM）。<br>其中SRAM利用双稳态触发器来保存信息,而且只要不断电,信息不会丢失,<br>DRAM使用MOS电容来保存信息,使用时需要不断给电容充电。</p><p><a href="https://sm.ms/image/pu7XfFymj3beQW9" target="_blank"><img src="https://s2.loli.net/2022/04/23/pu7XfFymj3beQW9.jpg" ></a></p><h2 id="SRAM"><a href="#SRAM" class="headerlink" title="SRAM"></a>SRAM</h2><p>静态RAM是利用双稳态触发器来记忆信息的。六管静态MOS记忆单元电路中的T1～T4组成两个反相器，交叉耦合连接成一个触发器；T1～T6管构成一个记忆单元的主体，能存放一位二进制信息。</p><h3 id="SRAM的读写"><a href="#SRAM的读写" class="headerlink" title="SRAM的读写"></a>SRAM的读写</h3><p><a href="https://sm.ms/image/TcMNbC6OUJIL1ik" target="_blank"><img src="https://s2.loli.net/2022/04/23/TcMNbC6OUJIL1ik.png" ></a></p><p>存储单元未被选中时，字选择线保持低电位，两位线保持高电位；单元被选中时，字选择线保持高电位。<br><a href="https://sm.ms/image/LHjvTfwScrnu2X7" target="_blank"><img src="https://s2.loli.net/2022/04/23/LHjvTfwScrnu2X7.png" ></a></p><p>由存储单元组成的存储器结构和功能表如下:</p><p><a href="https://sm.ms/image/g1dLcKMHYA46eSX" target="_blank"><img src="https://s2.loli.net/2022/04/23/g1dLcKMHYA46eSX.png" ></a></p><h3 id="读写时序"><a href="#读写时序" class="headerlink" title="读写时序"></a>读写时序</h3><p><a href="https://sm.ms/image/1mBpUZ6OlN3zSoe" target="_blank"><img src="https://s2.loli.net/2022/04/23/1mBpUZ6OlN3zSoe.jpg" ></a></p><p><a href="https://sm.ms/image/9dAgNRVwfpqcYKF" target="_blank"><img src="https://s2.loli.net/2022/04/23/9dAgNRVwfpqcYKF.jpg" ></a></p><h2 id="DRAM"><a href="#DRAM" class="headerlink" title="DRAM"></a>DRAM</h2><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><strong>储存单元</strong></p><p><a href="https://sm.ms/image/8c2nm7i9VG1AJvs" target="_blank"><img src="https://s2.loli.net/2022/04/23/8c2nm7i9VG1AJvs.png" ></a></p><p><strong>写入</strong>: 字线为高电平,T导通<br>写1: 位线为低电平,VDD通过T对Cs充电，  电容中有电荷则保持不变。<br>写0: 位线为高电平,Cs通过T放电，电容中无电荷则不变。</p><p><strong>读出</strong>:位线预充电至高电平; 当字线出现高电平后,T导通,若原来Cs充有电荷,则Cs放电,使位线电位下降,经放大后,读出为1; 若原来Cs上无电荷,则位线无电位变化,放大器无输出,读出为0。<br>读出后,若原来Cs充有电荷也被放掉了,和没有充电一样,因此读出是破坏性的,故读出后要立即对单元进行“重写”,以恢复原信息。</p><p><strong>储存器</strong></p><p>16K由两个64*128矩阵组成<br>WE为允许信号，若为0，执行写操作，Din通过T7T8以及T5T6进入单元<br>为1执行读操作，单元的状态通过位线1 位线2和T7T8传至读放<br>若CS = 1 不进行读写操作<br><a href="https://sm.ms/image/BSKJy8L15fWlOd4" target="_blank"><img src="https://s2.loli.net/2022/04/23/BSKJy8L15fWlOd4.png" ></a></p><h3 id="刷新"><a href="#刷新" class="headerlink" title="刷新"></a>刷新</h3><p><a href="https://sm.ms/image/3jAh5Px18slzZIi" target="_blank"><img src="https://s2.loli.net/2022/04/23/3jAh5Px18slzZIi.jpg" ></a></p><h2 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h2><ol><li><p>SDRAM —— 同步动态随机读写存储器<br>将CPU与RAM通过一个相同的时钟信号锁在一起，使RAM和CPU能够共享一个时钟周期，以相同的速度同步工作。在每一个时钟脉冲的上升沿开始传送数据。</p></li><li><p>DDR —— 双倍数据传输速率同步动态随机存储器<br>是SDRAM的一种新技术。<br>可在同一时钟周期的上升和下降沿都能传送数据，同样时间内的数据传送量翻了一倍。</p></li></ol><h1 id="ROM"><a href="#ROM" class="headerlink" title="ROM"></a>ROM</h1><p>停电时信息不丢失的存储器称为非易失性存储器。<br>可分为ROM、 PROM、EPROM、 E2 PROM 和 flash memory。</p><p>芯片的内容在制造时已经输入，只能读，不能修改。<br>存储原理：是根据元件的有无来表示该存储单元的信息（1或0）。<br>存储元件：二极管或晶体管</p><h1 id="容量扩展"><a href="#容量扩展" class="headerlink" title="容量扩展"></a>容量扩展</h1><p>1 bit  = 8 位</p><p><strong>数据线数目 = 芯片位长</strong></p><p><strong>存储器容量=字数*位长</strong></p><p><strong>地址线数 = log2(字数)</strong></p><h2 id="位扩展"><a href="#位扩展" class="headerlink" title="位扩展"></a>位扩展</h2><p>位扩展指只在位数方向扩展（加大字长），而芯片的字数和存储器的字数是一致的。位扩展的连接方式是将各存储芯片的地址线、片选线和读/写线相应地并联起来，而将各芯片的数据线单独列出。</p><p>eg:</p><p>两个16K* 4位的芯片采用位扩展方式扩展成一16K * 8 位的存储器。如下图所示。 16K * 4位的芯片的字长为4位，所以有4条数据线，分别用D0<del>D3和D4</del>D7表示；容量为16K = 2^14 ，有14条地址线，用A0~A13 表示。</p><p><a href="https://sm.ms/image/9GQzPrZYRTU6dtp" target="_blank"><img src="https://s2.loli.net/2022/04/23/9GQzPrZYRTU6dtp.png" ></a></p><h2 id="字扩展"><a href="#字扩展" class="headerlink" title="字扩展"></a>字扩展</h2><p>字扩展是指仅在容量方向扩展，而位数不变。字扩展将芯片的地址线、数据线、读/写线并联，由片选信号来区分各个芯片。64K<em>8位的存储器需要4个16K</em>8位芯片组成，连接图如下。</p><p><a href="https://sm.ms/image/CBHkpyxucihlNUZ" target="_blank"><img src="https://s2.loli.net/2022/04/23/CBHkpyxucihlNUZ.png" ></a></p><p>数据线D0 - D7线与各片的数据端相连，地址总线（共16条）低位A0 -A13 与各芯片的14个地址端相连，两位高位A14和A15经过译码器和4个片选端相连。<br>在同一时间内四个芯片中只能有一个芯片被选中。</p><h2 id="同时扩展"><a href="#同时扩展" class="headerlink" title="同时扩展"></a>同时扩展</h2><p>当构成一个容量较大的存储器时，往往需要在字方向和位方向上同时扩展，这将是前两种扩展的组合，实现起来也是很容易的。</p><p>一个存储器的容量为M<em>N位，若使用L</em>K位存储器芯片，需要(M/L)*(N/K)个芯片</p><p>如用16K×4位的SRAM组成64K×8位的存储器，需要8个芯片。</p><h1 id="xx3x"><a href="#xx3x" class="headerlink" title="xx3x"></a>xx3x</h1><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;计算机组成原理&lt;/p&gt;
&lt;p&gt;主存储器&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://sm.ms/image/UQvDjshEwNZuA92&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://s2.loli.net/2022/04/23/UQvDjshEwNZuA92.jpg&quot; &gt;&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="计算机组成原理" scheme="http://akkaduilin.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="主存储器" scheme="http://akkaduilin.com/tags/%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>节点选择</title>
    <link href="http://akkaduilin.com/2022/04/04/%E8%8A%82%E7%82%B9%E9%80%89%E6%8B%A9/"/>
    <id>http://akkaduilin.com/2022/04/04/%E8%8A%82%E7%82%B9%E9%80%89%E6%8B%A9/</id>
    <published>2022-04-04T09:39:27.000Z</published>
    <updated>2022-04-24T06:28:14.389Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>问题描述</p><p>有一棵 n 个节点的树，树上每个节点都有一个正整数权值。如果一个点被选择了，那么在树上和它相邻的点都不能被选择。求选出的点的权值和最大是多少？</p><span id="more"></span><p>输入格式<br>第一行包含一个整数 n 。<br>接下来的一行包含 n 个正整数，第 i 个正整数代表点 i 的权值。<br>接下来一共 n-1 行，每行描述树上的一条边。</p><p>输出格式<br>输出一个整数，代表选出的点的权值和的最大值。</p><p>样例输入<br>5<br>1 2 3 4 5<br>1 2<br>1 3<br>2 4<br>2 5</p><p>样例输出<br>12</p><p>样例说明<br>选择3、4、5号点，权值和为 3+4+5 = 12 。</p><p>数据规模与约定<br>对于20%的数据， n &lt;= 20。<br>对于50%的数据， n &lt;= 1000。<br>对于100%的数据， n &lt;= 100000。<br>权值均为不超过1000的正整数</p><p><a href="https://www.cnblogs.com/program-ccc/p/5221932.html">https://www.cnblogs.com/program-ccc/p/5221932.html</a></p><p>状态转移方程：</p><p>dp[x][1] = dp[x][1] + dp[u][0]  (u为x的子结点)</p><p>dp[x][0] = dp[x][0] + max{dp[u][0],dp[u][1]}(u为x的子结点)</p><figure class="highlight plaintext"><figcaption><span>[结点选择] [lang:C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN=8;</span><br><span class="line">int w[MAXN]; // 各点的权值</span><br><span class="line">vector&lt;int&gt; tree[MAXN]; // 数组下标对应的向量存贮该下标结点的邻接点</span><br><span class="line">int n;</span><br><span class="line">int dp[MAXN][2]; //dp[u][1] 存储 选了自己结点u的权值最大值 dp[u][0]存储不选结点u权值和</span><br><span class="line">int vis[MAXN]; // 判断是否遍历过</span><br><span class="line"></span><br><span class="line">void dfs(int u) // 结点u的dfs</span><br><span class="line">&#123;</span><br><span class="line">    vis[u]=1; </span><br><span class="line">    dp[u][0]=0;</span><br><span class="line">    dp[u][1]=w[u];</span><br><span class="line">    int s0=0,s1=0;</span><br><span class="line">    for(int i=0;i&lt;tree[u].size();i++) // 遍历结点u邻接结点v</span><br><span class="line">    &#123;</span><br><span class="line">        int v=tree[u][i]; </span><br><span class="line">        if(!vis[v])</span><br><span class="line">        &#123;</span><br><span class="line">            dfs(v); // 结点v的dfs</span><br><span class="line">            s0+=max(dp[v][0],dp[v][1]);</span><br><span class="line">            s1+=dp[v][0];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[u][0]+=s0;</span><br><span class="line">    dp[u][1]+=s1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;w[i]);</span><br><span class="line">    </span><br><span class="line">    for(int i=1;i&lt;=n-1;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int u,v;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;u,&amp;v);</span><br><span class="line">        tree[u].push_back(v);</span><br><span class="line">        tree[v].push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs(1);</span><br><span class="line">    </span><br><span class="line">    printf(&quot;%d\n&quot;,max(dp[1][0],dp[1][1]));</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;问题描述&lt;/p&gt;
&lt;p&gt;有一棵 n 个节点的树，树上每个节点都有一个正整数权值。如果一个点被选择了，那么在树上和它相邻的点都不能被选择。求选出的点的权值和最大是多少？&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="http://akkaduilin.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="C++" scheme="http://akkaduilin.com/tags/C/"/>
    
    <category term="树形DP" scheme="http://akkaduilin.com/tags/%E6%A0%91%E5%BD%A2DP/"/>
    
  </entry>
  
  <entry>
    <title>归并排序实战——逆序对问题</title>
    <link href="http://akkaduilin.com/2022/04/04/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E9%80%86%E5%BA%8F%E5%AF%B9%E9%97%AE%E9%A2%98/"/>
    <id>http://akkaduilin.com/2022/04/04/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E9%80%86%E5%BA%8F%E5%AF%B9%E9%97%AE%E9%A2%98/</id>
    <published>2022-04-04T09:38:03.000Z</published>
    <updated>2022-06-19T09:16:43.301Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>关于逆序对问题的题解和思路</p><span id="more"></span><p><strong>归并排序原算法指路：</strong></p><a href="/2021/12/01/%E6%8E%92%E5%BA%8F/" title="五种排序">五种排序</a><a href="/2021/12/01/%E6%8E%92%E5%BA%8F/" title="排序">排序</a><p><strong>逆序对：设a[0…n]为包含n个不数的一个序列，如果n&lt;m，且a[n]&gt;a[m],则称(n,m)构成a中的一个逆序对；</strong></p><p><a href="https://www.jb51.net/article/55283.htm">https://www.jb51.net/article/55283.htm</a></p><p>归并排序思想，先递归分治至两个数组内再依次返回排序比较<br>注意若左边数组大于右边数组，总计数应加上 <strong>mid - index1 + 1</strong><br>因为右数组是有序的，当左指针移动时会出现多个逆序对的情况，所以加上中间指针下标减去右指针所在下标加上1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int array[] = &#123;3, 9, 7, 4, 5, 2&#125;;</span><br><span class="line">const int size = sizeof array / sizeof *array;</span><br><span class="line">int temp[size];</span><br><span class="line">//int numbers[size];</span><br><span class="line"></span><br><span class="line">int reversePair(int *numbers, int start, int last, int &amp;index, int &amp;count)</span><br><span class="line">&#123;</span><br><span class="line">  if(start == last)</span><br><span class="line">  return 0;</span><br><span class="line">  int mid = (last - start) / 2 + start;</span><br><span class="line">  //递归分治</span><br><span class="line">  reversePair(numbers, start, mid, index, count);</span><br><span class="line">  reversePair(numbers, mid + 1, last, index, count);</span><br><span class="line"></span><br><span class="line">  for(int i = start; i &lt;= last; i++)</span><br><span class="line">    temp[i] = numbers[i];</span><br><span class="line"></span><br><span class="line">  int index1 = start, index2 = mid + 1;</span><br><span class="line">  index = start;</span><br><span class="line">  while(index1 &lt;= mid &amp;&amp; index2 &lt;= last) &#123;</span><br><span class="line">    if(temp[index1] &gt; temp[index2]) &#123;</span><br><span class="line">      numbers[index] = temp[index2];//将值较小的优先排入数组，起到排序作用</span><br><span class="line">      count += mid - index1 + 1;</span><br><span class="line">      index++;</span><br><span class="line">      index2++;</span><br><span class="line">    &#125; </span><br><span class="line">    else if(temp[index1] == temp[index2]) &#123;</span><br><span class="line">      numbers[index] = temp[index1];</span><br><span class="line">      index++;</span><br><span class="line">      index1++;</span><br><span class="line">      index2++;</span><br><span class="line">    &#125; </span><br><span class="line">    else if(temp[index1] &lt; temp[index2]) &#123;</span><br><span class="line">      numbers[index] = temp[index1];</span><br><span class="line">      index++;</span><br><span class="line">      index1++;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(index1 &lt;= mid) &#123;</span><br><span class="line">      while(index1 &lt;= mid) &#123;</span><br><span class="line">        numbers[index] = temp[index1];</span><br><span class="line">        index++;</span><br><span class="line">        index1++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    else &#123;</span><br><span class="line">      while(index2 &lt;= last) &#123;</span><br><span class="line">        numbers[index] = temp[index2];</span><br><span class="line">        index++;</span><br><span class="line">        index2++;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">  int count = 0;</span><br><span class="line">  int index = 0;</span><br><span class="line">  reversePair(array, 0, size - 1, index, count);</span><br><span class="line">  cout &lt;&lt; &quot;count = &quot; &lt;&lt; count &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关于逆序对问题的题解和思路&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="http://akkaduilin.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="C++" scheme="http://akkaduilin.com/tags/C/"/>
    
    <category term="归并排序" scheme="http://akkaduilin.com/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    
    <category term="逆序对" scheme="http://akkaduilin.com/tags/%E9%80%86%E5%BA%8F%E5%AF%B9/"/>
    
  </entry>
  
</feed>
