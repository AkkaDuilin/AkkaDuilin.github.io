<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>咸鱼享乐，摸鱼快乐</title>
  
  
  <link href="http://akkaduilin.com/atom.xml" rel="self"/>
  
  <link href="http://akkaduilin.com/"/>
  <updated>2022-06-23T18:01:55.102Z</updated>
  <id>http://akkaduilin.com/</id>
  
  <author>
    <name>不对de林</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计算机组成原理-中央处理器</title>
    <link href="http://akkaduilin.com/2022/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/"/>
    <id>http://akkaduilin.com/2022/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/</id>
    <published>2022-06-15T03:21:24.000Z</published>
    <updated>2022-06-23T18:01:55.102Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p><a href="https://sm.ms/image/q3H5Q21hRClFuIp" target="_blank"><img src="https://s2.loli.net/2022/06/23/q3H5Q21hRClFuIp.png" ></a></p><p><a href="https://www.bilibili.com/video/BV1BE411D7">https://www.bilibili.com/video/BV1BE411D7</a></p><span id="more"></span><h1 id="中央处理器的功能和组成"><a href="#中央处理器的功能和组成" class="headerlink" title="中央处理器的功能和组成"></a>中央处理器的功能和组成</h1><p>指令控制：程序的顺序控制<br>操作控制：一条指令有若干操作信号实现<br>时间控制：指令各个操作实施时间的定时<br>数据加工：算术运算和逻辑运算</p><p><strong>运算器：</strong><br>数据加工 </p><p><strong>控制器：</strong><br>①取指令 ②翻译指令 ③发送信号执行指令</p><p><strong>根本任务就是从应用程序中取指令并执行。</strong></p><h1 id="运算器-控制器"><a href="#运算器-控制器" class="headerlink" title="运算器/控制器"></a>运算器/控制器</h1><p><a href="https://sm.ms/image/ZGMEuWvyVO1irja" target="_blank"><img src="https://s2.loli.net/2022/06/23/ZGMEuWvyVO1irja.png" ></a></p><h2 id="运算器基本结构"><a href="#运算器基本结构" class="headerlink" title="运算器基本结构"></a>运算器基本结构</h2><p>定点运算器是数据的加工处理部件，<br>是CPU的重要组成部分。</p><p>包括：ALU算术/逻辑单元 ，阵列乘法器、阵列除法器、移位电路、寄存器组、选择电路、数据总线（内部总线），…… 等逻辑电路构成。</p><p><a href="https://sm.ms/image/hQplsKOZ7uGRHTv" target="_blank"><img src="https://s2.loli.net/2022/06/23/hQplsKOZ7uGRHTv.png" ></a></p><h2 id="控制器基本结构"><a href="#控制器基本结构" class="headerlink" title="控制器基本结构"></a>控制器基本结构</h2><p>控制器的功能：<br>        取指令<br>        分析指令<br>        执行指令<br>        控制程序和数据的输入与输出<br>        对异常和请求进行处理</p><p>控制器的组成：<br>        程序计数器（PC）<br>        指令寄存器（IR）<br>        指令译码器（I-decoder）<br>        脉冲源和启停线路<br>        时序控制信号形成部件</p><p><a href="https://sm.ms/image/5UuHYnQ68s4WNdV" target="_blank"><img src="https://s2.loli.net/2022/06/23/5UuHYnQ68s4WNdV.png" ></a></p><h1 id="指令的执行过程"><a href="#指令的执行过程" class="headerlink" title="指令的执行过程"></a>指令的执行过程</h1><p><a href="https://sm.ms/image/eWaRlAn9srFwpt1" target="_blank"><img src="https://s2.loli.net/2022/06/23/eWaRlAn9srFwpt1.png" ></a></p><p><a href="https://sm.ms/image/58InB7T3ZFapjNu" target="_blank"><img src="https://s2.loli.net/2022/06/23/58InB7T3ZFapjNu.png" ></a></p><h1 id="微程序"><a href="#微程序" class="headerlink" title="微程序"></a>微程序</h1><p>微指令：由同时发出的控制信号所执行的一组微操作。<br>    例如：<br>加法指令的执行可分为：取指、计算地址、取操作数和加法运算四步，每一步都由一组微操作实现。这一组能同时执行的微操作就构成一条微指令。</p><p>微程序：一组微指令的集合。这样：<br>程序由一组指令组成<br>指令由一个微程序实现<br>微程序由一组微指令实现<br>微指令由一组微操作实现</p><p><a href="https://sm.ms/image/byHGVLgcBQqlJuM" target="_blank"><img src="https://s2.loli.net/2022/06/23/byHGVLgcBQqlJuM.png" ></a></p><ol><li>将每个控制信号用1bit表示，当该位为1时，表示有控制信号；为0时，表示无控制信号。</li><li>对M/IO#、W/R#，则当该位为1时，分别表示访问存储器和写；当该位为0时，分别表示IO访问和读。</li><li> 每条微指令执行完后，需要给出下条微指令执行的地址。</li></ol><p><strong>基本结构</strong><br><a href="https://sm.ms/image/yWT27H4VsfIvw1S" target="_blank"><img src="https://s2.loli.net/2022/06/23/yWT27H4VsfIvw1S.png" ></a></p><p><strong>格式</strong><br><a href="https://sm.ms/image/OD6Fxvcz7U1IsuP" target="_blank"><img src="https://s2.loli.net/2022/06/23/OD6Fxvcz7U1IsuP.png" ></a></p><p><strong>编码方式</strong></p><p><a href="https://sm.ms/image/bO2VIUrWYnGfBTl" target="_blank"><img src="https://s2.loli.net/2022/06/23/bO2VIUrWYnGfBTl.png" ></a></p><p><a href="https://sm.ms/image/EFtsVHRleOXjYGz" target="_blank"><img src="https://s2.loli.net/2022/06/23/EFtsVHRleOXjYGz.png" ></a></p><p><a href="https://sm.ms/image/FnYSmG6Th1Dy7OX" target="_blank"><img src="https://s2.loli.net/2022/06/23/FnYSmG6Th1Dy7OX.png" ></a></p><p><a href="https://sm.ms/image/lBfQGSecj1xbRir" target="_blank"><img src="https://s2.loli.net/2022/06/23/lBfQGSecj1xbRir.png" ></a></p><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://sm.ms/image/q3H5Q21hRClFuIp&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://s2.loli.net/2022/06/23/q3H5Q21hRClFuIp.png&quot; &gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1BE411D7&quot;&gt;https://www.bilibili.com/video/BV1BE411D7&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>计算机组成原理-指令系统</title>
    <link href="http://akkaduilin.com/2022/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"/>
    <id>http://akkaduilin.com/2022/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/</id>
    <published>2022-06-15T03:21:02.000Z</published>
    <updated>2022-06-22T15:46:36.810Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>指令：要求计算机完成某种操作的命令。<br><strong>指令系统：1台计算机所能执行的全部指令的集合。</strong></p><p>计算机的性能与它所设置的指令系统有很大关系，而指令系统的设置又与机器的硬件结构密切相关。<br>机器指令的基本要素：<br>操作码<br>操作数的地址<br>操作结果的存储地址<br>下一条指令的地址</p><p><a href="https://sm.ms/image/ZBzuHGcbDaMfi3v" target="_blank"><img src="https://s2.loli.net/2022/06/22/ZBzuHGcbDaMfi3v.png" ></a></p><span id="more"></span><h1 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h1><p>计算机的指令格式与机器的字长、存储器的容量及指令的功能都有很大关系。</p><p>从机器指令的基本要素可知，一条指令包括两种信息：<strong>操作码和地址码</strong>。</p><p>操作码（operation code）：用来表示指令所要完成的操作(如加、减、乘、除、数据传送等)，其长度取决于指令系统中指令的条数。</p><p>地址码：用来描述指令的操作对象。或者直接给出操作数、或者指出操作数的存储地址或寄存器地址(即寄存器名)。</p><p><a href="https://sm.ms/image/xWrsiaveQNfA6E7" target="_blank"><img src="https://s2.loli.net/2022/06/21/xWrsiaveQNfA6E7.png" ></a></p><p>n位操作码可以定义2^n 条指令</p><h1 id="拓展操作码"><a href="#拓展操作码" class="headerlink" title="拓展操作码"></a>拓展操作码</h1><p>器字长位16位，用15/15/15扩展法可以设计一个具有15条三地址指令、15条双地址指令、15条单地址指令和16条零地址指令的指令系统</p><p><a href="https://sm.ms/image/nKU4ZgGrDqh1bBW" target="_blank"><img src="https://s2.loli.net/2022/06/21/nKU4ZgGrDqh1bBW.png" ></a></p><p>拓展思路：<br>设地址长度为n<br>上一层留出m种状态，下一层可拓展m*2^n种状态</p><p><a href="https://sm.ms/image/EDqNY35sZ9AWUi1" target="_blank"><img src="https://s2.loli.net/2022/06/21/EDqNY35sZ9AWUi1.png" ></a></p><h1 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h1><p>方式                 算法                 优点                     缺点           访存次数(执行期间)<br>立即               操作数=A           无存储器访问            操作数大小受限          0<br>直接               EA=A                   简单                   地址范围有限        1<br>间接               EA=(A)             大的地址范围            多重存储器访问          2<br>寄存器             EA=R                无存储器访问             地址范围有限          0<br>寄存器间接          EA=(R)              大的地址范围            额外地址访问           1<br>偏移               EA=A+(R)               灵活                    复杂               1<br>堆栈               EA=栈顶              无存储器访问              应用有限</p><p><a href="https://sm.ms/image/k6ZWhsAXx7BjClS" target="_blank"><img src="https://s2.loli.net/2022/06/22/k6ZWhsAXx7BjClS.png" ></a></p><p><a href="https://sm.ms/image/nS9tfvlFGAdrmiN" target="_blank"><img src="https://s2.loli.net/2022/06/22/nS9tfvlFGAdrmiN.png" ></a></p><p><a href="https://sm.ms/image/TBQYOV3H1s7cod9" target="_blank"><img src="https://s2.loli.net/2022/06/22/TBQYOV3H1s7cod9.png" ></a></p><p><a href="https://sm.ms/image/pjioez9wXZJ37Em" target="_blank"><img src="https://s2.loli.net/2022/06/22/pjioez9wXZJ37Em.png" ></a></p><p><a href="https://sm.ms/image/pqOaijgm4QP1BWk" target="_blank"><img src="https://s2.loli.net/2022/06/22/pqOaijgm4QP1BWk.png" ></a></p><p><a href="https://sm.ms/image/SHP3uXbOAWslLq1" target="_blank"><img src="https://s2.loli.net/2022/06/22/SHP3uXbOAWslLq1.png" ></a></p><p><a href="https://sm.ms/image/Lu76NVml8rbAItc" target="_blank"><img src="https://s2.loli.net/2022/06/22/Lu76NVml8rbAItc.png" ></a></p><p><a href="https://sm.ms/image/75dqoFezIgmlTZ8" target="_blank"><img src="https://s2.loli.net/2022/06/22/75dqoFezIgmlTZ8.png" ></a></p><h1 id="CISC-和-RISC"><a href="#CISC-和-RISC" class="headerlink" title="CISC 和 RISC"></a>CISC 和 RISC</h1><p>1、CISC计算机<br>CISC：复杂指令系统(集)计算机 (complex instruction set computer)的缩写。<br>一条指令完成一个复杂的功能<br>  DEC公司的VAX11/780计算机、Intel公司的80x86微处理器、IBM公司的大、中型计算机都是CISC。<br>2、RISC计算机<br>   RISC：精简指令系统(集)计算机 (reduced instruction set computer)的缩写。<br>   一条指令完成一个基本动作 多条指令组合完成一个复杂的基本功能</p><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;指令：要求计算机完成某种操作的命令。&lt;br&gt;&lt;strong&gt;指令系统：1台计算机所能执行的全部指令的集合。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;计算机的性能与它所设置的指令系统有很大关系，而指令系统的设置又与机器的硬件结构密切相关。&lt;br&gt;机器指令的基本要素：&lt;br&gt;操作码&lt;br&gt;操作数的地址&lt;br&gt;操作结果的存储地址&lt;br&gt;下一条指令的地址&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://sm.ms/image/ZBzuHGcbDaMfi3v&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://s2.loli.net/2022/06/22/ZBzuHGcbDaMfi3v.png&quot; &gt;&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="计算机组成原理" scheme="http://akkaduilin.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>数据库-事务</title>
    <link href="http://akkaduilin.com/2022/06/13/%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/"/>
    <id>http://akkaduilin.com/2022/06/13/%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/</id>
    <published>2022-06-13T08:08:54.000Z</published>
    <updated>2022-06-19T09:18:17.424Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>把多条语句作为一个整体进行操作的功能，被称为数据库事务。数据库事务可以确保该事务范围内的所有操作都可以全部成</p><p>功或者全部失败。如果事务失败，那么效果就和没有执行这些SQL一样，不会对数据库数据有任何改动。</p><p><a href="https://blog.csdn.net/qq_42192693/article/details/109963032">https://blog.csdn.net/qq_42192693/article/details/109963032</a></p><span id="more"></span><h1 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h1><p>数据库事务具有ACID这4个特性：</p><p>A：Atomic，原子性，将所有SQL作为原子工作单元执行，要么全部执行，要么全部不执行；<br>C：Consistent，一致性，事务完成后，所有数据的状态都是一致的，即A账户只要减去了100，B账户则必定加上了100；<br>I：Isolation，隔离性，如果有多个事务并发执行，每个事务作出的修改必须与其他事务隔离；<br>D：Duration，持久性，即事务完成后，对数据库数据的修改被持久化存储。</p><p>对于单条SQL语句，数据库系统自动将其作为一个事务执行，这种事务被称为<strong>隐式事务</strong>。</p><p>要手动把多条SQL语句作为一个事务执行，使用BEGIN开启一个事务，使用COMMIT提交一个事务，这种事务被称为<strong>显式事务</strong></p><h1 id="rollback-commit"><a href="#rollback-commit" class="headerlink" title="rollback/commit"></a>rollback/commit</h1><ol><li><p>使用 <strong>begin + transaction_name</strong> 来创建一个事务</p></li><li><p>commit 指提交事务，即尝试将事务内的SQL做出的修改尝试保存。</p></li><li><p>rollback 指回滚，主动让事务失败，事务内的SQL语句不生效</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BEGIN TRANsaction </span><br><span class="line">     Update student set sage=sage+1 where sno=’0001’</span><br><span class="line">     Select * from student where sno=’0002’</span><br><span class="line"></span><br><span class="line">ROLLBACK  TRANsaction</span><br><span class="line"></span><br><span class="line">commit transaction</span><br></pre></td></tr></table></figure><h1 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h1><p>事务是并发控制的基本单位</p><h2 id="封锁协议"><a href="#封锁协议" class="headerlink" title="封锁协议"></a>封锁协议</h2><p><a href="https://blog.csdn.net/weixin_40448140/article/details/115269643">https://blog.csdn.net/weixin_40448140/article/details/115269643</a></p><p>S锁 - 排他锁、写锁 只允许读取事务和修改数据对象</p><p>X锁 - 共享锁、读锁 只允许读取数据对象但不能修改数据对象</p><p><strong>第一类封锁协议</strong><br>第一类封锁协议指的是在对数据进行修改操作时需要对数据添加X锁.第一类封锁协议相当于把数据的读取和修改看成一个整体,在事务完成之前其他事务都不能对数据进行修改操作.</p><p><strong>第二类封锁协议</strong><br>第二类封锁协议是在第一类封锁协议的基础上加入了S锁.在读取数据前需要对数据添加S锁, 当数据读取完成后释放S锁 .如果一个事务读取数据并添加了S锁,另一个事务添加了X锁,那么添加X锁的那个事务必须等待添加了S锁的事务释放S锁后才能对数据进行修改操作.</p><p><strong>第三类封锁协议</strong><br>第三类封锁协议是在第一类封锁协议的基础上加入了S锁,在读取数据前需要对数据添加S锁, <strong>当事务结束后释放S锁</strong>.第三类封锁协议同时解决了数据的修改丢失,不可重复读和读脏数据问题.</p><h2 id="活锁-死锁"><a href="#活锁-死锁" class="headerlink" title="活锁/死锁"></a>活锁/死锁</h2><p><a href="https://sm.ms/image/DzEbiMu4OVh8XWm" target="_blank"><img src="https://s2.loli.net/2022/06/15/DzEbiMu4OVh8XWm.png" ></a></p><p>避免活锁：采用先来先服务的策略；当多个事务请求封锁同一数据对象时，按请求封锁的先后次序对这些事务排队，该数据对象上的锁一旦释放，首先批准申请队列中第一个事务获得锁。</p><p><a href="https://sm.ms/image/3OpRzWXJSKM4YoP" target="_blank"><img src="https://s2.loli.net/2022/06/15/3OpRzWXJSKM4YoP.png" ></a></p><p>解决死锁方法： 预防死锁（一次性封锁法和顺序封锁法）、诊断死锁并解除（超时法和等待图法）。<br>一次性封锁法：每个事务必须将所要求的数据对象全部上锁后才能执行读写操作，否则释放占用的资源。<br>顺序封锁法：对所有数据对象规定一个封锁顺序，所有事务均按这个顺序实行封锁。</p><h2 id="可串行性"><a href="#可串行性" class="headerlink" title="可串行性"></a>可串行性</h2><p><strong>可串行化调度</strong>：多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行这些事务时的结果相同。</p><p>可串行性是并发事务正确调度的准则，一个给定的并发调度，当且仅当它是可串行化的，才认为是正确调度。对若干个事务，不同的并发调度策略其最终的执行结果不一定完全相同。但只要它们的调度是可串行化的，则都是正确调度。                                                           </p><p><strong>冲突操作</strong>：是指不同的事务对同一数据的读写操作和写写操作。</p><p>一个调度Sc在保证冲突操作的次序不变的情况下，通过交换两个事务不冲突操作的次序得到另一个调度Sc’，如果Sc’是串行的，称调度Sc是<strong>冲突可串行化的调度</strong>。</p><p><strong>冲突可串行化调度是可串行化调度的充分条件</strong>，不是必要条件。还有不满足冲突可串行化条件的可串行化调度。</p><h2 id="两段锁协议"><a href="#两段锁协议" class="headerlink" title="两段锁协议"></a>两段锁协议</h2><p>数据库管理系统普遍采用两段锁协议的方法实现并发调度的可串行性，从而保证调度的正确性</p><p>两段封锁协议（也称两相上锁协议，简写2PL）指所有事务必须分两个阶段对数据项加锁和解锁。</p><p>（1）在对任何数据进行读、写操作之前，事务首先要申请并获得对该数据的封锁（读时S锁，写时X锁）；</p><p>（2）在释放一个封锁之后，事务不再申请和获得新的封锁。</p><p> “两段”锁的含义是事务分为两个阶段</p><p>第一阶段是获得封锁，也称为扩展阶段事务可以申请获得任何数据项上的任何类型的锁，但是不能释放任何锁<br>第二阶段是释放封锁，也称为收缩阶段事务可以释放任何数据项上的任何类型的锁，但是不能再申请任何锁<br>若所有事务都遵守两段封锁协议，则对这些事务的任何并发调度策略都是可串行化的。</p><h2 id="粒度"><a href="#粒度" class="headerlink" title="粒度"></a>粒度</h2><p>封锁的粒度：封锁对象的大小。可以是数据库、表、记录、字段等。</p><p>封锁粒度与系统的并发度和并发控制的开销密切相关。封锁的粒度越大，数据库所能够封锁的数据单元就越少，并发度就越小，系统开销也越小；封锁的粒度越小，并发度较高，但系统开销也就越大。</p><h1 id="数据库恢复"><a href="#数据库恢复" class="headerlink" title="数据库恢复"></a>数据库恢复</h1><p>计算机硬件故障<br>软件的错误<br>操作员的失误<br>恶意的破坏<br>故障的影响<br>运行事务非正常中断，影响数据库中数据的正确性<br>破坏数据库；全部或部分丢失数据</p><h2 id="数据库的恢复"><a href="#数据库的恢复" class="headerlink" title="数据库的恢复"></a>数据库的恢复</h2><p>数据库管理系统必须具有把数据库从错误状态恢复到某一已知的正确状态（亦称为一致状态或完整状态）的功能，这就是数据库的恢复管理系统对故障的对策</p><p>恢复子系统是数据库管理系统的一个重要组成部分<br>恢复技术是衡量系统优劣的重要指标</p><h2 id="故障的种类"><a href="#故障的种类" class="headerlink" title="故障的种类"></a>故障的种类</h2><ol><li>事务内部的故障</li></ol><p>有的是可以通过事务程序本身发现的（转账事务的例子）。有的是非预期的，不能由事务程序处理的。（如运算溢出、并发事务发生死锁而被选中撤销该事务、违反了某些完整性限制等）</p><ol start="2"><li>系统故障</li></ol><p>称为软故障，是指造成系统停止运转的任何事件，使得系统要重新启动。如：整个系统的正常运行突然被破坏、所有正在运行的事务都非正常终止、不破坏数据库、内存中数据库缓冲区的信息全部丢失。常见原因：特定类型的硬件错误（如CPU故障）、操作系统故障、DBMS代码错误、系统断电等。</p><ol start="3"><li>介质故障</li></ol><p>称为硬故障，指外存故障，如：磁盘损坏、磁头碰撞、操作系统的某种潜在错误、瞬时强磁场干扰。介质故障破坏数据库或部分数据库，并影响正在存取这部分数据的所有事务。</p><p>介质故障比前两类故障的可能性小得多，但破坏性大得多。</p><ol start="4"><li>计算机病毒</li></ol><p>一种人为的故障或破坏，是一些恶作剧者研制的一种计算机程序。可以繁殖和传播，造成对计算机系统包括数据库的危害。</p><h2 id="恢复的实现技术"><a href="#恢复的实现技术" class="headerlink" title="恢复的实现技术"></a>恢复的实现技术</h2><p>恢复操作的基本原理：冗余</p><p>利用存储这系统其他地方的冗余数据来重建数据库中已被破坏或不正确的那部分数据</p><p>恢复的实现技术：复杂</p><p>一个大型数据库产品，恢复子系统的代码要占全部代码的10%以上</p><p>恢复机制涉及的关键问题</p><p>如何建立冗余数据（恢复方式）</p><p>数据转储（backup）转储是指DBA将整个数据库复制到磁带或另一个磁盘上保存起来的过程</p><p>备用的数据文本称为后备副本或后援副本</p><p><strong>登录日志文件（logging）日志文件（log）是用来记录事务对数据库的更新操作的文件</strong></p><p>如何利用这些冗余数据实施数据库恢复</p><h2 id="恢复策略"><a href="#恢复策略" class="headerlink" title="恢复策略"></a>恢复策略</h2><ol><li>事务故障：事务在运行至正常终止点前被终止。</li></ol><p>恢复策略：由恢复子系统利用日志文件撤消（ UNDO ）此事务已对数据库进行的修改，使得该事务像根本没有启 动过一样。</p><p>事务故障的恢复由系统自动完成，对用户是透明的，不需要用户干预</p><ol start="2"><li>系统故障 造成数据库不一致状态的原因：</li></ol><p>①未完成事务对数据库的更新已写入数据库</p><p>②已提交事务对数据库的更新还留 在 缓冲区没来得及写入数据库。</p><p>恢复策略：</p><p>①Undo 故障发生时未完成的事务</p><p>②Redo 已完成的事务 系统故障的恢复由系统在 重新启动时 自动完成，不需要用户干预</p><ol start="3"><li>介质故障: 称为硬故障，指外存故障，如：磁盘损坏、磁头碰撞、操作系统的某种潜在错误、瞬时强磁场干扰。</li></ol><p>恢复策略：</p><p>①重装数据库</p><p>②重做已完成的事务</p><p>介质故障的恢复需要 DBA 介入，DBA 的工作</p><p>①重装最近转储的数据库副本和有关的各日志文件副本</p><p>②执行系统 提供的恢复命令。具体的恢复操作仍由 DBMS 完成。</p><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;把多条语句作为一个整体进行操作的功能，被称为数据库事务。数据库事务可以确保该事务范围内的所有操作都可以全部成&lt;/p&gt;
&lt;p&gt;功或者全部失败。如果事务失败，那么效果就和没有执行这些SQL一样，不会对数据库数据有任何改动。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_42192693/article/details/109963032&quot;&gt;https://blog.csdn.net/qq_42192693/article/details/109963032&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="http://akkaduilin.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="SQL" scheme="http://akkaduilin.com/tags/SQL/"/>
    
    <category term="数据库" scheme="http://akkaduilin.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="事务" scheme="http://akkaduilin.com/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>语法制导的翻译</title>
    <link href="http://akkaduilin.com/2022/06/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%9A%84%E7%BF%BB%E8%AF%91/"/>
    <id>http://akkaduilin.com/2022/06/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%9A%84%E7%BF%BB%E8%AF%91/</id>
    <published>2022-06-07T01:19:19.000Z</published>
    <updated>2022-06-19T09:16:15.297Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>将语义分析和中间代码生成统称为语义翻译，而语义翻译和语法分析统称为语法制导翻译</p><p><a href="https://blog.csdn.net/qq_33414271/article/details/95333962">https://blog.csdn.net/qq_33414271/article/details/95333962</a></p><span id="more"></span><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><ol><li>语法制导定义SDD：上下文无关文法+属性+规则</li></ol><p><strong>属性：和文法符号相关联</strong><br>每个文法符号都有一个相关的属性集，属性可以代表任何对象：字符串、数字、类型、内存单元或其他对象。<br>与这些属性相关的信息，即属性值可以在语法分析过程中计算和传递。属性加工的过程即语义的处理过程。</p><p><strong>规则：和产生式相关联</strong></p><ol start="2"><li><p>语法制导翻译方案SDT：文法产生式和语义规则交错<br>把语义规则用{}括起来，插入到规则右部的合适位置上，指明了语义规则的计算顺序，以便说明某些实现细节<br>高效、适合用于翻译的实现，一个语义动作在产生式中的位置决定了这个动作的执行时间<br>可以看作是对SDD的一种补充，是SDD的具体实施方案<br>显式地指明了语义规则的计算顺序，以便说明某些实现细节</p></li><li><p>综合属性<br>在分析树结点N上的非终结符A的综合属性只能通过N的子结点或N本身的属性值来定义<br>产生式 E → E1 + T<br>语义规则 E.val =E1.val + T.val<br><a href="https://sm.ms/image/hF23EsDWfGvrqBH" target="_blank"><img src="https://s2.loli.net/2022/06/17/hF23EsDWfGvrqBH.png" ></a></p></li><li><p>继承属性<br>在分析树结点N上的非终结符A的继承属性只能通过 N的父结点、N的兄弟结点或N本身的属性值来定义 。<br>产生式 D →T L<br>语义规则 L.inh= T.typeL<br><a href="https://sm.ms/image/ZkPwGbjzvAaRChV" target="_blank"><img src="https://s2.loli.net/2022/06/17/ZkPwGbjzvAaRChV.png" ></a><br>终结符没有继承属性。终结符从词法分析器处获得的属性值被归为综合属性值。</p></li><li><p>属性依赖图<br>给定一棵语法分析树和一个SDD，我们在各个语法分析树结点所关联的属性实例之间画上边，以指明位于边的头部的属性值要根据位于边的尾部的属性值计算得到。</p></li></ol><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将语义分析和中间代码生成统称为语义翻译，而语义翻译和语法分析统称为语法制导翻译&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_33414271/article/details/95333962&quot;&gt;https://blog.csdn.net/qq_33414271/article/details/95333962&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="编译原理" scheme="http://akkaduilin.com/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="语法制导翻译" scheme="http://akkaduilin.com/tags/%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>编译原理-语法分析</title>
    <link href="http://akkaduilin.com/2022/06/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/"/>
    <id>http://akkaduilin.com/2022/06/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/</id>
    <published>2022-06-07T01:18:47.000Z</published>
    <updated>2022-06-19T09:16:17.732Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><span id="more"></span><h1 id="上下文无关文法定义"><a href="#上下文无关文法定义" class="headerlink" title="上下文无关文法定义"></a>上下文无关文法定义</h1><p><a href="https://sm.ms/image/PNZyGmSsribpeCa" target="_blank"><img src="https://s2.loli.net/2022/06/17/PNZyGmSsribpeCa.png" ></a></p><p>由上下文无关文法生成的语言是上下文无关语言(CFL)。</p><h2 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h2><p><a href="https://sm.ms/image/PSjsKY7DxWOFQG2" target="_blank"><img src="https://s2.loli.net/2022/06/17/PSjsKY7DxWOFQG2.png" ></a></p><h1 id="语法错误处理机制"><a href="#语法错误处理机制" class="headerlink" title="语法错误处理机制"></a>语法错误处理机制</h1><p>一个文法，如果存在某个句子不止一棵分析树，或者说这个句子存在不止一种最左（最右）推导，那么称这个文法是二义的。</p><p><strong>消除二义性</strong></p><p>改写二义文法的关键步骤：</p><p>划分优先级和结合性<br>引入一个新的非终结符，增加一个子结构并提高一级优先级（优先级的判断）；<br>递归非终结符在终结符左边，运算具有左结合性，否则具有右结合性。</p><p><a href="https://sm.ms/image/t2vFunjK5AhaDVQ" target="_blank"><img src="https://s2.loli.net/2022/06/17/t2vFunjK5AhaDVQ.png" ></a></p><h2 id="消除左递归"><a href="#消除左递归" class="headerlink" title="消除左递归"></a>消除左递归</h2><p><a href="https://blog.csdn.net/qq2071114140/article/details/102787831">https://blog.csdn.net/qq2071114140/article/details/102787831</a></p><p>一个文法是左递归的，如果它有非终结符A，对某个串α，存在推导A =&gt; +Aα。</p><p>自顶向下语法分析不能处理左递归的方法，因此需要一个转换方法消除左递归。</p><p><a href="https://sm.ms/image/Wh7RnfweOJlZzpa" target="_blank"><img src="https://s2.loli.net/2022/06/17/Wh7RnfweOJlZzpa.png" ></a></p><p><a href="https://sm.ms/image/rj9nEzqmkOSKJif" target="_blank"><img src="https://s2.loli.net/2022/06/17/rj9nEzqmkOSKJif.png" ></a></p><p>不是之间左递归则转换为直接左递归</p><p>eg：<br>S → Aa | b<br>A → Aad | bd | ε</p><p>S → Aa | b<br>A → bdA’ | A’<br>A’→ adA’ | ε</p><h1 id="自顶向下语法分析"><a href="#自顶向下语法分析" class="headerlink" title="自顶向下语法分析"></a>自顶向下语法分析</h1><h2 id="first-follow集"><a href="#first-follow集" class="headerlink" title="first/follow集"></a>first/follow集</h2><p><a href="https://blog.csdn.net/RENSRM/article/details/111595754">https://blog.csdn.net/RENSRM/article/details/111595754</a></p><p>FIRST(α)被定义为可从α推导得到的串的首符号的集合，其中α是任意的文法符号串<br><a href="https://sm.ms/image/Cr9wlYHtuSze1da" target="_blank"><img src="https://s2.loli.net/2022/06/17/Cr9wlYHtuSze1da.png" ></a><br><a href="https://sm.ms/image/DzglIiXdoB2QhMH" target="_blank"><img src="https://s2.loli.net/2022/06/17/DzglIiXdoB2QhMH.png" ></a></p><p>FOLLOW(A)被定义为可能在某些举行中紧跟在 A 右边的终结符号的集合。<br><a href="https://sm.ms/image/FjSOXfoWsV6iDPv" target="_blank"><img src="https://s2.loli.net/2022/06/17/FjSOXfoWsV6iDPv.png" ></a><br><a href="https://sm.ms/image/wXo9DnCaky1Kh2E" target="_blank"><img src="https://s2.loli.net/2022/06/17/wXo9DnCaky1Kh2E.png" ></a></p><h2 id="构造预测分析表"><a href="#构造预测分析表" class="headerlink" title="构造预测分析表"></a>构造预测分析表</h2><ol><li>当非终结符遇到其First集中的终结符时填入相应候选式</li><li>当非终结符的First集中含有ε元素时，遇到其Follow集中的终结符时填入 非终结符→ ε </li></ol><p><a href="https://sm.ms/image/DC9vnpNFqImTRGi" target="_blank"><img src="https://s2.loli.net/2022/06/17/DC9vnpNFqImTRGi.png" ></a><br><a href="https://sm.ms/image/3Co6gEQvVdpUfNS" target="_blank"><img src="https://s2.loli.net/2022/06/17/3Co6gEQvVdpUfNS.png" ></a></p><h1 id="自底向上语法分析"><a href="#自底向上语法分析" class="headerlink" title="自底向上语法分析"></a>自底向上语法分析</h1><p><a href="https://blog.csdn.net/qq_44202160/article/details/123145144">https://blog.csdn.net/qq_44202160/article/details/123145144</a><br><a href="https://blog.csdn.net/qq_30225253/article/details/106078803">https://blog.csdn.net/qq_30225253/article/details/106078803</a></p><p><a href="https://sm.ms/image/DEBv1YPoQe8LKRW" target="_blank"><img src="https://s2.loli.net/2022/06/17/DEBv1YPoQe8LKRW.png" ></a></p><h2 id="LR语法分析算法"><a href="#LR语法分析算法" class="headerlink" title="LR语法分析算法"></a>LR语法分析算法</h2><p>输入：一个输入串w和一个LR语法分析表。</p><p>输出：如果w在L(G)中，输出w的自底向上语法分析过程中的归约步骤；否则给出错误提示。</p><p>方法：最初，语法分析器栈中的内容为初试状态S0，输入缓冲区的内容为w $。然后，执行语法分析程序。</p><p><a href="https://sm.ms/image/3CDQ4lIWgakO78G" target="_blank"><img src="https://s2.loli.net/2022/06/17/3CDQ4lIWgakO78G.png" ></a><br><a href="https://sm.ms/image/SjPTMxwNdVRAKlz" target="_blank"><img src="https://s2.loli.net/2022/06/17/SjPTMxwNdVRAKlz.png" ></a></p><p>在当前状态(编号)下, 面对当前文法符号时, 该采取什么动作</p><p>ACTION表指明动作, GOTO表仅用于归约时的状态转换</p><p><a href="https://sm.ms/image/vc3yGxOuZDXCiTd" target="_blank"><img src="https://s2.loli.net/2022/06/17/vc3yGxOuZDXCiTd.png" ></a></p><h2 id="SLR分析表"><a href="#SLR分析表" class="headerlink" title="SLR分析表"></a>SLR分析表</h2><p>在右部的某个地方加点的产生式<br>加点的目的是用来表示分析过程中的状态</p><p>例，从A·XYZ文法可得到如下四个项目;<br>A ·XYZ<br>A -&gt; X·YZ<br>A -&gt; XY·Z<br>A -&gt; XYZ·</p><p>拓广文法<br>如果G是一个以S为开始符号的文法, 那么G的拓广文法G’就是在G中加上新开始符号S’和产生式S’ -&gt; S而得到的文法。</p><p>项集闭包的求法<br>如果I是文法G的一个项集，那么CLOSURE(I)就是根据下面的两个规则从I构造得到的项集:：</p><p>一开始，将I中的各个项加入到CLOSURE(I)中。<br>如果A -&gt; α•Bβ在CLOSURE(I)中，B-&gt;γ是一个产生式，并且B-&gt;•γ不在CLOSURE(I)中，就将这个项加入其中。不断应用这个规则，直至没有新项添加。（大概意思就是如果闭包里如果没有希望识别γ的状态，就添加这个状态）</p><p>构造SLR分析表</p><ol><li>构造LR(0)项目核心规范族</li></ol><p>从增广文法添加的那个文法开始求闭包得到 I0</p><p>在接收符号后 · 向后移一位 得到核心项目 非核心项目通过对核心项目求闭包得到 In</p><p><a href="https://sm.ms/image/5uY9VglcPLXp3D7" target="_blank"><img src="https://s2.loli.net/2022/06/17/5uY9VglcPLXp3D7.png" ></a><br><a href="https://sm.ms/image/yciMVDXSqOn7Qdh" target="_blank"><img src="https://s2.loli.net/2022/06/17/yciMVDXSqOn7Qdh.png" ></a></p><ol start="2"><li>构造分析表<br><a href="https://sm.ms/image/wZS4KlgcLC7FHbU" target="_blank"><img src="https://s2.loli.net/2022/06/17/wZS4KlgcLC7FHbU.png" ></a></li></ol><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="编译原理" scheme="http://akkaduilin.com/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="语法分析" scheme="http://akkaduilin.com/tags/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/"/>
    
    <category term="编译原理" scheme="http://akkaduilin.com/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Java ArrayList</title>
    <link href="http://akkaduilin.com/2022/05/23/ArrayList/"/>
    <id>http://akkaduilin.com/2022/05/23/ArrayList/</id>
    <published>2022-05-23T08:01:07.000Z</published>
    <updated>2022-06-19T09:19:05.631Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>Java ArrayList 方法</p><p>sort函数的一些理解</p><p>Comparator接口的用法</p><span id="more"></span><h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><p>ArrayList是实现List接口的，底层采用数组实现。</p><p>ArrayList 实现了Cloneable接口，即覆盖了函数clone()，能被克隆。</p><p>ArrayList 实现java.io.Serializable接口，这意味着ArrayList支持序列化，能通过序列化去传输。</p><p>头文件<br>import java.util.ArrayList;</p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p><a href="https://blog.csdn.net/ly0724ok/article/details/117966154/">https://blog.csdn.net/ly0724ok/article/details/117966154/</a></p><p><a href="https://sm.ms/image/fOX4cxyuBvkgrKb" target="_blank"><img src="https://s2.loli.net/2022/05/23/fOX4cxyuBvkgrKb.png" ></a></p><h1 id="sort自定义排序"><a href="#sort自定义排序" class="headerlink" title="sort自定义排序"></a>sort自定义排序</h1><p>方法原型<br>void java.util.ArrayList.sort(Comparator&lt;? super Contury&gt; c)</p><p>Comparator接口具有比较的功能，接口注重容器<br>而Comparator接口中必须要实现的compare(T o1,T o2)有两个参数</p><p><strong>在数组sort中实现Comparator接口的重写</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">table.sort( new Comparator&lt;Contury&gt;() &#123;</span><br><span class="line">  @Override</span><br><span class="line">  // compare重写</span><br><span class="line">  public int compare(Contury c1,Contury c2)&#123;</span><br><span class="line">      if(c1.gold&gt;c2.gold)&#123;</span><br><span class="line">          return 0;</span><br><span class="line">      &#125;</span><br><span class="line">      else return -1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>直接重写Comparator接口</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class StudentComparator implements Comparator&lt;Student&gt;&#123;  </span><br><span class="line">    @Override  </span><br><span class="line">    public int compare(Student o1, Student o2) &#123;  </span><br><span class="line">        // TODO Auto-generated method stub  </span><br><span class="line">        if(o1.getScore()&gt;o2.getScore())  </span><br><span class="line">            return -1;  </span><br><span class="line">        else if(o1.getScore()&lt;o2.getScore())  </span><br><span class="line">            return 1;  </span><br><span class="line">        else&#123;  </span><br><span class="line">            if(o1.getAge()&gt;o2.getAge())  </span><br><span class="line">                return 1;  </span><br><span class="line">            else if(o1.getAge()&lt;o2.getAge())  </span><br><span class="line">                return -1;  </span><br><span class="line">            else   </span><br><span class="line">                return 0;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p><a href="https://blog.51cto.com/u_15338614/3582482">https://blog.51cto.com/u_15338614/3582482</a></p><h1 id="xx3x"><a href="#xx3x" class="headerlink" title="xx3x"></a>xx3x</h1><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Java ArrayList 方法&lt;/p&gt;
&lt;p&gt;sort函数的一些理解&lt;/p&gt;
&lt;p&gt;Comparator接口的用法&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="http://akkaduilin.com/categories/Java/"/>
    
    
    <category term="Java - ArrayList - Comparator" scheme="http://akkaduilin.com/tags/Java-ArrayList-Comparator/"/>
    
  </entry>
  
  <entry>
    <title>SQL-触发器</title>
    <link href="http://akkaduilin.com/2022/05/16/SQL-%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
    <id>http://akkaduilin.com/2022/05/16/SQL-%E8%A7%A6%E5%8F%91%E5%99%A8/</id>
    <published>2022-05-16T13:33:46.000Z</published>
    <updated>2022-06-19T09:20:51.219Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>触发器与存储过程非常相似，触发器也是 SQL 语句集，它是通过事件进行触发而被执<br>行的，不能用 EXECUTE 语句调用；而存储过程可以通过存储过程名字而被直接调用。当对<br>某一表进行诸如 UPDATE、INSERT、DELETE 这些操作时，SQL Server 就会自动执行触发<br>器所定义的 SQL 语句，从而确保对数据的处理必须符合由这些 SQL 语句所定义的规则。</p><span id="more"></span><h1 id="DML触发器"><a href="#DML触发器" class="headerlink" title="DML触发器"></a>DML触发器</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ol><li><p>AFTER 触发器<br>又称后触发器。在执行了 INSERT、UPDATE 或 DELETE 语句操作之后执行 AFTER<br>触发器。如果仅指定 FOR 关键字，则 AFTER 为默认值。AFTER 触发器只能在表上指定，<br>可以为任何一个 DML 操作定义多个 AFTER 触发器</p></li><li><p>INSTEAD OF 触发器<br>又称替代触发器。INSTEAD OF 触发器在数据变动之前被触发，代替引起触发器执行<br>的 T-SQL 语句，即 INSTEAD OF 触发器执行时并不执行所定义的 INSERT、UPDATE 或<br>DELETE 操作，而仅执行触发器本身。</p></li></ol><h2 id="相关的逻辑表"><a href="#相关的逻辑表" class="headerlink" title="相关的逻辑表"></a>相关的逻辑表</h2><p>Inserted 表用于存储 INSERT 和 UPDATE 语句所影响的行的副本。在插入或更新事务<br>期间，新行将同时被添加到 Inserted 表和触发器表（即对其尝试执行了用户操作的表）。<br>Inserted 表中的行是触发器表中的新行的副本。<br>Deleted 表用于存储 DELETE 和 UPDATE 语句所影响的行的副本。在执行 DELETE<br>或 UPDATE 语句的过程中，行从触发器表中删除，并传输到 Deleted 表中。Deleted 表和触<br>发器表通常没有相同的行。</p><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER trigger_name </span><br><span class="line">ON &#123; OBJECT NAME &#125; </span><br><span class="line">&#123; FOR → AFTER → INSTEAD OF &#125; </span><br><span class="line">&#123;[INSERT][,][UPFATE][,][DELETE]&#125; </span><br><span class="line"> AS </span><br><span class="line">&#123; sql_statement [ ...n ] &#125;</span><br></pre></td></tr></table></figure><p>1） trigger_name ：指定触发器名称<br>2） OBJECT NAME ：要对其执行 DML 触发器的表或视图<br>3） { FOR → AFTER → INSTEAD OF } ：指定触发器的类型，如果仅指定 FOR 关键<br>字，则 AFTER 是默认值<br>4） {[INSERT][,][UPDATE][,][DELETE]} ：指定激活触发器的数据修改语句，必须至少<br>指定一项，在触发器定义中允许使用上述选项的任意顺序组合。<br>5） sql_statement：指定触发器所指定的 T-SQL 语句。<br>6） 在 DML 触发器中不允许使用下列 Transact-SQL 语句：CREATE /ALTER/ DROP<br>DATABASE、CREATE/DROP INDEX、DROP TABLE；用于执行以下操作的 ALTER TABLE：<br>添加、修改或删除列、添加或删除 PRIMARY KEY 或 UNIQUE 约束。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>创建一个触发器，在修改 SC 表中的 grade 列时，判断平均成绩是否大于 80，<br>如果大于 80，拒绝该修改操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER trgUpdateSC ON dbo.SC</span><br><span class="line">FOR UPDATE</span><br><span class="line">AS</span><br><span class="line">begin</span><br><span class="line">  IF UPDATE (Grade)</span><br><span class="line">    BEGIN</span><br><span class="line">    --判断平均 grade 是否大于 80，如果大于 80，回滚</span><br><span class="line">    if(select avg(Grade) from dbo.SC)&gt;80</span><br><span class="line">      begin</span><br><span class="line">      print &#x27;The average value of Grade cannot be more than 80&#x27;</span><br><span class="line">      rollback</span><br><span class="line">      end</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h1 id="DDL触发器"><a href="#DDL触发器" class="headerlink" title="DDL触发器"></a>DDL触发器</h1><p>DDL 触发器当服务器或者数据库中发生数据定义语言（DDL，CREATE、ALTER 和<br>DROP）事件时将被触发。</p><h2 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER trigger_name </span><br><span class="line">ON &#123; ALL SERVER → DATABASE &#125; </span><br><span class="line">[ WITH &lt;ddl_trigger_option&gt; [ ,...n ] ]</span><br><span class="line">&#123; FOR → AFTER &#125; &#123; event_type → event_group &#125; [ ,...n ]</span><br><span class="line">AS &#123; sql_statement [ ; ] [ ,...n ]&#125;</span><br></pre></td></tr></table></figure><p>1） DATABASE :将 DDL 触发器的作用域应用于当前数据库。如果指定了此参数，则<br>只要当前数据库中出现 event_type 或 event_group，就会激发该触发器。<br>2） ALL SERVER :将 DDL 触发器的作用域应用于当前服务器。如果指定了此参数，<br>则只要当前服务器中的任何位置上出现 event_type 或 event_group，就会激发该触发器。<br>3） event_type ：执行之后将导致激发 DDL 触发器的 T-SQL 语言事件的名称。<br>4） event_group ：预定义的 T-SQL 语言事件分组的名称。执行任何属于 event_group<br>的 T-SQL 语言事件之后，都将激发 DDL 触发器。</p><h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h2><p>为“Music”数据库创建 DDL 触发器，用于禁止对数据库中的表进行删除和修改操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER trg_safe ON DATABASE </span><br><span class="line">FOR DROP_TABLE, ALTER_TABLE </span><br><span class="line">AS </span><br><span class="line">PRINT &#x27;You must disable Trigger &quot; trg_safe&quot; to drop or alter tables!&#x27; </span><br><span class="line">ROLLBACK</span><br></pre></td></tr></table></figure><h1 id="管理触发器"><a href="#管理触发器" class="headerlink" title="管理触发器"></a>管理触发器</h1><h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec sp_helptext trg_delete</span><br></pre></td></tr></table></figure><h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ALTER TRIGGER trigger_name</span><br><span class="line">ON &#123; table → view &#125;</span><br><span class="line">&#123; &#123; FOR → AFTER → INSTEAD OF &#125;</span><br><span class="line">&#123; [DELETE] [,] [INSERT] [,] [UPDATE] &#125;</span><br><span class="line">AS</span><br><span class="line">&#123;sql_statement&#125;&#125;</span><br></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TRIGGER Trg_delete</span><br></pre></td></tr></table></figure><h2 id="禁用"><a href="#禁用" class="headerlink" title="禁用"></a>禁用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1）禁用对表的 DML 触发器</span><br><span class="line">DISABLE TRIGGER trg_delete ON Songs</span><br><span class="line"></span><br><span class="line">2）禁用对数据库的 DDL 触发器</span><br><span class="line">DISABLE TRIGGER trig_DDL ON DATABASE</span><br><span class="line"></span><br><span class="line">3）禁用以同一作用域定义的所有触发器</span><br><span class="line">DISABLE TRIGGER ALL ON ALL SERVER</span><br></pre></td></tr></table></figure><p>禁用之后的启用操作，应该使用语句 ENABLE TRIGGER，该语句的参数与对应的禁用语句相同。</p><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;触发器与存储过程非常相似，触发器也是 SQL 语句集，它是通过事件进行触发而被执&lt;br&gt;行的，不能用 EXECUTE 语句调用；而存储过程可以通过存储过程名字而被直接调用。当对&lt;br&gt;某一表进行诸如 UPDATE、INSERT、DELETE 这些操作时，SQL Server 就会自动执行触发&lt;br&gt;器所定义的 SQL 语句，从而确保对数据的处理必须符合由这些 SQL 语句所定义的规则。&lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="http://akkaduilin.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="SQL" scheme="http://akkaduilin.com/tags/SQL/"/>
    
    <category term="数据库" scheme="http://akkaduilin.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Transact-SQL</title>
    <link href="http://akkaduilin.com/2022/05/13/Transact-SQL/"/>
    <id>http://akkaduilin.com/2022/05/13/Transact-SQL/</id>
    <published>2022-05-13T10:52:21.000Z</published>
    <updated>2022-06-19T10:34:12.106Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>SQL Server 在支持标准 SQL 语言的同时，对其进行了扩充，引入了 T-SQL，即 Transact-SQL。通过 T-SQL，可以定义变量、使用流控制语句、自定义函数和存储过程，极大地扩展了 SQL Server 的功能。</p><span id="more"></span><h1 id="语法约定"><a href="#语法约定" class="headerlink" title="语法约定"></a>语法约定</h1><p><a href="https://sm.ms/image/ul2WgxJFGmYLaAs" target="_blank"><img src="https://s2.loli.net/2022/05/13/ul2WgxJFGmYLaAs.png" ></a></p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>注释语句不是可执行语句，不参与程序的编译、注释语句通常是用来说明代码的功能或<br>者对代码的实现方式给出简单的解释和提示。<br>在 T-SQL 中可使用两类注释符：</p><ol><li>“–”用于单行注释；</li><li>“/* */”用于多行注释。“/<em>”用于注释文字的开头，“</em>/”用于注释文字的结束。</li></ol><h1 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h1><p>SQL Server 有两类标识符：<br>1）常规标识符：符合标识符的格式规则。在 T-SQL 语句中使用常规标识符时不用将其<br>分隔开。<br><strong>常规标识符的定义规则如下：</strong><br>  1） 名称的长度可以从 1 到 128（对于本地临时表，标识符最多可以有 116 个字符）。<br>  2） 名称的第一个字符必须是一个字母或者“_”、“@”和“#”中的任意字符。<br>  3） 在中文版 SQL Server 中，可以直接使用中文名称。<br>  4） 名称中不能有空格<br>  5） 不允许使用 SQL Server 的保留字。<br>2）分隔标识符：在 T-SQL 中，不符合常规标识符定义规则的标识符必须用分隔符双引<br>号 (“) 或者方括号 ([ ])分隔，称为分隔标识符。例如：Select * from [my table]中，因为“my<br>table”中间含有空格，不符合常规标识符的定义规则，因此必须用分隔符 ([ ])进行分隔。</p><p><strong>使用</strong><br>[[[server.][database].][owner_name].] object_name<br>1）server：本地服务器；<br>2）database：当前数据库；<br>3）owner_name：在数据库中与当前连接会话登录标识相关联的数据库用户名或数据库<br>所有者（dbo）。<br>例如，需要引用 customer 数据库中 employee 表的 telephone 列，可指定 customer..<br>employee.telephone。</p><h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><ol><li><p>字符串<br>单引号内</p></li><li><p>Unicode字符串<br>与普通字符串类似，前面有N标识</p></li><li><p>二进制常量<br>前有 0x 标识</p></li><li><p>datetime 常量<br>datetime 常量使用特定格式的字符日期值来表示，并被单引号括起来。<br>下面是 datetime 常量的示例：<br>‘December 5, 1985’； ‘5 December, 1985’； ‘12/5/98’<br>‘851205’（其中的 0 不能省略）<br>下面是时间常量的示例：’14:30:24’； ‘04:24 PM’</p></li><li><p>int<br>不包含小数</p></li><li><p>decimal<br>包含小数点的数字</p></li><li><p>float/real<br>科学计数法表示</p></li><li><p>money<br>money 常量以前缀为可选的小数点和可选的货币符号的数字字符串来表示。money 常<br>量不使用引号括起。money 常量的示例：$542023.14，￥30。</p></li></ol><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>声明变量：<br>DECLARE @变量名 变量类型[,@变量名 变量类型…]</p><p>赋值：<br>SET @变量名=表达式<br>或：SELECT @局部变量=变量值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DECLARE @no varchar(10) </span><br><span class="line">--变量赋值</span><br><span class="line">SET @no=&#x27;Bj10001&#x27; </span><br><span class="line">--显示指定学生学号、姓名 </span><br><span class="line">SELECT Sid,Sname FROM student WHERE SID=@no</span><br></pre></td></tr></table></figure><p>全局变量是 SQL Server 系统内部使用的变量，其作用范围并不局限于某一程序，而是<br>任何程序均可随时调用。<br>格式：@@变量名。<br><a href="https://sm.ms/image/muU79kRgsFht4bn" target="_blank"><img src="https://s2.loli.net/2022/05/13/muU79kRgsFht4bn.png" alt="image.png"></a></p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><ol><li><p>ASCII 函数<br>函数格式：<br>ASCII（character_expression）<br>功能：求 character_expression（char 或 varchar 类型）左端第一个字符的 ASCII 码。<br>返回值数据类型：int。例如：<br>Select ASCII（’abcd’） –结果为字符 a 的 ASCII 码 97。</p></li><li><p>CHAR 函数<br>函数格式：<br>CHAR（integer_expression）<br>功能：求 ASCII 码 integer_expression 对应的字符，<br>integer_expression 的有效范围为[0,255]，如果超出范围，则返<br>回值 NULL。<br>返回值数据类型：CHAR。例如：<br>Select CHAR（97） –结果为’a’。<br>CHAR 可用于将控制字符插入字符串中。表 9- 8 显示了<br>一些常用的控制字符。<br>例9- 6: 使用回车符。<br>select ‘<strong>‘+char(13)+’</strong>*’<br>结果如图 9- 1 所示（注意，显示该结果时，在查询编辑器中，<br>需在查询工具栏选择“以文本格式显示结果”）。</p></li><li><p>UNICODE 函数<br>语法:<br>UNICODE ( ‘ncharacter_expression’ )<br>功能：按照 Unicode 标准的定义，返回输入表达式的第一个字<br>符的整数值。<br>返回类型：int。例如：<br>Select unicode(N’kerge’) –返回字符 k 的 unicode 值 107</p></li><li><p>NCHAR 函数<br>语法：NCHAR ( integer_expression )<br>功能: 根据 Unicode 标准所进行的定义，用给定整数代码返回 Unicode 字符。<br>integer_expression 介于 0 与 65535 之间的所有正整数。如果指定了超出此范围的值，将返<br>回 NULL。<br>返回类型：nchar(1)。例如：<br>select nchar(107) –返回 unicode 字符 k</p></li><li><p>CHARINDEX 函数<br>函数格式：<br>CHARINDEX（expression1, expression2[,start]）<br>功能：在 expression2 中由 start 指定的位置开始查找 expression1 第一次出现的位置，如<br>表 9- 8 控制字符及值<br>控制字符 值<br>制表符 CHAR(9)<br>换行符 CHAR(10)<br>回车 CHAR(13)<br>图 9- 1 char 函数示例<br>果没有找到，则返回 0。如果省略 start，或 start≤0，则从 expression2 的第一个字符开始。<br>返回类型：int。例如：<br>Select CHARINDEX(‘ab’, ‘123abc123abc’) –结果为 4。</p></li><li><p>LEFT 函数<br>函数格式：<br>LEFT（expression1,n）<br>功能：返回字符串 expression1 从左边开始 n 个字符组成的字符串。如果 n=0，则返回一<br>个空字符串。<br>返回类型：varchar。例如：<br>LEFT(‘abcde’, 3) –结果为’abc’。 例 9- 7：找出 dbo.student 中名字以’刘’开头的学生信息。<br>select sno,sname from dbo.student where left(sname,1)=’刘’</p></li><li><p>RIGHT 函数<br>函数格式：<br>RIGHT（expression1,n）<br>功能：返回字符串 expression1 从右边开始 n 个字符组成的字符串。如果 n=0，则返回一<br>个空字符串。<br>返回类型：varchar。例如：<br>Select RIGHT(‘abcde’, 3) –结果为’cde’。</p></li><li><p>SUBSTRING 函数<br>函数格式：<br>SUBSTRING（expression1,start,length）<br>功能：返回 expression1（数据类型为字符串、binary、text 或 image）中从 start 开始长<br>度为 length 个字符或字节的子串。<br>返回值：数据类型与 expression1 数据类型相同，但 text 类型返回值为 varchar，image 类<br>型返回值为 varbinary，next 类型返回值为 nvarchar。例如：<br>Select SUBSTRING(‘abcde123’,3,4) –结果为’cde1’。 例 9- 7 也可以写成：<br>select sno,sname from dbo.student where substring(sname,1,1)=’刘’</p></li><li><p>LEN 函数<br>函数格式：<br>LEN（expression1）<br>功能：返回字符串 expression1 中的字符个数，不包括字符串末尾的空格。<br>返回类型：int。例如：<br>Select LEN(‘abcde ‘) –结果为 5。<br>select len(‘刘’) –结果为 1。</p></li><li><p>DATALENGTH 函数<br>DATALENGTH ( expression )<br>功能：返回用于表示任何表达式的字节数。<br>返回类型：int。例如：<br>Select DATALENGTH(‘abcde ‘) –结果为 8（含 3 个空格）。<br>select DATALENGTH(‘刘’) –结果为 2。</p></li><li><p>LOWER 函数<br>函数格式：<br>LOWER（expression1）<br>功能：将字符串 expression1 中的大写字母替换为小写字母。<br>返回类型：varchar。例如：<br>Select LOWER(‘12ABC45*%^def’) –结果为’12abc45*%^def’。</p></li><li><p>UPPER 函数<br>函数格式：<br>UPPER（expression1）<br>功能：将字符串 expression1 中的小写字母替换为大写字母。<br>返回类型：varchar。例如：<br>Select UPPER(‘12ABC45*%^def’) –结果为’12ABC45 *%^DEF’。</p></li><li><p>LTRIM 函数<br>函数格式：<br>LTRIM（expression1）<br>功能：删除字符串 expression1 左端的空格。<br>返回类型：varchar。例如：<br>Select LTRIM(‘ 12AB’) –结果为’12AB’。</p></li><li><p>RTRIM 函数<br>函数格式：<br>RTRIM（expression1）<br>功能：删除字符串 expression1 末尾的空格。<br>返回类型：varchar。例如：<br>Select RTRIM(LTRIM(‘ 12AB ‘)) –结果为’12AB’。</p></li><li><p>REPLACE 函数<br>函数格式：<br>REPLACE（expression1, expression2, expression3）<br>功能：将字符串 expression1 中所有的子字符串 expression2 替换为 expression3。<br>返回值数据类型：varchar。例如：<br>Select REPLACE(‘abcde’,’de’,’12’) –结果为’abc12’。</p></li><li><p>STUFF 函数<br>语法:<br>STUFF (character_expression,start,length,character_expression )<br>功能：删除指定长度的字符并在指定的起始点插入另一组字符。<br>返回类型:如果 character_expression 是一个支持的字符数据类型，则返回字符数据。<br>例如：<br>Select STUFF(‘abcde’,4,2,’12’) –结果为’abc12’。</p></li><li><p>REVERSE 函数<br>函数格式：<br>REVERSE（expression1）<br>功能：按相反顺序返回字符串 expression1 中的字符。<br>返回值数据类型：varchar。例如：<br>Select REVERSE (‘edcba’) –结果为 abcde。</p></li><li><p>SPACE 函数<br>函数格式：<br>SPACE（n）<br>功能：返回包含 n 个空格的字符串，如果 n 为负数，则返回一个空字符串。<br>返回值数据类型：char。</p></li><li><p>STR 函数<br>函数格式：<br>STR（expression1[,length[,decimal]]）<br>功能：将数字数据转换为字符数据。length 为转换得到的字符串总长度，包括符号、小<br>数点、数字或空格。如果数字长度不够，则在左端加入空格补足长度，如果小数部分超过总<br>长度，则进行四舍五入，length 的默认值为 10，decimal 为小数位位数。<br>返回值数据类型：char。例如：<br>select str(123,6) –结果为’ 123’<br>select str(123.456,5) –结果为’ 123’<br>select str(123.456,5,2) –结果为’123.5’<br>select str(123.456,8,2) –结果为’ 123.46’</p></li><li><p>REPLICATE(character_expression,times)<br>语法：<br>REPLICATE(character_expression,times)<br>功能：返回多次复制后的字符表达式。times 参数的计算结果必须为整数。例如：<br>select replicate(‘<em>‘,3) –返回‘</em><em><em>’ 例 9- 8：以“</em>”方式输出菱形。<br>输出结果见 图 9- 2（在查询编辑器中以文本格式显示结果）。<br>declare @i int<br>set @i=1<br>while @i&lt;=4<br>begin<br>print space(4-@i)+<br>replicate(‘<em>‘,2</em>@i-1)<br>set @i=@i+1<br>end<br>set @i=1<br>while @i&lt;=3<br>begin<br>print space(@i)+replicate(‘*’,7-2</em>@i)<br>set @i=@i+1<br>end</p></li><li><p>CAST 函数<br>功能：将一种数据类型的表达式转换为另一种数据类型的表达式。<br>语法：<br>CAST ( expression AS data_type [ (length ) ])<br>例：</p></li></ol><p>–将日期时间类型转换为 char 类型<br>select cast(‘2010-3-2’ as char(10))</p><ol start="22"><li><p>CONVERT 函数<br>CONVERT 函数将一种数据类型的表达式转换为另一种数据类型的表达式。<br>语法：<br>CONVERT ( data_type [ ( length ) ] , expression [ , style ] )</p></li><li><p>ISDATE 函数<br>语法：<br>ISDATE( expression )<br>功能：如果 expression 是 datetime 或 smalldatetime 数据类型的有效日期或时间值，则<br>返回 1；否则，返回 0。例如：<br>select ISDATE(‘2009/2/29’) –返回 0</p></li><li><p>ISNULL ( check_expression , replacement_value )<br>语法：<br>ISNULL ( check_expression , replacement_value )<br>功能：如果 check_expression 不为 NULL，则返回它的值；否则，在将 replacement_value<br>隐式转换为 check_expression 的类型（如果这两个类型不同）后，则返回前者。例如：</p></li></ol><p>–如果成绩为 NULL，替换为 0<br>select grade as 成绩,ISNULL(grade,0) as ISNULL_结果 from sc</p><ol start="25"><li><p>NULLIF 函数<br>NULLIF ( expression , expression )<br>功能：如果两个指定的表达式相等，则返回空值。</p></li><li><p>ISNUMERIC 函数<br>语法：<br>ISNUMERIC ( expression )<br>功能：确定表达式是否为有效的数值类型。</p></li></ol><h2 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h2><ol><li>GETDATE 函数<br>函数格式：<br>图 9- 2 输出菱形<br>GETDATE（）<br>功能：按 SQL Server 内部标准格式返回系统日期和时间。<br>返回值数据类型：datetime。例如：<br>Select getdate() –结果为 2012-08-13 21:51:32.390</li><li>YEAR 函数<br>函数格式：<br>YEAR（date）<br>功能：返回指定日期 date 中年的整数。<br>返回值数据类型：int。例如：<br>Select year(‘2004-3-5’) –结果为 2004<br>例 9- 9：返回学生表中学生的年龄。<br>select sname as 学号, BirthDate as 出生日期,<br>YEAR(getdate())-YEAR(birthdate) as 年龄<br>from dbo.student<br>结果见图 9- 3 所示。</li><li>MONTH 函数<br>函数格式：<br>MONTH（date）<br>功能：返回指定日期 date 中月份的整数。<br>返回值数据类型：int。例如：<br>Select month(‘2004-3-5’) –结果为 3</li><li>DAY 函数<br>函数格式：<br>DAY（date）<br>功能：返回指定日期 date 中天的整数。<br>返回值数据类型：int。例如：<br>Select day(‘2004-3-5’) –结果为 5</li><li>DATENAME 函数<br>函数格式：<br>DATENAME（datepart,date）<br>功能：返回日期 date 中由 datepart 指定的日期部分的字符串。<br>返回类型：nvarchar。</li><li>DATEPART 函数<br>函数格式：<br>DATEPART（dateprrt,date）<br>功能：与 DATENAME 类似，只是返回值为整数。<br>返回值数据类型：int。</li><li>DATEADD 函数<br>函数格式：<br>DATEADD（dateprrt,n,date）<br>功能：在 date 指定日期时间的 datepart 部分加上 n，得到一个新的日期时间值。<br>返回值数据类型：datetime，如果参数 date 为 smalldatetime，则返回值为 smalldatetime<br>类型。参数 datepart 可以使用如表 9- 9 所示中的短语或缩写。例如：<br>Select dateadd(yy,2,’2012-3-4’) –结果为’2014-03-04 00:00:00.000’<br>Select dateadd(m,2,’2012-3-4’) –结果为’2012-05-04 00:00:00.000’<br>Select dateadd(d,2,’2012-3-4’) –结果为’2012-03-06 00:00:00.000’</li><li>DATEDIFF 函数<br>格式：<br>DATEDIFF ( datepart , startdate , enddate )<br>功能：返回指定的 startdate 和 enddate 之间所跨的指定 datepart 边界的计数（带符号<br>的整数）。<br>例 9- 9：返回学生表中学生的年龄。<br>select sname as 学号, BirthDate as 出生日期,<br>DATEDIFF(yy, birthdate,getdate()) as 年龄 from dbo.student</li></ol><p>datepart可选参数<br>日期部分 缩写 日期部分 缩写<br>年份 yy、yyyy 工作日 dw<br>季度 qq、q 小时 hh<br>月份 mm、m 分钟 mi、n<br>每年的某一日 dy、y 秒 ss、s<br>图 9- 3 YEAR 函数示例<br>日期 dd、d 毫秒 ms<br>星期 wk、ww 工作日 dw</p><h1 id="批处理和流程控制语句"><a href="#批处理和流程控制语句" class="headerlink" title="批处理和流程控制语句"></a>批处理和流程控制语句</h1><h2 id="IF…ELSE-语句"><a href="#IF…ELSE-语句" class="headerlink" title="IF…ELSE 语句"></a>IF…ELSE 语句</h2><ol><li>如果满足条件，则在 IF 关键字及其条件之后执行<br>T-SQL 语句。可选的 ELSE 关键字引入另一个 T-SQL 语句，当不满足 IF 条件时就执行该<br>语句。</li><li>在实际程序中，IF…ELSE 语句中不止包含一条语句，而是一组的 SQL 语句。为了可以<br>一次执行一组 SQL 语句，这时就需要使用 BEGIN…END 语句将多条语句封闭起来。</li></ol><p>eg 查找学号为 200215121 的成绩。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">DECLARE @message varchar(255),@grade_num int</span><br><span class="line">--得到 200215121 号同学的选修课程的数目</span><br><span class="line">SELECT @grade_num=COUNT(grade) FROM sc </span><br><span class="line">WHERE sno=&#x27;200215121&#x27;</span><br><span class="line">IF @grade_num=0</span><br><span class="line"> BEGIN</span><br><span class="line">  SET @message= &#x27;没有学生 200215121 的成绩&#x27;</span><br><span class="line">  PRINT @message</span><br><span class="line"> END</span><br><span class="line">ELSE</span><br><span class="line"> BEGIN</span><br><span class="line">  SET @message= &#x27;有学生 200215121 的&#x27;</span><br><span class="line">  + convert(char(2),@grade_num)+ &#x27;门课程的成绩。&#x27;</span><br><span class="line">  PRINT @message</span><br><span class="line"> END</span><br><span class="line">SET @message=&#x27;课程号查询完毕&#x27;</span><br><span class="line">PRINT @message</span><br><span class="line">GO</span><br></pre></td></tr></table></figure><h2 id="CASE-分支语句"><a href="#CASE-分支语句" class="headerlink" title="CASE 分支语句"></a>CASE 分支语句</h2><p>CASE 关键字可根据表达式的真假来确定是否返回某个值，可在允许使用表达式的任意<br>位置使用这一关键字。<br>eg 为学生表的每个院系添加说明。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT sname AS 学号,sdept AS 院系, &#x27;院系说明&#x27;=</span><br><span class="line">CASE sdept</span><br><span class="line">  --分别为各个院系添加说明</span><br><span class="line">  WHEN &#x27;IS&#x27; THEN &#x27;属于信息系&#x27;</span><br><span class="line">  WHEN &#x27;MA&#x27; THEN &#x27;属于数学院&#x27;</span><br><span class="line">  WHEN &#x27;CS&#x27; THEN &#x27;属于计算机科学与技术学院&#x27;</span><br><span class="line">ELSE &#x27;其他院系&#x27;</span><br><span class="line">END </span><br><span class="line">FROM student ORDER BY sname --按照姓名排序</span><br></pre></td></tr></table></figure><h2 id="WHILE-语句"><a href="#WHILE-语句" class="headerlink" title="WHILE 语句"></a>WHILE 语句</h2><p>设置重复执行 SQL 语句或语句块的条件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">WHILE 逻辑表达式</span><br><span class="line">Begin</span><br><span class="line"> T-SQL 语句组</span><br><span class="line">[break] /*终止整个语句的执行*/</span><br><span class="line">[continue] /*结束一次循环体的执行*/</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p>eg 求 1 到 10 之间偶数的和。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">DECLARE @i smallint,@sum smallint</span><br><span class="line">SET @i=0</span><br><span class="line">SET @sum=0</span><br><span class="line">WHILE @i&gt;=0</span><br><span class="line">BEGIN</span><br><span class="line"> SET @i=@i+1</span><br><span class="line"> IF @i&gt;10</span><br><span class="line"> BEGIN</span><br><span class="line">SELECT &#x27;1 到之间偶数的和&#x27;=@sum</span><br><span class="line"> BREAK</span><br><span class="line"> END</span><br><span class="line"> IF (@i%2)!=0</span><br><span class="line"> CONTINUE</span><br><span class="line"> ELSE</span><br></pre></td></tr></table></figure><h2 id="GOTO-语句"><a href="#GOTO-语句" class="headerlink" title="GOTO 语句"></a>GOTO 语句</h2><p>GOTO 语句将执行语句无条件跳转到标签处，并从标签位置继续处理。GOTO 语句和标<br>签可在过程、批处理或语句块中的任何位置使用。其语法格式为：<br>GOTO label</p><h2 id="WAITFOR-语句"><a href="#WAITFOR-语句" class="headerlink" title="WAITFOR 语句"></a>WAITFOR 语句</h2><p>WAITFOR 语句，称为延迟语句，就是暂停执行一个指定的时间间隔或者到一个指定的时间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">WAITFOR </span><br><span class="line">&#123; </span><br><span class="line">DELAY &#x27;time_to_pass&#x27; /* 设定等待时间 */</span><br><span class="line"></span><br><span class="line">| TIME &#x27;time_to_execute&#x27; /* 设定等待到某一时刻 */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">延迟 30 秒执行查询。</span><br><span class="line">WAITFOR DELAY &#x27;00:00:30&#x27;</span><br><span class="line">SELECT * FROM student</span><br></pre></td></tr></table></figure> <h2 id="TRY-CATCH"><a href="#TRY-CATCH" class="headerlink" title="TRY-CATCH"></a>TRY-CATCH</h2><p>TRY 块包含一组 T-SQL 语句。如果 TRY 块的语句中发生任何错误，控制将传递给CATCH 块。CATCH 块包含另外一组语句，这些语句在错误发生时执行。如果 TRY 块中没有错误，控制将传递到关联的 END CATCH 语句后紧跟的语句。如果 END CATCH 语句是存储过程或触发器中的最后一条语句，控制将传递到调用该存储过程或触发器的语句。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">BEGIN TRY </span><br><span class="line">&#123; sql_statement | statement_block &#125; </span><br><span class="line">END TRY</span><br><span class="line">BEGIN CATCH </span><br><span class="line">&#123; sql_statement | statement_block &#125; </span><br><span class="line">END CATCH [ ; ]</span><br><span class="line"></span><br></pre></td></tr></table></figure> <h2 id="Raiserror"><a href="#Raiserror" class="headerlink" title="Raiserror"></a>Raiserror</h2><p>有时会遇到 SQL SERVER 实际并不知道的一些错误，但我们希望能在客户端产生运行错误，而客户端使用的时候能够唤醒异常处理并进行相应的处理。RAISERROR 生成的错误与数据库引擎代码生成的错误的运行方式相同。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">RAISERROR(&lt;message ID | message_string&gt;, &lt;severity #级别 &gt;,&lt;state #状态 &gt; [,&lt;argument&gt; </span><br><span class="line">[,&lt;…n&gt;]]) </span><br><span class="line">[WITH option[,…n]]</span><br></pre></td></tr></table></figure><h1 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h1><p>游标（Cursor）是一种从包括多条数据记录的结果集中每次提取一条记录以便处理的机<br>制，可以看做是查询结果的记录指针。<br><strong>游标的作用：</strong><br>1） 允许定位在结果集的特定行。<br>2） 从结果集的当前位置检索一行或一部分行。<br>3） 支持对结果集中当前位置的行进行数据修改。<br>4） 为由其他用户对显示在结果集中的数据所做的更改提供不同级别的可见性支持。<br>5） 提供脚本、存储过程和触发器中用于访问结果集中的数据的 T-SQL 语句。</p><p><strong>@@FETCH_STATUS 全局变量</strong>返回上次执行 FETCH 命令的状态。在每次用 FETCH 从<br>游标中读取数据时，都应检查该变量，以确定上次 FETCH 操作是否成功，来决定如何进行<br>下一步处理。@@FETCH_STATUS 变量有三个不同的返回值: 1）返回值为 0，说明 FETCH 语句成功。<br>2）返回值为-1，说明 FETCH 语句失败或行不在结果集中。<br>3）返回值为-2，说明提取的行不存在。</p><p>利用游标将成绩表（SC）中不及格的成绩改为 60 分。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">--声明变量</span><br><span class="line">declare @v_sno varchar(10),</span><br><span class="line">@v_cno varchar(10),@v_grade int</span><br><span class="line">--声明游标</span><br><span class="line">declare cur scroll cursor</span><br><span class="line">for select sno,cno,grade from sc</span><br><span class="line">--打开游标</span><br><span class="line">open cur</span><br><span class="line">--取出第一行记录</span><br><span class="line">fetch next from cur into @v_sno,@v_cno,@v_grade</span><br><span class="line">--循环取值</span><br><span class="line">while @@FETCH_STATUS=0</span><br><span class="line">begin</span><br><span class="line">--判断当前记录的成绩值</span><br><span class="line">if @v_grade&lt;60</span><br><span class="line"> begin </span><br><span class="line">--显示修改前的成绩</span><br><span class="line"> select sno as 学号,cno as 课程号,grade as 更改前的成绩</span><br><span class="line"> from sc where sno=@v_sno and cno=@v_cno</span><br><span class="line">--修改游标所在行的成绩</span><br><span class="line">update sc set grade=60 where current of cur</span><br><span class="line">--显示修改后的成绩</span><br><span class="line"> select sno as 学号,cno as 课程号,grade as 更改后的成绩</span><br><span class="line"> from sc where sno=@v_sno and cno=@v_cno</span><br><span class="line"> end</span><br><span class="line">--取下一行记录</span><br><span class="line">fetch next from cur into @v_sno,@v_cno,@v_grade</span><br><span class="line">end</span><br><span class="line">--关闭游标</span><br><span class="line">close cur</span><br><span class="line">--释放游标</span><br><span class="line">deallocate cur</span><br></pre></td></tr></table></figure><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SQL Server 在支持标准 SQL 语言的同时，对其进行了扩充，引入了 T-SQL，即 Transact-SQL。通过 T-SQL，可以定义变量、使用流控制语句、自定义函数和存储过程，极大地扩展了 SQL Server 的功能。&lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="http://akkaduilin.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="SQL" scheme="http://akkaduilin.com/tags/SQL/"/>
    
    <category term="数据库" scheme="http://akkaduilin.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理-运算方法</title>
    <link href="http://akkaduilin.com/2022/04/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/"/>
    <id>http://akkaduilin.com/2022/04/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/</id>
    <published>2022-04-24T06:25:34.000Z</published>
    <updated>2022-06-19T09:17:19.612Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>计算机组成与结构课程笔记</p><span id="more"></span><h1 id="原码、反码、补码"><a href="#原码、反码、补码" class="headerlink" title="原码、反码、补码"></a>原码、反码、补码</h1><ol><li>原码<br>原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:</li></ol><p>[+1]原 = 0000 0001</p><p>[-1]原 = 1000 0001</p><p>第一位是符号位. 因为第一位是符号位, 所以8位二进制数的取值范围就是:</p><p>[1111 1111 , 0111 1111]</p><p>即</p><p>[-127 , 127]</p><p>原码是人脑最容易理解和计算的表示方式.</p><ol start="2"><li>反码<br>反码的表示方法是:</li></ol><p>正数的反码是其本身</p><p>负数的反码是在其原码的基础上, 符号位不变，其余各个位取反.</p><p>[+1] = [00000001]原 = [00000001]反</p><p>[-1] = [10000001]原 = [11111110]反</p><p>可见如果一个反码表示的是负数, 人脑无法直观的看出来它的数值. 通常要将其转换成原码再计算.</p><ol start="3"><li>补码<br>补码的表示方法是:</li></ol><p>正数的补码就是其本身</p><p>负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)</p><p>[+1] = [00000001]原 = [00000001]反 = [00000001]补</p><p>[-1] = [10000001]原 = [11111110]反 = [11111111]补</p><p>对于负数, 补码表示方式也是人脑无法直观看出其数值的. 通常也需要转换成原码在计算其数值.</p><h1 id="加减法溢出处理"><a href="#加减法溢出处理" class="headerlink" title="加减法溢出处理"></a>加减法溢出处理</h1><p><a href="https://sm.ms/image/nNip3D4zq6t8CIX" target="_blank"><img src="https://s2.loli.net/2022/04/25/nNip3D4zq6t8CIX.png" ></a></p><p>fa fb 两操作数的符号位<br>Cf 为符号位的进位<br>C 为数值最高位的进位</p><ol><li>符号相同，结果符号位与加数符号位不同，溢出</li><li>任意符号两数相加，Cf 不等于 C 溢出</li><li>双符号位f1 f2 正数为00 负数为11 符号位参与运算 结果 f1 f2 不相等，溢出<br><a href="https://sm.ms/image/Mc7uPzleO1vfNSR" target="_blank"><img src="https://s2.loli.net/2022/04/25/Mc7uPzleO1vfNSR.png" ></a></li></ol><h1 id="乘法、除法"><a href="#乘法、除法" class="headerlink" title="乘法、除法"></a>乘法、除法</h1><h2 id="定点乘法"><a href="#定点乘法" class="headerlink" title="定点乘法"></a>定点乘法</h2><ol><li><p>手工算法<br><a href="https://sm.ms/image/OYLmCwtvenBGKX4" target="_blank"><img src="https://s2.loli.net/2022/04/25/OYLmCwtvenBGKX4.png" ></a></p></li><li><p>定点原码一位乘法<br><a href="https://sm.ms/image/4VhK8T6pauRebyw" target="_blank"><img src="https://s2.loli.net/2022/04/25/4VhK8T6pauRebyw.png" ></a></p></li><li><p>定点补码一位乘法<br>布斯算法<br><a href="https://blog.csdn.net/qq_41844076/article/details/109594076">https://blog.csdn.net/qq_41844076/article/details/109594076</a></p></li></ol><h2 id="定点除法"><a href="#定点除法" class="headerlink" title="定点除法"></a>定点除法</h2><ol><li><p>手工算法<br><a href="https://sm.ms/image/5KX1bTh2tz9Ovj4" target="_blank"><img src="https://s2.loli.net/2022/04/25/5KX1bTh2tz9Ovj4.png" ></a></p></li><li><p>加减交替法<br><a href="https://sm.ms/image/w9F68ncKEaPxBUg" target="_blank"><img src="https://s2.loli.net/2022/04/25/w9F68ncKEaPxBUg.png" ></a></p></li></ol><h1 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h1><p><a href="http://kaito-kidd.com/2018/08/08/computer-system-float-point/">http://kaito-kidd.com/2018/08/08/computer-system-float-point/</a></p><p><a href="https://sm.ms/image/LiutGTOhM2p89Pq" target="_blank"><img src="https://s2.loli.net/2022/04/25/LiutGTOhM2p89Pq.png" ></a></p><p>Ms 为符号位 0正1负<br>E 为阶码 8位以2为底，阶码 = 阶码真值 + 127<br>M 为尾数 23位，采用隐含尾数最高位1的表示方法，<br>实际尾数24位，尾数真值 = 1 + 尾数</p><p>单精度浮点数 float：32 位，符号位 Ms 占 1 bit，指数 E 占 8 bit，尾数 M 占 23 bit<br>双精度浮点数 float：64 位，符号位 Ms 占 1 bit，指数 E 占 11 bit，尾数 M 占 52 bit</p><p><a href="https://sm.ms/image/wSd3TPiebLayWMI" target="_blank"><img src="https://s2.loli.net/2022/04/25/wSd3TPiebLayWMI.png" ></a></p><h2 id="移码"><a href="#移码" class="headerlink" title="移码"></a>移码</h2><p>阶码采用移码<br>尾数采用原码或补码</p><p>移码：<br><strong>补码的符号位取反</strong><br>最高位为符号位<br>只执行加减运算，加以2^n的修正量<br><a href="https://sm.ms/image/2o4zguAIMrUP7lN" target="_blank"><img src="https://s2.loli.net/2022/04/25/2o4zguAIMrUP7lN.png" ></a><br><a href="https://sm.ms/image/IAx7zFtaqHSn4TP" target="_blank"><img src="https://s2.loli.net/2022/04/26/IAx7zFtaqHSn4TP.png" ></a></p><h2 id="精度、范围"><a href="#精度、范围" class="headerlink" title="精度、范围"></a>精度、范围</h2><p><a href="https://blog.csdn.net/l1028386804/article/details/113065755">https://blog.csdn.net/l1028386804/article/details/113065755</a></p><p><a href="https://sm.ms/image/UG82NABqjEu1tKp" target="_blank"><img src="https://s2.loli.net/2022/04/25/UG82NABqjEu1tKp.png" ></a></p><p>单精度浮点数 32 位<br>符号位1位，阶码8位，尾数23位。<br>精度24位，范围 -2^127 - (1-(2^-23))*2^127</p><h2 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h2><ol><li><p>对阶</p></li><li><p>尾数的计算(加减乘除)</p></li><li><p>规格化处理<br>如果<strong>结果的两个符号位的值不同</strong>,表示运算尾数结果溢出,应“右规”,即尾数结果右移一位,阶码+1。</p></li></ol><p>如果<strong>最高数值位与符号位相同</strong>,应“左规”,此时尾数连续左移,直到最高数值位与符号位的值不同为止;同时从阶码中减去移位的位数。</p><ol start="4"><li><p>舍入<br>截断处理:无条件地丢掉正常尾数最低位之后的全部数值<br>舍入处理:运算过程中保留右移中移出的若干高位的值,然而再按某种规则用这些位上的值修正尾数</p></li><li><p>判断溢出</p></li></ol><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;计算机组成与结构课程笔记&lt;/p&gt;</summary>
    
    
    
    <category term="计算机组成原理" scheme="http://akkaduilin.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="运算方法" scheme="http://akkaduilin.com/tags/%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成笔记-主存储器</title>
    <link href="http://akkaduilin.com/2022/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E7%AC%94%E8%AE%B0-%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8/"/>
    <id>http://akkaduilin.com/2022/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E7%AC%94%E8%AE%B0-%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8/</id>
    <published>2022-04-23T07:59:21.000Z</published>
    <updated>2022-06-19T09:17:01.448Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>计算机组成原理</p><p>主存储器</p><p><a href="https://sm.ms/image/UQvDjshEwNZuA92" target="_blank"><img src="https://s2.loli.net/2022/04/23/UQvDjshEwNZuA92.jpg" ></a></p><span id="more"></span><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><a href="https://sm.ms/image/nJjHB8GmbpCu14X" target="_blank"><img src="https://s2.loli.net/2022/04/23/nJjHB8GmbpCu14X.jpg" alt="Screenshot 2022-04-12 144845.jpg"></a></p><ol><li><p>主要指标：主存容量、储存器存储时间(启动一次读写操作到完成该操作的时间)、存储周期(连续启动两次独立的储存器操作所需间隔的最小时间)</p></li><li><p>一个字节 = 8个二进制位</p></li><li><p>总线：地址总线、数据总线、控制总线 连接主存储器和CPU</p></li><li><p>AR(地址寄存器)K位 DR(数码寄存器)n位 允许主存包含2^K个可寻址的字节 在一个存储周期内，CPU和主存通过总线进行n位数据传送。</p></li></ol><h1 id="RAM"><a href="#RAM" class="headerlink" title="RAM"></a>RAM</h1><p>半导体读/写存储器按存储元件在运行中能否长时间保存信息来分为静态存储器（SRAM）和动态存储器（DRAM）。<br>其中SRAM利用双稳态触发器来保存信息,而且只要不断电,信息不会丢失,<br>DRAM使用MOS电容来保存信息,使用时需要不断给电容充电。</p><p><a href="https://sm.ms/image/pu7XfFymj3beQW9" target="_blank"><img src="https://s2.loli.net/2022/04/23/pu7XfFymj3beQW9.jpg" ></a></p><h2 id="SRAM"><a href="#SRAM" class="headerlink" title="SRAM"></a>SRAM</h2><p>静态RAM是利用双稳态触发器来记忆信息的。六管静态MOS记忆单元电路中的T1～T4组成两个反相器，交叉耦合连接成一个触发器；T1～T6管构成一个记忆单元的主体，能存放一位二进制信息。</p><h3 id="SRAM的读写"><a href="#SRAM的读写" class="headerlink" title="SRAM的读写"></a>SRAM的读写</h3><p><a href="https://sm.ms/image/TcMNbC6OUJIL1ik" target="_blank"><img src="https://s2.loli.net/2022/04/23/TcMNbC6OUJIL1ik.png" ></a></p><p>存储单元未被选中时，字选择线保持低电位，两位线保持高电位；单元被选中时，字选择线保持高电位。<br><a href="https://sm.ms/image/LHjvTfwScrnu2X7" target="_blank"><img src="https://s2.loli.net/2022/04/23/LHjvTfwScrnu2X7.png" ></a></p><p>由存储单元组成的存储器结构和功能表如下:</p><p><a href="https://sm.ms/image/g1dLcKMHYA46eSX" target="_blank"><img src="https://s2.loli.net/2022/04/23/g1dLcKMHYA46eSX.png" ></a></p><h3 id="读写时序"><a href="#读写时序" class="headerlink" title="读写时序"></a>读写时序</h3><p><a href="https://sm.ms/image/1mBpUZ6OlN3zSoe" target="_blank"><img src="https://s2.loli.net/2022/04/23/1mBpUZ6OlN3zSoe.jpg" ></a></p><p><a href="https://sm.ms/image/9dAgNRVwfpqcYKF" target="_blank"><img src="https://s2.loli.net/2022/04/23/9dAgNRVwfpqcYKF.jpg" ></a></p><h2 id="DRAM"><a href="#DRAM" class="headerlink" title="DRAM"></a>DRAM</h2><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><strong>储存单元</strong></p><p><a href="https://sm.ms/image/8c2nm7i9VG1AJvs" target="_blank"><img src="https://s2.loli.net/2022/04/23/8c2nm7i9VG1AJvs.png" ></a></p><p><strong>写入</strong>: 字线为高电平,T导通<br>写1: 位线为低电平,VDD通过T对Cs充电，  电容中有电荷则保持不变。<br>写0: 位线为高电平,Cs通过T放电，电容中无电荷则不变。</p><p><strong>读出</strong>:位线预充电至高电平; 当字线出现高电平后,T导通,若原来Cs充有电荷,则Cs放电,使位线电位下降,经放大后,读出为1; 若原来Cs上无电荷,则位线无电位变化,放大器无输出,读出为0。<br>读出后,若原来Cs充有电荷也被放掉了,和没有充电一样,因此读出是破坏性的,故读出后要立即对单元进行“重写”,以恢复原信息。</p><p><strong>储存器</strong></p><p>16K由两个64*128矩阵组成<br>WE为允许信号，若为0，执行写操作，Din通过T7T8以及T5T6进入单元<br>为1执行读操作，单元的状态通过位线1 位线2和T7T8传至读放<br>若CS = 1 不进行读写操作<br><a href="https://sm.ms/image/BSKJy8L15fWlOd4" target="_blank"><img src="https://s2.loli.net/2022/04/23/BSKJy8L15fWlOd4.png" ></a></p><h3 id="刷新"><a href="#刷新" class="headerlink" title="刷新"></a>刷新</h3><p><a href="https://sm.ms/image/3jAh5Px18slzZIi" target="_blank"><img src="https://s2.loli.net/2022/04/23/3jAh5Px18slzZIi.jpg" ></a></p><h2 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h2><ol><li><p>SDRAM —— 同步动态随机读写存储器<br>将CPU与RAM通过一个相同的时钟信号锁在一起，使RAM和CPU能够共享一个时钟周期，以相同的速度同步工作。在每一个时钟脉冲的上升沿开始传送数据。</p></li><li><p>DDR —— 双倍数据传输速率同步动态随机存储器<br>是SDRAM的一种新技术。<br>可在同一时钟周期的上升和下降沿都能传送数据，同样时间内的数据传送量翻了一倍。</p></li></ol><h1 id="ROM"><a href="#ROM" class="headerlink" title="ROM"></a>ROM</h1><p>停电时信息不丢失的存储器称为非易失性存储器。<br>可分为ROM、 PROM、EPROM、 E2 PROM 和 flash memory。</p><p>芯片的内容在制造时已经输入，只能读，不能修改。<br>存储原理：是根据元件的有无来表示该存储单元的信息（1或0）。<br>存储元件：二极管或晶体管</p><h1 id="容量扩展"><a href="#容量扩展" class="headerlink" title="容量扩展"></a>容量扩展</h1><p>1 bit  = 8 位</p><p><strong>数据线数目 = 芯片位长</strong></p><p><strong>存储器容量=字数*位长</strong></p><p><strong>地址线数 = log2(字数)</strong></p><h2 id="位扩展"><a href="#位扩展" class="headerlink" title="位扩展"></a>位扩展</h2><p>位扩展指只在位数方向扩展（加大字长），而芯片的字数和存储器的字数是一致的。位扩展的连接方式是将各存储芯片的地址线、片选线和读/写线相应地并联起来，而将各芯片的数据线单独列出。</p><p>eg:</p><p>两个16K* 4位的芯片采用位扩展方式扩展成一16K * 8 位的存储器。如下图所示。 16K * 4位的芯片的字长为4位，所以有4条数据线，分别用D0<del>D3和D4</del>D7表示；容量为16K = 2^14 ，有14条地址线，用A0~A13 表示。</p><p><a href="https://sm.ms/image/9GQzPrZYRTU6dtp" target="_blank"><img src="https://s2.loli.net/2022/04/23/9GQzPrZYRTU6dtp.png" ></a></p><h2 id="字扩展"><a href="#字扩展" class="headerlink" title="字扩展"></a>字扩展</h2><p>字扩展是指仅在容量方向扩展，而位数不变。字扩展将芯片的地址线、数据线、读/写线并联，由片选信号来区分各个芯片。64K<em>8位的存储器需要4个16K</em>8位芯片组成，连接图如下。</p><p><a href="https://sm.ms/image/CBHkpyxucihlNUZ" target="_blank"><img src="https://s2.loli.net/2022/04/23/CBHkpyxucihlNUZ.png" ></a></p><p>数据线D0 - D7线与各片的数据端相连，地址总线（共16条）低位A0 -A13 与各芯片的14个地址端相连，两位高位A14和A15经过译码器和4个片选端相连。<br>在同一时间内四个芯片中只能有一个芯片被选中。</p><h2 id="同时扩展"><a href="#同时扩展" class="headerlink" title="同时扩展"></a>同时扩展</h2><p>当构成一个容量较大的存储器时，往往需要在字方向和位方向上同时扩展，这将是前两种扩展的组合，实现起来也是很容易的。</p><p>一个存储器的容量为M<em>N位，若使用L</em>K位存储器芯片，需要(M/L)*(N/K)个芯片</p><p>如用16K×4位的SRAM组成64K×8位的存储器，需要8个芯片。</p><h1 id="xx3x"><a href="#xx3x" class="headerlink" title="xx3x"></a>xx3x</h1><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;计算机组成原理&lt;/p&gt;
&lt;p&gt;主存储器&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://sm.ms/image/UQvDjshEwNZuA92&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://s2.loli.net/2022/04/23/UQvDjshEwNZuA92.jpg&quot; &gt;&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="计算机组成原理" scheme="http://akkaduilin.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="主存储器" scheme="http://akkaduilin.com/tags/%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>节点选择</title>
    <link href="http://akkaduilin.com/2022/04/04/%E8%8A%82%E7%82%B9%E9%80%89%E6%8B%A9/"/>
    <id>http://akkaduilin.com/2022/04/04/%E8%8A%82%E7%82%B9%E9%80%89%E6%8B%A9/</id>
    <published>2022-04-04T09:39:27.000Z</published>
    <updated>2022-04-24T06:28:14.389Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>问题描述</p><p>有一棵 n 个节点的树，树上每个节点都有一个正整数权值。如果一个点被选择了，那么在树上和它相邻的点都不能被选择。求选出的点的权值和最大是多少？</p><span id="more"></span><p>输入格式<br>第一行包含一个整数 n 。<br>接下来的一行包含 n 个正整数，第 i 个正整数代表点 i 的权值。<br>接下来一共 n-1 行，每行描述树上的一条边。</p><p>输出格式<br>输出一个整数，代表选出的点的权值和的最大值。</p><p>样例输入<br>5<br>1 2 3 4 5<br>1 2<br>1 3<br>2 4<br>2 5</p><p>样例输出<br>12</p><p>样例说明<br>选择3、4、5号点，权值和为 3+4+5 = 12 。</p><p>数据规模与约定<br>对于20%的数据， n &lt;= 20。<br>对于50%的数据， n &lt;= 1000。<br>对于100%的数据， n &lt;= 100000。<br>权值均为不超过1000的正整数</p><p><a href="https://www.cnblogs.com/program-ccc/p/5221932.html">https://www.cnblogs.com/program-ccc/p/5221932.html</a></p><p>状态转移方程：</p><p>dp[x][1] = dp[x][1] + dp[u][0]  (u为x的子结点)</p><p>dp[x][0] = dp[x][0] + max{dp[u][0],dp[u][1]}(u为x的子结点)</p><figure class="highlight plaintext"><figcaption><span>[结点选择] [lang:C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN=8;</span><br><span class="line">int w[MAXN]; // 各点的权值</span><br><span class="line">vector&lt;int&gt; tree[MAXN]; // 数组下标对应的向量存贮该下标结点的邻接点</span><br><span class="line">int n;</span><br><span class="line">int dp[MAXN][2]; //dp[u][1] 存储 选了自己结点u的权值最大值 dp[u][0]存储不选结点u权值和</span><br><span class="line">int vis[MAXN]; // 判断是否遍历过</span><br><span class="line"></span><br><span class="line">void dfs(int u) // 结点u的dfs</span><br><span class="line">&#123;</span><br><span class="line">    vis[u]=1; </span><br><span class="line">    dp[u][0]=0;</span><br><span class="line">    dp[u][1]=w[u];</span><br><span class="line">    int s0=0,s1=0;</span><br><span class="line">    for(int i=0;i&lt;tree[u].size();i++) // 遍历结点u邻接结点v</span><br><span class="line">    &#123;</span><br><span class="line">        int v=tree[u][i]; </span><br><span class="line">        if(!vis[v])</span><br><span class="line">        &#123;</span><br><span class="line">            dfs(v); // 结点v的dfs</span><br><span class="line">            s0+=max(dp[v][0],dp[v][1]);</span><br><span class="line">            s1+=dp[v][0];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[u][0]+=s0;</span><br><span class="line">    dp[u][1]+=s1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;w[i]);</span><br><span class="line">    </span><br><span class="line">    for(int i=1;i&lt;=n-1;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int u,v;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;u,&amp;v);</span><br><span class="line">        tree[u].push_back(v);</span><br><span class="line">        tree[v].push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs(1);</span><br><span class="line">    </span><br><span class="line">    printf(&quot;%d\n&quot;,max(dp[1][0],dp[1][1]));</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;问题描述&lt;/p&gt;
&lt;p&gt;有一棵 n 个节点的树，树上每个节点都有一个正整数权值。如果一个点被选择了，那么在树上和它相邻的点都不能被选择。求选出的点的权值和最大是多少？&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="http://akkaduilin.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="C++" scheme="http://akkaduilin.com/tags/C/"/>
    
    <category term="树形DP" scheme="http://akkaduilin.com/tags/%E6%A0%91%E5%BD%A2DP/"/>
    
  </entry>
  
  <entry>
    <title>归并排序实战——逆序对问题</title>
    <link href="http://akkaduilin.com/2022/04/04/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E9%80%86%E5%BA%8F%E5%AF%B9%E9%97%AE%E9%A2%98/"/>
    <id>http://akkaduilin.com/2022/04/04/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E9%80%86%E5%BA%8F%E5%AF%B9%E9%97%AE%E9%A2%98/</id>
    <published>2022-04-04T09:38:03.000Z</published>
    <updated>2022-06-19T09:16:43.301Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>关于逆序对问题的题解和思路</p><span id="more"></span><p><strong>归并排序原算法指路：</strong></p><a href="/2021/12/01/%E6%8E%92%E5%BA%8F/" title="五种排序">五种排序</a><a href="/2021/12/01/%E6%8E%92%E5%BA%8F/" title="排序">排序</a><p><strong>逆序对：设a[0…n]为包含n个不数的一个序列，如果n&lt;m，且a[n]&gt;a[m],则称(n,m)构成a中的一个逆序对；</strong></p><p><a href="https://www.jb51.net/article/55283.htm">https://www.jb51.net/article/55283.htm</a></p><p>归并排序思想，先递归分治至两个数组内再依次返回排序比较<br>注意若左边数组大于右边数组，总计数应加上 <strong>mid - index1 + 1</strong><br>因为右数组是有序的，当左指针移动时会出现多个逆序对的情况，所以加上中间指针下标减去右指针所在下标加上1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int array[] = &#123;3, 9, 7, 4, 5, 2&#125;;</span><br><span class="line">const int size = sizeof array / sizeof *array;</span><br><span class="line">int temp[size];</span><br><span class="line">//int numbers[size];</span><br><span class="line"></span><br><span class="line">int reversePair(int *numbers, int start, int last, int &amp;index, int &amp;count)</span><br><span class="line">&#123;</span><br><span class="line">  if(start == last)</span><br><span class="line">  return 0;</span><br><span class="line">  int mid = (last - start) / 2 + start;</span><br><span class="line">  //递归分治</span><br><span class="line">  reversePair(numbers, start, mid, index, count);</span><br><span class="line">  reversePair(numbers, mid + 1, last, index, count);</span><br><span class="line"></span><br><span class="line">  for(int i = start; i &lt;= last; i++)</span><br><span class="line">    temp[i] = numbers[i];</span><br><span class="line"></span><br><span class="line">  int index1 = start, index2 = mid + 1;</span><br><span class="line">  index = start;</span><br><span class="line">  while(index1 &lt;= mid &amp;&amp; index2 &lt;= last) &#123;</span><br><span class="line">    if(temp[index1] &gt; temp[index2]) &#123;</span><br><span class="line">      numbers[index] = temp[index2];//将值较小的优先排入数组，起到排序作用</span><br><span class="line">      count += mid - index1 + 1;</span><br><span class="line">      index++;</span><br><span class="line">      index2++;</span><br><span class="line">    &#125; </span><br><span class="line">    else if(temp[index1] == temp[index2]) &#123;</span><br><span class="line">      numbers[index] = temp[index1];</span><br><span class="line">      index++;</span><br><span class="line">      index1++;</span><br><span class="line">      index2++;</span><br><span class="line">    &#125; </span><br><span class="line">    else if(temp[index1] &lt; temp[index2]) &#123;</span><br><span class="line">      numbers[index] = temp[index1];</span><br><span class="line">      index++;</span><br><span class="line">      index1++;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(index1 &lt;= mid) &#123;</span><br><span class="line">      while(index1 &lt;= mid) &#123;</span><br><span class="line">        numbers[index] = temp[index1];</span><br><span class="line">        index++;</span><br><span class="line">        index1++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    else &#123;</span><br><span class="line">      while(index2 &lt;= last) &#123;</span><br><span class="line">        numbers[index] = temp[index2];</span><br><span class="line">        index++;</span><br><span class="line">        index2++;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">  int count = 0;</span><br><span class="line">  int index = 0;</span><br><span class="line">  reversePair(array, 0, size - 1, index, count);</span><br><span class="line">  cout &lt;&lt; &quot;count = &quot; &lt;&lt; count &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关于逆序对问题的题解和思路&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="http://akkaduilin.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="C++" scheme="http://akkaduilin.com/tags/C/"/>
    
    <category term="归并排序" scheme="http://akkaduilin.com/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    
    <category term="逆序对" scheme="http://akkaduilin.com/tags/%E9%80%86%E5%BA%8F%E5%AF%B9/"/>
    
  </entry>
  
  <entry>
    <title>Java GUI</title>
    <link href="http://akkaduilin.com/2022/04/02/Java%20GUI/"/>
    <id>http://akkaduilin.com/2022/04/02/Java%20GUI/</id>
    <published>2022-04-02T01:29:22.000Z</published>
    <updated>2022-06-19T09:19:37.666Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>Swing 是一个为Java设计的GUI工具包。</p><p>Swing是JAVA基础类的一部分。</p><p>Swing包括了图形用户界面（GUI）器件如：文本框，按钮，分隔窗格和表。</p><p><a href="http://c.biancheng.net/view/1209.html">http://c.biancheng.net/view/1209.html</a></p><span id="more"></span><h1 id="JFrame"><a href="#JFrame" class="headerlink" title="JFrame"></a>JFrame</h1><p>JFrame 用来设计类似于 Windows 系统中窗口形式的界面。JFrame 是 Swing 组件的顶层容器，该类继承了 AWT 的 Frame 类，支持 Swing 体系结构的高级 GUI 属性。</p><table border="1">    <caption>        表1 JFrame类的常用方法</caption>    <tbody>        <tr>            <th>                方法名称</th>            <th>                概述</th>        </tr>        <tr>            <td>                getContentPane()</td>            <td>                返回此窗体的 contentPane 对象</td>        </tr>        <tr>            <td>                getDefaultCloseOperation()</td>            <td>                返回用户在此窗体上单击&ldquo;关闭&rdquo;按钮时执行的操作</td>        </tr>        <tr>            <td>                setContentPane(Container contentPane)</td>            <td>                设置 contentPane 属性</td>        </tr>        <tr>            <td>                setDefaultCloseOperation(int operation)</td>            <td>                设置用户在此窗体上单击&ldquo;关闭&rdquo;按钮时默认执行的操作</td>        </tr>        <tr>            <td>                setDefaultLookAndFeelDecorated (boolean<br />                defaultLookAndFeelDecorated)</td>            <td>                设置 JFrame 窗口使用的 Windows 外观（如边框、关<br />                闭窗口的 小部件、标题等）</td>        </tr>        <tr>            <td>                setIconImage(Image image)</td>            <td>                设置要作为此窗口图标显不的图像</td>        </tr>        <tr>            <td>                setJMenuBar( JMenuBar menubar)</td>            <td>                设置此窗体的菜单栏</td>        </tr>        <tr>            <td>                setLayout(LayoutManager manager)</td>            <td>                设置&nbsp;LayoutManager&nbsp;属性</td>        </tr>        <tr>            <td>                setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);</td>            <td>                设置用户在此窗体上发起 "close" 时默认执行的操作。必须指定以下选项之一：DO_NOTHING_ON_CLOSE（在 WindowConstants 中定义）：不执行任何操作；要求程序在已注册的WindowListener 对象的 windowClosing 方法中处理该操作。                HIDE_ON_CLOSE（在 WindowConstants 中定义）：调用任意已注册的 WindowListener 对象后自动隐藏该窗体。                DISPOSE_ON_CLOSE（在 WindowConstants 中定义）：调用任意已注册 WindowListener 的对象后自动隐藏并释放该窗体。                EXIT_ON_CLOSE（在 JFrame 中定义）：使用 System exit 方法退出应用程序。仅在应用程序中使用。            </td>        </tr>    </tbody></table><h1 id="JPanel"><a href="#JPanel" class="headerlink" title="JPanel"></a>JPanel</h1><p>JPanel 是一种中间层容器，它能容纳组件并将组件组合在一起，但它本身必须添加到其他容器中使用。JPanel 类的构造方法如下。</p><ol><li>JPanel()：使用默认的布局管理器创建新面板，默认的布局管理器为 FlowLayout。</li><li>JPanel(LayoutManagerLayout layout)：创建指定布局管理器的 JPanel 对象。</li></ol><table border="1">    <caption>        表2 JPanel类的常用方法</caption>    <tbody>        <tr>            <th>                方法名及返回值类型</th>            <th>                说明</th>        </tr>        <tr>            <td>                Component add(Component comp)</td>            <td>                将指定的组件追加到此容器的尾部</td>        </tr>        <tr>            <td>                void remove(Component comp)</td>            <td>                从容器中移除指定的组件</td>        </tr>        <tr>            <td>                void setFont(Font f)</td>            <td>                设置容器的字体</td>        </tr>        <tr>            <td>                void setLayout(LayoutManager mgr)</td>            <td>                设置容器的布局管理器</td>        </tr>        <tr>            <td>                void setBackground(Color c)</td>            <td>                设置组件的背景色</td>        </tr>    </tbody></table>wdas# xx3x<h1 id="布局管理器"><a href="#布局管理器" class="headerlink" title="布局管理器"></a>布局管理器</h1><h2 id="BorderLayout-边框布局管理器"><a href="#BorderLayout-边框布局管理器" class="headerlink" title="BorderLayout 边框布局管理器"></a>BorderLayout 边框布局管理器</h2><p>边框布局管理器将窗口分为 5 个区域：North、South、East、West 和 Center。<br>BorderLayout 布局管理器的构造方法如下所示。<br>BorderLayout()：创建一个 Border 布局，组件之间没有间隙。<br>BorderLayout(int hgap,int vgap)：创建一个 Border 布局，其中 hgap 表示组件之间的横向间隔；vgap 表示组件之间的纵向间隔，单位是像素。</p><h2 id="FlowLayout-流式布局管理器"><a href="#FlowLayout-流式布局管理器" class="headerlink" title="FlowLayout   流式布局管理器"></a>FlowLayout   流式布局管理器</h2><p>FlowLayout 布局管理器不限制它所管理组件的大小，而是允许它们有自己的最佳大小。<br>FlowLayout 布局管理器的构造方法如下。<br>FlowLayout()：创建一个布局管理器，使用默认的居中对齐方式和默认 5 像素的水平和垂直间隔。<br>FlowLayout(int align)：创建一个布局管理器，使用默认 5 像素的水平和垂直间隔。其中，align 表示组件的对齐方式，对齐的值必须是 FlowLayoutLEFT、FlowLayout.RIGHT 和 FlowLayout.CENTER，指定组件在这一行的位置是居左对齐、居右对齐或居中对齐。<br>FlowLayout(int align, int hgap,int vgap)：创建一个布局管理器，其中 align 表示组件的对齐方式；hgap 表示组件之间的横向间隔；vgap 表示组件之间的纵向间隔，单位是像素。</p><h2 id="CardLayout-卡片布局管理器"><a href="#CardLayout-卡片布局管理器" class="headerlink" title="CardLayout 卡片布局管理器"></a>CardLayout 卡片布局管理器</h2><p>CardLayout 布局管理器将容器分成许多层，每层的显示空间占据整个容器的大小，但是每层只允许放置一个组件。CardLayout 的构造方法如下。<br>CardLayout()：构造一个新布局，默认间隔为 0。<br>CardLayout(int hgap, int vgap)：创建布局管理器，并指定组件间的水平间隔（hgap）和垂直间隔（vgap）。</p><h2 id="GridLayout-网格布局管理器"><a href="#GridLayout-网格布局管理器" class="headerlink" title="GridLayout 网格布局管理器"></a>GridLayout 网格布局管理器</h2><p>GridLayout 布局管理器将组件分布在一个网格中，每个网格占据一个容器的尺寸。<br>GridLayout 的构造方法如下。<br>GridLayout()：创建一个新的网格布局，默认的行数为 1，默认的列数为 1，默认的水平间隔为 5 像素，默认的垂直间隔为 5 像素。<br>GridLayout(int rows, int cols,int hgap,int vgap)：创建一个新的网格布局，其中 rows 表示网格的行数，cols 表示网格的列数。并且可以指定组件之间横向（hgap）和纵向（vgap）的间隔，单位是像素。</p><h2 id="GridBagLayout-网格包布局管理器"><a href="#GridBagLayout-网格包布局管理器" class="headerlink" title="GridBagLayout 网格包布局管理器"></a>GridBagLayout 网格包布局管理器</h2><p>GridBagLayout 布局管理器将组件分布在一个网格中，每个网格占据一个容器的尺寸。GridBagLayout 不需要组件的尺寸一致，允许组件扩展到多行多列。<br>GridBagLayout 的构造方法如下。<br>GridBagLayout()：创建一个新的网格包布局，默认的行数为 1，默认的列数为 1，默认的水平间隔为 5 像素，默认的垂直间隔为 5 像素。</p><h2 id="BoxLayout-盒布局管理器"><a href="#BoxLayout-盒布局管理器" class="headerlink" title="BoxLayout 盒布局管理器"></a>BoxLayout 盒布局管理器</h2><p>BoxLayout 布局管理器将组件分布在一个盒子中，盒子的大小由组件的大小决定。<br>BoxLayout 的构造方法如下。<br>BoxLayout(int axis)：创建一个新的盒布局，其中 axis 表示组件的布局方向，对齐的值必须是 BoxLayout.X_AXIS 或 BoxLayout.Y_AXIS。</p><table border="1">    <caption>        表1 Box类设置组件间隔的静态方法</caption>    <tbody>        <tr>            <th>                网格包布局</th>            <th>                说明</th>        </tr>        <tr>            <td>                static Component createHorizontalGlue()</td>            <td>                创建一个不可见的、可以被水平拉伸和收缩的组件</td>        </tr>        <tr>            <td>                static Component createVerticalGlue()</td>            <td>                创建一个不可见的、可以被垂直拉伸和收缩的组件</td>        </tr>        <tr>            <td>                static Component createHorizontalStrut(int width)</td>            <td>                创建一个不可见的、固定宽度的组件</td>        </tr>        <tr>            <td>                static Component createVerticalStrut(int height)</td>            <td>                创建一个不可见的、固定高度的组件</td>        </tr>        <tr>            <td>                static Component createRigidArea(Dimension d)</td>            <td>                创建一个不可见的、总是具有指定大小的组件</td>        </tr>    </tbody></table><h1 id="标签组件"><a href="#标签组件" class="headerlink" title="标签组件"></a>标签组件</h1><p>JLabel()：创建无图像并且标题为空字符串的 JLabel。<br>JLabel(Icon image)：创建具有指定图像的 JLabel。<br>JLabel(String text)：创建具有指定文本的 JLabel。<br>JLabel(String textjcon image,int horizontalAlignment)：创建具有指定文本、图像和水平对齐方式的 JLabel，horizontalAlignment 的取值有 3 个，即 JLabel.LEFT、JLabel.RIGHT 和 JLabel.CENTER。</p><table border="1">    <caption>        表1 JLabel类的常用方法</caption>    <tbody>        <tr>            <th>                方法名称</th>            <th>                说明</th>        </tr>        <tr>            <td>                void setText(Stxing text)</td>            <td>                定义 JLabel 将要显示的单行文本</td>        </tr>        <tr>            <td>                void setIcon(Icon image)</td>            <td>                定义 JLabel 将要显示的图标</td>        </tr>        <tr>            <td>                void setIconTextGap(int iconTextGap)</td>            <td>                如果 JLabel 同时显示图标和文本，则此属性定义它们之间的间隔</td>        </tr>        <tr>            <td>                void setHorizontalTextPosition(int textPosition)</td>            <td>                设置 JLabel 的文本相对其图像的水平位置</td>        </tr>        <tr>            <td>                void setHorizontalAlignment(int alignment)</td>            <td>                设置标签内容沿 X 轴的对齐方式</td>        </tr>        <tr>            <td>                int getText()</td>            <td>                返回 JLabel 所显示的文本字符串</td>        </tr>        <tr>            <td>                Icon getIcon()</td>            <td>                返回 JLabel 显示的图形图像</td>        </tr>        <tr>            <td>                Component getLabelFor()</td>            <td>                获得将 JLabel 添加到的组件</td>        </tr>        <tr>            <td>                int getIconTextGap()</td>            <td>                返回此标签中显示的文本和图标之间的间隔量</td>        </tr>        <tr>            <td>                int getHorizontalTextPosition()</td>            <td>                返回 JLabel 的文本相对其图像的水平位置</td>        </tr>        <tr>            <td>                int getHorizontalAlignment()</td>            <td>                返回 JLabel 沿 X 轴的对齐方式</td>        </tr>    </tbody></table><h1 id="按钮组件"><a href="#按钮组件" class="headerlink" title="按钮组件"></a>按钮组件</h1><p>JButton()：创建一个无标签文本、无图标的按钮。<br>JButton(Icon icon)：创建一个无标签文本、有图标的按钮。<br>JButton(String text)：创建一个有标签文本、无图标的按钮。<br>JButton(String text,Icon icon)：创建一个有标签文本、有图标的按钮。</p><p><a href="http://c.biancheng.net/view/1217.html">http://c.biancheng.net/view/1217.html</a></p><h1 id="单行文本框组件"><a href="#单行文本框组件" class="headerlink" title="单行文本框组件"></a>单行文本框组件</h1><p>JTextField()：创建一个默认的文本框。<br>JTextField(String text)：创建一个指定初始化文本信息的文本框。<br>JTextField(int columns)：创建一个指定列数的文本框。<br>JTextField(String text,int columns)：创建一个既指定初始化文本信息，又指定列数的文本框。</p><h1 id="文本域组件"><a href="#文本域组件" class="headerlink" title="文本域组件"></a>文本域组件</h1><p>文本域与文本框的最大区别就是文本域允许用户输入多行文本信息。<br>JTextArea()：创建一个默认的文本域。<br>JTextArea(int rows,int columns)：创建一个具有指定行数和列数的文本域。<br>JTextArea(String text)：创建一个包含指定文本的文本域。<br>JTextArea(String text,int rows,int columns)：创建一个既包含指定文本，又包含指定行数和列数的多行文本域。</p><h1 id="选框组件"><a href="#选框组件" class="headerlink" title="选框组件"></a>选框组件</h1><p>JCheckBox()：创建一个默认的复选框，在默认情况下既未指定文本，也未指定图像，并且未被选择。<br>JCheckBox(String text)：创建一个指定文本的复选框。<br>JCheckBox(String text,boolean selected)：创建一个指定文本和选择状态的复选框。</p><p><strong>JRadioButton 通常位于一个 ButtonGroup 按钮组中，不在按钮组中的 JRadioButton 也就失去了单选按钮的意义。</strong><br>使用时先创建一个ButtonGroup实例，再将创建的JRadioButton加入到ButtonGroup中，这样就可以实现单选按钮的功能。</p><p>JRadioButton()：创建一个初始化为未选择的单选按钮，其文本未设定。<br>JRadioButton(Icon icon)：创建一个初始化为未选择的单选按钮，其具有指定的图像但无文本。<br>JRadioButton(Icon icon,boolean selected)：创建一个具有指定图像和选择状态的单选按钮，但无文本。<br>JRadioButton(String text)：创建一个具有指定文本但未选择的单选按钮。<br>JRadioButton(String text,boolean selected)：创建一个具有指定文本和选择状态的单选按钮。<br>JRadioButton(String text,Icon icon)：创建一个具有指定的文本和图像并初始化为未选择的单选按钮。<br>JRadioButton(String text,Icon icon,boolean selected)：创建一个具有指定的文本、图像和选择状态的单选按钮。</p><h1 id="下拉列表组件"><a href="#下拉列表组件" class="headerlink" title="下拉列表组件"></a>下拉列表组件</h1><p>JComboBox()：创建一个空的 JComboBox 对象。<br>JComboBox(ComboBoxModel aModel)：创建一个 JComboBox，其选项取自现有的 ComboBoxModel。<br>JComboBox(Object[] items)：创建包含指定数组中元素的 JComboBox。</p><p>JComboBox 能够响应 ItemEvent 事件和 ActionEvent 事件，其中 ItemEvent 触发的时机是当下拉列表框中的所选项更改时，ActionEvent 触发的时机是当用户在 JComboBox 上直接输入选择项并回车时。要处理这两个事件，需要创建相应的事件类并实现 ItemListener 接口和 ActionListener 接口。</p><h1 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h1><p>事件处理者（监听器）通常是一个类，该类如果能够处理某种类型的事件，就必须实现与该事件类型相对的接口。</p><h2 id="ActionEvent-动作事件监听器"><a href="#ActionEvent-动作事件监听器" class="headerlink" title="ActionEvent 动作事件监听器"></a>ActionEvent 动作事件监听器</h2><p>接口： ActionListener</p><p>方法</p><ol><li>addActionListener() 添加监听</li></ol><p>添加指定的动作侦听器，以接收发自此按钮的动作事件。当用户在此按钮上按下或释放鼠标时，发生动作事件。如果 l 为 null，则不抛出任何异常，也不执行任何动作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import javax.swing.*;</span><br><span class="line">import java.awt.*;</span><br><span class="line">import java.awt.event.*;</span><br><span class="line">public class FrameDemo</span><br><span class="line">&#123;</span><br><span class="line">    //定义该图形中所需的组件的引用</span><br><span class="line">    private Frame f;</span><br><span class="line">    private Button bt;</span><br><span class="line"></span><br><span class="line">    //方法</span><br><span class="line">    FrameDemo()//构造方法</span><br><span class="line">    &#123;</span><br><span class="line">        madeFrame();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void madeFrame()</span><br><span class="line">    &#123;</span><br><span class="line">        f = new Frame(&quot;My Frame&quot;);</span><br><span class="line"></span><br><span class="line">        //对Frame进行基本设置。</span><br><span class="line">        f.setBounds(300,100,600,500);//对框架的位置和大小进行设置</span><br><span class="line">        f.setLayout(new FlowLayout(FlowLayout.CENTER,5,5));//设计布局</span><br><span class="line"></span><br><span class="line">        bt = new Button(&quot;My Button&quot;);</span><br><span class="line"></span><br><span class="line">        //将组件添加到Frame中</span><br><span class="line">        f.add(bt);</span><br><span class="line"></span><br><span class="line">        //加载一下窗体上的事件</span><br><span class="line">        myEvent();</span><br><span class="line"></span><br><span class="line">        //显示窗体</span><br><span class="line">        f.setVisible(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void myEvent()</span><br><span class="line">    &#123;</span><br><span class="line">        f.addWindowListener(new WindowAdapter()//窗口监听</span><br><span class="line">        &#123;</span><br><span class="line">            public void windowClosing(WindowEvent e)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(&quot;窗体执行关闭！&quot;);</span><br><span class="line">                System.exit(0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        //让按钮具备关闭窗口的功能</span><br><span class="line">        bt.addActionListener(new ActionListener()</span><br><span class="line">        &#123;</span><br><span class="line">            public void actionPerformed(ActionEvent e)</span><br><span class="line">            &#123;</span><br><span class="line">                 System.out.println(&quot;按钮执行关闭窗口的功能&quot;);</span><br><span class="line">                 System.exit(0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] agrs)</span><br><span class="line">    &#123;</span><br><span class="line">        new FrameDemo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>removeActionListener() 删除监听</li></ol><h2 id="FocusEvent-焦点事件监听器"><a href="#FocusEvent-焦点事件监听器" class="headerlink" title="FocusEvent 焦点事件监听器"></a>FocusEvent 焦点事件监听器</h2><p>接口： FocusListener</p><p>FocusEvent 接口定义了两个方法，分别为 focusGained() 方法和 focusLost() 方法，其中 focusGained() 方法是在组件获得焦点时执行，focusLost() 方法是在组件失去焦点时执行。</p><p>方法</p><ol><li><p>addFocusListener() 添加监听</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">JTextField txtfield1 = new JTextField(20);</span><br><span class="line">txtfield1.addFocusListener(new FocusListener()</span><br><span class="line">&#123;</span><br><span class="line">@Override</span><br><span class="line">public void focusGained(FocusEvent arg0)</span><br><span class="line">&#123;</span><br><span class="line">// 获取焦点时执行此方法</span><br><span class="line">label.setText(&quot;文本框获得焦点，正在输入内容&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void focusLost(FocusEvent arg0)</span><br><span class="line">&#123;</span><br><span class="line">// 失去焦点时执行此方法</span><br><span class="line">label.setText(&quot;文本框失去焦点，内容输入完成&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>removeFocusListener() 删除监听</p></li></ol><h2 id="ListSelectionEvent-选择事件监听器"><a href="#ListSelectionEvent-选择事件监听器" class="headerlink" title="ListSelectionEvent 选择事件监听器"></a>ListSelectionEvent 选择事件监听器</h2><p>列表框控件 JList 会显示很多项供用户选择，通常在使用时会根据用户选择的列表项完成不同的操作.</p><p>接口： ListSelectionListener</p><ol><li><p>addListSelectionListener() 添加监听</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">JList list = new JList(new String[]&#123;&quot;Java&quot;, &quot;C++&quot;, &quot;C#&quot;, &quot;Python&quot;, &quot;PHP&quot;, &quot;JavaScript&quot;&#125;);</span><br><span class="line">list.addListSelectionListener(new ListSelectionListener()</span><br><span class="line">&#123;</span><br><span class="line">@Override</span><br><span class="line">public void valueChanged(ListSelectionEvent e)</span><br><span class="line">&#123;</span><br><span class="line">// 当选择项发生变化时执行此方法</span><br><span class="line">label.setText(&quot;选择了&quot; + list.getSelectedValue());</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>removeListSelectionListener() 删除监听</p></li></ol><h1 id="JSlider"><a href="#JSlider" class="headerlink" title="JSlider"></a>JSlider</h1><p>滑块（JSlider）是一个允许用户在有限区间内通过移动滑块来选择值的组件。</p><p><strong>JSlider(int min,int max,int value)</strong><br>用指定的最小值、最大值和初始值创建一个水平滑块。</p><h1 id="JProgressBar"><a href="#JProgressBar" class="headerlink" title="JProgressBar"></a>JProgressBar</h1><p>进度条（JProgressBar）是一种以可视化形式显示某些任务进度的组件。JProgressBar 类实现了一个用于为长时间的操作提供可视化指示器的 GUI 进度条。在任务的完成进度中，进度条显示该任务完成的百分比。</p><p>ProgressBar 类的常用构造方法和 JSlider 类的常用构造方法一样</p><h1 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h1><p>计时器（Timer）组件可以在指定时间间隔触发一个或多个 ActionEvent。</p><p>第一个参数为事件触发之间的间隔 单位为毫秒<br>第二个参数为ActionListener</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Timer timer = new Timer(1000, new ActionListener()</span><br><span class="line">&#123;</span><br><span class="line">@Override</span><br><span class="line">public void actionPerformed(ActionEvent e)</span><br><span class="line">&#123;</span><br><span class="line">// 每隔一秒执行一次</span><br><span class="line">label.setText(&quot;计时器触发了一次&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">timer.start();</span><br></pre></td></tr></table></figure><h1 id="JTable"><a href="#JTable" class="headerlink" title="JTable"></a>JTable</h1><p>JTable()：构造一个默认的 JTable，使用默认的数据模型、默认的列模型和默认的选择模型对其进行初始化。<br>JTable(int numRows,int numColumns)：使用 DefaultTableModel 构造具有 numRows 行和 numColumns 列个空单元格的 JTable。<br>JTable(Object[][] rowData,Object[] columnNames)：构造一个 JTable 来显示二 维数组 rowData 中的值，其列名称为 columnNames。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JTable table = new JTable(new Object[][]&#123;</span><br><span class="line">&#123;&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;&#125;,</span><br><span class="line">&#123;&quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;10&quot;&#125;&#125;,</span><br><span class="line">new Object[]&#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;&#125;);</span><br></pre></td></tr></table></figure><h1 id="其他组件"><a href="#其他组件" class="headerlink" title="其他组件"></a>其他组件</h1><h2 id="JMenu"><a href="#JMenu" class="headerlink" title="JMenu"></a>JMenu</h2><p>菜单由 Swing 中的 JMenu 类实现，可以包含多个菜单项和带分隔符的菜单。在菜单中，菜单项由 JMenuItem 类表示，分隔符由 JSeparator 类表示。</p><h2 id="弹出式菜单-JPopuMenu"><a href="#弹出式菜单-JPopuMenu" class="headerlink" title="弹出式菜单 JPopuMenu"></a>弹出式菜单 JPopuMenu</h2><p>弹出式菜单由 JPopupMenu 类实现，它是一个可弹出并显示一系列选项的小窗口。它还用于当用户选择菜单项并激活它时显示的“右拉式(pull-right)”菜单，可以在想让菜单显示的任何其他位置使用。</p><h2 id="JToolBar-工具栏组件"><a href="#JToolBar-工具栏组件" class="headerlink" title="JToolBar 工具栏组件"></a>JToolBar 工具栏组件</h2><p>工具栏提供了一个用来显示常用按钮和操作的组件</p><h2 id="JFileChooser-文件选择器"><a href="#JFileChooser-文件选择器" class="headerlink" title="JFileChooser 文件选择器"></a>JFileChooser 文件选择器</h2><p>文件选择器为用户能够操作系统文件提供了桥梁。swing 中使用 JFileChooser 类实现文件选择器，该类常用的构造方法如下。<br>JFileChooser()：创建一个指向用户默认目录的 JFileChooser。<br>JFileChooser(File currentDirectory)：使用指定 File 作为路径来创建 JFileChooser。<br>JFileChooser(String currentDirectoryPath)：创建一个使用指定路径的 JFileChooser。<br>JFileChooser(String currentDirectoryPath, FileSystemView fsv)：使用指定的当前目录路径和 FileSystem View 构造一个 JFileChooser。</p><h2 id="JColorChooser-颜色选择器"><a href="#JColorChooser-颜色选择器" class="headerlink" title="JColorChooser 颜色选择器"></a>JColorChooser 颜色选择器</h2><p>JColorChooser()：创建初始颜色为白色的颜色选取器窗格。<br>JColorChooser(Color initialColor)：创建具有指定初始颜色的颜色选取器窗格。<br>JColorChooser(ColorSelectionModel model)：创建具有指定 ColorSelectionModel 颜色选取器窗格。</p><h2 id="JOptionPane"><a href="#JOptionPane" class="headerlink" title="JOptionPane"></a>JOptionPane</h2><p>对话框通常用作从用户处接收附加信息，或者提供发生了某种事件的通知。Java 提供了 JOptionPane 类，用来创建标准对话框，也可以通过扩展 JDialog 类创建自定义的对话框。JOptionPane 类可以用来创建 4 种类型的标准对话框：确认对话框、消息对话框、输入对话框和选项对话框。</p><h2 id="JTabbedPane-选项卡组件"><a href="#JTabbedPane-选项卡组件" class="headerlink" title="JTabbedPane 选项卡组件"></a>JTabbedPane 选项卡组件</h2><p>使用选项卡可以在有限的布局空间内展示更多的内容。Swing 使用 JTabbedPane 类实现选项卡。</p><p>JTabbedPane 类创建的选项卡可以通过单击标题或者图标在选项卡之间进行切换。JTabbedPane 类的常用构造方法如下所示。<br>JTabbedPane()：创建一个具有默认 JTabbedPane.TOP 布局的空 TabbedPane。<br>JTabbedPane(int tabPlacement)：创建一个空的 TabbedPane，使其具有以下指定选项卡布局中的一种：JTabbedPane.TOP、JTabbedPane.BOTTOM、JTabbedPane.LEFT 或 JTabbedPane.RIGHT。</p><hr />         版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Swing 是一个为Java设计的GUI工具包。&lt;/p&gt;
&lt;p&gt;Swing是JAVA基础类的一部分。&lt;/p&gt;
&lt;p&gt;Swing包括了图形用户界面（GUI）器件如：文本框，按钮，分隔窗格和表。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://c.biancheng.net/view/1209.html&quot;&gt;http://c.biancheng.net/view/1209.html&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="http://akkaduilin.com/categories/Java/"/>
    
    
    <category term="Java - GUI" scheme="http://akkaduilin.com/tags/Java-GUI/"/>
    
  </entry>
  
  <entry>
    <title>关系代数</title>
    <link href="http://akkaduilin.com/2022/03/24/%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0/"/>
    <id>http://akkaduilin.com/2022/03/24/%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0/</id>
    <published>2022-03-24T13:34:27.000Z</published>
    <updated>2022-06-19T09:16:27.774Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>数据库笔记 ——  关系代数</p><span id="more"></span><h1 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h1><p><a href="https://sm.ms/image/6TerPQDAohzCOqf" target="_blank"><img src="https://s2.loli.net/2022/03/24/6TerPQDAohzCOqf.png" ></a></p><h2 id="传统运算"><a href="#传统运算" class="headerlink" title="传统运算"></a>传统运算</h2><ol><li><p>并：假设有两个关系 R1 和 R2,R1 和 R2 的并运算产生一个新关系 R3。R3 是 由属于关系 R1 或 R2 的所有不同元组所组成，记为 R3=R1∪R2。 </p></li><li><p>差：假设有两个关系 R1 和 R2，R1 和 R2 的差运算产生一个新关系 R3。R3 是由属于关系关系 R1，但不属于 R2 的元组组成，记为 R3=R1-R2。 </p></li><li><p>交：假设有两个关系 R1 和 R2，R1 和 R2 的交运算产生一个新关系 R3。R3 是由既属于关系 R1，同时又属于 R2 的元组组成，记为 R3=R1∩R2。</p></li><li><p>笛卡尔积：假设有两个关系 R1 和 R2，且 R1 为 m 元关系，R2 为 n 元关系， R1 和 R2 的笛卡尔积产生一个新关系 R3，记作 R3=R1✖R2。R3 是由 R1 和 R2 的所有元组连接而成的具有(m+n)个分量的元组组成。</p></li></ol><h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><p>关系代数中用符号 σ（西格玛，sigma）来描述选择语句。选择是根据某些条件对关系做水平切割<br>此外我们可以在 select 的同时，添加限制条件（即 where），使用例如下：</p><p><a href="https://sm.ms/image/fmZdWqKQ8Peuo6k" target="_blank"><img src="https://s2.loli.net/2022/03/24/fmZdWqKQ8Peuo6k.png" ></a></p><p>等价与</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from student where AGE=19;</span><br></pre></td></tr></table></figure><h2 id="投影"><a href="#投影" class="headerlink" title="投影"></a>投影</h2><p>投影与选择正好相反，是对关系的一种垂直切割</p><p>在关系代数中的投影语句相当于 SQL 中的字段筛选，可以选择特定的字段进行查询，格式如下：<br><a href="https://sm.ms/image/GuvKOoS2LVZQ8RF" target="_blank"><img src="https://s2.loli.net/2022/03/24/GuvKOoS2LVZQ8RF.png" ></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select sno, age, sname from student;</span><br></pre></td></tr></table></figure><p>当选择和投影连用时<br>可以和where联动 相当于一个完整的selec语句<br><a href="https://sm.ms/image/P5sA9udivbH7YRZ" target="_blank"><img src="https://s2.loli.net/2022/03/24/P5sA9udivbH7YRZ.png" ></a><br>select sname from student where AGE=19;</p><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><p><a href="https://sm.ms/image/DxoWVwcfCKZEYRm" target="_blank"><img src="https://s2.loli.net/2022/03/25/DxoWVwcfCKZEYRm.png" ></a><br>连接运算：从两个关系的笛卡尔积中选取属性间满足一定条件的元组，用(R ⋈ S）表示。<br>连接分为两种，<br>一种是等值连接(θ 为 = 关系)<br>另一种是自然连接 根据R与S共同的属性进行选择 结果中去掉重复属性列 自然联接是特殊的的等值联接</p><p><a href="https://sm.ms/image/HUV3amCqj2ngelx" target="_blank"><img src="https://s2.loli.net/2022/03/25/HUV3amCqj2ngelx.jpg" ></a></p><p>自然连接时，被舍弃的元组称为<strong>悬浮元组</strong>，如果将悬浮元组也保存在结果中，在其他属性保持空值，称为<strong>外连接</strong>，只保留左边R中的悬浮元组称为<strong>左外连接</strong>，只保留右边S中的悬浮元组称为<strong>右外连接</strong></p><p><a href="https://sm.ms/image/buEwmhMo6UJ7yN1" target="_blank"><img src="https://s2.loli.net/2022/03/28/buEwmhMo6UJ7yN1.jpg" ></a></p><h2 id="除运算"><a href="#除运算" class="headerlink" title="除运算"></a>除运算</h2><p><a href="https://sm.ms/image/NfL7kYnJmTgaA53" target="_blank"><img src="https://s2.loli.net/2022/03/23/NfL7kYnJmTgaA53.png" ></a></p><h3 id="象集"><a href="#象集" class="headerlink" title="象集"></a>象集</h3><p>象集：本质上是一次选择行的运算和一次选择列的运算。<br>求x1在表A中的象集，就是先选出所有x属性中x=x1的那些行，然后选择出不包含x1的那些列。</p><p>如A：<br>X     Y     Z<br>a1    b1    c2<br>a2    b3    c7<br>a3    b4    c6<br>a1    b2    c3<br>a4    b6    c6<br>a2    b2    c3<br>a1    b2    c1<br>a1在A中的象集为{(b1,c2),(b2,c3),(b2,c1)}</p><h3 id="除运算-1"><a href="#除运算-1" class="headerlink" title="除运算"></a>除运算</h3><p>设关系R除以关系S的结果为关系T，则T包含所有在R但是不在S中的属性及其值，且T的元组与S的元组的所有集合都在R中</p><p>R与S的除运算构成新的关系P(X),P是R中满足下列条件的元组在X属性列上的投影，元组在X上分量值x的象集Yx包含S在Y上投影的集合。</p><p><a href="https://sm.ms/image/JXj2BdQ31NFn4SE" target="_blank"><img src="https://s2.loli.net/2022/03/26/JXj2BdQ31NFn4SE.png" ></a></p><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数据库笔记 ——  关系代数&lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="http://akkaduilin.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="SQL" scheme="http://akkaduilin.com/tags/SQL/"/>
    
    <category term="数据库" scheme="http://akkaduilin.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="关系代数" scheme="http://akkaduilin.com/tags/%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>SQL数据查询</title>
    <link href="http://akkaduilin.com/2022/03/23/SQL%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2/"/>
    <id>http://akkaduilin.com/2022/03/23/SQL%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2/</id>
    <published>2022-03-23T01:59:50.000Z</published>
    <updated>2022-06-19T09:21:02.198Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>SQL的查询相关代码</p><p><a href="https://blog.csdn.net/weixin_44176696/article/details/112586831">https://blog.csdn.net/weixin_44176696/article/details/112586831</a></p><span id="more"></span><h1 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h1><h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><p>数据查询是数据库的核心操作，SQL 使用 SELECT 语句进行数据库的查询，其一般格式<br>为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT [ ALL｜DISTINCT ] &lt; 目标列表达式 &gt; [，&lt;目标列表达式 &gt; …] </span><br><span class="line">FROM &lt; 表名或视图名 &gt; [，&lt;表名或视图名&gt;… ] </span><br><span class="line">[ WHERE &lt; 条件表达式&gt; ]</span><br><span class="line">[ GROUP BY &lt; 列名列表&gt; [ HAVING &lt; 条件表达式&gt; ] ]</span><br><span class="line">[ ORDER BY &lt; 列名&gt; [ ASC ｜DESC ] ]；</span><br></pre></td></tr></table></figure><p>（1） []：表示[]中的内容是可选的，比如[ WHERE &lt; 条件表达式&gt; ]，表示可以使用 WHERE 也可以不使用</p><p>（2） &lt;&gt;：表示&lt;&gt;中的内容必须出现。比如&lt; 表名或视图名 &gt;，这个部分表示从哪个地方获取数据，是不可或缺的。</p><p>（3） ｜：表示选择其一，例如 &lt; 列名 2&gt; [ ASC ｜DESC ] ]，表示列名 2 后只能用ASC或者DESC其中之一来进行结果的排序，前者代表升序，后者代表降序。</p><p>（4） [，…]：表示括号中的内容可以重复出现 1 至多次。</p><p>（5） * 表示相应范围内的所有内容 select * 表示查找表中所有数据</p><h2 id="列操作"><a href="#列操作" class="headerlink" title="列操作"></a>列操作</h2><h3 id="查询列"><a href="#查询列" class="headerlink" title="查询列"></a>查询列</h3><p>在 SQL 语句中，用 FROM 子句指定要操纵的表，SELECT 子句给出要投影的列，对应的 SQL 语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select A,B </span><br><span class="line">from T_A</span><br><span class="line"></span><br><span class="line">select * </span><br><span class="line">from T_B</span><br></pre></td></tr></table></figure><p>SELECT 语句的执行结果是一个新表，这个表没有名字，是个临时表，它的关系模式由SELECT 子句里的属性列构成</p><p>select * 表示查找全部列</p><h3 id="列别名"><a href="#列别名" class="headerlink" title="列别名"></a>列别名</h3><p>有时候，我们希望查询结果中的某些列名不同于基本表中的列名，这时，可以在 SELECT<br>子句中增加列别名。<br>SQL 语句使用 AS 关键词对列设置“别名”。AS 使用格式如下：</p><p>旧名 AS 别名</p><p>eg：<br>查询曲库里的所有歌曲的详细信息，请把表中的各个列名：SongID，Name，Lyricist，Composer，Lang 分别替换成：歌曲编号、歌曲名称、词作者、曲作者、语言类别。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT SongID AS 歌曲编号, Name AS 歌曲名称, Lyricist AS 词作者,Composer AS 曲作者, Lang AS 语言类别</span><br><span class="line">FROM Songs;</span><br></pre></td></tr></table></figure><h3 id="查询计算列"><a href="#查询计算列" class="headerlink" title="查询计算列"></a>查询计算列</h3><p>SELECT 子句的&lt;目标列表达式&gt;不仅可以是表中真实存在的列，也可以是一个表达式。可以使用常量计算表达式或者函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT SongID, SingerID, Circulation*10000 as NewCirculation</span><br><span class="line">FROM Track</span><br><span class="line"></span><br><span class="line">SELECT Name as 姓名, Birth as 出生日期, 2012-Year（Birth） as 年龄</span><br><span class="line">FROM Singers</span><br></pre></td></tr></table></figure><h3 id="过滤重复列"><a href="#过滤重复列" class="headerlink" title="过滤重复列"></a>过滤重复列</h3><p>两条本来并不完全相同的元组，投影到某些列上后，可能变成相同的行了，可以用DISTINCT 关键字过滤它们。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT Style</span><br><span class="line">FROM Track;</span><br></pre></td></tr></table></figure><h2 id="where-子句"><a href="#where-子句" class="headerlink" title="where 子句"></a>where 子句</h2><p>WHERE 子句用于表达关系代数中选择运算的选择条件。<br><a href="https://sm.ms/image/dJUMtu5DN2VwaYr" target="_blank"><img src="https://s2.loli.net/2022/03/24/dJUMtu5DN2VwaYr.png" ></a></p><p>逻辑运算符 AND 和 OR 可以用来联结多个查询条件。<strong>AND 的优先级高于 OR</strong>，但用户可以用括号来改变优先级。</p><h3 id="确定范围"><a href="#确定范围" class="headerlink" title="确定范围"></a>确定范围</h3><p>比较运算符包括：=（等于），&gt;（大于），&lt;(小于)，&gt;=（大于等于），&lt;=（小于等于），!=<br>或者&lt;&gt;（不等于）。</p><p>谓词 BETWEEN…AND 用于查询列值在指定范围内]的元组，其中 BETWEEN 后面跟的<br>是范围下限，AND 后跟的是范围的上限。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT Name, Birth</span><br><span class="line">FROM Singers</span><br><span class="line">Where Birth&lt;1967</span><br><span class="line"></span><br><span class="line">求查询出生年份不在 1970~1980 之间的歌手的姓名与性别</span><br><span class="line">SELECT Name, Gender</span><br><span class="line">FROM Singers</span><br><span class="line">WHERE Birth NOT BETWEEN 1970 AND 1980;</span><br></pre></td></tr></table></figure><h3 id="字段匹配"><a href="#字段匹配" class="headerlink" title="字段匹配"></a>字段匹配</h3><p>谓词 LIKE 可以用来进行字符串的匹配。 其一般语法格式如下：</p><p>列名 [NOT] LIKE ‘&lt;匹配串&gt;’ [ESCAPE ‘&lt;换码字符&gt;’]</p><p>其含义是查找列值与&lt;匹配串&gt;相匹配的元组。通常，&lt;匹配串&gt;中可以使用通配符“%”（百分号）和“_”（下横线）。<br>其中：<br>%：代表任意长度（长度可以为 0）的字符串。例如，a%b 表示以 a 开头、以 b 结尾的<br>任意长度的字符串。字符串 ab、axb、agxb 都满足该匹配串。<br>_：代表任意单个字符。例如，a_b 表示以 a 开头，以 b 结尾，中间夹一个字符的任意字<br>符串。如 axb、a!b 等都满足要求。</p><p>如果用户要查询的字符串本身就含有%或_，这时就要使用’ESCAPE&lt;换码字符&gt;’对通配<br>符进行转义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">查询歌手编号以“GC”开头的歌手姓名、性别。</span><br><span class="line">SELECT Name, Gender</span><br><span class="line">FROM Singers</span><br><span class="line">WHERE SingerID like ‘GC%’</span><br><span class="line"></span><br><span class="line">查询以”John_”开头的歌手的详细信息。</span><br><span class="line">SELECT *</span><br><span class="line">FROM Singers</span><br><span class="line">WHERE Name like ‘John\_%’ ESCAPE ’\’;</span><br></pre></td></tr></table></figure><h3 id="确定集合-判空"><a href="#确定集合-判空" class="headerlink" title="确定集合/判空"></a>确定集合/判空</h3><p>谓词 IN 用来查找某个列值属于指定集合的元组，格式为：</p><p>列名 IN/NOTT IN 集合 (x , x , x , x )</p><p>谓词 IS NULL 用于判断某列的值是否为空值，格式如下：</p><p>列名 IS NULL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">查询曲目表中既不属于“乡村”、“爵士”也不是“摇滚”曲风的专辑详细信息。</span><br><span class="line">SELECT SongID, SingerID</span><br><span class="line">FROM Track</span><br><span class="line">WHERE Style NOT IN (‘乡村’, ‘爵士’ , ‘摇滚’);</span><br><span class="line"></span><br><span class="line">查询曲目表中缺少发行量信息的记录。</span><br><span class="line">SELECT *</span><br><span class="line">FROM Track</span><br><span class="line">WHERE Circulation IS NULL;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="order-by-子句"><a href="#order-by-子句" class="headerlink" title="order by 子句"></a>order by 子句</h2><p>由 SELECT-FROM-WHERE 构成的 SELECT 查询语句完成对表的选择和投影操作，得到一个新的结果表，还可以对得到的新表做进一步的操作。</p><p>ORDER BY 子句用于对查询结果进行排序。<strong>可以按照一个或者多个属性列进行升序（ASC）或者降序(DESC)排列</strong>，默认将按照升序排列。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">查询曲目表中的歌手编号、歌曲编号和曲风类别，将查询结果按照发行时间降序排列。</span><br><span class="line"></span><br><span class="line">SELECT SongID, SingerID, Style</span><br><span class="line">FROM Track</span><br><span class="line">ORDER BY PubYear DESC,SingerID ASC;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="聚集函数"><a href="#聚集函数" class="headerlink" title="聚集函数"></a>聚集函数</h2><p>AVG()：返回某列的平均值</p><p>COUNT()：返回某列的行数</p><p>MAX()：返回某列的最大值</p><p>MIN()：返回某列的最小值</p><p>SUM()：返回某列值之和<br>如果指定 DISTINCT 标识符，则表示计算时要取消指定列中的重复值。如果不指定DISTINCT 或指定 ALL（ALL 为缺省），则表示不取消重复值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">查询 Track 表中的记录总数，最早发行时间、最近发行时间和整个发行量的总和。</span><br><span class="line"></span><br><span class="line">SELECT Count(*) as 记录总数, MIN(PubYear) as ‘最早发行量’, MAX(PubYear) as ‘最近发行</span><br><span class="line">时间’, SUM(Circulation) as ‘发行量总和’</span><br><span class="line"></span><br><span class="line">FROM Track</span><br></pre></td></tr></table></figure><h2 id="group-by-子句"><a href="#group-by-子句" class="headerlink" title="group by 子句"></a>group by 子句</h2><p>聚合函数是对查询结果（一个元组集）中的值进行统计。在有的查询中，我们要把具有相同特征的元组分成若干子集，然后需要再对每个子集中的值进行统计，此时就要用到SELECT 句型中的分组子句“GROUP BY”，格式为:</p><p>GROUP BY &lt;列名列表&gt;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM access_log;</span><br><span class="line">+-----+---------+-------+------------+</span><br><span class="line">| aid | site_id | count | date       |</span><br><span class="line">+-----+---------+-------+------------+</span><br><span class="line">|   1 |       1 |    45 | 2016-05-10 |</span><br><span class="line">|   2 |       3 |   100 | 2016-05-13 |</span><br><span class="line">|   3 |       1 |   230 | 2016-05-14 |</span><br><span class="line">|   4 |       2 |    10 | 2016-05-14 |</span><br><span class="line">|   5 |       5 |   205 | 2016-05-14 |</span><br><span class="line">|   6 |       4 |    13 | 2016-05-15 |</span><br><span class="line">|   7 |       3 |   220 | 2016-05-15 |</span><br><span class="line">|   8 |       5 |   545 | 2016-05-16 |</span><br><span class="line">|   9 |       3 |   201 | 2016-05-17 |</span><br><span class="line">+-----+---------+-------+------------+</span><br><span class="line">9 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">统计 access_log 各个 site_id 的访问量：</span><br><span class="line">SELECT site_id, SUM(access_log.count) AS nums</span><br><span class="line">FROM access_log GROUP BY site_id;</span><br></pre></td></tr></table></figure><p>在用分组语句时，SELECT 后跟的列只能是聚集函数或者是出现在 GROUP BY 之后的分组列。</p><h2 id="having-子句"><a href="#having-子句" class="headerlink" title="having 子句"></a>having 子句</h2><p>在 SQL 中增加 HAVING 子句原因是，WHERE 关键字无法与聚合函数一起使用。</p><p>HAVING 子句可以让我们筛选分组后的各组数据。</p><p><a href="https://www.runoob.com/sql/sql-having.html">https://www.runoob.com/sql/sql-having.html</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT column_name, aggregate_function(column_name)</span><br><span class="line">FROM table_name</span><br><span class="line">WHERE column_name operator value</span><br><span class="line">GROUP BY column_name</span><br><span class="line">HAVING aggregate_function(column_name) operator value;</span><br></pre></td></tr></table></figure><h2 id="笛卡儿积和连接"><a href="#笛卡儿积和连接" class="headerlink" title="笛卡儿积和连接"></a>笛卡儿积和连接</h2><p>SQL 在一个查询中建立几个表的联系的方法非常简单，只要在 FROM 子句中列出所有<br>涉及到的表就可以了。从概念上讲，FROM 子句先对这些表做笛卡尔积操作，得到一个临<br>时表，以后的选择、投影等操作都是针对这个临时表，从而将多表查询转换为单表查询。</p><p>一般格式为</p><p><strong>[&lt;表名 1&gt;.]&lt;列名 1&gt; &lt;比较运算符&gt; [&lt;表名 2&gt;.]&lt;列名 2&gt;</strong></p><h2 id="join-子句"><a href="#join-子句" class="headerlink" title="join 子句"></a>join 子句</h2><p><a href="https://sm.ms/image/KJqzfrO1AQtiM9u" target="_blank"><img src="https://s2.loli.net/2022/03/30/KJqzfrO1AQtiM9u.jpg" ></a></p><h3 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h3><p>在非 ANSI 标准的实现中，连接是在 WHERE 子句中执行的（即在 WHERE 子句中指定表间的连接条件）；在 ANSI SQL-92 中，连接是在 JOIN 子句中执行的。前者称为Theta 连接，后者称为 ANSI 连接。</p><p>ANSI 内连接的语法格式：<br>FROM 表 1 [INNER] JOIN 表 2 ON &lt;连接条件&gt;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">eg ：列出曲库中所有演唱过歌曲的歌手名，歌曲名和发行量。</span><br><span class="line"></span><br><span class="line">Theta 方式的 SQL 语句：</span><br><span class="line">SELECT Songs.Name AS 歌曲名, Singers.Name AS 歌手名,Circulation AS 发行量</span><br><span class="line">FROM Songs,Track,Singers</span><br><span class="line">WHERE Songs.SongID=Track.SongID AND Track.SingerID=Singers.SingerID</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ANSI 方式的 SQL 语句为：</span><br><span class="line">SELECT Songs.Name AS 歌曲名, Singers.Name AS 歌手名,Circulation AS 发行量</span><br><span class="line">FROM Songs JOIN Track ON Songs.SongID=Track.SongID</span><br><span class="line">JOIN Singers ON Track.SingerID=Singers.SingerID</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="自身连接"><a href="#自身连接" class="headerlink" title="自身连接"></a>自身连接</h3><p><strong>连接操作不仅可以在两个表之间进行，也可以与其自身进行连接，称为表的自身连接。</strong></p><p>可以为表提供别名，其格式如下：<br>FROM &lt;源表名&gt; [AS] &lt;表别名&gt;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT FIRST.CNumber， SECOND.PCNumber</span><br><span class="line">FROM Course FIRST， Course SECOND</span><br><span class="line">WHERE FIRST.PCNumber=SECOND.CNumber；</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><p>外连接之限制一张表中的数据必须满足连接条件，而另一张表中的数据可以不满足连接<br>条件。</p><p>Theta 方式的外连接语法格式为：<br>左外连接：FROM 表 1，表 2 WHERE [表 1.]列名(+)=[表 2.]列名<br>右外连接：FROM 表 1，表 2 WHERE [表 1.]列名=[表 2.]列名(+)</p><p>ANSI 方式的外连接语法格式为：<br>FROM 表 1 LEFT | RIGHT JOIN [OUTER] 表 2 ON &lt;连接条件&gt;</p><p>SQL SERVER 支持 ANSI 方式的外连接，但 ORACLE 支持的是 Theta 方式的外连接。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT column_name(s)</span><br><span class="line">FROM table1</span><br><span class="line">FULL OUTER/RIGHT/LEFT JOIN table2</span><br><span class="line">ON table1.column_name=table2.column_name;</span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>在实际应用中，经常有一些 SELECT 语句需要使用其他 SELECT 语句的查询结果，此时就需要用到子查询。</p><h3 id="IN谓词子查询"><a href="#IN谓词子查询" class="headerlink" title="IN谓词子查询"></a>IN谓词子查询</h3><p>其格式如下：<br>SELECT &lt;列名&gt; [,&lt;列名&gt;] …<br>FROM &lt;表名&gt;<br>WHERE &lt;表达式&gt; &lt;[NOT] IN | 其它比较运算符&gt;<br>(<br>  SELECT &lt;列名&gt;<br>  FROM &lt;表名&gt;<br>  WHERE &lt;条件&gt;<br>）</p><p>NOT IN 执行的是集合运算 其他运算符执行比较运算</p><p>使用 IN 运算时，如果表达式的值与集合中的某个值相等，则此运算结果为真；如果表达式的值与集合中的所有值均不相等，则运算结果为假。由关键字 IN 引入的子查询的 SELECT 后的列名只允许有 1 项内容，即只能是一个列名或者是表达式。</p><p>使用子查询进行比较运算时，通过比较运算符（=、&lt;&gt;、&lt;、&gt;、&lt;=、&gt;=），将一个表达式的值与子查询返回的值进行比较。如果比较运算的结果为真，则比较运算返回 TRUE。使用子查询进行比较测试时，要求子查询语句必须是返回单值的查询语句。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">查询歌唱风格是“摇滚”的歌手信息。</span><br><span class="line"></span><br><span class="line">SELECT *</span><br><span class="line">FROM Singers</span><br><span class="line">WHERE SingerID IN</span><br><span class="line">(</span><br><span class="line">  SELECT DISTINCT SingerID</span><br><span class="line">  FROM Track</span><br><span class="line">  WHERE Style =’摇滚’ </span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="带有比较运算符的子查询"><a href="#带有比较运算符的子查询" class="headerlink" title="带有比较运算符的子查询"></a>带有比较运算符的子查询</h3><p>使用子查询进行比较运算时，通过比较运算符（=、&lt;&gt;、&lt;、&gt;、&lt;=、&gt;=），将一个表达式的值与子查询返回的值进行比较。如果比较运算的结果为真，则比较运算返回 TRUE。使用子查询进行比较测试时，要求子查询语句必须是返回单值的查询语句。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">查询年龄最大的歌手的信息</span><br><span class="line"></span><br><span class="line">SELECT *</span><br><span class="line">FROM Singers</span><br><span class="line">WHERE Birth =</span><br><span class="line">(</span><br><span class="line">  SELECT MAX(Birth)</span><br><span class="line">  FROM Singers</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="带有ANY或ALL谓词的子查询"><a href="#带有ANY或ALL谓词的子查询" class="headerlink" title="带有ANY或ALL谓词的子查询"></a>带有ANY或ALL谓词的子查询</h3><p><a href="https://sm.ms/image/UVIQPu9qDElgR6o" target="_blank"><img src="https://s2.loli.net/2022/03/30/UVIQPu9qDElgR6o.jpg" ></a></p><p><a href="https://blog.csdn.net/qq_38157534/article/details/108527994">https://blog.csdn.net/qq_38157534/article/details/108527994</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">【例】查询非计算机科学系中比计算机科学系任意一个学生年龄小的学生姓名和年龄</span><br><span class="line">select Sname，Sage </span><br><span class="line">from student</span><br><span class="line">where Sage &lt; ANY</span><br><span class="line">  ( select  Sage </span><br><span class="line">    from student </span><br><span class="line">    where Sdept  = &quot;CS&quot;) </span><br><span class="line">AND Sdept &lt;&gt; &quot;CS&quot;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="带有EXISTS谓词的子查询"><a href="#带有EXISTS谓词的子查询" class="headerlink" title="带有EXISTS谓词的子查询"></a>带有EXISTS谓词的子查询</h3><p>相关子查询通常使用 EXISTS 谓词，其形式为：<br>SELECT &lt;列名&gt; [,&lt;列名&gt;] …<br>FROM &lt;表名&gt;<br>WHERE<br>WHERE [NOT] EXISTS<br>(<br>  SELECT *<br>  FROM &lt;表名&gt;<br>  WHERE &lt;条件&gt;<br>)</p><p>带有 EXISTS 谓词的子查询不返回任何数据，只产生逻辑真值“true”或逻辑假值“false”：<br><em>若内层查询结果非空，则外层的 WHERE 子句返回真值</em><br><em>若内层查询结果为空，则外层的 WHERE 子句返回假值</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">查询歌唱风格是“摇滚”的歌手信息。</span><br><span class="line"></span><br><span class="line">SELECT *</span><br><span class="line">FROM Singers X</span><br><span class="line">WHERE EXISTS</span><br><span class="line">(</span><br><span class="line">SELECT *</span><br><span class="line">FROM Track</span><br><span class="line">WHERE Track.SingerID=X.SingerID and Style =’摇滚’ )</span><br></pre></td></tr></table></figure><h2 id="集合查询"><a href="#集合查询" class="headerlink" title="集合查询"></a>集合查询</h2><p>SELECT 查询操作的对象是集合，结果也是集合。集合操作主要包括并操作 UNION，交操作 INTERSECT 和差操作 EXCEPT。</p><p>注意： 参加集合操作的各查询结果的列数必须相同；对应项的数据类型也要相同。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">查询中国歌手和出生日期晚于 1960 年的歌手。</span><br><span class="line"></span><br><span class="line">SELECT *</span><br><span class="line">FROM Singers</span><br><span class="line">WHERE Nation=’中国’</span><br><span class="line">UNION</span><br><span class="line">SELECT *</span><br><span class="line">FROM Singers</span><br><span class="line">WHERE Birth&gt;=1960</span><br></pre></td></tr></table></figure><h1 id="xx3x"><a href="#xx3x" class="headerlink" title="xx3x"></a>xx3x</h1><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SQL的查询相关代码&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_44176696/article/details/112586831&quot;&gt;https://blog.csdn.net/weixin_44176696/article/details/112586831&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="http://akkaduilin.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="SQL" scheme="http://akkaduilin.com/tags/SQL/"/>
    
    <category term="数据库" scheme="http://akkaduilin.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="关系代数" scheme="http://akkaduilin.com/tags/%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>自动机基础</title>
    <link href="http://akkaduilin.com/2022/03/10/%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    <id>http://akkaduilin.com/2022/03/10/%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%9F%BA%E7%A1%80/</id>
    <published>2022-03-10T08:00:34.000Z</published>
    <updated>2022-06-19T09:18:44.516Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>编译原理语法分析和自动机笔记</p><span id="more"></span><h1 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h1><ol><li>词法记号：由记号名和属性值构成的二元组，属性值不是必须项，记号名是语法分析的输入符号。</li><li>模式：一个记号的模式描述属于该记号的词法单元的形式。和一个给定模式匹配的字（字符串）的集合成为该模式的语言。</li><li>词法单元：是源程序中匹配一个记号模式的字符序列，由词法分析器识别为该记号的一个实例。<br><a href="https://sm.ms/image/uPWla5wI7JXTDYb" target="_blank"><img src="https://s2.loli.net/2022/04/10/uPWla5wI7JXTDYb.png" ></a></li></ol><h1 id="有限自动机"><a href="#有限自动机" class="headerlink" title="有限自动机"></a>有限自动机</h1><p>词法单元的识别<br><a href="https://sm.ms/image/gv2d78rL1SQahHc" target="_blank"><img src="https://s2.loli.net/2022/04/10/gv2d78rL1SQahHc.png" ></a></p><h2 id="状态转换图"><a href="#状态转换图" class="headerlink" title="状态转换图"></a>状态转换图</h2><ol><li>圆圈表示状态，开始状态由一条没有出发节点、标号为“开始”的边指明</li><li>双层圆圈表示接受状态，表示已识别一个记号</li><li>有向边表示从一个状态到另一状态</li><li>每条边的标号包含一个或多个符号，若离开状态s的某边上标号为other，则它表示离开s的其他边所指示的字符以外的任意字符</li><li>*表示输入指针必须回退的转态</li></ol><p><a href="https://sm.ms/image/Cwu4Y2OULmiG1IJ" target="_blank"><img src="https://s2.loli.net/2022/04/10/Cwu4Y2OULmiG1IJ.png" ></a></p><p>使用*installNum()*来获取要返回的记号名和属性</p><h2 id="不确定的有限自动机（NFA）"><a href="#不确定的有限自动机（NFA）" class="headerlink" title="不确定的有限自动机（NFA）"></a>不确定的有限自动机（NFA）</h2><p><em>不确定的含义是存在这样的状态，对于某个输入符号，存在不止一种的转换</em></p><p><a href="https://sm.ms/image/QKDBcj7fCsMP59F" target="_blank"><img src="https://s2.loli.net/2022/04/10/QKDBcj7fCsMP59F.png" ></a></p><p><strong>手工构造NFA</strong><br><a href="https://sm.ms/image/GJVDSbQnlEvoU34" target="_blank"><img src="https://s2.loli.net/2022/04/10/GJVDSbQnlEvoU34.png" ></a></p><p><strong>转换表表示在NFA输入是a时，状态i所能到达的状态集合。</strong></p><h2 id="确定的有限自动机（DFA）"><a href="#确定的有限自动机（DFA）" class="headerlink" title="确定的有限自动机（DFA）"></a>确定的有限自动机（DFA）</h2><p>是不确定自动机的特殊情况</p><ol><li>任何状态不存在空转换</li><li>对任何状态s和输入符号a，最多只有一条标记为a的边离开s，即转换函数move最多只有一个，并且可以是不分函数</li><li>如果用转换表来表示DFA，表中每个条目最多只有一个状态。</li></ol><p><a href="https://sm.ms/image/b2lZOW4RVk5xnBi" target="_blank"><img src="https://s2.loli.net/2022/04/10/b2lZOW4RVk5xnBi.png" ></a></p><p><a href="https://sm.ms/image/gQ5wBUqhaXrbkiR" target="_blank"><img src="https://s2.loli.net/2022/04/10/gQ5wBUqhaXrbkiR.png" ></a></p><h1 id="从正则表达式到NFA"><a href="#从正则表达式到NFA" class="headerlink" title="从正则表达式到NFA"></a>从正则表达式到NFA</h1><p><strong>MYT算法构造NFA</strong></p><h2 id="构造识别空和字母表中一个符号的NFA"><a href="#构造识别空和字母表中一个符号的NFA" class="headerlink" title="构造识别空和字母表中一个符号的NFA"></a>构造识别空和字母表中一个符号的NFA</h2><p><a href="https://sm.ms/image/S2cYgyePsK37BFZ" target="_blank"><img src="https://s2.loli.net/2022/04/11/S2cYgyePsK37BFZ.png" ></a></p><h2 id="构造识别主算符为选择正则式的NFA"><a href="#构造识别主算符为选择正则式的NFA" class="headerlink" title="构造识别主算符为选择正则式的NFA"></a>构造识别主算符为选择正则式的NFA</h2><p><a href="https://sm.ms/image/jl8qX65Q9fFSWDN" target="_blank"><img src="https://s2.loli.net/2022/04/11/jl8qX65Q9fFSWDN.png" ></a></p><h2 id="造识别主算符为闭包正则式的NFA"><a href="#造识别主算符为闭包正则式的NFA" class="headerlink" title="造识别主算符为闭包正则式的NFA"></a>造识别主算符为闭包正则式的NFA</h2><p><a href="https://sm.ms/image/oszIn5VJFXSbWRv" target="_blank"><img src="https://s2.loli.net/2022/04/11/oszIn5VJFXSbWRv.png" ></a></p><h1 id="从NFA到DFA"><a href="#从NFA到DFA" class="headerlink" title="从NFA到DFA"></a>从NFA到DFA</h1><p><strong>子集构造法</strong></p><p>从第一个状态集合{0} 开始，寻找通过对应的的输入符号所达到的新的状态集合</p><p><a href="https://sm.ms/image/dakmJMfp6csuWOS" target="_blank"><img src="https://s2.loli.net/2022/04/11/dakmJMfp6csuWOS.png" ></a></p><p><a href="https://sm.ms/image/f7G4CmQtKMcugVn" target="_blank"><img src="https://s2.loli.net/2022/04/11/f7G4CmQtKMcugVn.png" ></a></p><h1 id="DFA最简化"><a href="#DFA最简化" class="headerlink" title="DFA最简化"></a>DFA最简化</h1><p>D＇的开始状态是包含了D的开始状态的组的代表<br>D＇的接受状态是包含了D的接受状态的组的代表<br>如果D＇有死状态，则删除它<br>从开始状态不可达的状态也删除<br>从任何其他状态到死状态的转换都改成无定义</p><p>例：<br>为正则表达式(a|b)*a(a|b)(a|b)构造NFA。并将NFA转换为DFA<br><a href="https://sm.ms/image/cCKnjfMRz7u9bUy" target="_blank"><img src="https://s2.loli.net/2022/04/11/cCKnjfMRz7u9bUy.png" ></a></p><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;编译原理语法分析和自动机笔记&lt;/p&gt;</summary>
    
    
    
    <category term="编译原理" scheme="http://akkaduilin.com/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="编译原理" scheme="http://akkaduilin.com/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    <category term="概念" scheme="http://akkaduilin.com/tags/%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>数据库完整性</title>
    <link href="http://akkaduilin.com/2022/03/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7/"/>
    <id>http://akkaduilin.com/2022/03/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7/</id>
    <published>2022-03-10T07:54:08.000Z</published>
    <updated>2022-06-19T09:18:23.056Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>SQL Server 为了保证数据完整性共提供了以下 6 种约束。</p><ol><li>非空（NOT NULL）约束</li><li>主键（PRIMARY KEY）约束</li><li>外键（FOREIGN KEY）约束</li><li>唯一性（UNIQUE）约束</li><li>检查（CHECK）约束</li><li>默认（DEFAULT）约束</li></ol><span id="more"></span><h1 id="实体完整性及其实现"><a href="#实体完整性及其实现" class="headerlink" title="实体完整性及其实现"></a>实体完整性及其实现</h1><p>规则：若属性A是基本关系R的主属性，则属性A不能取空值</p><h2 id="PRIMARY-KEY-约束"><a href="#PRIMARY-KEY-约束" class="headerlink" title="PRIMARY KEY 约束"></a>PRIMARY KEY 约束</h2><p>表通常具有包含唯一标识表中每一行值的一列或一组列，这样的一列或多列称为表的主键（PRIMARY KEY）。</p><p><strong>一个表只能有一个 PRIMARY KEY 约束，并且 PRIMARY KEY 约束中的列不能接受空值。</strong> </p><p><strong>如果对多列定义了 PRIMARY KEY 约束，则一列中的值可能会重复，但来自 PRIMARY KEY 约束定义中所有列的任何值组合必须唯一。</strong></p><p><strong>当定义主键约束时，SQL Server 在主键列上建立唯一聚簇索引，以加快查询速度。</strong></p><ol><li><p>单一主键的约束<br>CREATE TABLE 或 ALTER TABLE 中使用 PRIMARY KEY 关键字</p></li><li><p>组合主键的约束<br>PRIMARY KEY(列名1，列名2)</p></li></ol><p>代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CREATE TABLE Track</span><br><span class="line">(SongID CHAR(10) not null，</span><br><span class="line">SingerID CHAR(10) not null,</span><br><span class="line">Album VARCHAR(50),</span><br><span class="line">Style VARCHAR(20) default(&#x27;流行&#x27;), /*DEFAULT 约束*/</span><br><span class="line">Circulation INTEGER, PubYear INTEGER,</span><br><span class="line">PRIMARY KEY(SongID, SingerID)) /*主键约束，该约束是表级完整性约束*/</span><br><span class="line"></span><br><span class="line">ALTER TABLE Persons</span><br><span class="line">ADD PRIMARY KEY (P_Id)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="UNIQUE-约束"><a href="#UNIQUE-约束" class="headerlink" title="UNIQUE 约束"></a>UNIQUE 约束</h2><p>唯一约束被用来增强非主键列的唯一性。设置了唯一约束的列不能有重复值，可以但最<br>多允许一个 NULL 值。</p><p><strong>主键约束与唯一约束的异同：</strong><br>两者都要求约束的列不能有重复值；<br>主键约束要求主键列不能为空；唯一约束允许有空值，但只允许一个 NULL 值。</p><p><strong>在一个表上可以定义多个 UNIQUE 约束；</strong></p><p><strong>可以在多个列上定义一个 UNIQUE 约束，表示这些列组合起来不能有重复值。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CREATE TABLE Singer(</span><br><span class="line">-- 主键约束</span><br><span class="line">SingerID char(10) NOT NULL PRIMARY KEY,</span><br><span class="line">-- 唯一约束 </span><br><span class="line">Name varchar(50) NOT NULL UNIQUE, </span><br><span class="line">Gender varchar(2) NULL, Birth datetime NULL,</span><br><span class="line">Nation varchar(20) NULL)</span><br><span class="line"></span><br><span class="line">ALTER TABLE Persons</span><br><span class="line">ADD UNIQUE (P_Id)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="检查和违约"><a href="#检查和违约" class="headerlink" title="检查和违约"></a>检查和违约</h2><ol><li><p>检查主码值是否唯一，如果不唯一则拒绝插入或修改。</p></li><li><p>检查主码的各个属性是否为空，只要有一个为空就拒绝插入或修改。</p></li></ol><h1 id="用户定义完整性及实现"><a href="#用户定义完整性及实现" class="headerlink" title="用户定义完整性及实现"></a>用户定义完整性及实现</h1><p>用户定义的完整性是通过检查约束来实现的。<br>约束条件应是逻辑表达式，多个条件可以用 AND 或 OR 组合。<br>NUll<br>UNIQUE</p><h2 id="CHECK约束"><a href="#CHECK约束" class="headerlink" title="CHECK约束"></a>CHECK约束</h2><p>1） 列级的约束只能引用被约束的列上的值，一个列上可以有任意多个 CHECK 约束，<br>多个 CHECK 约束按创建顺序进行验证。<br>2） 可以在表上建立一个可以在多个列上使用的 CHECK 约束，但是表级约束只能引用<br>同一表中的列。<br>3） 不能在 text、ntext 或 image 列上定义 CHECK 约束。<br>4） CHECK 可以使用 IN、LIKE、BETWEEN 关键字。<br>5)  ADD CONSTRAINT CK_name 命名约束</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>常用约束</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CREATE TABLE Singer(</span><br><span class="line">SingerID char(10) NOT NULL PRIMARY KEY, /* 主键约束 */</span><br><span class="line">Name varchar(50) NOT NULL /* 非空约束 */</span><br><span class="line">UNIQUE, /* 唯一约束 */</span><br><span class="line">Gender varchar(2) NULL CHECK(Gender in(’男’,’女’)), /* 检查约束 */</span><br><span class="line">Birth datetime NULL, Nation varchar(20) NULL)</span><br><span class="line"></span><br><span class="line">WEIGHTNUMERIC(9,2) CHECK(WEIGHT&gt;0 AND WEIGHT&lt;=100 // 体重大于0小于100</span><br><span class="line">SSEXCHAR(2)CHECK(SSEX=&#x27;male&#x27; OR SSEX=&#x27;female&#x27;) // 性别男或女</span><br><span class="line">SAGESMALLINT CHECK(SAGE&gt;=15 AND SAGE&lt;=45)</span><br><span class="line"></span><br><span class="line">ALTER TABLE Persons ADD CONSTRAINT chk_Person CHECK (Id_P&gt;0 AND City=&#x27;Sandnes&#x27;) //命名约束</span><br><span class="line">ALTER TABLE Persons DROP CHECK chk_Person // 删除约束</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="检查和违约-1"><a href="#检查和违约-1" class="headerlink" title="检查和违约"></a>检查和违约</h2><p>当往表中插入元组或修改属性的值时，关系数据库管理系统将检查属性上的约束条件是否满足，不满足被拒绝执行</p><h1 id="参照完整性及实现"><a href="#参照完整性及实现" class="headerlink" title="参照完整性及实现"></a>参照完整性及实现</h1><p>参照完整性主要通过主键与外键的联系来实现的。主键所在的表称为主表，外键所在的<br>表称为子表。外键的取值参照主键的取值，即外键列的值有两种可能：一是等于主键的某个<br>值；二是为空值，否则将返回违反外键约束的错误信息。</p><h2 id="FOREIGN-KEY"><a href="#FOREIGN-KEY" class="headerlink" title="FOREIGN KEY"></a>FOREIGN KEY</h2><ol><li>FOREIGN KEY 约束只能引用同一个服务器上的同一数据库中的表。跨数据库的参照完整性必须通过触发器实现。</li><li>FOREIGN KEY 可引用同一个表中的其他列，这称为自引用。</li><li>FOREIGN KEY 约束并不仅仅可以与另一表的 PRIMARY KEY 约束相链接，它还可以定义为引用另一表的 UNIQUE 约束。</li><li>不能更改定义了 FOREIGN KEY 约束的列的长度，因为外键列和主键列的数据类型和长度需一致。</li></ol><p>利用 <strong>FOREIGN KEY……REFERENCES</strong> 关键字设置参照完整性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE Track</span><br><span class="line">(/*外键约束*/</span><br><span class="line">SongID CHAR(10) not null FOREIGN KEY REFERENCES Songs(SongID), </span><br><span class="line">/*外键约束*/</span><br><span class="line">SingerID CHAR(10) not null</span><br><span class="line">FOREIGN KEY REFERENCES Singers(SingerID),</span><br><span class="line">Album VARCHAR(50),</span><br><span class="line">Style VARCHAR(20) default(&#x27;流行&#x27;), /*DEFAULT 约束*/ </span><br><span class="line">Circulation INTEGER, PubYear INTEGER,</span><br><span class="line">PRIMARY KEY(SongID, SingerID) ) /*主键约束*/</span><br><span class="line"></span><br><span class="line">ALTER TABLE Orders</span><br><span class="line">ADD FOREIGN KEY (P_Id)</span><br><span class="line">REFERENCES Persons(P_Id)</span><br></pre></td></tr></table></figure><h2 id="ON-UPDATE-和-ON-DELETE"><a href="#ON-UPDATE-和-ON-DELETE" class="headerlink" title="ON UPDATE 和 ON DELETE"></a>ON UPDATE 和 ON DELETE</h2><p>SQL Server 2008 中 ，可以 在 CREATE TABLE 语 句和 ALTER TABLE 语 句的<br>REFERENCES 子句中使用 ON DELETE 子句和 ON UPDATE 子句来定义当用户试图删<br>除或更新现有外键指向的主键值时，SQL Server 执行的操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">REFERENCES referenced_table_name [ ( ref_column ) ]</span><br><span class="line">[ ON DELETE &#123; NO ACTION → CASCADE → SET NULL → SET DEFAULT &#125; ]</span><br><span class="line">[ ON UPDATE &#123; NO ACTION → CASCADE → SET NULL → SET DEFAULT &#125; ]</span><br><span class="line"></span><br><span class="line">//为 Track 表添加约束，且指定当主表进行 update 操作时，子表级联更新。</span><br><span class="line">alter table Track add foreign key(SongID) references Songs(Songid) on update cascade</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="检查和违约-2"><a href="#检查和违约-2" class="headerlink" title="检查和违约"></a>检查和违约</h2><p><a href="https://blog.csdn.net/weixin_43524214/article/details/122850808?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_ecpm_v1~rank_v31_ecpm-3-122850808.pc_agg_new_rank&amp;utm_term=%E8%BF%9D%E5%8F%8D%E5%8F%82%E7%85%A7%E5%AE%8C%E6%95%B4%E6%80%A7%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F&amp;spm=1000.2123.3001.4430">https://blog.csdn.net/weixin_43524214/article/details/122850808?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_ecpm_v1~rank_v31_ecpm-3-122850808.pc_agg_new_rank&amp;utm_term=%E8%BF%9D%E5%8F%8D%E5%8F%82%E7%85%A7%E5%AE%8C%E6%95%B4%E6%80%A7%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F&amp;spm=1000.2123.3001.4430</a></p><p><a href="https://sm.ms/image/bsyC7qtdueGkoQ4" target="_blank"><img src="https://s2.loli.net/2022/03/10/bsyC7qtdueGkoQ4.png"  style="width:80%"></a></p><p>（1） 拒绝（NO ACTION）执行<br>不允许该操作执行。该策略一般设置为默认策略<br>（2） 级联（CASCADE）操作<br>当删除或修改被参照表（Student）的一个元组造成了与参照表（SC）的不一致，则删除或修改参照表中的所有造成不一致的元组<br>（3）设置为空值（SET-NULL）<br>当删除或修改被参照表的一个元组时造成了不一致，则将参照表中的所有造成不一致的元组的对应属性设置为空值。</p><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SQL Server 为了保证数据完整性共提供了以下 6 种约束。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;非空（NOT NULL）约束&lt;/li&gt;
&lt;li&gt;主键（PRIMARY KEY）约束&lt;/li&gt;
&lt;li&gt;外键（FOREIGN KEY）约束&lt;/li&gt;
&lt;li&gt;唯一性（UNIQUE）约束&lt;/li&gt;
&lt;li&gt;检查（CHECK）约束&lt;/li&gt;
&lt;li&gt;默认（DEFAULT）约束&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="数据库" scheme="http://akkaduilin.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="SQL" scheme="http://akkaduilin.com/tags/SQL/"/>
    
    <category term="数据库" scheme="http://akkaduilin.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>SQL基础</title>
    <link href="http://akkaduilin.com/2022/03/10/SQL%E5%9F%BA%E7%A1%80/"/>
    <id>http://akkaduilin.com/2022/03/10/SQL%E5%9F%BA%E7%A1%80/</id>
    <published>2022-03-10T07:47:30.000Z</published>
    <updated>2022-06-19T09:20:56.728Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p><strong>SQL学习笔记</strong></p><p><strong>持续更新ing</strong><br><a href="https://www.runoob.com/sql/sql-tutorial.htmlhttps://www.runoob.com/sql/sql-tutorial.html">https://www.runoob.com/sql/sql-tutorial.htmlhttps://www.runoob.com/sql/sql-tutorial.html</a><br><a href="https://www.liaoxuefeng.com/wiki/1177760294764384">https://www.liaoxuefeng.com/wiki/1177760294764384</a></p><span id="more"></span><h1 id="数据定义"><a href="#数据定义" class="headerlink" title="数据定义"></a>数据定义</h1><h2 id="数据库的定义"><a href="#数据库的定义" class="headerlink" title="数据库的定义"></a>数据库的定义</h2><h3 id="使用T-SQL创建"><a href="#使用T-SQL创建" class="headerlink" title="使用T-SQL创建"></a>使用T-SQL创建</h3><p>使用 SSMS 可以方便地创建数据库，但是，有些情况下不能使用图形化方式创建数据<br>库。比如在设计一个应用程序时，开发人员需要在程序代码中创建数据库及其他数据库对象，<br>而不用在制作应用程序安装包时再放置数据库或让用户自行创建，这就需要采用 T-SQL 语<br>句来创建数据库。</p><p>当使用 SSMS 向导创建数据库后，用户可以查看创建该数据库的 T-SQL 语句。方法是：<br>点击“对象资源管理器”→Music，点击右键快捷菜单中的“编写数据库脚本为”→“Create<br>到”→“新查询编辑器窗口”选项，在打开的查询编辑器窗口中，可以看到创建该数据库的<br>T-SQL 语句</p><p><strong>创建语句</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE database_name /* 指定数据库逻辑文件名*/</span><br><span class="line">[ON</span><br><span class="line">  [PRIMARY]</span><br><span class="line">  [&lt;filespec&gt; [1,…n]]</span><br><span class="line">  [,&lt;filegroup&gt; [1,…n]]</span><br><span class="line">]</span><br><span class="line">/* ON 子句指定数据库的数据文件属性和文件组属性；其中 PRIMARY 指定关联的&lt;filespec&gt;列表定义主文件，如果没有定义 PRIMARY, 则 CREATE DATABASE语句中列出的第一个文件成为主文件 */</span><br><span class="line"></span><br><span class="line">[LOG ON &#123;&lt;filespec&gt; [1,…n]&#125;] /* LOG ON 子句指定事务日志文件属性*/</span><br></pre></td></tr></table></figure><h3 id="修改数据库"><a href="#修改数据库" class="headerlink" title="修改数据库"></a>修改数据库</h3><p>在 SQL Server 中，可用 ALTER DATABASE 语句修改数据库</p><p>其中&lt; filespec &gt;的格式同 CREATE DATABASE 中的&lt; filespec &gt;。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">ALTER DATABASE database</span><br><span class="line"></span><br><span class="line">ADD FILE &lt; filespec &gt; [ ,...n ]</span><br><span class="line">/* 添加新的数据文件 */</span><br><span class="line">[ TO FILEGROUP filegroup_name ]</span><br><span class="line">/* 将要添加的数据文件添加到指</span><br><span class="line">定的文件组中 */</span><br><span class="line"></span><br><span class="line">ADD LOG FILE &lt; filespec &gt; [ ,...n ]</span><br><span class="line">/* 添加新的事务日志文件 */</span><br><span class="line">| REMOVE FILE logical_file_name</span><br><span class="line">/* 删除某一文件 */</span><br><span class="line"></span><br><span class="line">ADD FILEGROUP filegroup_name </span><br><span class="line">/* 添加一个文件组 */</span><br><span class="line"></span><br><span class="line">REMOVE FILEGROUP filegroup_name</span><br><span class="line">/* 删除一个文件组 */</span><br><span class="line"></span><br><span class="line">MODIFY FILE &lt; filespec &gt; </span><br><span class="line">/* 修改某个文件的属性 */</span><br><span class="line"></span><br><span class="line">MODIFY NAME = new_dbname </span><br><span class="line">/* 修改数据库的名字 */</span><br><span class="line"></span><br><span class="line">MODIFY FILEGROUP filegroup_name &#123;filegroup_property|NAME= new_filegroup_name &#125;</span><br><span class="line">/* 修改某个文件组的属性或为文件组定义一个新名字。文件组的属性有三种：READONLY（只读）、READWRITE（读写）、Default（默认） */</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><p>使用 DROP DATABASE 语句删除数据库的语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">DROP DATABASE database_name [,…n]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>创建 Employee 数据库，要求如下：<br>1）主数据库文件名为 Employee，物理文件名为 Employee.mdf，初始大小为 5MB，最大文件大小为100MB，增长幅度为 1MB；<br>2 ） 在 文 件 组 usergroup1 上 建 立 辅 助 数 据 文 件 Employee_dat ， 物 理 文 件 名 为<br>Employee_dat.ndf，初始大小为 3MB，最大为无限大，增幅为 1MB；<br>3）日志文件逻辑文件名和物理文件名均为 Employee_log，初始大小为 3MB，最大为<br>20MB，增幅为 10%。以上文件均存储在为 E:\mssql2008\data 文件夹中。<br>4）为Employee数据库的usergroup2文件组添加一个辅助数据文件Employee_dat2，<br>要求：文件存储在 E:\mssql2008\data 文件夹下，初始大小为 10MB，最大为 20MB，增<br>幅为 5MB<br>5）删除 Employee 数据库的文件组 usergroup2<br>6）修改 Employee 中的数据文件 Employee_dat,将其初始大小改为 10MB，最大容<br>量改为 20MB，增幅设为 2MB。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE Employee </span><br><span class="line">--定义主数据文件</span><br><span class="line">ON PRIMARY </span><br><span class="line">( NAME =Employee, FILENAME = &#x27;E:\mssql2008\data\Employee.mdf&#x27; , </span><br><span class="line">SIZE = 5, MAXSIZE = 100 , FILEGROWTH = 1KB ), </span><br><span class="line"></span><br><span class="line">--定义辅助数据文件</span><br><span class="line">FILEGROUP usergroup1 </span><br><span class="line">( NAME = Employee_dat, </span><br><span class="line">FILENAME = &#x27;E:\mssql2008\data\Employee_dat.ndf&#x27; , </span><br><span class="line">SIZE = 3 , MAXSIZE = UNLIMITED, FILEGROWTH = 1)</span><br><span class="line"></span><br><span class="line">--定义日志文件</span><br><span class="line">LOG ON </span><br><span class="line">(NAME = Employee_log, </span><br><span class="line">FILENAME = &#x27;E:\mssql2008\data\Employee_log.ldf&#x27; , </span><br><span class="line">SIZE = 3, MAXSIZE = 20, FILEGROWTH = 10%)</span><br><span class="line"></span><br><span class="line">--添加数据文件</span><br><span class="line">Alter DATABASE employee</span><br><span class="line">Add file ( NAME = employee_dat2,</span><br><span class="line">FILENAME=&#x27;E:\mssql2008\data\Employee_dat2.mdf&#x27;,</span><br><span class="line">SIZE = 10, MAXSIZE = 50, FILEGROWTH = 5) to filegroup usergroup2</span><br><span class="line"></span><br><span class="line">--删除文件组</span><br><span class="line">--删除文件组中的文件</span><br><span class="line">alter database employee remove file employee_dat2</span><br><span class="line">--删除文件组</span><br><span class="line">alter database employee remove filegroup usergroup2</span><br><span class="line"></span><br><span class="line">--修改数据文件</span><br><span class="line">AlTER DATABASE employee</span><br><span class="line">MODIFY FILE</span><br><span class="line">(NAME = Employee_dat, SIZE = 10, MAXSIZE = 20, FILEGROWTH = 2)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="基本表的定义"><a href="#基本表的定义" class="headerlink" title="基本表的定义"></a>基本表的定义</h2><p>SQL Server 中，可以从两种角度来对表进行分类。</p><ol><li><p>按照数据存储的时间分类：<br>1）永久表<br>表建立后，除非人工删除，否则一直保存。在 master、model、msdb 和用户数据库中建<br>立的表都是永久表。<br>2）临时表<br>临时表的数据只在数据库运行期间临时保存数据，临时表存储在 tempdb 中。</p></li><li><p>按照表的用途来分类<br>1）用户表<br>用户创建的，用于开发各种数据库应用系统的表。<br>2）系统表<br>维护 SQL Server 服务器和数据库正常工作的数据表。每个数据库都会建立很多系统表，<br>这些表不允许用户进行更改，只能由 DBMS 自行维护。<br>3）临时表<br>SQL Server 的临时表有两种类型：本地临时表和全局临时表。<br>本地临时表只对于创建者是可见的。当用户与 SQL Server 实例断开连接后，将删除本<br>地临时表。<br>全局临时表在创建后对任何用户和任何连接都是可见的，当引用该表的所有用户都与<br>SQL Server 实例断开连接后，将删除全局临时表。<br>如果 SQL Server 服务器关闭，则所有的本地和全局临时表都被清空、关闭。<br>从表名称上来看，本地临时表的名称前面有一个“#”符号；而全局临时表的名称前面<br>有两个“##”符号 。</p></li></ol><p><em>说明：临时表的作用——当对数据库执行大数据量的排序等操作时，要产生大量的中间运算结果，因此需要消耗大量的内存资源。如果内存资源不够用，那么 SQL Server 将在临时数据库 tempdb中创建临时表用于存放这些中间结果。</em><br> 4）分区表<br>当一个表中的数据量过于庞大时，可以使用分区表。分区表是将数据水平划分为多个单<br>元的表，这些单元可以分布到数据库中的多个文件组中。在维护整个集合的完整性时，使用<br>分区可以快速而有效地访问或管理数据子集，从而使大型表或索引更易于管理。</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><table><thead><tr><th align="left">序号</th><th align="left">数据类型</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">char(n)</td><td align="left">长度为n的定长字符串</td></tr><tr><td align="left">2</td><td align="left">varchar(n)</td><td align="left">最大程度为n的变长字符串</td></tr><tr><td align="left">3</td><td align="left">clob</td><td align="left">字符串大对象</td></tr><tr><td align="left">4</td><td align="left">blob</td><td align="left">二进制大对象</td></tr><tr><td align="left">5</td><td align="left">int</td><td align="left">长整数(4 字节)</td></tr><tr><td align="left">6</td><td align="left">smallint</td><td align="left">短整数(2 字节)</td></tr><tr><td align="left">7</td><td align="left">bigint</td><td align="left">大整数(8 字节)</td></tr><tr><td align="left">8</td><td align="left">Numeric(10,2)</td><td align="left">指字段是数字型,长度为10 小数为两位的</td></tr><tr><td align="left">9</td><td align="left">Date</td><td align="left">YYYY-mm-dd</td></tr><tr><td align="left">10</td><td align="left">time</td><td align="left">HH:ii:ss</td></tr><tr><td align="left">11</td><td align="left">Datetime</td><td align="left">YYYY-mm-dd HH:ii:ss</td></tr><tr><td align="left">12</td><td align="left">Timestamp</td><td align="left">时间戳类型 不为空 默认值为当前时间</td></tr><tr><td align="left">13</td><td align="left">float</td><td align="left">浮点型，含字节数为4，32bit，数值范围为-3.4E38~3.4E38（7个有效位）</td></tr><tr><td align="left">14</td><td align="left">double</td><td align="left">双精度实型，含字节数为8，64bit数值范围-1.7E308~1.7E308（15个有效位）</td></tr><tr><td align="left">15</td><td align="left">decimal</td><td align="left">数字型，128bit，不存在精度损失，常用于银行帐目计算。（28个有效位）</td></tr></tbody></table><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">create table &lt;表名&gt; (</span><br><span class="line">&lt;列名&gt;&lt;数据类型&gt;[列级完整性约束条件]，</span><br><span class="line">&lt;列名&gt;&lt;数据类型&gt;[列级完整性约束条件]，</span><br><span class="line">...</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>eg：<br><a href="https://sm.ms/image/ywXh2P7sROeGqfn" target="_blank"><img src="https://s2.loli.net/2022/03/10/ywXh2P7sROeGqfn.png" ></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE Singer(</span><br><span class="line">SingerID char(10) NOT NULL,</span><br><span class="line">Name varchar(50) NOT NULL,</span><br><span class="line">Gender varchar(2) NULL,</span><br><span class="line">Birth datetime NULL,</span><br><span class="line">Nation varchar(20) NULL</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="列属性的设置"><a href="#列属性的设置" class="headerlink" title="列属性的设置"></a>列属性的设置</h3><ol><li><p>NULL<br>NULL（空值）表示数值未知或将在以后添加的数据。</p></li><li><p>DEFAULT<br>默认值是指当向表中插入数据时，如果用户没有明确给出某列的值，SQL Server 自动为<br>该列添加的值。</p></li><li><p>IDENTITY<br>使用 IDENTITY 关键字定义的字段又称标识字段。开发人员可以为标识字段指定标识<br>种子（Identity Seed 属性）和标识增量（Identity Increment 属性），系统按照给定的种子和增<br>量自动生成标识号，该标识号是唯一的。<br>使用 IDENTITY 属性时要注意：<br>一个表只能有一个使用 IDENTITY 属性定义的列;<br>IDENTITY 只适用于 decimal（小数部分为 0）、int、numeric（小数部分为 0）、smallint、bigint 或 tinyint 数据类型；<br>标识种子和增量的默认值均为 1；  标识符列不能允许为空值，也不能包含 DEFAULT 定义或对象；<br>标识符列不能更新；<br>如果在经常进行删除操作的表中存在标识符列，那么标识值之间可能会出现断缺。</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">create table Student</span><br><span class="line">(</span><br><span class="line">sno int not null identity(201102001,1), /*设置 IDENTITY*/</span><br><span class="line">sname varchar(50) not null,</span><br><span class="line">sex varchar(2),</span><br><span class="line">hometown varchar(50) null default(&#x27;江苏&#x27;), /*设置默认值*/</span><br><span class="line">introuction varchar(50) null,</span><br><span class="line">birthdate datetime not null )</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="修改-删除表"><a href="#修改-删除表" class="headerlink" title="修改/删除表"></a>修改/删除表</h3><p>表建立好后，一般不会再修改，但随着应用环境和需求的变化，偶尔也要修改已建立好<br>的表，SQL 语言用 ALTER TABLE 语句修改表，其一般格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE &lt;表名&gt;</span><br><span class="line"></span><br><span class="line">[ ADD &lt;新列名&gt; &lt;数据类型&gt; &lt;完整性约束&gt;] /*增加新列*/</span><br><span class="line"></span><br><span class="line">[DROP COLUMN &lt;列名&gt;] /*删除列*/</span><br><span class="line"></span><br><span class="line">[ALTER COLUMN &lt;列名&gt; &lt;数据类型&gt;] /*修改列定义*/</span><br><span class="line"></span><br><span class="line">[ADD &lt;完整性约束&gt;] /*添加约束*/</span><br><span class="line"></span><br><span class="line">[DROP &lt;完整性约束&gt;] /*删除约束*/</span><br><span class="line"></span><br><span class="line">// 当某个表不再需要时，可以使用 DROP TABLE 语句删除它。其一般格式为：</span><br><span class="line"></span><br><span class="line">DROP TABLE &lt;表名&gt;</span><br></pre></td></tr></table></figure><p>其中&lt;表名&gt;是要修改的表，ADD 子句用于增加新列和新的完整性约束条件，DROP 子句用于删除指定的完整性约束条件，ALTER COLUMN 子句用于修改原有的列定义，包括修改列名和数据类型。</p><h2 id="数据完整性的实现"><a href="#数据完整性的实现" class="headerlink" title="数据完整性的实现"></a>数据完整性的实现</h2><a href="/2022/03/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7/" title="数据库完整性">数据库完整性</a><a href="/2022/03/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7/" title="数据库完整性">数据库完整性</a><h1 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h1><a href="/2022/03/23/SQL%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2/" title="SQL数据查询">SQL数据查询</a><a href="/2022/03/23/SQL%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2/" title="SQL数据查询">SQL数据查询</a><h1 id="数据更新"><a href="#数据更新" class="headerlink" title="数据更新"></a>数据更新</h1><h2 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h2><p>元组插入语句的一般格式：<br>INSERT INTO &lt;表名&gt; ( &lt;列名 1&gt; [ , &lt;列名 2&gt;] …)<br>VALUES<br>(&lt;常量 1&gt; [, &lt;常量 2&gt; ]…)<br>(&lt;常量 11&gt; [, &lt;常量 22&gt; ]…)<br>(&lt;常量 111&gt; [, &lt;常量 222&gt; ]…)<br>或者<br>INSERT INTO &lt;表名&gt; ( &lt;列名 1&gt; [ , &lt;列名 2&gt;] …)<br>&lt;子查询&gt;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">假设另有一张歌手表 S，表结构与 Singer 一致，现在要求把 S 表中所有没有在</span><br><span class="line">Singer 表里出现过的男歌星加入到 Singer 表中。</span><br><span class="line"></span><br><span class="line">INSERT INTO Singers (SingerID, Name, Gender, Nation, Birth)</span><br><span class="line">(</span><br><span class="line">  SELECT (SingerID, Name, Gender, Nation, Birth)</span><br><span class="line">  FROM S</span><br><span class="line">  WHERE S.Gender=’男’ and NOT EXISTS (S.SingerID=Singers.SingerID)</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h2><p>SQL 删除语句的格式：</p><p>DELETE FROM &lt;表名&gt; ［WHERE &lt;条件&gt;］</p><p>如果没有 WHERE 子句，将会删除表中所有数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">删除歌手表中不是中国国籍的歌手</span><br><span class="line">DELETE FROM Singers</span><br><span class="line">WHERE Nation&lt;&gt;’中国’</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="修改操作"><a href="#修改操作" class="headerlink" title="修改操作"></a>修改操作</h2><p>当需要修改关系中元组的某些值时，可以用 UPDATE 语句实现。SQL 的 UPDATE 语句的<br>格式：</p><p>UPDATE &lt;表名&gt;<br>SET &lt;列名&gt;＝&lt;值表达式&gt;［，&lt;列名&gt;＝&lt;值表达式&gt;］… [WHERE &lt;条件&gt;］</p><p>如果省略 WHERE 子句，将会修改表中所有的元组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">将 Singers 表中歌手编号为“GC002”的 Birth 属性值修改为 1978。</span><br><span class="line"></span><br><span class="line">UPDATE Singers</span><br><span class="line">SET Birth＝1978</span><br><span class="line">WHERE SingerID＝&#x27; GC002</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="索引与视图"><a href="#索引与视图" class="headerlink" title="索引与视图"></a>索引与视图</h1><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>建立索引以加快查询速度</p><ol><li>在表上创建一个简单的索引。允许使用重复的值：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX index_name</span><br><span class="line">ON table_name (column_name)</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li>在表上创建一个唯一的索引。不允许使用重复的值：唯一的索引意味着两个行不能拥有相同的索引值<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE UNIQUE INDEX index_name</span><br><span class="line">ON table_name (column_name)</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li>修改索引<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter index index_name rename to new_name</span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li>删除索引<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop index index_name</span><br></pre></td></tr></table></figure></li></ol><h2 id="视图-view"><a href="#视图-view" class="headerlink" title="视图 view"></a>视图 view</h2><p>在 SQL 中，视图是基于 SQL 语句的结果集的可视化的表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW view_name AS</span><br><span class="line">SELECT column_name(s)</span><br><span class="line">FROM table_name</span><br><span class="line">WHERE condition</span><br></pre></td></tr></table></figure><p>通过 DROP VIEW 命令来删除视图。<br>通过select 语句查询<br>通过update 语句更新 并不是所有视图都可以更新</p><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SQL学习笔记&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;持续更新ing&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;https://www.runoob.com/sql/sql-tutorial.htmlhttps://www.runoob.com/sql/sql-tutorial.html&quot;&gt;https://www.runoob.com/sql/sql-tutorial.htmlhttps://www.runoob.com/sql/sql-tutorial.html&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/1177760294764384&quot;&gt;https://www.liaoxuefeng.com/wiki/1177760294764384&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="http://akkaduilin.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="SQL" scheme="http://akkaduilin.com/tags/SQL/"/>
    
    <category term="数据库" scheme="http://akkaduilin.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Java面向对象</title>
    <link href="http://akkaduilin.com/2022/03/07/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>http://akkaduilin.com/2022/03/07/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</id>
    <published>2022-03-07T02:57:21.000Z</published>
    <updated>2022-06-19T09:20:06.097Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言</strong></p><p><strong>Java 面向对象编程 笔记</strong></p><p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1260451488854880">https://www.liaoxuefeng.com/wiki/1252599548343744/1260451488854880</a><br><a href="https://www.cnblogs.com/hellojava/archive/2013/02/27/2935450.html">https://www.cnblogs.com/hellojava/archive/2013/02/27/2935450.html</a><br><a href="https://www.runoob.com/java/java-tutorial.html">https://www.runoob.com/java/java-tutorial.html</a></p><span id="more"></span><h1 id="类的声明"><a href="#类的声明" class="headerlink" title="类的声明"></a>类的声明</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[public | protected | private ][abstract|final] class className [extends superclassName] [implements interfaceNameList]&#123;……&#125;</span><br></pre></td></tr></table></figure><p>其中，修饰符public,abstract,final 说明了类的属性，<br>className为类名，<br>superclassName为类的父类的名字，用于继承<br>interfaceNameList为类所实现的接口列表。</p><h2 id="abstract-抽象类"><a href="#abstract-抽象类" class="headerlink" title="abstract 抽象类"></a>abstract 抽象类</h2><p>如果一个class定义了方法，但没有具体执行代码，这个方法就是抽象方法<br>抽象类除了<strong>不能实例化对象</strong>之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。<br>可以用于继承，即定义新的类父类是一个抽象类</p><h1 id="成员变量和成员方法"><a href="#成员变量和成员方法" class="headerlink" title="成员变量和成员方法"></a>成员变量和成员方法</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class className&#123;</span><br><span class="line">    [public | protected | private ] [static] [final] [transient] [volatile] type variableName;//成员变量</span><br><span class="line">    [public | protected | private ] [static] [final | abstract] [native] [synchronized] returnType methodName([paramList]) [throws exceptionList]&#123;</span><br><span class="line">        statements</span><br><span class="line">    &#125;//成员方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>成员变量限定词的含义：</strong></p><p>static: 静态变量（类变量）<br>final: 常量；<br>transient: 暂时性变量，用于对象存档，用于对象的串行化<br>volatile: 贡献变量，用于并发线程的共享</p><p>方法的实现也包括两部分内容：方法声明和方法体。</p><p>方法声明</p><p><strong>方法声明中的限定词的含义：</strong></p><p>static: 类方法，可通过类名直接调用<br>abstract: 抽象方法，没有方法体<br>final: 方法不能被重写、继承<br>native: 集成其它语言的代码<br>synchronized: 控制多个并发线程的访问</p><h2 id="abstract-抽象方法"><a href="#abstract-抽象方法" class="headerlink" title="abstract 抽象方法"></a>abstract 抽象方法</h2><p>如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是让子类去覆写它，那么，可以把父类的方法声明为抽象方法</p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p><strong>this代表本类的对象</strong></p><p>没有在构造方法中初始化字段时，引用类型的字段默认是null，数值类型的字段用默认值，int类型默认值是0，布尔类型默认值是false</p><p>可以定义多个构造方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Person p1 = new Person(&quot;Xiao Ming&quot;, 15); // 既可以调用带参数的构造方法</span><br><span class="line">        Person p2 = new Person(); // 也可以调用无参数构造方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public Person() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Person(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = 12;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Person(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return this.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="面向对象的基本特征"><a href="#面向对象的基本特征" class="headerlink" title="面向对象的基本特征"></a>面向对象的基本特征</h1><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>在面向对象程式设计方法中，封装（英语：Encapsulation）是指一种将抽象性函式接口的实现细节部分包装、隐藏起来的方法。<br>封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。<br>要访问该类的代码和数据，必须通过严格的接口控制。<br>封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。<br>适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。</p><p><a href="https://www.runoob.com/java/java-encapsulation.html">https://www.runoob.com/java/java-encapsulation.html</a></p><p>private：类中限定为private的成员，只能被这个类本身访问。如果一个类的构造方法声明为private,则其它类不能生成该类的一个实例。<br>default：类中不加任何访问权限限定的成员属于缺省的（default）访问状态，可以被这个类本身和同一个包中的类所访问。<br>protected：类中限定为protected的成员，可以被这个类本身、它的子类（包括同一个包中以及不同包中的子类）和同一个包中的所有其他的类访问。<br>public：类中限定为public的成员，可以被所有的类访问。<br><a href="https://sm.ms/image/TKfdORlCGaQgJVD" target="_blank"><img src="https://s2.loli.net/2022/03/08/TKfdORlCGaQgJVD.jpg" ></a></p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>解决代码重复和便于维护</p><h3 id="继承格式"><a href="#继承格式" class="headerlink" title="继承格式"></a>继承格式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class 父类 &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class 子类 extends 父类 &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>子类拥有父类 <strong>非 private</strong> 的属性、方法。</p><p>子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。</p><p>子类可以用自己的方式实现父类的方法。</p><p><strong>Java支持多重继承，不支持多继承</strong><br><a href="https://sm.ms/image/lNnouWEYDSv2U13" target="_blank"><img src="https://s2.loli.net/2022/03/08/lNnouWEYDSv2U13.jpg" ></a></p><h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><p>我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">  void eat() &#123;</span><br><span class="line">    System.out.println(&quot;animal : eat&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line">  void eat() &#123;</span><br><span class="line">    System.out.println(&quot;dog : eat&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  void eatTest() &#123;</span><br><span class="line">    this.eat();   // this 调用自己的方法</span><br><span class="line">    super.eat();  // super 调用父类方法</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类是不继承父类的构造器（构造方法或者构造函数）的，它只是调用（隐式或显式）。如果父类的构造器带有参数，则必须在子类的构造器中显式地通过 super 关键字调用父类的构造器并配以适当的参数列表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class SuperClass &#123;</span><br><span class="line">  private int n;</span><br><span class="line">  SuperClass()&#123;</span><br><span class="line">    System.out.println(&quot;SuperClass()&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  SuperClass(int n) &#123;</span><br><span class="line">    System.out.println(&quot;SuperClass(int n)&quot;);</span><br><span class="line">    this.n = n;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// SubClass 类继承</span><br><span class="line">class SubClass extends SuperClass&#123;</span><br><span class="line">  private int n;</span><br><span class="line">  </span><br><span class="line">  SubClass()&#123; // 自动调用父类的无参数构造器</span><br><span class="line">    System.out.println(&quot;SubClass&quot;);</span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  public SubClass(int n)&#123;</span><br><span class="line">    super(300);  // 调用父类中带有参数的构造器</span><br><span class="line">    System.out.println(&quot;SubClass(int n):&quot;+n);</span><br><span class="line">    this.n = n;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class TestSuperSub&#123;</span><br><span class="line">  public static void main (String args[])&#123;</span><br><span class="line">    System.out.println(&quot;------SubClass 类继承------&quot;);</span><br><span class="line">    SubClass sc1 = new SubClass();</span><br><span class="line">    SubClass sc2 = new SubClass(100);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为<br>——SubClass 类继承——<br>SuperClass()<br>SubClass<br>SuperClass(int n)<br>SubClass(int n):100</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p><a href="https://sm.ms/image/z3q1aP4sbDHMUx8" target="_blank"><img src="https://s2.loli.net/2022/03/08/z3q1aP4sbDHMUx8.jpg" ></a><br>方法名相同、参数不同（数量不同、类型不同、顺序不同）、同一作用域。<br>返回值类型可以相同也可以不相同，无法以返回型别作为重载函数的区分标准。</p><h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><p>重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。<strong>即外壳不变，核心重写！</strong></p><p><strong>当需要在子类中调用父类的被重写方法时，要使用 super 关键字。</strong></p><p><strong>重写规则</strong></p><ol><li><p>参数列表与被重写方法的参数列表必须完全相同。</p></li><li><p>返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。</p></li><li><p>访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。</p></li><li><p>父类的成员方法只能被它的子类重写。</p></li><li><p>声明为 final 的方法不能被重写。</p></li><li><p>声明为 static 的方法不能被重写，但是能够被再次声明。</p></li><li><p>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。</p></li><li><p>子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。</p></li><li><p>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。</p></li><li><p>构造方法不能被重写。</p></li><li><p>如果不能继承一个类，则不能重写该类的方法。</p></li></ol><h3 id="重载重写区别"><a href="#重载重写区别" class="headerlink" title="重载重写区别"></a>重载重写区别</h3><ol><li><p>方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载(Overloading)。</p></li><li><p>方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写(Overriding)。</p></li><li><p>方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。</p></li></ol><p><a href="https://sm.ms/image/vecY2Ql85H7sOEk" target="_blank"><img src="https://s2.loli.net/2022/03/08/vecY2Ql85H7sOEk.jpg" ></a></p><h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><p>虚函数的存在是为了多态。<br>Java 中其实没有虚函数的概念，它的普通函数就相当于 C++ 的虚函数，动态绑定是Java的默认行为。如果 Java 中不希望某个函数具有虚函数特性，可以加上 final 关键字变成非虚函数。</p><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1260456790454816">https://www.liaoxuefeng.com/wiki/1252599548343744/1260456790454816</a></p><p>如果一个抽象类没有字段，所有方法全部都是抽象方法，就可以把该抽象类改写为接口：<strong>interface</strong></p><p>所谓interface，就是比抽象类还要抽象的纯抽象接口，因为它连字段都不能有。因为接口定义的所有方法默认都是<strong>public abstract</strong>的，所以这两个修饰符不需要写出来（写不写效果都一样）</p><h2 id="接口声明和实现"><a href="#接口声明和实现" class="headerlink" title="接口声明和实现"></a>接口声明和实现</h2><p>Interface关键字用来声明一个接口。</p><p>类使用implements关键字实现接口。在类声明中，Implements关键字放在class声明后面。<br>当类实现接口的时候，类要实现接口中所有的方法。否则，类必须声明为抽象的类。</p><p>类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    void run();</span><br><span class="line">    String getName();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student implements Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public Student(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(this.name + &quot; run&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口特性"><a href="#接口特性" class="headerlink" title="接口特性"></a>接口特性</h2><ol><li><p>接口文件保存在 .java 结尾的文件中，文件名使用接口名</p></li><li><p>当一个具体的class去实现一个interface时，需要使用<strong>implements</strong>关键字</p></li><li><p><strong>一个类可以实现多个interface</strong></p></li><li><p>接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。</p></li><li><p>接口中每一个方法也是隐式抽象</p></li><li><p>接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是 public，用 private 修饰会报编译错误）</p></li><li><p>一个接口能继承另一个接口，这和类之间的继承比较相似。接口的继承使用extends关键字 <strong>并且接口允许多继承</strong><br>eg: public interface int extends int1, int2</p></li></ol><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><h2 id="Inner-Class"><a href="#Inner-Class" class="headerlink" title="Inner Class"></a>Inner Class</h2><p>如果一个类定义在另一个类的内部，这个类就是Inner Class<br>Inner Class 不能单独存在，必须依附于一个实例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Outer outer = new Outer(&quot;Nested&quot;); // 实例化一个Outer</span><br><span class="line">        Outer.Inner inner = outer.new Inner(); // 实例化一个Inner</span><br><span class="line">        inner.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Outer &#123;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    Outer(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class Inner &#123;</span><br><span class="line">        void hello() &#123;</span><br><span class="line">            System.out.println(&quot;Hello, &quot; + Outer.this.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Anonymous-Class"><a href="#Anonymous-Class" class="headerlink" title="Anonymous Class"></a>Anonymous Class</h2><p>在方法内部，通过匿名类（Anonymous Class）来定义Inner Class</p><p>Runnable本身是接口，接口是不能实例化的，所以这里实际上是定义了一个实现了Runnable接口的匿名类，并且通过new实例化该匿名类，然后转型为Runnable</p><p>不关心类名，简化代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Outer outer = new Outer(&quot;Nested&quot;);</span><br><span class="line">        outer.asyncHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Outer &#123;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    Outer(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void asyncHello() &#123;</span><br><span class="line">        Runnable r = new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;Hello, &quot; + Outer.this.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        new Thread(r).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Static-Nested-Class"><a href="#Static-Nested-Class" class="headerlink" title="Static Nested Class"></a>Static Nested Class</h2><p>使用static修饰，静态内部类</p><p>用static修饰的内部类不再依附于Outer的实例，而是一个完全独立的类，因此无法引用Outer.this，但它可以访问Outer的private静态字段和静态方法。<br><strong>用途，可以访问private的方法和变量</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Outer.StaticNested sn = new Outer.StaticNested();</span><br><span class="line">        sn.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Outer &#123;</span><br><span class="line">    private static String NAME = &quot;OUTER&quot;;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    Outer(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class StaticNested &#123;</span><br><span class="line">        void hello() &#123;</span><br><span class="line">            System.out.println(&quot;Hello, &quot; + Outer.NAME);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="包"><a href="#包" class="headerlink" title="包+"></a>包+</h1><p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1260467032946976">https://www.liaoxuefeng.com/wiki/1252599548343744/1260467032946976</a></p><p>将功能相似或相关的类或者接口组织在同一个包中，方便查找和使用。<br>防止命名冲突</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">packsge package_name // 申明包名</span><br><span class="line"></span><br><span class="line">public cless Cless_name&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 导入包</span><br><span class="line">package ming;</span><br><span class="line"></span><br><span class="line">// 导入完整类名:</span><br><span class="line">import mr.jun.Arrays;</span><br><span class="line"></span><br><span class="line">// 导入mr.jun包的所有class</span><br><span class="line">import mr.jun.*;</span><br><span class="line"></span><br><span class="line">public class Person &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        Arrays arrays = new Arrays();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Java 面向对象编程 笔记&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/1252599548343744/1260451488854880&quot;&gt;https://www.liaoxuefeng.com/wiki/1252599548343744/1260451488854880&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.cnblogs.com/hellojava/archive/2013/02/27/2935450.html&quot;&gt;https://www.cnblogs.com/hellojava/archive/2013/02/27/2935450.html&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.runoob.com/java/java-tutorial.html&quot;&gt;https://www.runoob.com/java/java-tutorial.html&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="http://akkaduilin.com/categories/Java/"/>
    
    
    <category term="Java" scheme="http://akkaduilin.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>编译原理基础概念</title>
    <link href="http://akkaduilin.com/2022/03/01/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <id>http://akkaduilin.com/2022/03/01/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</id>
    <published>2022-03-01T09:29:16.000Z</published>
    <updated>2022-06-19T09:16:10.836Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言</strong></p><p><strong>编译原理笔记</strong></p><p>编译程序的组成及概念解释</p><p><a href="https://sm.ms/image/KEVZuPkjTrQ2UYa" target="_blank"><img src="https://s2.loli.net/2022/03/01/KEVZuPkjTrQ2UYa.jpg"  style="width:60%"></a></p><span id="more"></span><h1 id="语言处理系统"><a href="#语言处理系统" class="headerlink" title="语言处理系统"></a>语言处理系统</h1><p><a href="https://sm.ms/image/PDkWqNwRTOKUV9M" target="_blank"><img src="https://s2.loli.net/2022/03/01/PDkWqNwRTOKUV9M.jpg" style="width:60%"></a></p><h1 id="翻译器"><a href="#翻译器" class="headerlink" title="翻译器"></a>翻译器</h1><p>翻译器是能够完成从一种语言到另一种语言变换的软件</p><p><a href="https://sm.ms/image/LG9S8uT7lUOkjDi" target="_blank"><img src="https://s2.loli.net/2022/03/01/LG9S8uT7lUOkjDi.jpg" style="width:60%"></a></p><h1 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h1><p>编译器是指将<strong>源程序</strong>编译为目标<strong>可执行程序</strong>的系统</p><p>编译器的前端与后端<br>前端：只依赖于源语言<br>后端：依赖于目标机器，一般独立于源语言，与中间语言有关<br>前端+后端：组合<br>取一个编译器前端，重写它的后端以产生同一源语言在另一机器上的编译器<br>把几种不同的语言编译成同一种中间语言，让不同的前端使用同一后端，从而得到一台机器上的几个编译器<br>编译的几个阶段常用一趟/遍（pass）扫描来实现，一趟/遍扫描包括读一个输入文件和写一个输出文件</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><a href="https://sm.ms/image/yqvLdF9N1MsflIT" target="_blank"><img src="https://s2.loli.net/2022/03/01/yqvLdF9N1MsflIT.jpg" style="width:60%"></a></p><h2 id="分析部分-前端阶段任务"><a href="#分析部分-前端阶段任务" class="headerlink" title="分析部分(前端阶段任务)"></a>分析部分(前端阶段任务)</h2><p>前端：源程序 → 中间表示</p><ol><li><p><strong>词法分析</strong><br><a href="https://sm.ms/image/mLJdAs1lEK3IGeS" target="_blank"><img src="https://s2.loli.net/2022/03/01/mLJdAs1lEK3IGeS.jpg" style="width:60%"></a><br>识别最小语法单位并表示词性<br>逐个读构成源程序的字符，把它们组成词法单元(token)流</p></li><li><p><strong>语法分析</strong><br><a href="https://sm.ms/image/etIwzx8q5EZs3gu" target="_blank"><img src="https://s2.loli.net/2022/03/01/etIwzx8q5EZs3gu.jpg" style="width:60%"></a><br>根据单词词性分析语法<br>把词法记号流依照语言的语法结构按层次分组，以形成语法短语</p></li><li><p><strong>语义分析</strong><br>根据单词值分析语义是否正确<br>· 类型转换<br>· 类型检查<br>· 语法制导翻译</p></li><li><p><strong>中间代码生成</strong><br>生成中间代码<br>中间代码位于<strong>高级编程语言</strong>和<strong>机器语言</strong>（目标程序）之间</p></li></ol><h2 id="综合部分-后端阶段任务"><a href="#综合部分-后端阶段任务" class="headerlink" title="综合部分(后端阶段任务)"></a>综合部分(后端阶段任务)</h2><p>后端：中间表示 → 目标程序</p><ol><li><p><strong>代码优化</strong><br>对中间代码进行优化，以期产生更高效的目标代码。</p></li><li><p><strong>目标程序生成</strong><br>将中间代码转换成低级语言代码、机器代码或汇编码。</p></li><li><p><strong>符号表管理</strong><br>编译器的一项重要工作是记录源程序中使用的标识符，并收集每个标识符的各种属性。<br>符号表是为每个标识符保存一个记录的数据结构，记录的域是标识符的属性。</p></li><li><p><strong>出错管理</strong><br>每个阶段都可能发现源程序的错误。发现错误后，该阶段必须处理此错误，使得编译可以继续进行，以便进一步发现源程序的其他错误。</p></li></ol><h1 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h1><p>百度百科：<br>解释器（英语：Interpreter），又译为直译器，是一种电脑程序，能够把高级编程语言一行一行直接转译运行。解释器不会一次把整个程序转译出来，只像一位“中间人”，每次运行程序时都要先转成另一种语言再作运行，因此解释器的程序运行速度比较缓慢。它每转译一行程序叙述就立刻运行，然后再转译下一行，再运行，如此不停地进行下去。</p><p>编译器与解释器区别：</p><p>解释器不像编译器通过翻译来生成目标程序，而是直接执行源程序所指定的运算。</p><h1 id="混合编译器"><a href="#混合编译器" class="headerlink" title="混合编译器"></a>混合编译器</h1><p><a href="https://sm.ms/image/6qEwzlsM79CA1ki" target="_blank"><img src="https://s2.loli.net/2022/03/01/6qEwzlsM79CA1ki.jpg" style="width:60%"></a></p><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编译原理笔记&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;编译程序的组成及概念解释&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://sm.ms/image/KEVZuPkjTrQ2UYa&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://s2.loli.net/2022/03/01/KEVZuPkjTrQ2UYa.jpg&quot;  style=&quot;width:60%&quot;&gt;&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="编译原理" scheme="http://akkaduilin.com/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="编译原理" scheme="http://akkaduilin.com/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    <category term="概念" scheme="http://akkaduilin.com/tags/%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
</feed>
