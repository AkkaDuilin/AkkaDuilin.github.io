<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>咸鱼享乐，摸鱼快乐</title>
  
  
  <link href="http://akkaduilin.com/atom.xml" rel="self"/>
  
  <link href="http://akkaduilin.com/"/>
  <updated>2022-01-25T16:37:43.193Z</updated>
  <id>http://akkaduilin.com/</id>
  
  <author>
    <name>不对de林</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一些成长的故事</title>
    <link href="http://akkaduilin.com/2022/01/26/her/"/>
    <id>http://akkaduilin.com/2022/01/26/her/</id>
    <published>2022-01-25T16:46:26.000Z</published>
    <updated>2022-01-25T16:37:43.193Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://sm.ms/image/AxWVizPOZgqN8cw" target="_blank"><img src="https://s2.loli.net/2021/12/24/AxWVizPOZgqN8cw.jpg" ></a> </p><p><strong>前言</strong></p><p><strong>对每一个男孩来说，总有一个女孩，会让你成长</strong></p><span id="more"></span><h1 id="最想让你看的"><a href="#最想让你看的" class="headerlink" title="最想让你看的"></a>最想让你看的</h1><p>距离上次见面已经过去了四天了，我们可能谁都没法想到我们三周年的那一天会变成那个样子，种种三年积压下来的矛盾在那天之后一下子全部爆发了出来，在这几天，我想了很多很多，从在最开始的对你的愧疚，到对自己的反省，到理性的分析我们之间的关系。在当面你把你对我的种种不满一下子倾倒出来的时候，我脑子里真的一片空告，我没有想到在你眼里我竟然是那么的不堪，那么恶劣，在你眼里我竟然是自己最讨厌的那个样子，在那种情况之下，我能做到的就是对自己所做的愧疚，但等我回到家仔细分析的时候，我发现问题可能并不是我真的做的不好，所以我第一次向你说了异地这么长时间一直以来的想法，一直以来我都不愿意将我们之间的关系变成你的负担，这个世界对你已经很糟糕了，我想要给你的是一份陪伴，一份温暖。但是好像我做的一切改变在你眼里都微不足道，我开始反省自己，反思自己是不是应该这么做，那天我把你买的蛋糕带回家给妈妈，妈妈真的很开心，那一刻我真的发现原来这么长时间我对你的付出甚至比起家里至情之人都少了很多，哪怕只以金钱来衡量，在你身上的付出可能会比我这么多年对家里人总和都要多，可能在你看我做的微不足道的事情在妈妈眼里却能让她开心很久。只能说，只有至情之人才会无条件不求回报的对自己好啊。<br>这几天最大的感受就是，很多曾经只是听个调子的歌，现在竟然能一下子明白了其中歌词的含义，可能这就是成长吧。在最迷茫的时候，我甚至把我的想法发到了一个论坛里，得到的回复竟然都是劝我分手，可能是我的描述带有我的主观性吧，但是这清一色的回复还是让我挺难过的，这么长时间的坚持，到最后其实也就是世俗所能预料到的结果吗? 可能要不要分手这种想法在很早之前就有过了，在你复读的时候是想要陪着你坚持下去拿到本应属于你的成绩，在你去看心理医生的时候是想要一直一直坚持做你的后盾，可能每个时间段都会有能让我坚持下去的理由，哪怕到了现在，在你说你因为你爸妈的情况开始害怕爱情后我的理由都会是想要让你在我身上重新期待爱情，期待生活。因为我知道，你真的是一个特别特别好的女孩，如果因为这种事情而在你心里结下一个心结，对你来说是不公平的，也是我不想看到的。<br>我也意识到了，这次可能真的是目前为止我们最有可能分道扬镳的一次了，我们两个人真的有很多很多还需要解决的问题，不管是你我家庭的情况还是你我两个人对爱情的看法，可能在我看来爱情应该是平等的吧，所以在我一次次付出之后渐渐开始考虑做这件事的意义，在我付出了这些之后你会不会也会这样对我。可能对你来说你所希望的爱情是能让你能感受到在经历的是你心中的美好爱情吧，这么长时间你也从来没有和我说过对我有什么期望，希望的爱情是什么样子的，可能你现在真的不愿意去想爱情吧，如果我和你是朋友，是闺蜜，我们都不会有这些矛盾。你说做不好当下，怎么去谈未来，但我觉得，未来是为了让我们能更好的做好当下，没有一个目标，你为什么要做好当下呢? 我也很羡慕别人女朋友会给她的男孩买鞋子、织围巾，会陪她的男孩子一起玩游戏，一起听歌，但我觉得不能因为你没有做这些就说你是不好的，每个人的情况都是不一样的。所以我一直在等，等你说你真的也愿意为我们两个的未来努力，等你说你期望的未来是有我的。但是这么长时间了，我一直没有等到，甚至会感觉越来越等不到了，所以我选择和你好好聊一聊这些事情。在我看来我既然选择了要和你在一起，那就是为了以后，如果只是为了当下的快乐，那又何必选择这条崎岖的路呢。所以我哪怕觉得可能会出现现在的情况，也决定说出来这些。<br>其实之前那几次对我们之间的感情的怀疑最后都是感性占了上风，但这次我能感觉到自己真的理性了很多，我不会再觉得自己对你真的有我想象的那么重要，我想要的是你的回答，而不是我的一厢情愿。但是不管最后的结果怎么样，我都希望你能知道，和你的这三年真的让我成长了很多，我真的很感谢你的出现，可能在这段感情中，我收获的真的比你要多吧，所以我不会强求你什么，你是怎么想的我都会尊重你的想法。我不想再这么等下去了，继续还是分开，都会是上天给我们这段感情的安排吧。</p><p><em>你会不会偶尔想起，十几岁只图你感情的人？</em><br><a href="https://b23.tv/YTZymNu">https://b23.tv/YTZymNu</a></p><h1 id="关于以前"><a href="#关于以前" class="headerlink" title="关于以前"></a>关于以前</h1><h2 id="2021-12-2"><a href="#2021-12-2" class="headerlink" title="2021.12.2"></a>2021.12.2</h2><p>真的是，有那么一天晚上突然就破防了———— 记事本奉上<br><em>网易云那个点评</em><br><em>虽然只是数据的玩笑罢了（大概吧）可能这就是真的内在吧 哪怕做了三四遍结果也没能改变 现在的感觉就像小时候装作大人的样子，明明已经很努力的去付出改变了但好像最后也没得到什么…… 有时候也会想 明明自己也还稚嫩为什么要逼着自己成熟  想有人能给自己说一句你已经很棒了  而不是每天都在方方面面觉得自己不好  为什么内疚呢 会难过呢  因为自己又不满意了吗  怎样才能让你满意呢 不知道  只会做现在能做的的 害怕 害怕自己现在做的不够多会失去什么 害怕哪怕以后能做到却没了目标  这种明明做了很多还感觉自己不好 配不上现在的感觉也太可笑了  难道我感觉的不平 都是正常的吗  一边觉得自己做的这么好还得不到理解的不满  一边怀疑自己真的做好了的怀疑  一边害怕失去脑补各种结局的不安  不知道怎么办 也没有什么可以说的  说给谁呢  为什么不去说呢  你在怕什么  不知道  就是怕…  哦懂了  你害怕得到的答案是你这么做没感觉不对吗  你觉得你很好了吗？</em></p><p>内心挣扎后的现状(笑死 想这么多真就不想睡觉)：</p><p><em>好吧  说了  开始脑补结果了  真是闲</em></p><p><em>好了  什么都说了啊  早上能收到什么呢  不安</em></p><p>其实这种感觉好像也不止这一次了吧 总是能在晚上想到我们两个人以后怎么办 真正晚上想了这么多第二天也不知道该怎么和她去说 在一起真的以及快三年了啊<br>每次看到网上关于异地的评论都在一次次怀疑自己 每次和别人讨论起来基本没几个人能看好吧 说实话有时候觉得自己蛮累的 有时候觉得自己坚持不是为了自己 但是仔细静下心想想自己真的想要什么呢？ 可能就是那种哪怕忙了一天回家能和她一起做饭看电影的日子吧 是怕自己没有了了她真的会孤独吧 我还记得自己当时晚上因为一些小事泣不成声 感觉这么久了每次难过都和这份感情有联系 可能是自己喜欢多想 一遍遍强调自己要相信对方一次次还怀疑自己 可能这就是真正的爱吧 自从慢慢长大发现成年人的爱情真的很累啊 可能自己如果放弃这段感情真的会没有勇气去向前看吧 现在能想到的就只有坚持下去 可能变数真的很多 不安也有很多 那也只能这样了吧 </p><h2 id="2021-12-7"><a href="#2021-12-7" class="headerlink" title="2021.12.7"></a>2021.12.7</h2><p>好久没有打过视频了啊，看到屏幕对面几近崩溃的你真的有一种很无助的感觉，我不知道怎么能帮到现在的你，可能这种情况下你最需要的是一个深深的拥抱而已，但我却没有办法做到，这可能就是异地吧，明明是在最需要你的时候你却没有办法做任何事情，只能用你那笨拙的言语去安慰别人。有时候真的希望能出现在你的身边，大学几年越上越发现有些事情真的不是你想要能做到就能做到的。你学习的压力我已经能感觉快要压垮你了，我能怎么办呢，难道只能遥远的陪伴吗。。。我真的不知道，我害怕，又希望能出现比我更能照顾好你的人。可能对我来说，现在前进的动力是能让未来的我们过的更好。我总是喜欢往前看，这样就能忘记现在的难过。但是若现在的问题解决不了，未来又在哪里呢。。。。。。</p><h2 id="2021-12-19"><a href="#2021-12-19" class="headerlink" title="2021.12.19"></a>2021.12.19</h2><p>今天是该死大直男！<br>但是自己真的忘记了她最喜欢的明星是谁啊。。。。 说起来，这个事情也就是在之前逛街的时候随口提到了吧，只能说有点印象(再加上自己真对演艺明星认识的就少)。感觉好像哪怕在一起将近三年了对互相的了解也只是一点啊。可能和我们互相见面互相深入聊天的次数太少有关叭，好想找个时间可以一起好好聊一聊互相，聊一聊过去的自己。总有一天，会有这个机会吧。<br>记个笔记： 我们家小朋友最喜欢陈伟霆 记住名字！！！不要只认个脸 这么帅的脸你记不住吗？？？</p><h2 id="2022-1-1"><a href="#2022-1-1" class="headerlink" title="2022.1.1"></a>2022.1.1</h2><p>第一次断片，没想到会是因为这么一件小事，其实真的很想让你关心关心我吧，可是好像得到的就是简简单单的下次不要这样了。我真的没什么重要的。<br>补：<br>10月17号，你还会问我在干嘛，要不要打语音，我们还在吐槽身边的各种事情<br>18号，你安架子磨破了手，会怪我没有关心你，希望有人在你身边<br>24号，你叫我陪你一起听歌，会催我给你打视频，晚上会忙<br>26号，你说你有了同款礼物，好开心<br>27号，你很崩溃，我只能发几个抱抱，发消息安慰你，无助<br>31号，你说，你觉得给我发消息之后会猜到我说什么，我只能一遍一遍说我真的在乎你，距离真的会拉远两个人<br>11月1号，你会给我考试加加油，会在我考不好的时候安慰我<br>8号，你说2021所剩无几，时间流逝，我们还剩下什么?<br>16号，你被选上去见领导，参加那个形象大使比赛<br>21号，我帮你给视频消音，能帮到你真的很开心，原来，我在你心里也会很棒啊，<br>22号，你说你感觉你离我好远，我说，四年之后我会和你在一个城市，你给我发了一个爱心，那时的我，还坚定着自己的心<br>25号，你说你已经习惯了忙碌，我说，我们要一起加油<br>28号，你要我帮你领游戏，我们会有一起玩的机会吗？<br>29号，你说你不努力，你在疯狂的否定自己，但是在我心里，你一直都是最好的<br>12月1号，我给你发了网易云的截图，你说你承受了很多，我发了好多好多消息<br>2号，你说你梦到我了，你说我现在其实挺好的，原来付出是有回报的<br>5号，你开始在寝室喝酒，这一年你最忙的时间就要来了<br>6号，给你打视频你很崩溃，无助，胡思乱想<br>7号，你通过了初试，要去电视台参加复试<br>10号，帮你剪歌<br>11号，你上台表演了，并且很棒的进入了下一轮<br>14号，你收到了老师的贺卡，你真的好开心，如果我也能让你这么开心就好了<br>16号，你在否定自己，说自己不努力，真的有好多好多想说的，结果到最后就只有我一直都在而已<br>19号，我没能说出你最喜欢的明星，感觉自己真的对你了解有限，你给老猫说，我完全不懂你<br>22号，你说我在大学学到了很多，你什么都没学到<br>23号，你又在寝室喝酒，生活的压力逐渐把我们两个压垮，对我来说，这段感情最艰难的时候来了<br>24、25号，圣诞节，什么都没有收到，觉得自己很孤独，想要你陪陪我<br>26号，因为礼物寄的晚了所以记得要给你买个蛋糕补偿一下，那是，我还在期待今年会不会有礼物<br>28号，你被垃圾老师弄的很生气，你渐渐变得没有以前那样，你也会骂脏话，会和我狠狠的骂老师<br>29号，帮你弄题，我都不知道为什么自己会这么用心，可能，只是想让你知道我也是很重要的吧<br>30号，你看到了我给你写的信，你说你想了很多，说会和我好好聊一聊，我一直在等<br>31号，晚上你去看电影，说好要给我打电话，没等到，梦想中的礼物也不了了之，那天晚上我很难过，我不知道自己为什么要坚持下去，第一次喝酒到断片</p><h2 id="2022-1-6"><a href="#2022-1-6" class="headerlink" title="2022.1.6"></a>2022.1.6</h2><p>又是睡不着的一晚上，最近发生的事情太多了，有点不太能清楚分析了。<br>跨年夜那天断片的经历是人生第一次，我也不希望会有下一次，我依稀记得在电话里给zly说我到底为什么要坚持下去，说实话，哪怕是清醒的我也不知道，我到底是为了什么要像现在这样痛苦。或者说，我这样坚持是不是只是想知道自己会不会有那一个坚定的目标呢？我说不清楚，可能只是因为感觉自己真的找到心仪的她，或者是因为不愿意去再像现在这样用心去对一个人，现在能做的就是苦苦的继续坚持。为什么在这段感情里自己要处于这么卑微的一个状态呢，明明应该是双向奔赴的感情却好像总是自己的一厢情愿，有点累，有点无助。难道爱情就应该是现在这种感觉吗，这么长时间回想起来却没办法想到多少甜蜜的感觉，仔细想来真的有些好笑，值得吗？<br>最近真的感觉两个人有越走越远的感觉了，这次投票我能感觉到她背后的家庭是多么强大，我相比人家可能真的平平无奇，有时候会想自己要足够强大，这样才能配的上她，才能让人家家里人放心的将她的下半生交给我，但是仔细想想我能做到吗？或者说，我尽心尽力去做的能达到人家的要求吗，从来没有对我们未来的日子这么迷茫过，能想象到的只有很多很多的困难，会是我真的想多了吧，但是总感觉自己像是小说里的那个种平凡的男生，费尽心思追到想要伴随一生的人却因为种种原因没办法得到，这种天生的家庭差距会不会在未来真的变成我们两个之间的隔阂，我不想多想，明明当下都不知道怎么办为什么还要想那么多，我哪怕再怎么拉人能做到的也不及人家家里的百分之一，就这样的我真的能够和她在一起吗。我曾经也相信过爱情，相信走过高三那段时间就可以开始真正的恋爱，但哪怕到了现在我也没感受过什么叫甜蜜的爱，能感觉到的只有无尽的压力，我真的好羡慕那种可以天天一起打游戏，一起出去旅行，天天都能陪在身边的情侣，和他们相比感觉我这真的算是在恋爱吗……<br>说句实话，她一个学期和我发信息的语气渐渐变得没有以前的那种撒娇，就感觉只是普普通通的工作聊天，没有表情包，没有任何恋爱的感觉，以前真的不是这样的。我不知道是不是成熟的爱情就应该这样，每次和别人问我都说什么老夫老妻了这些不重要，但是问问自己的内心，真的不重要吗？可能真的是她很累了吧，但是我想要的真的是这样吗？<br>无助，迷茫，真的不知道感情到现在这个样子该怎么办，下定决心假期和她好好说这件事真的能说出来吗，要是没有任何进展的话自己还能坚持下去吗……我觉得可能不行了吧，我真的真的不喜欢这种压抑的感觉了，希望假期的见面真的能改变这种状态吧。<br>晚安，快去睡觉吧</p><p>补：<br>在我看来，两个人出现不合的情况有两种，一种是不爱了，一种是两个人爱的方式不一样了，第二种对我来说是可以接受的，但是需要两个人去交流，第一种就可以放手了，何必互相为难对方呢？<br>我相信，是第二种</p><h2 id="2022-1-11"><a href="#2022-1-11" class="headerlink" title="2022.1.11"></a>2022.1.11</h2><p>印象里上一次这么长时间没有收到回复是她爷爷去世的时候，也是从那时候开始，你渐渐变了，有一阵你可能真的有抑郁症的倾向，所以我选择一直陪着你，最近我们的交流少到可怜，以至于今天早上醒过来我甚至有一种没有过你的感觉，很恐怖，两个人的感情到了现在这个样子我真的不知道该怎么办了。可能你真的因为比赛很忙很忙，但是真的忙到连消息也看不到吗，我不知道，我不敢多想。<br>从来没用过这种怀疑自己的感觉，一时间我不知道我是不是还爱你，我仔细回想过来总是想不到有什么开心的事情，真的，要结束了吗？<br>今天又翻看以前的聊天记录，只能感觉到真的变了，是我的错觉吗，你是不是真的只是在敷衍我了？这是我这么长时间第一次有这种感觉，但好像又没有那么难过了，好像真的只有怅然了吧。我，尽力了吗？尽力了吧。</p><p><a href="https://sm.ms/image/R7T8qibSgMwuhGY" target="_blank"><img src="https://s2.loli.net/2021/12/24/R7T8qibSgMwuhGY.jpg" ></a></p><p>未完待续。。。。。。</p><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://sm.ms/image/AxWVizPOZgqN8cw&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://s2.loli.net/2021/12/24/AxWVizPOZgqN8cw.jpg&quot; &gt;&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对每一个男孩来说，总有一个女孩，会让你成长&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="日常" scheme="http://akkaduilin.com/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
    <category term="想法" scheme="http://akkaduilin.com/tags/%E6%83%B3%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>matlab笔记</title>
    <link href="http://akkaduilin.com/2022/01/17/matlab/"/>
    <id>http://akkaduilin.com/2022/01/17/matlab/</id>
    <published>2022-01-17T03:17:51.000Z</published>
    <updated>2022-01-17T06:07:00.380Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://sm.ms/image/pstS2TFVXGEo71x" target="_blank"><img src="https://s2.loli.net/2022/01/17/pstS2TFVXGEo71x.jpg" ></a></p><p><strong>前言</strong></p><p>matlab笔记，备战美赛</p><p>冲鸭！！！</p><span id="more"></span><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="矩阵和数组"><a href="#矩阵和数组" class="headerlink" title="矩阵和数组"></a>矩阵和数组</h2><p>所有 MATLAB 变量都是多维数组，与数据类型无关。矩阵是指通常用来进行线性代数运算的二维数组。</p><h3 id="数组创建"><a href="#数组创建" class="headerlink" title="数组创建"></a>数组创建</h3><ol><li>用空格或者逗号(,)分隔数据<br>a = [1 2 3 4]</li><li>用分号;分隔多行数据<br>a = [1 3 5; 2 4 6; 7 8 10]</li><li>创建矩阵的另一种方法是使用 ones、zeros 或 rand 等函数。<br>zeros全部为零</li></ol><p>ones全部为 1</p><p>rand均匀分布的随机元素</p><p>randn正态分布的随机元素</p><p>z = zeros(5,1)</p><h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><ol><li><p>用单一运算符处理矩阵中的所有值<br><a href="https://sm.ms/image/uTdrzlhOf4jVIJq" target="_blank"><img src="https://s2.loli.net/2022/01/17/uTdrzlhOf4jVIJq.jpg" style="width:60%"></a></p></li><li><p>转置矩阵使用单引号<br>a’<br>撇号运算符（例如，A’）执行复共轭转置。它会围绕主对角线翻转矩阵，并且还会更改矩阵的任何复数元素的虚部符号。点撇号运算符 (A.’) 转置矩阵，但不会影响复数元素的符号。对于包含所有实数元素的矩阵，这两个运算符返回相同结果。</p></li><li><p>inv()<br>计算方阵x的逆矩阵</p></li><li><p>使用 * 执行矩阵乘法<br><a href="https://sm.ms/image/aZrP1lmifzCGKJM" target="_blank"><img src="https://s2.loli.net/2022/01/17/aZrP1lmifzCGKJM.jpg" style="width:60%" ></a></p></li><li><p>使用 format 命令可以显示更多小数位数<br>format long<br>format short</p></li><li><p>执行元素级乘法 .* 运算符<br>乘法、除法和幂的矩阵运算符分别具有执行元素级运算的对应数组运算符。</p></li><li><p>串联<br>连接数组以便形成更大数组的过程，成对的方括号 [] 即为串联运算符。<br><a href="https://sm.ms/image/QPu2vlSCEnIe15g" target="_blank"><img src="https://s2.loli.net/2022/01/17/QPu2vlSCEnIe15g.jpg" style="width:60%"></a></p></li><li><p>复数<br>表示虚部用 i j<br>c = [3+4i, 4+3j; -i, 10j]<br>c = 2×2 complex</p><p>3.0000 + 4.0000i   4.0000 + 3.0000i<br>0.0000 - 1.0000i   0.0000 +10.0000i</p></li><li><p>sum()<br>S = sum(A) 返回 A 沿大小不等于 1 的第一个数组维度的元素之和。</p></li></ol><p>如果 A 是向量，则 sum(A) 返回元素之和。</p><p>如果 A 是矩阵，则 sum(A) 将返回包含每列总和的行向量。</p><p>如果 A 是多维数组，则 sum(A) 沿大小不等于 1 的第一个数组维度计算，并将这些元素视为向量。此维度会变为 1，而所有其他维度的大小保持不变。</p><p>S = sum(A,dim) 沿维度 dim 返回总和。例如，如果 A 为矩阵，则 sum(A,2) 是包含每一行总和的列向量。</p><p>S = sum(A,’all’) 计算 A 的所有元素的总和。</p><p>使用 sum 和 diag 函数可以获取主对角线上的元素的总和：</p><p>sum(diag(A))</p><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>A = 4×4</p><pre><code> 1     2     3     4 5     6     7     8 9    10    11    1213    14    15    16</code></pre><ol><li><p>指定行和列下标<br>A(4,2)<br>ans = 14</p></li><li><p>单一下标按顺序向下遍历每一列<br>A(8)<br>ans = 14</p></li><li><p>要引用多个数组元素，请使用冒号运算符，这使您可以指定一个格式为 start:end 的范围<br>A(1:3,2)<br>ans = 3×1</p><p>  2<br>  6<br> 10<br>单独的冒号（没有起始值或结束值）指定该维中的所有元素。<br>A(3,:)<br>ans = 1×5</p><p>  9    10    11    12<br>冒号运算符还允许您使用较通用的格式 start:step:end 创建等间距向量值。默认步长为1<br>B = 0:10:100<br>B = 1×11</p><p>  0    10    20    30    40    50    60    70    80    90   100</p></li><li><p>包含冒号的下标表达式引用部分矩阵：<br>A(1:k,j)<br>表示 A 第 j 列中的前 k 个元素。因此，<br>sum(A(1:4,4)) 计算第四列的总和。<br>但是，执行此计算有一种更好的方法。冒号本身引用矩阵行或列中的所有元素，而关键字 end 引用最后一个行或列。<br>sum(A(:,end))</p></li><li><p>删除行和列<br>只需使用一对方括号即可从矩阵中删除行和列。首先<br>X = A<br>然后，要删除 X 的第二列，请使用<br>X(:,2) = []<br>这会将 X 更改为<br>X =<br> 16     2    13<br>  5    11     8<br>  9     7    12<br>  4    14     1<br>如果您删除矩阵中的单个元素，结果将不再是矩阵。因此，以下类似表达式<br>X(1,2) = []<br>将会导致错误。<br>但是，使用单一下标可以删除一个元素或元素序列，并将其余元素重构为一个行向量。因此<br>X(2:2:10) = []<br>生成<br>X =<br> 16     9     2     7    13    12     1</p></li></ol><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>结构体是多维 MATLAB 数组，包含可按文本字段标志符访问的元素。例如，<br>S.name = ‘Ed Plum’;<br>S.score = 83;<br>S.grade = ‘B+’<br>创建一个具有三个字段的标量结构体：<br>S =<br>     name: ‘Ed Plum’<br>    score: 83<br>    grade: ‘B+’<br>与 MATLAB 环境中的所有其他内容一样，结构体也为数组，因此可以插入其他元素。在本示例中，数组的每个元素都是一个具有若干字段的结构体。可以一次添加一个字段，<br>S(2).name = ‘Toni Miller’;<br>S(2).score = 91;<br>S(2).grade = ‘A-‘;<br>也可以使用一个语句添加整个元素：<br>S(3) = struct(‘name’,’Jerry Garcia’,… ‘score’,70,’grade’,’C’)</p><h2 id="工作区变量"><a href="#工作区变量" class="headerlink" title="工作区变量"></a>工作区变量</h2><p>使用<br>whos 查看工作区内容<br>save 保存数据 系统使用.mat拓展名将工作区保存在当前工作文件夹中一个名为 MAT 文件的压缩文件中<br>load 还原到工作区<br><a href="https://ww2.mathworks.cn/help/matlab/learn_matlab/workspace.html">https://ww2.mathworks.cn/help/matlab/learn_matlab/workspace.html</a></p><h2 id="字符串和文本"><a href="#字符串和文本" class="headerlink" title="字符串和文本"></a>字符串和文本</h2><p>处理文本时，将字符序列括在双引号中<br>strlength 函数求数组中每个字符串的长度<br>是个数组，每个元素包含单个字符<br><a href="https://ww2.mathworks.cn/help/matlab/learn_matlab/character-strings.html">https://ww2.mathworks.cn/help/matlab/learn_matlab/character-strings.html</a></p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>输入参数括在圆括号</p><p>存在多个输入参数，请使用逗号加以分隔</p><p>存在多个输出参数，请将其括在方括号中<br>[maxA,location] = max(A)<br>maxA = 5<br>location = 3</p><p>字符输入括在单引号中</p><p>有关初等数学函数的列表，请键入</p><p>help elfun<br>有关更多高等数学函数和矩阵函数的列表，请键入</p><p>help specfun<br>help elmat</p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="矩阵运算符"><a href="#矩阵运算符" class="headerlink" title="矩阵运算符"></a>矩阵运算符</h3><p>表达式使用大家熟悉的算术运算符和优先法则。</p><ul><li>加法</li></ul><ul><li>减法</li></ul><ul><li>乘法</li></ul><p>/ 除法</p><p>\ 左除</p><p>^ 幂</p><p>‘ 复共轭转置</p><p>( )指定计算顺序</p><h3 id="数组运算符"><a href="#数组运算符" class="headerlink" title="数组运算符"></a>数组运算符</h3><p>如果矩阵不用于线性代数运算，则成为二维数值数组。数组的算术运算按元素执行。这意味着，加法和减法运算对数组和矩阵都是相同的，但乘法运算不相同。MATLAB 的乘法数组运算表示法中包含点，也就是小数点。</p><p>运算符列表包括</p><ul><li>加法</li></ul><ul><li>减法</li></ul><p>.* 逐元素乘法</p><p>./ 逐元素除法</p><p>.\ 逐元素左除</p><p>.^ 逐元素幂</p><p>.’ 非共轭数组转置</p><h3 id="构建表"><a href="#构建表" class="headerlink" title="构建表"></a>构建表</h3><p>数组运算对构建表非常有用。假定 n 为列向量</p><p>n = (0:9)’;<br>然后，</p><p>pows = [n  n.^2  2.^n]<br>构建一个平方和 2 次幂的表：</p><p>pows =<br>     0     0     1<br>     1     1     2<br>     2     4     4<br>     3     9     8<br>     4    16    16<br>     5    25    32<br>     6    36    64<br>     7    49   128<br>     8    64   256<br>     9    81   512</p><h3 id="常用常量值"><a href="#常用常量值" class="headerlink" title="常用常量值"></a>常用常量值</h3><p>pi 3.14159265…</p><p>i 虚数单位 </p><p>j 与 i 相同</p><p>eps 浮点相对精度 ε=2^−52</p><p>realmin 最小浮点数 2^−1022</p><p>realmax 最大浮点数 (2−ε)2^1023</p><p>Inf 无穷</p><p>NaN 非数字</p><h2 id="二维图和三维图"><a href="#二维图和三维图" class="headerlink" title="二维图和三维图"></a>二维图和三维图</h2><p><a href="https://ww2.mathworks.cn/help/matlab/learn_matlab/basic-plotting-functions.html#responsive_offcanvas">https://ww2.mathworks.cn/help/matlab/learn_matlab/basic-plotting-functions.html#responsive_offcanvas</a></p><h3 id="线图"><a href="#线图" class="headerlink" title="线图"></a>线图</h3><p>要创建二维线图，请使用 plot 函数<br>plot(x,y,’r–’)</p><p>x 数据范围<br>x = 0:pi/100:2*pi;<br><em>0到2pi，中间以pi/100为间距取点</em><br><em>x分别取0，pi/100,2pi/100,3pi/100…….2pi</em></p><p>y 函数<br>y = sin(x);</p><p>‘r–’ 线条设定。每个设定可包含表示线条颜色、样式和标记的字符。</p><p>默认情况下，每次调用绘图函数、重置坐标区及其他元素以准备新绘图时，MATLAB® 都会清空图窗。</p><p>要将绘图添加到现有图窗中，请使用 hold on。在使用 hold off 或关闭窗口之前，当前图窗窗口中会显示所有绘图。</p><h3 id="三维绘图"><a href="#三维绘图" class="headerlink" title="三维绘图"></a>三维绘图</h3><p>surf(X,Y,Z)<br>z = f (x,y)<br>要计算 z，请首先使用 meshgrid 在此函数的域中创建一组 (x,y) 点。</p><p>[X,Y] = meshgrid(-2:.2:2);<br><em>.2表示0.2 (-2:.2:2)表示在-2到2的区间上以0.2的长度为间隔的向量</em><br>Z = X .* exp(-X.^2 - Y.^2);<br>然后，创建曲面图。</p><p>surf(X,Y,Z)<br>surf 函数及其伴随函数 mesh 以三维形式显示曲面图。surf 使用颜色显示曲面图的连接线和面。mesh 生成仅以颜色标记连接定义点的线条的线框曲面图。</p><h3 id="子图"><a href="#子图" class="headerlink" title="子图"></a>子图</h3><p>subplot 函数可以在同一窗口的不同子区域显示多个绘图<br>subplot 的前两个输入表示每行和每列中的绘图数。第三个输入指定绘图是否处于活动状态。</p><h2 id="编程和脚本"><a href="#编程和脚本" class="headerlink" title="编程和脚本"></a>编程和脚本</h2><h3 id="基本语言"><a href="#基本语言" class="headerlink" title="基本语言"></a>基本语言</h3><ol><li><p>创建脚本<br>edit name</p></li><li><p>注释 %</p></li><li><p>运行脚本 输入当前脚本名称</p></li></ol><h3 id="实时脚本"><a href="#实时脚本" class="headerlink" title="实时脚本"></a>实时脚本</h3><p>要使用 edit 命令创建新的实时脚本，请在文件名中包含 .mlx 扩展名：</p><p>edit newfile.mlx</p><h3 id="循环和条件语句"><a href="#循环和条件语句" class="headerlink" title="循环和条件语句"></a>循环和条件语句</h3><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">N = 100;</span><br><span class="line">f(1) = 1;</span><br><span class="line">f(2) = 1;</span><br><span class="line">%循环%</span><br><span class="line">for n = 3:N</span><br><span class="line">    f(n) = f(n-1) + f(n-2);</span><br><span class="line">end</span><br><span class="line">f(1:10)</span><br><span class="line">%条件%</span><br><span class="line">num = randi(100)</span><br><span class="line">if num &lt; 34</span><br><span class="line">   sz = &#x27;low&#x27;</span><br><span class="line">elseif num &lt; 67</span><br><span class="line">   sz = &#x27;medium&#x27;</span><br><span class="line">else</span><br><span class="line">   sz = &#x27;high&#x27;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="函数总结"><a href="#函数总结" class="headerlink" title="函数总结"></a>函数总结</h1><h2 id="magic-n"><a href="#magic-n" class="headerlink" title="magic(n)"></a>magic(n)</h2><p>M = magic(n) 返回由 1 到 n2 的整数构成并且总行数和总列数相等的 n×n 矩阵。n 的阶数必须是大于或等于 3 的标量才能创建有效的幻方矩阵。</p><h2 id="inv"><a href="#inv" class="headerlink" title="inv()"></a>inv()</h2><p>Y = inv(X) 计算方阵 X 的 逆矩阵。</p><h2 id="clc"><a href="#clc" class="headerlink" title="clc"></a>clc</h2><p>clc 函数清空命令行窗口。</p><h2 id="meshgrid-x-y"><a href="#meshgrid-x-y" class="headerlink" title="meshgrid(x,y)"></a>meshgrid(x,y)</h2><p>语法</p><p>[X,Y] = meshgrid(x,y)<br>[X,Y] = meshgrid(x)<br>[X,Y,Z] = meshgrid(x,y,z)<br>[X,Y,Z] = meshgrid(x)</p><p>说明<br>[X,Y] = meshgrid(x,y) 基于向量 x 和 y 中包含的坐标返回二维网格坐标。X 是一个矩阵，每一行是 x 的一个副本；Y 也是一个矩阵，每一列是 y 的一个副本。坐标 X 和 Y 表示的网格有 length(y) 个行和 length(x) 个列。</p><p>[X,Y] = meshgrid(x) 与 [X,Y] = meshgrid(x,x) 相同，并返回网格大小为 length(x)×length(x) 的方形网格坐标。</p><p>[X,Y,Z] = meshgrid(x,y,z) 返回由向量 x、y 和 z 定义的三维网格坐标。X、Y 和 Z 表示的网格的大小为 length(y)×length(x)×length(z)。</p><p>[X,Y,Z] = meshgrid(x) 与 [X,Y,Z] = meshgrid(x,x,x) 相同，并返回网格大小为 length(x)×length(x)×length(x) 的三维网格坐标。</p><h2 id="exp-x"><a href="#exp-x" class="headerlink" title="exp(x)"></a>exp(x)</h2><p>Y = exp(X) 为数组 X 中的每个元素返回指数 ex。 </p><h2 id="cylinder"><a href="#cylinder" class="headerlink" title="cylinder()"></a>cylinder()</h2><p>创建圆柱<br>[X,Y,Z] = cylinder 返回三个 2×21 矩阵，其中包含圆柱的 x、y 和 z 坐标，但不对其绘图。圆柱的半径为 1，圆周上有 20 个等间距点。底面平行于 xy 平面。</p><p>要绘制圆柱，请将 X、Y 和 Z 传递给 surf 或 mesh 函数。<br><a href="https://ww2.mathworks.cn/help/matlab/ref/cylinder.html?searchHighlight=cylinder&amp;s_tid=srchtitle_cylinder_1">https://ww2.mathworks.cn/help/matlab/ref/cylinder.html?searchHighlight=cylinder&amp;s_tid=srchtitle_cylinder_1</a></p><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://sm.ms/image/pstS2TFVXGEo71x&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://s2.loli.net/2022/01/17/pstS2TFVXGEo71x.jpg&quot; &gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;matlab笔记，备战美赛&lt;/p&gt;
&lt;p&gt;冲鸭！！！&lt;/p&gt;</summary>
    
    
    
    <category term="数据分析" scheme="http://akkaduilin.com/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
    <category term="matlab" scheme="http://akkaduilin.com/tags/matlab/"/>
    
  </entry>
  
  <entry>
    <title>前中后缀表达式</title>
    <link href="http://akkaduilin.com/2022/01/08/%E5%89%8D%E4%B8%AD%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://akkaduilin.com/2022/01/08/%E5%89%8D%E4%B8%AD%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2022-01-07T16:08:41.000Z</published>
    <updated>2022-01-08T03:52:55.608Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>栈的应用，四则运算表达式求值</p><span id="more"></span><h1 id="后缀表达式计算结果"><a href="#后缀表达式计算结果" class="headerlink" title="后缀表达式计算结果"></a>后缀表达式计算结果</h1><p>遍历每个数字和符号，遇到数字就进栈，遇到符号，将处于栈顶的两个数字出栈，运算后将结果进栈，直到得到最终结果</p><p>例：<br>   后缀表达式为：9 3 1 - 3 * + 10 2 / +</p><p>   规则为：从左到右遍历表达式的每个数字和符号，遇到是数字就进栈，遇到是符号，就将处于栈顶两个数字出栈，进行运算，运算结果进栈，一直到最终获得结果。</p><p>   a.初始化一个空栈。此栈用来对要运算的数字进行进出使用。</p><p>   b.后缀表达式中前三个是、都是数字，所以9 3 1 进栈。</p><p>   c.接下来是“-”，所以将栈中的1出栈作为减数，3出栈作为被减数，并运算3-1得到2，再讲2进栈。</p><p>   d.接着是数字3进栈。</p><p>   e.后面是“*”，也就意味着栈中3和2出栈，2与3相乘，得到6，并将6进栈。</p><p>   f.下面是“+”，所以栈中6和9出栈，9和6相加，得到15，将15进栈。</p><p>   g.接着是10和2两数字进栈。</p><p>   h.接下来是符号“/”，因此，栈顶的2与10出栈，10与2相除，得到5，将5进栈。</p><p>   i.最后一个是符号“+”，所以15与5出栈并相加，得到20，讲20进栈。</p><p>   j.结果是20出栈，栈变为空。</p><h1 id="中缀表达式转后缀表达式"><a href="#中缀表达式转后缀表达式" class="headerlink" title="中缀表达式转后缀表达式"></a>中缀表达式转后缀表达式</h1><p>遍历每个数字和符号，遇到数字就输出，若是符号则判断其与栈顶符号的优先级。是右括号或优先级不高于栈顶符号的则将栈顶元素依次出栈并输出，之后将当前符号进栈，直到得到最终结果</p><p>例：<br>　　以中缀表达式“9+（（3*2）+（3-1））/2”的转化为例介绍栈s1和栈s2的情况：</p><p>　　注：数字和符号的顺序是按在栈中的顺序排列的。</p><p>　　（1）遍历到字符“9”时：</p><p>　　　　栈s1：9 ；</p><p>　　　　栈s2：空 ；</p><p>　　（1）遍历到符号“+”时：</p><p>　　　　栈s1：9 ；</p><p>　　　　栈s2：+ ；</p><p>　　（1）遍历到符号“(”时：</p><p>　　　　栈s1：9 ；</p><p>　　　　栈s2：( + ；</p><p>　　（2）遍历到符号“(”时：</p><p>　　　　栈s1：9 ；</p><p>　　　　栈s2：( ( + ；</p><p>　　（3）遍历到字符“3”时：</p><p>　　　　栈s1：3 9 ；</p><p>　　　　栈s2：( ( +；</p><p>　　（4）遍历到符号“*”时：</p><p>　　　　栈s1：3 9 ；</p><p>　　　　栈s2：* ( ( + ；</p><p>　　（5）遍历到字符“2”时：</p><p>　　　　栈s1：2 3 9 ；</p><p>　　　　栈s2：* ( ( + ；</p><p>　　（6）遍历到符号“)”时：</p><p>　　　　栈s1：2 3 9 ；</p><p>　　　　栈s2：* ( ( + ；</p><p>　　　　此时开始比较，比较之后：</p><p>　　　　栈s1：* 2 3 9 ；</p><p>　　　　栈s2：( + ；</p><p>　　（7）遍历到符号“+”时：</p><p>　　　　栈s1：* 2 3 9 ；</p><p>　　　　栈s2：+ ( +；</p><p>　　（8）遍历到符号“(”时：</p><p>　　　　栈s1：* 2 3 9 ；</p><p>　　　　栈s2：( + ( + ；</p><p>　　（9）遍历到字符“3”时：</p><p>　　　　栈s1：3 * 2 3 9 ；</p><p>　　　　栈s2：( + ( + ；</p><p>　　（10）遍历到符号“-”时：</p><p>　　　　栈s1：3 * 2 3 9 ；</p><p>　　　　栈s2：- ( + ( + ；</p><p>　　（11）遍历到字符“1”时：</p><p>　　　　栈s1：1 3 * 2 3 9 ；</p><p>　　　　栈s2：- ( + ( + ；</p><p>　　（12）遍历到符号“)”时：</p><p>　　　　栈s1：1 3 * 2 3 9 ；</p><p>　　　　栈s2：- ( + ( + ；</p><p>　　　　此时开始比较，比较之后：</p><p>　　　　栈s1：- 1 3 * 2 3 9 ；</p><p>　　　　栈s2：+ ( +；</p><p>　　（13）遍历到符号“)”时：</p><p>　　　　栈s1：- 1 3 * 2 3 9 ；</p><p>　　　　栈s2：+ ( +；</p><p>　　　　此时开始比较，比较之后：</p><p>　　　　栈s1：+ - 1 3 * 2 3 9 ；</p><p>　　　　栈s2：+；</p><p>　　（14）遍历到符号“/”时：</p><p>　　　　栈s1：+ - 1 3 * 2 3 9 ；</p><p>　　　　栈s2：/ + ；</p><p>　　（15）遍历到字符“2”时：</p><p>　　　　栈s1：2 + - 1 3 * 2 3 9 ；</p><p>　　　　栈s2：/ + ；</p><p>　　（16）遍历结束，但栈s2中还有符号，所以将栈s2中的符号全部依次压入栈s1中，此时：</p><p>　　　　栈s1：+ / 2 + - 1 3 * 2 3 9 ；</p><p>　　　　栈s2：空；</p><p>　　　所以后缀表达式为：9 3 2 * 3 1 - + 2 / + ；</p><h1 id="xx3x"><a href="#xx3x" class="headerlink" title="xx3x"></a>xx3x</h1><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;栈的应用，四则运算表达式求值&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="http://akkaduilin.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="题解" scheme="http://akkaduilin.com/categories/%E7%BC%96%E7%A8%8B/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="C++" scheme="http://akkaduilin.com/tags/C/"/>
    
    <category term="栈" scheme="http://akkaduilin.com/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>字符串</title>
    <link href="http://akkaduilin.com/2022/01/07/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://akkaduilin.com/2022/01/07/%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2022-01-07T09:19:55.000Z</published>
    <updated>2022-01-07T16:07:23.966Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>串和简单模式匹配算法KMP算法</p><span id="more"></span><h1 id="字符串基本概念"><a href="#字符串基本概念" class="headerlink" title="字符串基本概念"></a>字符串基本概念</h1><p><a href="https://sm.ms/image/r348tomKAB6kvcN" target="_blank"><img src="https://s2.loli.net/2022/01/08/r348tomKAB6kvcN.jpg" ></a></p><h1 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h1><p>在查找字符串前先对查找字符串做一个分析</p><h2 id="求next数组"><a href="#求next数组" class="headerlink" title="求next数组"></a>求next数组</h2><p>转载自B站视频<br><a href="https://www.bilibili.com/video/BV1nF411e7gq?from=search&amp;seid=2280439246733213375&amp;spm_id_from=333.337.0.0">https://www.bilibili.com/video/BV1nF411e7gq?from=search&amp;seid=2280439246733213375&amp;spm_id_from=333.337.0.0</a></p><p><a href="https://sm.ms/image/UY2CGIdsinNZjXA" target="_blank"><img src="https://s2.loli.net/2022/01/08/UY2CGIdsinNZjXA.jpg" ></a></p><h2 id="nexval数组"><a href="#nexval数组" class="headerlink" title="nexval数组"></a>nexval数组</h2><p><a href="https://sm.ms/image/2DZzaKm4sRT35dc" target="_blank"><img src="https://s2.loli.net/2022/01/08/2DZzaKm4sRT35dc.jpg" ></a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/* 通过计算返回子串T的next数组。 */</span><br><span class="line">void get_next(String T, int *next) </span><br><span class="line">&#123;</span><br><span class="line">int i,k;</span><br><span class="line">  i=1;</span><br><span class="line">  k=0;</span><br><span class="line">  next[1]=0;</span><br><span class="line">  while (i&lt;T[0])  /* 此处T[0]表示串T的长度 */</span><br><span class="line"> &#123;</span><br><span class="line">    if(k==0 || T[i]== T[k]) </span><br><span class="line">&#123;</span><br><span class="line">      ++i;  </span><br><span class="line">++k;  </span><br><span class="line">next[i] = k;</span><br><span class="line">    &#125; </span><br><span class="line">else </span><br><span class="line">k= next[k];/* 若字符不相同，则k值回溯 */</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 返回子串T在主串S中第pos个字符之后的位置。若不存在，则函数返回值为0。 */</span><br><span class="line">/*  T非空，1≤pos≤StrLength(S)。 */</span><br><span class="line">int Index_KMP(String S, String T, int pos) </span><br><span class="line">&#123;</span><br><span class="line">int i = pos;/* i用于主串S中当前位置下标值，若pos不为1，则从pos位置开始匹配 */</span><br><span class="line">int j = 1;/* j用于子串T中当前位置下标值 */</span><br><span class="line">int next[255];/* 定义一next数组 */</span><br><span class="line">get_next(T, next);/* 对串T作分析，得到next数组 */</span><br><span class="line">while (i &lt;= S[0] &amp;&amp; j &lt;= T[0]) /* 若i小于S的长度并且j小于T的长度时，循环继续 */</span><br><span class="line">&#123;</span><br><span class="line">if (j==0 || S[i] == T[j]) /* 两字母相等则继续，与朴素算法增加了j=0判断 */</span><br><span class="line">      &#123;</span><br><span class="line">         ++i;</span><br><span class="line">         ++j; </span><br><span class="line">      &#125; </span><br><span class="line">      else /* 指针后退重新开始匹配 */</span><br><span class="line">       j = next[j];/* j退回合适的位置，i值不变 */</span><br><span class="line">&#125;</span><br><span class="line">if (j &gt; T[0]) </span><br><span class="line">return i-T[0];</span><br><span class="line">else </span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 求模式串T的next函数修正值并存入数组nextval */</span><br><span class="line">void get_nextval(String T, int *nextval) </span><br><span class="line">&#123;</span><br><span class="line">  int i,k;</span><br><span class="line">  i=1;</span><br><span class="line">  k=0;</span><br><span class="line">  nextval[1]=0;</span><br><span class="line">  while (i&lt;T[0])  /* 此处T[0]表示串T的长度 */</span><br><span class="line"> &#123;</span><br><span class="line">    if(k==0 || T[i]== T[k]) /* T[i]表示后缀的单个字符，T[k]表示前缀的单个字符 */</span><br><span class="line">&#123;</span><br><span class="line">      ++i;  </span><br><span class="line">++k;  </span><br><span class="line">if (T[i]!=T[k])      /* 若当前字符与前缀字符不同 */</span><br><span class="line">nextval[i] = k;/* 则当前的j为nextval在i位置的值 */</span><br><span class="line">      else </span><br><span class="line">nextval[i] = nextval[k];/* 如果与前缀字符相同，则将前缀字符的 */</span><br><span class="line">/* nextval值赋值给nextval在i位置的值 */</span><br><span class="line">    &#125; </span><br><span class="line">else </span><br><span class="line">k= nextval[k];/* 若字符不相同，则k值回溯 */</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Index_KMP1(String S, String T, int pos) </span><br><span class="line">&#123;</span><br><span class="line">int i = pos;/* i用于主串S中当前位置下标值，若pos不为1，则从pos位置开始匹配 */</span><br><span class="line">int j = 1;/* j用于子串T中当前位置下标值 */</span><br><span class="line">int next[255];/* 定义一next数组 */</span><br><span class="line">get_nextval(T, next);/* 对串T作分析，得到next数组 */</span><br><span class="line">while (i &lt;= S[0] &amp;&amp; j &lt;= T[0]) /* 若i小于S的长度并且j小于T的长度时，循环继续 */</span><br><span class="line">&#123;</span><br><span class="line">if (j==0 || S[i] == T[j]) /* 两字母相等则继续，与朴素算法增加了j=0判断 */</span><br><span class="line">      &#123;</span><br><span class="line">         ++i;</span><br><span class="line">         ++j; </span><br><span class="line">      &#125; </span><br><span class="line">      else /* 指针后退重新开始匹配 */</span><br><span class="line">       j = next[j];/* j退回合适的位置，i值不变 */</span><br><span class="line">&#125;</span><br><span class="line">if (j &gt; T[0]) </span><br><span class="line">return i-T[0];</span><br><span class="line">else </span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;串和简单模式匹配算法KMP算法&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="http://akkaduilin.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="数据结构" scheme="http://akkaduilin.com/categories/%E7%BC%96%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="字符串" scheme="http://akkaduilin.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="KMP" scheme="http://akkaduilin.com/tags/KMP/"/>
    
  </entry>
  
  <entry>
    <title>线性表</title>
    <link href="http://akkaduilin.com/2022/01/04/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <id>http://akkaduilin.com/2022/01/04/%E7%BA%BF%E6%80%A7%E8%A1%A8/</id>
    <published>2022-01-04T12:31:29.000Z</published>
    <updated>2022-01-07T09:16:30.679Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>总结一些线性表有关的知识点和代码<br>参考博客:<br><a href="https://blog.csdn.net/weixin_38984030/article/details/86076074">https://blog.csdn.net/weixin_38984030/article/details/86076074</a><br><a href="https://sm.ms/image/eaOZdNzFQPDE5hl" target="_blank"><img src="https://s2.loli.net/2022/01/07/eaOZdNzFQPDE5hl.jpg" ></a></p><span id="more"></span><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>线性表是最基本、最简单、也是最常用的一种数据结构。线性表（linear list）是数据结构的一种，一个线性表是n个具有相同特性的数据元素的有限序列。</p><p>特点：</p><p>1．集合中必存在唯一的一个“第一元素”。</p><p>2．集合中必存在唯一的一个 “最后元素” 。</p><p>3．除最后一个元素之外，均有唯一的后继(后件)。</p><p>4．除第一个元素之外，均有唯一的前驱(前件)。</p><p>线性表、包括顺序表和链表，顺序表里面元素的地址是连续的。链表里面节点的地址不是连续的，是通过指针连起来的。</p><h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><p>线性表除第一个元素外，每个元素有且仅有一个直接 前驱 ， 除最后一个元素外，每个元素有且仅有一个直接 后继 。</p><h2 id="顺序储存"><a href="#顺序储存" class="headerlink" title="顺序储存"></a>顺序储存</h2><p>占用一片连续的存储单元<br>数组实现<br>插入操作原理为将第i个元素及其后的所有元素右移一个位置，并在空的位置插入新元素<br><a href="https://sm.ms/image/qWOwAFaJUh6EumR" target="_blank"><img src="https://s2.loli.net/2022/01/07/qWOwAFaJUh6EumR.jpg" style="width:80%"></a><br>最坏时间复杂度为O(n)</p><h2 id="链式储存"><a href="#链式储存" class="headerlink" title="链式储存"></a>链式储存</h2><p><a href="https://sm.ms/image/qhQrPEnkX8IWeG2" target="_blank"><img src="https://s2.loli.net/2022/01/07/qhQrPEnkX8IWeG2.jpg" style="width:80%"></a><br>头指针和头结点<br>头节点数据域无信息，指针域指向线性表第一个元素，方便运算的实现<br>头指针来指示一个单链表，指向链表的第一个结点</p><p>插入/删除<br><a href="https://sm.ms/image/Vn6sfuehNIzb4Xv" target="_blank"><img src="https://s2.loli.net/2022/01/07/Vn6sfuehNIzb4Xv.jpg" style="width:80%"></a><br><a href="https://sm.ms/image/ZJb9WkBKsoXzTiE" target="_blank"><img src="https://s2.loli.net/2022/01/07/ZJb9WkBKsoXzTiE.jpg" style="width:80%"></a></p><h2 id="不引用新节点实现逆置"><a href="#不引用新节点实现逆置" class="headerlink" title="不引用新节点实现逆置"></a>不引用新节点实现逆置</h2><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void inversionList(LNode *L)&#123;</span><br><span class="line">LNode *p,*q;</span><br><span class="line">p = L-&gt;next;//记录节点信息 </span><br><span class="line">L-&gt;next = NULL;//将头结点置为空作为新的头节点</span><br><span class="line">//将链表中原有的元素作为新元素头插法插入到链表中 </span><br><span class="line">while(p != NULL)&#123;</span><br><span class="line">q = p-&gt;next;//q用来记录下一个节点信息 </span><br><span class="line">p-&gt;next = L-&gt;next;</span><br><span class="line">L-&gt;next = p;</span><br><span class="line">p = q;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h2><p>定义<br><a href="https://sm.ms/image/XbTEpZahBcMCfRt" target="_blank"><img src="https://s2.loli.net/2022/01/07/XbTEpZahBcMCfRt.jpg" style="width:80%"></a><br>插入删除<br><a href="https://sm.ms/image/j3LxdU6hsKwE2BZ" target="_blank"><img src="https://s2.loli.net/2022/01/07/j3LxdU6hsKwE2BZ.jpg" style="width:80%"></a></p><h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><p>每一个元素都有后继<br>最后一个结点的后继为头节点<br><a href="https://sm.ms/image/5NCF8SyT93ijn7X" target="_blank"><img src="https://s2.loli.net/2022/01/07/5NCF8SyT93ijn7X.jpg" style="width:80%"></a></p><h1 id="顺序储存结构代码"><a href="#顺序储存结构代码" class="headerlink" title="顺序储存结构代码"></a>顺序储存结构代码</h1><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#define MAXSIZE 20          /* 存储空间初始分配量 */</span><br><span class="line">typedef int ElemType;       /* ElemType类型根据实际情况而定，这里假设为int */</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    ElemType data[MAXSIZE]; /* 数组，存储数据元素 */</span><br><span class="line">    int length;             /* 线性表当前长度 */</span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line">typedef int Status;         /* Status是函数的类型,其值是函数结果状态代码，如OK等 */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Status visit(ElemType c)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;%d &quot;,c);</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 初始化顺序线性表 */</span><br><span class="line">Status InitList(SqList *L) </span><br><span class="line">&#123; </span><br><span class="line">    L-&gt;length=0;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 初始条件：顺序线性表L已存在。操作结果：若L为空表，则返回TRUE，否则返回FALSE */</span><br><span class="line">Status ListEmpty(SqList L)</span><br><span class="line">&#123; </span><br><span class="line">if(L.length==0)</span><br><span class="line">return TRUE;</span><br><span class="line">else</span><br><span class="line">return FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 初始条件：顺序线性表L已存在。操作结果：将L重置为空表 */</span><br><span class="line">Status ClearList(SqList *L)</span><br><span class="line">&#123; </span><br><span class="line">    L-&gt;length=0;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 初始条件：顺序线性表L已存在。操作结果：返回L中数据元素个数 */</span><br><span class="line">int ListLength(SqList L)</span><br><span class="line">&#123;</span><br><span class="line">return L.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) */</span><br><span class="line">/* 操作结果：用e返回L中第i个数据元素的值,注意i是指位置，第1个位置的数组是从0开始 */</span><br><span class="line">Status GetElem(SqList L,int i,ElemType *e)</span><br><span class="line">&#123;</span><br><span class="line">    if(L.length==0 || i&lt;1 || i&gt;L.length)</span><br><span class="line">            return ERROR;</span><br><span class="line">    *e=L.data[i-1];</span><br><span class="line"></span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 初始条件：顺序线性表L已存在 */</span><br><span class="line">/* 操作结果：返回L中第1个与e满足关系的数据元素的位序。 */</span><br><span class="line">/* 若这样的数据元素不存在，则返回值为0 */</span><br><span class="line">int LocateElem(SqList L,ElemType e)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    if (L.length==0)</span><br><span class="line">            return 0;</span><br><span class="line">    for(i=0;i&lt;L.length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">            if (L.data[i]==e)</span><br><span class="line">                    break;</span><br><span class="line">    &#125;</span><br><span class="line">    if(i&gt;=L.length)</span><br><span class="line">            return 0;</span><br><span class="line"></span><br><span class="line">    return i+1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* 初始条件：顺序线性表L已存在,1≤i≤ListLength(L)， */</span><br><span class="line">/* 操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1 */</span><br><span class="line">Status ListInsert(SqList *L,int i,ElemType e)</span><br><span class="line">&#123; </span><br><span class="line">int k;</span><br><span class="line">if (L-&gt;length==MAXSIZE)  /* 顺序线性表已经满 */</span><br><span class="line">return ERROR;</span><br><span class="line">if (i&lt;1 || i&gt;L-&gt;length+1)/* 当i比第一位置小或者比最后一位置后一位置还要大时 */</span><br><span class="line">return ERROR;</span><br><span class="line"></span><br><span class="line">if (i&lt;=L-&gt;length)        /* 若插入数据位置不在表尾 */</span><br><span class="line">&#123;</span><br><span class="line">for(k=L-&gt;length-1;k&gt;=i-1;k--)  /* 将要插入位置之后的数据元素向后移动一位 */</span><br><span class="line">L-&gt;data[k+1]=L-&gt;data[k];</span><br><span class="line">&#125;</span><br><span class="line">L-&gt;data[i-1]=e;          /* 将新元素插入 */</span><br><span class="line">L-&gt;length++;</span><br><span class="line"></span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) */</span><br><span class="line">/* 操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1 */</span><br><span class="line">Status ListDelete(SqList *L,int i,ElemType *e) </span><br><span class="line">&#123; </span><br><span class="line">    int k;</span><br><span class="line">    if (L-&gt;length==0)               /* 线性表为空 */</span><br><span class="line">return ERROR;</span><br><span class="line">    if (i&lt;1 || i&gt;L-&gt;length)         /* 删除位置不正确 */</span><br><span class="line">        return ERROR;</span><br><span class="line">    *e=L-&gt;data[i-1];</span><br><span class="line">    if (i&lt;L-&gt;length)                /* 如果删除不是最后位置 */</span><br><span class="line">    &#123;</span><br><span class="line">        for(k=i;k&lt;L-&gt;length;k++)/* 将删除位置后继元素前移 */</span><br><span class="line">L-&gt;data[k-1]=L-&gt;data[k];</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;length--;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 初始条件：顺序线性表L已存在 */</span><br><span class="line">/* 操作结果：依次对L的每个数据元素输出 */</span><br><span class="line">Status ListTraverse(SqList L)</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">    for(i=0;i&lt;L.length;i++)</span><br><span class="line">            visit(L.data[i]);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*将所有的在线性表Lb中但不在La中的数据元素插入到La中*/</span><br><span class="line">void unionL(SqList *La,SqList Lb)</span><br><span class="line">&#123;</span><br><span class="line">int La_len,Lb_len,i;</span><br><span class="line">ElemType e;                        /*声明与La和Lb相同的数据元素e*/</span><br><span class="line">La_len=ListLength(*La);            /*求线性表的长度 */</span><br><span class="line">Lb_len=ListLength(Lb);</span><br><span class="line">for (i=1;i&lt;=Lb_len;i++)</span><br><span class="line">&#123;</span><br><span class="line">GetElem(Lb,i,&amp;e);              /*取Lb中第i个数据元素赋给e*/</span><br><span class="line">if (!LocateElem(*La,e))        /*La中不存在和e相同数据元素*/</span><br><span class="line">ListInsert(La,++La_len,e); /*插入*/</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="链式储存结构"><a href="#链式储存结构" class="headerlink" title="链式储存结构"></a>链式储存结构</h1><h2 id="单链表代码"><a href="#单链表代码" class="headerlink" title="单链表代码"></a>单链表代码</h2><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#define MAXSIZE 20 /* 存储空间初始分配量 */</span><br><span class="line"></span><br><span class="line">typedef int Status;/* Status是函数的类型,其值是函数结果状态代码，如OK等 */</span><br><span class="line">typedef int ElemType;/* ElemType类型根据实际情况而定，这里假设为int */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Status visit(ElemType c)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;%d &quot;,c);</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">typedef struct Node</span><br><span class="line">&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    struct Node *next;</span><br><span class="line">&#125;Node;</span><br><span class="line">typedef struct Node *LinkList; /* 定义LinkList */</span><br><span class="line"></span><br><span class="line">/* 初始化链式线性表 */</span><br><span class="line">Status InitList(LinkList *L) </span><br><span class="line">&#123; </span><br><span class="line">    *L=(LinkList)malloc(sizeof(Node)); /* 产生头结点,并使L指向此头结点 */</span><br><span class="line">    if(!(*L)) /* 存储分配失败 */</span><br><span class="line">            return ERROR;</span><br><span class="line">    (*L)-&gt;next=NULL; /* 指针域为空 */</span><br><span class="line"></span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 初始条件：链式线性表L已存在。操作结果：若L为空表，则返回TRUE，否则返回FALSE */</span><br><span class="line">Status ListEmpty(LinkList L)</span><br><span class="line">&#123; </span><br><span class="line">    if(L-&gt;next)</span><br><span class="line">            return FALSE;</span><br><span class="line">    else</span><br><span class="line">            return TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 初始条件：链式线性表L已存在。操作结果：将L重置为空表 */</span><br><span class="line">Status ClearList(LinkList *L)</span><br><span class="line">&#123; </span><br><span class="line">LinkList p,q;</span><br><span class="line">p=(*L)-&gt;next;           /*  p指向第一个结点 */</span><br><span class="line">while(p)                /*  没到表尾 */</span><br><span class="line">&#123;</span><br><span class="line">q=p-&gt;next;</span><br><span class="line">free(p);</span><br><span class="line">p=q;</span><br><span class="line">&#125;</span><br><span class="line">(*L)-&gt;next=NULL;        /* 头结点指针域为空 */</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 初始条件：链式线性表L已存在。操作结果：返回L中数据元素个数 */</span><br><span class="line">int ListLength(LinkList L)</span><br><span class="line">&#123;</span><br><span class="line">    int i=0;</span><br><span class="line">    LinkList p=L-&gt;next; /* p指向第一个结点 */</span><br><span class="line">    while(p)                        </span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 初始条件：链式线性表L已存在，1≤i≤ListLength(L) */</span><br><span class="line">/* 操作结果：用e返回L中第i个数据元素的值 */</span><br><span class="line">Status GetElem(LinkList L,int i,ElemType *e)</span><br><span class="line">&#123;</span><br><span class="line">int j;</span><br><span class="line">LinkList p;/* 声明一结点p */</span><br><span class="line">p = L-&gt;next;/* 让p指向链表L的第一个结点 */</span><br><span class="line">j = 1;/*  j为计数器 */</span><br><span class="line">while (p &amp;&amp; j&lt;i)  /* p不为空或者计数器j还没有等于i时，循环继续 */</span><br><span class="line">&#123;   </span><br><span class="line">p = p-&gt;next;  /* 让p指向下一个结点 */</span><br><span class="line">++j;</span><br><span class="line">&#125;</span><br><span class="line">if ( !p || j&gt;i ) </span><br><span class="line">return ERROR;  /*  第i个元素不存在 */</span><br><span class="line">*e = p-&gt;data;   /*  取第i个元素的数据 */</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 初始条件：链式线性表L已存在 */</span><br><span class="line">/* 操作结果：返回L中第1个与e满足关系的数据元素的位序。 */</span><br><span class="line">/* 若这样的数据元素不存在，则返回值为0 */</span><br><span class="line">int LocateElem(LinkList L,ElemType e)</span><br><span class="line">&#123;</span><br><span class="line">    int i=0;</span><br><span class="line">    LinkList p=L-&gt;next;</span><br><span class="line">    while(p)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">        if(p-&gt;data==e) /* 找到这样的数据元素 */</span><br><span class="line">                return i;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* 初始条件：链式线性表L已存在,1≤i≤ListLength(L)， */</span><br><span class="line">/* 操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1 */</span><br><span class="line">Status ListInsert(LinkList *L,int i,ElemType e)</span><br><span class="line">&#123; </span><br><span class="line">int j;</span><br><span class="line">LinkList p,s;</span><br><span class="line">p = *L;   </span><br><span class="line">j = 1;</span><br><span class="line">while (p &amp;&amp; j &lt; i)     /* 寻找第i个结点 */</span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">++j;</span><br><span class="line">&#125; </span><br><span class="line">if (!p || j &gt; i) </span><br><span class="line">return ERROR;   /* 第i个元素不存在 */</span><br><span class="line">s = (LinkList)malloc(sizeof(Node));  /*  生成新结点(C语言标准函数) */</span><br><span class="line">s-&gt;data = e;  </span><br><span class="line">s-&gt;next = p-&gt;next;      /* 将p的后继结点赋值给s的后继  */</span><br><span class="line">p-&gt;next = s;          /* 将s赋值给p的后继 */</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 初始条件：链式线性表L已存在，1≤i≤ListLength(L) */</span><br><span class="line">/* 操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1 */</span><br><span class="line">Status ListDelete(LinkList *L,int i,ElemType *e) </span><br><span class="line">&#123; </span><br><span class="line">int j;</span><br><span class="line">LinkList p,q;</span><br><span class="line">p = *L;</span><br><span class="line">j = 1;</span><br><span class="line">while (p-&gt;next &amp;&amp; j &lt; i)/* 遍历寻找第i个元素 */</span><br><span class="line">&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        ++j;</span><br><span class="line">&#125;</span><br><span class="line">if (!(p-&gt;next) || j &gt; i) </span><br><span class="line">    return ERROR;           /* 第i个元素不存在 */</span><br><span class="line">q = p-&gt;next;</span><br><span class="line">p-&gt;next = q-&gt;next;/* 将q的后继赋值给p的后继 */</span><br><span class="line">*e = q-&gt;data;               /* 将q结点中的数据给e */</span><br><span class="line">free(q);                    /* 让系统回收此结点，释放内存 */</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 初始条件：链式线性表L已存在 */</span><br><span class="line">/* 操作结果：依次对L的每个数据元素输出 */</span><br><span class="line">Status ListTraverse(LinkList L)</span><br><span class="line">&#123;</span><br><span class="line">    LinkList p=L-&gt;next;</span><br><span class="line">    while(p)</span><br><span class="line">    &#123;</span><br><span class="line">        visit(p-&gt;data);</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*  随机产生n个元素的值，建立带表头结点的单链线性表L（头插法） */</span><br><span class="line">void CreateListHead(LinkList *L, int n) </span><br><span class="line">&#123;</span><br><span class="line">LinkList p;</span><br><span class="line">int i;</span><br><span class="line">srand(time(0));                         /* 初始化随机数种子 */</span><br><span class="line">*L = (LinkList)malloc(sizeof(Node));</span><br><span class="line">(*L)-&gt;next = NULL;                      /*  先建立一个带头结点的单链表 */</span><br><span class="line">for (i=0; i&lt;n; i++) </span><br><span class="line">&#123;</span><br><span class="line">p = (LinkList)malloc(sizeof(Node)); /*  生成新结点 */</span><br><span class="line">p-&gt;data = rand()%100+1;             /*  随机生成100以内的数字 */</span><br><span class="line">p-&gt;next = (*L)-&gt;next;    </span><br><span class="line">(*L)-&gt;next = p;/*  插入到表头 */</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*  随机产生n个元素的值，建立带表头结点的单链线性表L（尾插法） */</span><br><span class="line">void CreateListTail(LinkList *L, int n) </span><br><span class="line">&#123;</span><br><span class="line">LinkList p,r;</span><br><span class="line">int i;</span><br><span class="line">srand(time(0));                      /* 初始化随机数种子 */</span><br><span class="line">*L = (LinkList)malloc(sizeof(Node)); /* L为整个线性表 */</span><br><span class="line">r=*L;                                /* r为指向尾部的结点 */</span><br><span class="line">for (i=0; i&lt;n; i++) </span><br><span class="line">&#123;</span><br><span class="line">p = (Node *)malloc(sizeof(Node)); /*  生成新结点 */</span><br><span class="line">p-&gt;data = rand()%100+1;           /*  随机生成100以内的数字 */</span><br><span class="line">r-&gt;next=p;                        /* 将表尾终端结点的指针指向新结点 */</span><br><span class="line">r = p;                            /* 将当前的新结点定义为表尾终端结点 */</span><br><span class="line">&#125;</span><br><span class="line">r-&gt;next = NULL;                       /* 表示当前链表结束 */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;总结一些线性表有关的知识点和代码&lt;br&gt;参考博客:&lt;br&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_38984030/article/details/86076074&quot;&gt;https://blog.csdn.net/weixin_38984030/article/details/86076074&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://sm.ms/image/eaOZdNzFQPDE5hl&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://s2.loli.net/2022/01/07/eaOZdNzFQPDE5hl.jpg&quot; &gt;&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="http://akkaduilin.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="数据结构" scheme="http://akkaduilin.com/categories/%E7%BC%96%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="C++" scheme="http://akkaduilin.com/tags/C/"/>
    
    <category term="线性表" scheme="http://akkaduilin.com/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>栈和队列</title>
    <link href="http://akkaduilin.com/2022/01/04/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <id>http://akkaduilin.com/2022/01/04/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</id>
    <published>2022-01-04T12:27:51.000Z</published>
    <updated>2022-01-07T15:36:42.500Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>栈与队列<br>期末秃头人限定<br><a href="https://sm.ms/image/Yd5sbtuagm9RUSA" target="_blank"><img src="https://s2.loli.net/2022/01/07/Yd5sbtuagm9RUSA.jpg"  style="width:80%"></a></p><span id="more"></span><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>栈是只允许在一端进行插入或删除的线性表。</strong><br><strong>先进后出</strong></p><h2 id="储存结构"><a href="#储存结构" class="headerlink" title="储存结构"></a>储存结构</h2><p><strong>先移动指针再入栈</strong><br><strong>先出栈再移动指针</strong></p><h3 id="顺序储存"><a href="#顺序储存" class="headerlink" title="顺序储存"></a>顺序储存</h3><p><strong>利用一组地址连续的储存单元存放自栈底到栈顶的数据元素</strong><br><strong>附设一个top指针指向栈顶元素</strong></p><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#define OK 1</span><br><span class="line">#define ERROR 0</span><br><span class="line">#define TRUE 1</span><br><span class="line">#define FALSE 0</span><br><span class="line">#define MAXSIZE 20 /* 存储空间初始分配量 */</span><br><span class="line"></span><br><span class="line">typedef int Status; </span><br><span class="line">typedef int SElemType; /* SElemType类型根据实际情况而定，这里假设为int */</span><br><span class="line"></span><br><span class="line">/* 顺序栈结构 */</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">        SElemType data[MAXSIZE];</span><br><span class="line">        int top; /* 用于栈顶指针 */</span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line">Status visit(SElemType c)</span><br><span class="line">&#123;</span><br><span class="line">        printf(&quot;%d &quot;,c);</span><br><span class="line">        return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*  构造一个空栈S */</span><br><span class="line">Status InitStack(SqStack *S)</span><br><span class="line">&#123; </span><br><span class="line">        /* S.data=(SElemType *)malloc(MAXSIZE*sizeof(SElemType)); */</span><br><span class="line">        S-&gt;top=-1;</span><br><span class="line">        return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 把S置为空栈 */</span><br><span class="line">Status ClearStack(SqStack *S)</span><br><span class="line">&#123; </span><br><span class="line">        S-&gt;top=-1;</span><br><span class="line">        return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 若栈S为空栈，则返回TRUE，否则返回FALSE */</span><br><span class="line">Status StackEmpty(SqStack S)</span><br><span class="line">&#123; </span><br><span class="line">        if (S.top==-1)</span><br><span class="line">                return TRUE;</span><br><span class="line">        else</span><br><span class="line">                return FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 返回S的元素个数，即栈的长度 */</span><br><span class="line">int StackLength(SqStack S)</span><br><span class="line">&#123; </span><br><span class="line">        return S.top+1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 若栈不空，则用e返回S的栈顶元素，并返回OK；否则返回ERROR */</span><br><span class="line">Status GetTop(SqStack S,SElemType *e)</span><br><span class="line">&#123;</span><br><span class="line">        if (S.top==-1)</span><br><span class="line">                return ERROR;</span><br><span class="line">        else</span><br><span class="line">                *e=S.data[S.top];</span><br><span class="line">        return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 插入元素e为新的栈顶元素 */</span><br><span class="line">Status Push(SqStack *S,SElemType e)</span><br><span class="line">&#123;</span><br><span class="line">        if(S-&gt;top == MAXSIZE -1) /* 栈满 */</span><br><span class="line">        &#123;</span><br><span class="line">                return ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">        S-&gt;top++;/* 栈顶指针增加一 */</span><br><span class="line">        S-&gt;data[S-&gt;top]=e;  /* 将新插入元素赋值给栈顶空间 */</span><br><span class="line">        return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR */</span><br><span class="line">Status Pop(SqStack *S,SElemType *e)</span><br><span class="line">&#123; </span><br><span class="line">        if(S-&gt;top==-1)</span><br><span class="line">                return ERROR;</span><br><span class="line">        *e=S-&gt;data[S-&gt;top];/* 将要删除的栈顶元素赋值给e */</span><br><span class="line">        S-&gt;top--;/* 栈顶指针减一 */</span><br><span class="line">        return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 从栈底到栈顶依次对栈中每个元素显示 */</span><br><span class="line">Status StackTraverse(SqStack S)</span><br><span class="line">&#123;</span><br><span class="line">        int i;</span><br><span class="line">        i=0;</span><br><span class="line">        while(i&lt;=S.top)</span><br><span class="line">        &#123;</span><br><span class="line">                visit(S.data[i++]);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">        return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="链式储存"><a href="#链式储存" class="headerlink" title="链式储存"></a>链式储存</h3><p><strong>单链表实现</strong><br><strong>规定所有操作都是在栈顶实现</strong></p><p>没有头结点</p><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">#define OK 1</span><br><span class="line">#define ERROR 0</span><br><span class="line">#define TRUE 1</span><br><span class="line">#define FALSE 0</span><br><span class="line">#define MAXSIZE 20 /* 存储空间初始分配量 */</span><br><span class="line"></span><br><span class="line">typedef int Status; </span><br><span class="line">typedef int SElemType; /* SElemType类型根据实际情况而定，这里假设为int */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* 链栈结构 */</span><br><span class="line">typedef struct StackNode</span><br><span class="line">&#123;</span><br><span class="line">        SElemType data;</span><br><span class="line">        struct StackNode *next;</span><br><span class="line">&#125;StackNode,*LinkStackPtr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">        LinkStackPtr top;</span><br><span class="line">        int count;</span><br><span class="line">&#125;LinkStack;</span><br><span class="line"></span><br><span class="line">Status visit(SElemType c)</span><br><span class="line">&#123;</span><br><span class="line">        printf(&quot;%d &quot;,c);</span><br><span class="line">        return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*  构造一个空栈S */</span><br><span class="line">Status InitStack(LinkStack *S)</span><br><span class="line">&#123; </span><br><span class="line">        S-&gt;top = (LinkStackPtr)malloc(sizeof(StackNode));</span><br><span class="line">        if(!S-&gt;top)</span><br><span class="line">                return ERROR;</span><br><span class="line">        S-&gt;top=NULL;</span><br><span class="line">        S-&gt;count=0;</span><br><span class="line">        return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 把S置为空栈 */</span><br><span class="line">Status ClearStack(LinkStack *S)</span><br><span class="line">&#123; </span><br><span class="line">        LinkStackPtr p,q;</span><br><span class="line">        p=S-&gt;top;</span><br><span class="line">        while(p)</span><br><span class="line">        &#123;  </span><br><span class="line">                q=p;</span><br><span class="line">                p=p-&gt;next;</span><br><span class="line">                free(q);</span><br><span class="line">        &#125; </span><br><span class="line">        S-&gt;count=0;</span><br><span class="line">        return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 若栈S为空栈，则返回TRUE，否则返回FALSE */</span><br><span class="line">Status StackEmpty(LinkStack S)</span><br><span class="line">&#123; </span><br><span class="line">        if (S.count==0)</span><br><span class="line">                return TRUE;</span><br><span class="line">        else</span><br><span class="line">                return FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 返回S的元素个数，即栈的长度 */</span><br><span class="line">int StackLength(LinkStack S)</span><br><span class="line">&#123; </span><br><span class="line">        return S.count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 若栈不空，则用e返回S的栈顶元素，并返回OK；否则返回ERROR */</span><br><span class="line">Status GetTop(LinkStack S,SElemType *e)</span><br><span class="line">&#123;</span><br><span class="line">        if (S.top==NULL)</span><br><span class="line">                return ERROR;</span><br><span class="line">        else</span><br><span class="line">                *e=S.top-&gt;data;</span><br><span class="line">        return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 插入元素e为新的栈顶元素 */</span><br><span class="line">Status Push(LinkStack *S,SElemType e)</span><br><span class="line">&#123;</span><br><span class="line">        LinkStackPtr s=(LinkStackPtr)malloc(sizeof(StackNode)); </span><br><span class="line">        s-&gt;data=e; </span><br><span class="line">        s-&gt;next=S-&gt;top;/* 把当前的栈顶元素赋值给新结点的直接后继，见图中① */</span><br><span class="line">        S-&gt;top=s;         /* 将新的结点s赋值给栈顶指针，见图中② */</span><br><span class="line">        S-&gt;count++;</span><br><span class="line">        return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR */</span><br><span class="line">Status Pop(LinkStack *S,SElemType *e)</span><br><span class="line">&#123; </span><br><span class="line">        LinkStackPtr p;</span><br><span class="line">        if(StackEmpty(*S))</span><br><span class="line">                return ERROR;</span><br><span class="line">        *e=S-&gt;top-&gt;data;</span><br><span class="line">        p=S-&gt;top;/* 将栈顶结点赋值给p，见图中③ */</span><br><span class="line">        S-&gt;top=S-&gt;top-&gt;next;    /* 使得栈顶指针下移一位，指向后一结点，见图中④ */</span><br><span class="line">        free(p);                    /* 释放结点p */        </span><br><span class="line">        S-&gt;count--;</span><br><span class="line">        return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Status StackTraverse(LinkStack S)</span><br><span class="line">&#123;</span><br><span class="line">        LinkStackPtr p;</span><br><span class="line">        p=S.top;</span><br><span class="line">        while(p)</span><br><span class="line">        &#123;</span><br><span class="line">                 visit(p-&gt;data);</span><br><span class="line">                 p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">        return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="共享栈"><a href="#共享栈" class="headerlink" title="共享栈"></a>共享栈</h2><p><a href="https://sm.ms/image/7aPM3FTuXfAI1JH" target="_blank"><img src="https://s2.loli.net/2022/01/07/7aPM3FTuXfAI1JH.jpg" ></a></p><h2 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h2><p>数据逆置算法、括号匹配的判断、后缀表达式求值算法</p><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p><strong>在表的一端经行输入，在另一端经行输出</strong></p><h2 id="储存结构-1"><a href="#储存结构-1" class="headerlink" title="储存结构"></a>储存结构</h2><h3 id="顺序储存-1"><a href="#顺序储存-1" class="headerlink" title="顺序储存"></a>顺序储存</h3><p><strong>分配一块连续的储存空间</strong><br><strong>两个指针一个指向指向队头(front),一个指向队尾(rear)</strong></p><p>入栈操作<br><strong>队不满时，先送值到队尾，再将队尾指针加1</strong></p><p>出栈操作<br><strong>队不空时，先取队头元素，在将队头指针加1</strong></p><p>队空条件<br><strong>Q.front == Q.rear == 0</strong></p><h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p><a href="https://sm.ms/image/qkyF3WwiMEUSGfJ" target="_blank"><img src="https://s2.loli.net/2022/01/07/qkyF3WwiMEUSGfJ.jpg" ></a></p><p>代码:</p><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#define OK 1</span><br><span class="line">#define ERROR 0</span><br><span class="line">#define TRUE 1</span><br><span class="line">#define FALSE 0</span><br><span class="line">#define MAXSIZE 20 /* 存储空间初始分配量 */</span><br><span class="line"></span><br><span class="line">typedef int Status; </span><br><span class="line">typedef int QElemType; /* QElemType类型根据实际情况而定，这里假设为int */</span><br><span class="line"></span><br><span class="line">/* 循环队列的顺序存储结构 */</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">QElemType data[MAXSIZE];</span><br><span class="line">int front;    /* 头指针 */</span><br><span class="line">int rear;/* 尾指针，若队列不空，指向队列尾元素的下一个位置 */</span><br><span class="line">&#125;SqQueue;</span><br><span class="line"></span><br><span class="line">Status visit(QElemType c)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d &quot;,c);</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 初始化一个空队列Q */</span><br><span class="line">Status InitQueue(SqQueue *Q)</span><br><span class="line">&#123;</span><br><span class="line">Q-&gt;front=0;</span><br><span class="line">Q-&gt;rear=0;</span><br><span class="line">return  OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 将Q清为空队列 */</span><br><span class="line">Status ClearQueue(SqQueue *Q)</span><br><span class="line">&#123;</span><br><span class="line">Q-&gt;front=Q-&gt;rear=0;</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 若队列Q为空队列,则返回TRUE,否则返回FALSE */</span><br><span class="line">Status QueueEmpty(SqQueue Q)</span><br><span class="line">&#123; </span><br><span class="line">if(Q.front==Q.rear) /* 队列空的标志 */</span><br><span class="line">return TRUE;</span><br><span class="line">else</span><br><span class="line">return FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 返回Q的元素个数，也就是队列的当前长度 */</span><br><span class="line">int QueueLength(SqQueue Q)</span><br><span class="line">&#123;</span><br><span class="line">return  (Q.rear-Q.front+MAXSIZE)%MAXSIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 若队列不空,则用e返回Q的队头元素,并返回OK,否则返回ERROR */</span><br><span class="line">Status GetHead(SqQueue Q,QElemType *e)</span><br><span class="line">&#123;</span><br><span class="line">if(Q.front==Q.rear) /* 队列空 */</span><br><span class="line">return ERROR;</span><br><span class="line">*e=Q.data[Q.front];</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 若队列未满，则插入元素e为Q新的队尾元素 */</span><br><span class="line">Status EnQueue(SqQueue *Q,QElemType e)</span><br><span class="line">&#123;</span><br><span class="line">if ((Q-&gt;rear+1)%MAXSIZE == Q-&gt;front)/* 队列满的判断 */</span><br><span class="line">return ERROR;</span><br><span class="line">Q-&gt;data[Q-&gt;rear]=e;/* 将元素e赋值给队尾 */</span><br><span class="line">Q-&gt;rear=(Q-&gt;rear+1)%MAXSIZE;/* rear指针向后移一位置， */</span><br><span class="line">/* 若到最后则转到数组头部 */</span><br><span class="line">return  OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 若队列不空，则删除Q中队头元素，用e返回其值 */</span><br><span class="line">Status DeQueue(SqQueue *Q,QElemType *e)</span><br><span class="line">&#123;</span><br><span class="line">if (Q-&gt;front == Q-&gt;rear)/* 队列空的判断 */</span><br><span class="line">return ERROR;</span><br><span class="line">*e=Q-&gt;data[Q-&gt;front];/* 将队头元素赋值给e */</span><br><span class="line">Q-&gt;front=(Q-&gt;front+1)%MAXSIZE;/* front指针向后移一位置， */</span><br><span class="line">/* 若到最后则转到数组头部 */</span><br><span class="line">return  OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 从队头到队尾依次对队列Q中每个元素输出 */</span><br><span class="line">Status QueueTraverse(SqQueue Q)</span><br><span class="line">&#123; </span><br><span class="line">int i;</span><br><span class="line">i=Q.front;</span><br><span class="line">while((i+Q.front)!=Q.rear)</span><br><span class="line">&#123;</span><br><span class="line">visit(Q.data[i]);</span><br><span class="line">i=(i+1)%MAXSIZE;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链式储存-1"><a href="#链式储存-1" class="headerlink" title="链式储存"></a>链式储存</h3><p><strong>同时带有队头指针和队尾指针的单链表</strong></p><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#define OK 1</span><br><span class="line">#define ERROR 0</span><br><span class="line">#define TRUE 1</span><br><span class="line">#define FALSE 0</span><br><span class="line">#define MAXSIZE 20 /* 存储空间初始分配量 */</span><br><span class="line"></span><br><span class="line">typedef int Status; </span><br><span class="line"></span><br><span class="line">typedef int QElemType; /* QElemType类型根据实际情况而定，这里假设为int */</span><br><span class="line"></span><br><span class="line">typedef struct QNode/* 结点结构 */</span><br><span class="line">&#123;</span><br><span class="line">   QElemType data;</span><br><span class="line">   struct QNode *next;</span><br><span class="line">&#125;QNode,*QueuePtr;</span><br><span class="line"></span><br><span class="line">typedef struct/* 队列的链表结构 */</span><br><span class="line">&#123;</span><br><span class="line">   QueuePtr front,rear; /* 队头、队尾指针 */</span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br><span class="line">Status visit(QElemType c)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d &quot;,c);</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 构造一个空队列Q */</span><br><span class="line">Status InitQueue(LinkQueue *Q)</span><br><span class="line">&#123; </span><br><span class="line">Q-&gt;front=Q-&gt;rear=(QueuePtr)malloc(sizeof(QNode));</span><br><span class="line">if(!Q-&gt;front)</span><br><span class="line">exit(OVERFLOW);</span><br><span class="line">Q-&gt;front-&gt;next=NULL;</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 销毁队列Q */</span><br><span class="line">Status DestroyQueue(LinkQueue *Q)</span><br><span class="line">&#123;</span><br><span class="line">while(Q-&gt;front)</span><br><span class="line">&#123;</span><br><span class="line"> Q-&gt;rear=Q-&gt;front-&gt;next;</span><br><span class="line"> free(Q-&gt;front);</span><br><span class="line"> Q-&gt;front=Q-&gt;rear;</span><br><span class="line">&#125;</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 将Q清为空队列 */</span><br><span class="line">Status ClearQueue(LinkQueue *Q)</span><br><span class="line">&#123;</span><br><span class="line">QueuePtr p,q;</span><br><span class="line">Q-&gt;rear=Q-&gt;front;</span><br><span class="line">p=Q-&gt;front-&gt;next;</span><br><span class="line">Q-&gt;front-&gt;next=NULL;</span><br><span class="line">while(p)</span><br><span class="line">&#123;</span><br><span class="line"> q=p;</span><br><span class="line"> p=p-&gt;next;</span><br><span class="line"> free(q);</span><br><span class="line">&#125;</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 若Q为空队列,则返回TRUE,否则返回FALSE */</span><br><span class="line">Status QueueEmpty(LinkQueue Q)</span><br><span class="line">&#123; </span><br><span class="line">if(Q.front==Q.rear)</span><br><span class="line">return TRUE;</span><br><span class="line">else</span><br><span class="line">return FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 求队列的长度 */</span><br><span class="line">int QueueLength(LinkQueue Q)</span><br><span class="line">&#123; </span><br><span class="line">int i=0;</span><br><span class="line">QueuePtr p;</span><br><span class="line">p=Q.front;</span><br><span class="line">while(Q.rear!=p)</span><br><span class="line">&#123;</span><br><span class="line"> i++;</span><br><span class="line"> p=p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">return i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 若队列不空,则用e返回Q的队头元素,并返回OK,否则返回ERROR */</span><br><span class="line">Status GetHead(LinkQueue Q,QElemType *e)</span><br><span class="line">&#123; </span><br><span class="line">QueuePtr p;</span><br><span class="line">if(Q.front==Q.rear)</span><br><span class="line">return ERROR;</span><br><span class="line">p=Q.front-&gt;next;</span><br><span class="line">*e=p-&gt;data;</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* 插入元素e为Q的新的队尾元素 */</span><br><span class="line">Status EnQueue(LinkQueue *Q,QElemType e)</span><br><span class="line">&#123; </span><br><span class="line">QueuePtr s=(QueuePtr)malloc(sizeof(QNode));</span><br><span class="line">if(!s) /* 存储分配失败 */</span><br><span class="line">exit(OVERFLOW);</span><br><span class="line">s-&gt;data=e;</span><br><span class="line">s-&gt;next=NULL;</span><br><span class="line">Q-&gt;rear-&gt;next=s;/* 把拥有元素e的新结点s赋值给原队尾结点的后继，见图中① */</span><br><span class="line">Q-&gt;rear=s;/* 把当前的s设置为队尾结点，rear指向s，见图中② */</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 若队列不空,删除Q的队头元素,用e返回其值,并返回OK,否则返回ERROR */</span><br><span class="line">Status DeQueue(LinkQueue *Q,QElemType *e)</span><br><span class="line">&#123;</span><br><span class="line">QueuePtr p;</span><br><span class="line">if(Q-&gt;front==Q-&gt;rear)</span><br><span class="line">return ERROR;</span><br><span class="line">p=Q-&gt;front-&gt;next;/* 将欲删除的队头结点暂存给p，见图中① */</span><br><span class="line">*e=p-&gt;data;/* 将欲删除的队头结点的值赋值给e */</span><br><span class="line">Q-&gt;front-&gt;next=p-&gt;next;/* 将原队头结点的后继p-&gt;next赋值给头结点后继，见图中② */</span><br><span class="line">if(Q-&gt;rear==p)/* 若队头就是队尾，则删除后将rear指向头结点，见图中③ */</span><br><span class="line">Q-&gt;rear=Q-&gt;front;</span><br><span class="line">free(p);</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 从队头到队尾依次对队列Q中每个元素输出 */</span><br><span class="line">Status QueueTraverse(LinkQueue Q)</span><br><span class="line">&#123;</span><br><span class="line">QueuePtr p;</span><br><span class="line">p=Q.front-&gt;next;</span><br><span class="line">while(p)</span><br><span class="line">&#123;</span><br><span class="line"> visit(p-&gt;data);</span><br><span class="line"> p=p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;栈与队列&lt;br&gt;期末秃头人限定&lt;br&gt;&lt;a href=&quot;https://sm.ms/image/Yd5sbtuagm9RUSA&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://s2.loli.net/2022/01/07/Yd5sbtuagm9RUSA.jpg&quot;  style=&quot;width:80%&quot;&gt;&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="http://akkaduilin.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="数据结构" scheme="http://akkaduilin.com/categories/%E7%BC%96%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="C++" scheme="http://akkaduilin.com/tags/C/"/>
    
    <category term="栈" scheme="http://akkaduilin.com/tags/%E6%A0%88/"/>
    
    <category term="队列" scheme="http://akkaduilin.com/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>不正经的2021总结</title>
    <link href="http://akkaduilin.com/2021/12/31/2021%E6%80%BB%E7%BB%93/"/>
    <id>http://akkaduilin.com/2021/12/31/2021%E6%80%BB%E7%BB%93/</id>
    <published>2021-12-31T04:18:37.000Z</published>
    <updated>2021-12-31T07:06:09.110Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://sm.ms/image/ghyrXm5CScL4RJN" target="_blank"><img src="https://s2.loli.net/2021/12/31/ghyrXm5CScL4RJN.jpg" ></a></p><p><strong>前言</strong></p><p>这是一篇不太正经的年度总结呢！</p><span id="more"></span><h1 id="很喜欢的一张画"><a href="#很喜欢的一张画" class="headerlink" title="很喜欢的一张画"></a>很喜欢的一张画</h1><p><a href="https://sm.ms/image/C3VqX8gh4vlpxUc" target="_blank"><img src="https://s2.loli.net/2021/12/31/C3VqX8gh4vlpxUc.jpg" style="width:50%"></a></p><h1 id="1-21"><a href="#1-21" class="headerlink" title="1.21"></a>1.21</h1><p>和小朋友在一起两年啦<br>假期有和她一起出去玩<br><a href="https://sm.ms/image/qFNkLcW1VgaA2O3" target="_blank"><img src="https://s2.loli.net/2021/12/31/qFNkLcW1VgaA2O3.jpg" style="width:50%"></a></p><h1 id="一些春天的照片"><a href="#一些春天的照片" class="headerlink" title="一些春天的照片"></a>一些春天的照片</h1><p>春天的雨后晚上和春天的园林<br>苏州在春天的时候会有很多古装小姐姐逛园子哦<br><a href="https://sm.ms/image/9dawstyPgzmK4nV" target="_blank"><img src="https://s2.loli.net/2021/12/31/9dawstyPgzmK4nV.jpg" style="width:50%"></a><br><a href="https://sm.ms/image/dYrW7meOPQGftgs" target="_blank"><img src="https://s2.loli.net/2021/12/31/dYrW7meOPQGftgs.jpg" style="width:50%"></a><br><a href="https://sm.ms/image/b8yfcjrSmlDZ3WX" target="_blank"><img src="https://s2.loli.net/2021/12/31/b8yfcjrSmlDZ3WX.jpg" style="width:50%"></a><br><a href="https://sm.ms/image/CVPFJioXN8ctRjq" target="_blank"><img src="https://s2.loli.net/2021/12/31/CVPFJioXN8ctRjq.jpg" style="width:50%"></a></p><h1 id="学期内"><a href="#学期内" class="headerlink" title="学期内"></a>学期内</h1><p><a href="https://sm.ms/image/Apa1b2NBndxcRKm" target="_blank"><img src="https://s2.loli.net/2021/12/31/Apa1b2NBndxcRKm.jpg" style="width:50%"></a><br>王者之志<br>见到了好多学校的专业运动员，见到了丹总</p><p><a href="https://sm.ms/image/sFOdqiKUSkh5BDm" target="_blank"><img src="https://s2.loli.net/2021/12/31/sFOdqiKUSkh5BDm.jpg" style="width:50%"></a></p><p>去LNG比赛现场志愿者*2<br>LNG 打 RNG 在现场，那种现场观赛的感觉超棒<br>更加喜欢lol，喜欢电竞<br><a href="https://sm.ms/image/zs6WRAciIYOwEPD" target="_blank"><img src="https://s2.loli.net/2021/12/31/zs6WRAciIYOwEPD.jpg"  style="width:50%"></a></p><h1 id="5-1-太湖"><a href="#5-1-太湖" class="headerlink" title="5.1 太湖"></a>5.1 太湖</h1><p>贴上今年最喜欢的照片之一<br>环太湖骑行是这几年最喜欢的骑行了<br>日落真的很好看，以后一定要带小朋友来看</p><p><a href="https://sm.ms/image/eihKcnoBGJ8DEjy" target="_blank"><img src="https://s2.loli.net/2021/12/31/eihKcnoBGJ8DEjy.jpg" style="width:80%"></a><br><a href="https://sm.ms/image/iBzvp7dA8KwOcDJ" target="_blank"><img src="https://s2.loli.net/2021/12/31/iBzvp7dA8KwOcDJ.jpg" style="width:80%"></a></p><h1 id="5-21-5-26"><a href="#5-21-5-26" class="headerlink" title="5.21 5.26"></a>5.21 5.26</h1><p>收到小朋友送的花花！</p><p><a href="https://sm.ms/image/CSvOKWcXdlRxoEe" target="_blank"><img src="https://s2.loli.net/2021/12/31/CSvOKWcXdlRxoEe.jpg" style="width:50%"></a></p><p>又长大了一岁！<br>有猫猫陪伴</p><p><a href="https://sm.ms/image/BIPhyqadpMwJzT7" target="_blank"><img src="https://s2.loli.net/2021/12/31/BIPhyqadpMwJzT7.jpg" style="width:50%"></a></p><h1 id="暑假"><a href="#暑假" class="headerlink" title="暑假"></a>暑假</h1><p>有初步学习微信小程序并且写了一个不太完整的demo(为了一个比赛来着，不过好像被咕了)<br>一定一定要记得不要参加那些不官方的比赛了</p><p>和好朋友们出去 玩玩玩</p><p>给小朋友们代课</p><p>科目三挂了。。。。。。。艹</p><p>开始习惯于自己做饭，厨艺渐长<br><a href="https://sm.ms/image/dfJ9EokF5tpLasI" target="_blank"><img src="https://s2.loli.net/2021/12/31/dfJ9EokF5tpLasI.jpg" style="width:50%"></a></p><h1 id="去四川"><a href="#去四川" class="headerlink" title="去四川"></a>去四川</h1><p>很长时间没有去旅行了，趁着放假的延长去了一次四川，不仅仅是去找她，还是为完成自己多年的愿望。<br>去了发现自己真的很喜欢四川的生活，饮食风格也好，生活节奏也好，这个城市可能是更适合我的吧<br>第一次一个人的旅行，过程中有时候会觉得自己很孤独，但是自己还是很喜欢这种自由自在的旅行<br>和小朋友过了过简单的二人世界，虽然没有去什么景点，就只是在自己租的民宿一起刷B站，去买菜做饭(虽然翻车了),去就近的电影院看电影，但是确能感到很开心，可能自己就喜欢这种过小日子的感觉吧<br><a href="https://sm.ms/image/QbgVYoi2FWeTkyt" target="_blank"><img src="https://s2.loli.net/2021/12/31/QbgVYoi2FWeTkyt.jpg" style="width:50%"></a><br><a href="https://sm.ms/image/EOaIyociGHZ93Vk" target="_blank"><img src="https://s2.loli.net/2021/12/31/EOaIyociGHZ93Vk.jpg" style="width:50%"></a><br><a href="https://sm.ms/image/6ZnBIAylVDHTFbh" target="_blank"><img src="https://s2.loli.net/2021/12/31/6ZnBIAylVDHTFbh.jpg" style="width:50%"></a><br><a href="https://sm.ms/image/GDEcbOs25CK7LYa" target="_blank"><img src="https://s2.loli.net/2021/12/31/GDEcbOs25CK7LYa.jpg" style="width:50%"></a><br><a href="https://sm.ms/image/ELhwWSACO4js5bo" target="_blank"><img src="https://s2.loli.net/2021/12/31/ELhwWSACO4js5bo.jpg" style="width:50%"></a><br><a href="https://sm.ms/image/PcLiplS8oO6aTEQ" target="_blank"><img src="https://s2.loli.net/2021/12/31/PcLiplS8oO6aTEQ.jpg" style="width:50%"></a></p><h1 id="大二下"><a href="#大二下" class="headerlink" title="大二下"></a>大二下</h1><p>大二下的一年里渐渐习惯晚上喝一两杯再睡觉，也可能是因为自己日常的压力逐渐增大，和其他人的关系也渐渐固化，不愿意去进行多余的交际，晚上总是会莫名其妙的难过，喝两杯，会舒服很多</p><p><a href="https://sm.ms/image/XwqzyhJcQtMIGOT" target="_blank"> <img src="https://s2.loli.net/2021/12/31/XwqzyhJcQtMIGOT.jpg" style="width:50%"></a></p><p>举办校赛，真的很忙很累，这种300+人参加的全校活动是第一次举办，详情转至博客</p><a href="/2021/12/06/thinking1/" title="一些胡思乱想">一些胡思乱想</a><a href="/2021/12/06/thinking1/" title="一些胡思乱想">一些胡思乱想</a><p>秋天的苏大，很美，但是一直是一个人<br><a href="https://sm.ms/image/jPNA9VfO5L1MKxr" target="_blank"><img src="https://s2.loli.net/2021/12/31/jPNA9VfO5L1MKxr.jpg" style="width:50%"></a></p><p>喜欢在学习的时候听爵士。</p><p>拿到了教练员证！</p><p>开始学习怎么写博客，学着记录自己的生活</p><p>认识了加油站，很有意思的音乐社团，大家都和很喜欢音乐，太喜欢那种弹吉他一起唱歌的感觉了</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>一些没用的年度总结</p><table>  <tr>      <td ><center><img src="https://s2.loli.net/2021/12/31/jgQIlwob5YHhnps.jpg" style="width:50%"> </center></td>      <td ><center><img src="https://s2.loli.net/2021/12/31/jheYux8wvbH7iZk.jpg" style="width:70%"> </center></td>  </tr>    <tr>      <td ><center><img src="https://s2.loli.net/2021/12/31/NRKzIqCEX7ktwyB.jpg" style="width:50%"> </center></td>      <td ><center><img src="https://s2.loli.net/2021/12/31/j5hR2guETlsADf7.jpg" style="width:80%"> </center></td>  </tr>    <tr>      <td ><center><img src="https://s2.loli.net/2021/12/31/tQA18sTuNSWyxCZ.jpg" style="width:50%"> </center></td>  </tr></table><p>2021身边的事情发生了太多太多，全球形势也好，网络舆论也好，给人的感觉是这一年负面情绪太多了，以至于现在的人们对于新的一年的期望远远没有之前更高，可能是疫情的原因吧，也可能是逐渐成年的原因，自己已经感觉不到那种跨年的喜悦，对于过年的渴望了，身边的人都在抱怨自己的生活怎样差劲，感觉在大学一年过去了什么都没有发生改变，但仔细一总结还是有很多收获的，有认识新的朋友圈子，有学习新的知识，有完成自己的小小心愿，虽然难过很多，崩溃常有，但是已经都过去了，负面情绪就让他在时间的长河中流逝，能留下来的，才是最珍贵的。</p><p>新的一年，继续加油吧！</p><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://sm.ms/image/ghyrXm5CScL4RJN&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://s2.loli.net/2021/12/31/ghyrXm5CScL4RJN.jpg&quot; &gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是一篇不太正经的年度总结呢！&lt;/p&gt;</summary>
    
    
    
    <category term="年度总结" scheme="http://akkaduilin.com/categories/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="日常" scheme="http://akkaduilin.com/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>最小生成树问题</title>
    <link href="http://akkaduilin.com/2021/12/24/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    <id>http://akkaduilin.com/2021/12/24/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</id>
    <published>2021-12-23T17:16:29.000Z</published>
    <updated>2022-01-08T03:51:05.293Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>实现生成最小生成树的原理和代码</p><p><em>普里姆(Prim)算法</em></p><p><em>克鲁斯卡尔(Kruskal)算法</em></p><span id="more"></span><h1 id="普里姆-Prim-算法"><a href="#普里姆-Prim-算法" class="headerlink" title="普里姆(Prim)算法"></a>普里姆(Prim)算法</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>每次迭代选择代价最小的边对应的点，加入到最小生成树中。算法从某一个顶点s开始，逐渐长大覆盖整个连通网的所有顶点。</p><p><a href="https://sm.ms/image/cJoNn5OkyBbvM1K" target="_blank"><img src="https://s2.loli.net/2021/12/24/cJoNn5OkyBbvM1K.jpg" style="width:80%"></a><br><a href="https://sm.ms/image/r2hfNoOITXntadm" target="_blank"><img src="https://s2.loli.net/2021/12/24/r2hfNoOITXntadm.jpg" style="width:80%"></a></p><h2 id="代码解读"><a href="#代码解读" class="headerlink" title="代码解读"></a>代码解读</h2><p>v表示从哪个结点开始</p><p>用有权的邻接矩阵实现</p><p>若两边不相邻，设为Infinty</p><p>定义两个数组</p><p>adjvex 存储lowcost中对应下标元素是从哪个结点为起点的</p><p>lowcost 中元素意思为现有的存在于最小生成树的结点到此下标结点的最小距离 当值为0时表示此元素以及存在于最小生成树中</p><p>定义函数  MinEdge 寻找lowcost中距离最小的下标 下标带入adjvex中找到结点的值</p><p>当寻找到最小下标时，将此结点写入最小生成树中，并遍历此结点所连接的边，若能到达的结点边权值小于lowcost中储存的，更新</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MaxSize = 10;</span><br><span class="line">const int Infinty = 10000;</span><br><span class="line"></span><br><span class="line">template&lt;typename DataType&gt; </span><br><span class="line">class MGraph&#123;</span><br><span class="line">public:</span><br><span class="line">    MGraph(DataType a[ ],int n, int e);</span><br><span class="line">    ~MGraph()&#123;&#125;;</span><br><span class="line">    void Prim(int v);</span><br><span class="line">    int MinEdge(int lowcost[],int vertexNum);</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    DataType vertex[MaxSize];</span><br><span class="line">    int edge[MaxSize][MaxSize];</span><br><span class="line">    int visited[MaxSize] = &#123;0&#125;;</span><br><span class="line">    int vertexNum,edgeNum;//结点数，边数</span><br><span class="line">    void clear()&#123;</span><br><span class="line">        for(int i=0;i&lt;MaxSize;i++)&#123;</span><br><span class="line">            visited[i] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename DataType&gt; </span><br><span class="line">MGraph&lt;DataType&gt;::MGraph(DataType a[ ],int n, int e)&#123;</span><br><span class="line">    int i,j,k,v;</span><br><span class="line">    vertexNum = n;</span><br><span class="line">    edgeNum = e;</span><br><span class="line">    for(i=0;i&lt;vertexNum;i++)&#123;</span><br><span class="line">        vertex[i] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for(i=0;i&lt;vertexNum;i++)&#123;</span><br><span class="line">        for(j=0;j&lt;vertexNum;j++)&#123;</span><br><span class="line">            edge[i][j] = Infinty;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(k=0;k&lt;edgeNum;k++)&#123;</span><br><span class="line">        cin &gt;&gt; i &gt;&gt; j &gt;&gt; v;</span><br><span class="line">        edge[i][j] = v;</span><br><span class="line">        edge[j][i] = v;</span><br><span class="line">    &#125;</span><br><span class="line">    for(k=0;k&lt;edgeNum;k++)&#123;</span><br><span class="line">        edge[k][k] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">template&lt;typename DataType&gt; </span><br><span class="line">void MGraph&lt;DataType&gt; :: Prim(int v)&#123;</span><br><span class="line">    int i,j,k;</span><br><span class="line">    int adjvex[MaxSize],lowcost[MaxSize];</span><br><span class="line">    // adjvex 存储lowcost中对应下标元素是从哪个结点为起点的</span><br><span class="line">    // lowcost 中元素意思为现有的存在于最小生成树的结点到此下标结点的最小距离</span><br><span class="line">    for( i =0;i&lt;vertexNum;i++)&#123; </span><br><span class="line">        adjvex[i] = v;</span><br><span class="line">        lowcost[i] = edge[v][i];</span><br><span class="line">    &#125;</span><br><span class="line">    // 初始化 adjvex lowcost</span><br><span class="line">    lowcost[v] = 0;</span><br><span class="line">    // lowcost[v] = 0 指下标为v的顶点已经在最小生成树中</span><br><span class="line"></span><br><span class="line">    for(k = 1;k&lt;vertexNum;k++)&#123;</span><br><span class="line">        j = MinEdge(lowcost,vertexNum);//寻找lowcost中最小权值结点的下标</span><br><span class="line">        cout &lt;&lt; adjvex[j] &lt;&lt;&#x27;-&#x27;&lt;&lt; j &lt;&lt;endl;</span><br><span class="line">        lowcost[j] =  0;// 写入最小生成树</span><br><span class="line">        for( i =0;i&lt;vertexNum;i++)&#123;</span><br><span class="line">            if(edge[j][i]&lt;lowcost[i] &amp;&amp; edge[j][i]&gt;0)&#123;</span><br><span class="line">                lowcost[i] = edge[j][i];</span><br><span class="line">                adjvex[i] = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">template&lt;typename DataType&gt; </span><br><span class="line">int MGraph&lt;DataType&gt; ::MinEdge(int lowcost[],int vertexNum)&#123;</span><br><span class="line">    int step = 0;</span><br><span class="line">    for(int j = 0;j&lt;vertexNum;j++)&#123;</span><br><span class="line">        if(lowcost[j]!=0)&#123;</span><br><span class="line">            step = j;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;vertexNum;i++)&#123;</span><br><span class="line">        if(lowcost[i]&lt;lowcost[step] &amp;&amp; lowcost[i]&gt;0)&#123;</span><br><span class="line">            step = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return step;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="克鲁斯卡尔-Kruskal-算法"><a href="#克鲁斯卡尔-Kruskal-算法" class="headerlink" title="克鲁斯卡尔(Kruskal)算法"></a>克鲁斯卡尔(Kruskal)算法</h1><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>先将权值最短的边挑出来，如果这条边两边的结点都已经连通，则跳过，知道最小生成树完成。</p><p><a href="https://sm.ms/image/zkfAPwc4WxG9KqN" target="_blank"><img src="https://s2.loli.net/2021/12/25/zkfAPwc4WxG9KqN.jpg" style="width:80%"></a><br><a href="https://sm.ms/image/nmRqi1F4GUvYocj" target="_blank"><img src="https://s2.loli.net/2021/12/25/nmRqi1F4GUvYocj.jpg" style="width:80%"></a></p><h2 id="代码解读-1"><a href="#代码解读-1" class="headerlink" title="代码解读"></a>代码解读</h2><p>定义边结构Edge出度结点入度结点边的权值</p><p>将邻接矩阵转化为边集数组edges并按权值大小排序</p><p>定义parent数组判断是否形成环</p><p>若parent数组下标所指示的元素不为0，表示此顶点已经在生成树中，所对应的元素值为此下标指向的结点</p><p>Find函数从结点f开始寻找连线顶点的尾部下标</p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">struct Edge&#123;</span><br><span class="line">    int begin;</span><br><span class="line">    int end;</span><br><span class="line">    int weight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void Kruskal(MGraph G)&#123;</span><br><span class="line">    int i,n m;</span><br><span class="line">    Edge edge[MAXEDGE];</span><br><span class="line">    int parent[MAXVEX];</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    此处省略将邻接矩阵G转化为边集数组edges并按权值大小排序代码</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    for(i=0;i&lt;G.vertexNum;i++)&#123;</span><br><span class="line">        parent[i] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    for(i=0;i&lt;G.edgeNum;i++)&#123;</span><br><span class="line">        n = Find(parent,edge[i].begin);</span><br><span class="line">        m = Find(parent,edge[i].end);</span><br><span class="line">        if(m!=n)&#123;</span><br><span class="line">            //  m，n不等，说明此边没有与现有生成树形成环路</span><br><span class="line">            parent[n] = m;</span><br><span class="line">            printf(edge[i].begin,edge[i].end)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Find(int *parent,int f)&#123;</span><br><span class="line">    while( parent[f]&gt;0)&#123;</span><br><span class="line">        f = parent[f];</span><br><span class="line">    &#125;</span><br><span class="line">    return f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;实现生成最小生成树的原理和代码&lt;/p&gt;
&lt;p&gt;&lt;em&gt;普里姆(Prim)算法&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;克鲁斯卡尔(Kruskal)算法&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="http://akkaduilin.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="算法" scheme="http://akkaduilin.com/categories/%E7%BC%96%E7%A8%8B/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="图论" scheme="http://akkaduilin.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="Prim" scheme="http://akkaduilin.com/tags/Prim/"/>
    
    <category term="Kruskal" scheme="http://akkaduilin.com/tags/Kruskal/"/>
    
  </entry>
  
  <entry>
    <title>判断图是否为树/是否成环</title>
    <link href="http://akkaduilin.com/2021/12/22/%E5%88%A4%E6%96%AD%E5%9B%BE%E6%98%AF%E5%90%A6%E4%B8%BA%E6%A0%91-%E6%98%AF%E5%90%A6%E6%88%90%E7%8E%AF/"/>
    <id>http://akkaduilin.com/2021/12/22/%E5%88%A4%E6%96%AD%E5%9B%BE%E6%98%AF%E5%90%A6%E4%B8%BA%E6%A0%91-%E6%98%AF%E5%90%A6%E6%88%90%E7%8E%AF/</id>
    <published>2021-12-21T17:40:22.000Z</published>
    <updated>2022-01-08T03:50:46.657Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>总结一下关于判断图是否成环的问题</p><p>参考博客:<br><a href="https://www.cnblogs.com/wangkundentisy/p/9320499.html">https://www.cnblogs.com/wangkundentisy/p/9320499.html</a><br><a href="https://blog.csdn.net/weixin_45697774/article/details/109528240">https://blog.csdn.net/weixin_45697774/article/details/109528240</a></p><span id="more"></span><h1 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h1><h2 id="利用DFS经行判断"><a href="#利用DFS经行判断" class="headerlink" title="利用DFS经行判断"></a>利用DFS经行判断</h2><ol><li>若在深搜的过程中遇到已经遍历过的边，则为环<br>可以定义visited数组，一个结点对应三种状态<br>x = 0 表示没有被访问过<br>x = 1 表示正在被访问<br>x = 2 表示生成树上的所有的子孙节点都已经访问完</li></ol><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class Graph</span><br><span class="line">&#123;</span><br><span class="line">    public:</span><br><span class="line">    int vertexNum;//顶点个数</span><br><span class="line">    int arcNum;//弧的个数</span><br><span class="line">    int vertex[MAX_NUM];//顶点表</span><br><span class="line">    int arc[MAX_NUM][MAX_NUM];//弧信息表</span><br><span class="line">&#125;;</span><br><span class="line">int visited[MAX_NUM];//顶点访问表</span><br><span class="line">int father[MAX_NUM];//父节点表</span><br><span class="line">void DFS(int v,Graph G)</span><br><span class="line">&#123;</span><br><span class="line">    visited[v] = 1;</span><br><span class="line">    for(int i = 0 ; i &lt; G.vertexNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(i != v &amp;&amp; G.arc[v][i] != INF)//邻接矩阵中节点v的邻接点</span><br><span class="line">        &#123;</span><br><span class="line">            if(visited[i] == 1 &amp;&amp; father[v] != i)//vi不是父节点，而且还访问过(而且为状态1，说明不是回溯过来的顶点)，说明存在环(判断i不是v的父节点)</span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;&quot;图存在环&quot;;</span><br><span class="line">                int temp = v;</span><br><span class="line">                while(temp != i)</span><br><span class="line">                &#123;</span><br><span class="line">                    cout&lt;&lt;temp&lt;&lt;&quot;&lt;-&quot;;//输出环</span><br><span class="line">                    temp = father[temp];</span><br><span class="line">                &#125;</span><br><span class="line">                cout&lt;&lt;temp&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                if(visited[i] == 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    father[i] = v;//更新father数组</span><br><span class="line">                    DFS(i,G);</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[v] = 2;//遍历完所有的邻接点才变为状态2</span><br><span class="line">&#125;</span><br><span class="line">void DFSTraverse(Graph G)</span><br><span class="line">&#123;</span><br><span class="line">    memset(visited,0,sizeof(visited));</span><br><span class="line">    memset(father,-1,sizeof(father));</span><br><span class="line">    for(int i = 0 ; i &lt; G.vertexNum; i++)</span><br><span class="line">        if(!visited[i])</span><br><span class="line">            DFS(i,G);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h1><ol><li>拓扑排序判断是否成环 <a href="/2021/12/22/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/" title="拓扑排序">拓扑排序</a> <a href="/2021/12/22/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/" title="拓扑排序">拓扑排序</a></li></ol><h1 id="是否为树"><a href="#是否为树" class="headerlink" title="是否为树"></a>是否为树</h1><h2 id="无向图-1"><a href="#无向图-1" class="headerlink" title="无向图"></a>无向图</h2><p>对无向图来说，若连通且不成环，则为树<br>可以用定义来判断，即边数=结点数-1，并且在深度遍历整个图后所有边都被遍历过</p><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">int DFTraverse(int v,int edge[MaxSize][MaxSize],int vertexNum)&#123;</span><br><span class="line">    int sum_edge = 0;</span><br><span class="line">    visited[v] = 1;</span><br><span class="line">    for(int j = 0;j&lt;vertexNum;j++)&#123;</span><br><span class="line">        if(edge[v][j] == 1 &amp;&amp; visited[j] == 0) &#123;</span><br><span class="line">            sum_edge = sum_edge + DFTraverse(j,edge,vertexNum) +1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum_edge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void judge_tree(int edge[MaxSize][MaxSize],int vertexNum)</span><br><span class="line">&#123;</span><br><span class="line">    int edge_count = DFTraverse(0,edge,vertexNum);</span><br><span class="line">    int sum_edge = 0;</span><br><span class="line">    int node_count = vertexNum;</span><br><span class="line">    bool flag = true;</span><br><span class="line">    for(int i =0;i&lt;node_count;i++)&#123;</span><br><span class="line">        if(visited[i]==0)&#123;</span><br><span class="line">            flag = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int m =0;m&lt;node_count;m++)&#123;</span><br><span class="line">        for(int n =0;n&lt;node_count;n++)&#123;</span><br><span class="line">            if(edge[m][n]==1)&#123;</span><br><span class="line">                sum_edge++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(edge_count == node_count-1 &amp;&amp; flag &amp;&amp;sum_edge/2==edge_count)&#123;</span><br><span class="line">        cout &lt;&lt; &quot;is tree&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        cout &lt;&lt; &quot;is not tree&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="有向图-1"><a href="#有向图-1" class="headerlink" title="有向图"></a>有向图</h2><ol><li><p>若有一个结点的入度大于1，则不为树</p></li><li><p>同无向图判断成环，不成环为树</p></li></ol><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int Find(int x)</span><br><span class="line">&#123;</span><br><span class="line">    if(fa[x] == x)return x;</span><br><span class="line">    return fa[x] = Find(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool unions(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">    int fx = Find(x);</span><br><span class="line">    int fy = Find(y);</span><br><span class="line">    if(fx != fy)&#123;</span><br><span class="line">        fa[fy] = fx;//注意合并的是原来的点</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;//有环，不是树</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>详细代码见参考博客</p><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;总结一下关于判断图是否成环的问题&lt;/p&gt;
&lt;p&gt;参考博客:&lt;br&gt;&lt;a href=&quot;https://www.cnblogs.com/wangkundentisy/p/9320499.html&quot;&gt;https://www.cnblogs.com/wangkundentisy/p/9320499.html&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_45697774/article/details/109528240&quot;&gt;https://blog.csdn.net/weixin_45697774/article/details/109528240&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="http://akkaduilin.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="题解" scheme="http://akkaduilin.com/categories/%E7%BC%96%E7%A8%8B/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="DFS" scheme="http://akkaduilin.com/tags/DFS/"/>
    
    <category term="图论" scheme="http://akkaduilin.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>骑士周游问题</title>
    <link href="http://akkaduilin.com/2021/12/22/%E9%AA%91%E5%A3%AB%E5%91%A8%E6%B8%B8%E9%97%AE%E9%A2%98/"/>
    <id>http://akkaduilin.com/2021/12/22/%E9%AA%91%E5%A3%AB%E5%91%A8%E6%B8%B8%E9%97%AE%E9%A2%98/</id>
    <published>2021-12-21T17:24:29.000Z</published>
    <updated>2022-01-08T03:49:28.596Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong><br><a href="https://sm.ms/image/QhmFXdajT5IULBN" target="_blank"><img src="https://s2.loli.net/2021/12/25/QhmFXdajT5IULBN.jpg" style="width:50%"></a><br>骑士周游问题 马踏棋盘问题题解<br>还未优化！！</p><span id="more"></span><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>在一个棋盘上，一个棋子“马”（骑士），按照“马走日”的规则，从一个格子出发，走遍所有棋盘格恰好一次，一个这样的走棋序列称为一次“周游”。利用图的搜索算法，给出一个周游序列。</p><h1 id="方法解读"><a href="#方法解读" class="headerlink" title="方法解读"></a>方法解读</h1><p>递归深搜+回溯解决<br>可以使用贪心减少算法时间</p><p>参考博客:<br><a href="https://blog.csdn.net/u011718609/article/details/60873403">https://blog.csdn.net/u011718609/article/details/60873403</a><br><a href="https://www.cnblogs.com/Bone-ACE/p/4531306.html">https://www.cnblogs.com/Bone-ACE/p/4531306.html</a></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int MaxSize = 5;</span><br><span class="line"></span><br><span class="line"> int step_arr[8][2] = &#123;</span><br><span class="line">   &#123;-1,2&#125;,&#123;1,2&#125;,&#123;2,1&#125;,&#123;2,-1&#125;,&#123;1,-2&#125;,&#123;-1,-2&#125;,&#123;-2,-1&#125;,&#123;-2,1&#125;</span><br><span class="line">   &#125;;</span><br><span class="line"> </span><br><span class="line">//可移动的八个方向</span><br><span class="line">int ans_arr[5][5] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">void Dfs(int x, int y, int count,int step[5][5],int * flag)&#123;</span><br><span class="line"></span><br><span class="line">    if(*flag)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;    </span><br><span class="line">    if(count&gt;=25)&#123;</span><br><span class="line">        *flag = 1;</span><br><span class="line">        for(int i=0;i&lt;MaxSize;i++)&#123;</span><br><span class="line">            for(int j=0;j&lt;MaxSize;j++)&#123;</span><br><span class="line">                ans_arr[i][j] = step[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if(x&gt;=0&amp;&amp;x&lt;MaxSize&amp;&amp;y&gt;=0&amp;&amp;y&lt;MaxSize&amp;&amp;step[x][y]==0)&#123;  </span><br><span class="line">        count++;</span><br><span class="line">        step[x][y]=count;</span><br><span class="line">        for(int i=0;i&lt;8;i++)&#123;   </span><br><span class="line">            Dfs(x+step_arr[i][0],y+step_arr[i][1],count,step,flag);  </span><br><span class="line">        &#125;</span><br><span class="line">        step[x][y]=0;//回溯***</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">    int step[5][5] = &#123;0&#125;;</span><br><span class="line">    int x, y,flag = 0;</span><br><span class="line">    Dfs(0,2,0,step,&amp;flag);</span><br><span class="line">    for(int i=0;i&lt;MaxSize;i++)&#123;</span><br><span class="line">        for(int j=0;j&lt;MaxSize;j++)&#123;</span><br><span class="line">            cout &lt;&lt; ans_arr[i][j] &lt;&lt; &#x27; &#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;https://sm.ms/image/QhmFXdajT5IULBN&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://s2.loli.net/2021/12/25/QhmFXdajT5IULBN.jpg&quot; style=&quot;width:50%&quot;&gt;&lt;/a&gt;&lt;br&gt;骑士周游问题 马踏棋盘问题题解&lt;br&gt;还未优化！！&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="http://akkaduilin.com/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="C++" scheme="http://akkaduilin.com/tags/C/"/>
    
    <category term="DFS" scheme="http://akkaduilin.com/tags/DFS/"/>
    
    <category term="动态规划" scheme="http://akkaduilin.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>拓扑排序</title>
    <link href="http://akkaduilin.com/2021/12/22/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    <id>http://akkaduilin.com/2021/12/22/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</id>
    <published>2021-12-21T17:20:11.000Z</published>
    <updated>2022-01-08T03:52:30.321Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>总结一下拓扑排序相关的知识点和代码</p><p><a href="https://sm.ms/image/9cDbKx6CoEXuWkF" target="_blank"><img src="https://s2.loli.net/2021/12/28/9cDbKx6CoEXuWkF.jpg" ></a></p><span id="more"></span><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>拓扑排序是对DAG（有向无环图）上的节点进行排序，使得对于每一条有向边 v -&gt; j ， v 都在 j 之前出现。简单地说，是在不破坏节点先后顺序的前提下，把DAG拉成一条链。如果以游戏中的科技树（虽然名字带树，其实常常不是树而只是DAG）举例，拓扑排序就是找到一种可能的点科技树的顺序。<br>参考文章:<br><a href="https://zhuanlan.zhihu.com/p/260112913">https://zhuanlan.zhihu.com/p/260112913</a></p><h1 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h1><p>从AVO网中选择一个入度为0的顶点输出，然后删除此结点，并删除以此顶点为尾的弧，继续重复此步骤，直到输出全部顶点或者AVO网中不存在入度为0的顶点为止。</p><h1 id="代码解读"><a href="#代码解读" class="headerlink" title="代码解读"></a>代码解读</h1><p>为AVO网建立一个邻接表，并在原基础上增加一个入度域<br>使用栈/队列来存储入度为0的结点<br>栈为深度优先实现<br>队列为广度优先实现<br>最后一步判断是否完成了拓扑排序。</p><p>若图成环，则一定不能构成拓扑排序<br>可以作为判断是否成环的方法之一</p><h1 id="完整代码实现"><a href="#完整代码实现" class="headerlink" title="完整代码实现"></a>完整代码实现</h1><figure class="highlight plaintext"><figcaption><span>[拓扑排序] [lang:C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// edges 邻接矩阵</span><br><span class="line">// deg是入度，在存图的时候需要录入数据</span><br><span class="line">// A是排序后的数组</span><br><span class="line">int deg[MAXN], A[MAXN];</span><br><span class="line">bool toposort(int n)</span><br><span class="line">&#123;</span><br><span class="line">    int cnt = 0;</span><br><span class="line">    queue&lt;int&gt; q;</span><br><span class="line">// 先将本没有入度的结点输入进队列</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i)</span><br><span class="line">        if (deg[i] == 0)</span><br><span class="line">            q.push(i);</span><br><span class="line">    while (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        int t = q.front();</span><br><span class="line">// 输出辅助队列中首位元素，并以此元素为下一次循环的判断准则</span><br><span class="line">        q.pop();</span><br><span class="line">        A[cnt++] = t;</span><br><span class="line">// 遍历上一个排序好的元素行的元素，判断此元素相邻的结点是否符合规则</span><br><span class="line">        for (auto to : edges[t])</span><br><span class="line">        &#123;</span><br><span class="line">            deg[to]--;</span><br><span class="line">            if (deg[to] == 0) // 出现了新的入度为0的点</span><br><span class="line">                q.push(to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return cnt == n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;总结一下拓扑排序相关的知识点和代码&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://sm.ms/image/9cDbKx6CoEXuWkF&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://s2.loli.net/2021/12/28/9cDbKx6CoEXuWkF.jpg&quot; &gt;&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="http://akkaduilin.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="算法" scheme="http://akkaduilin.com/categories/%E7%BC%96%E7%A8%8B/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="图论" scheme="http://akkaduilin.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="排序" scheme="http://akkaduilin.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
    <category term="AOV" scheme="http://akkaduilin.com/tags/AOV/"/>
    
  </entry>
  
  <entry>
    <title>最短路径</title>
    <link href="http://akkaduilin.com/2021/12/22/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    <id>http://akkaduilin.com/2021/12/22/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</id>
    <published>2021-12-21T17:16:50.000Z</published>
    <updated>2022-01-07T17:33:43.748Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>对网来说，最短路径是指两顶点之间经过边上权值之和最少的路径，并且我们称路径上的第一个顶点是源点，最后一个是终点。</p><span id="more"></span><h1 id="迪杰斯特拉-Dijkstra-算法"><a href="#迪杰斯特拉-Dijkstra-算法" class="headerlink" title="迪杰斯特拉(Dijkstra)算法"></a>迪杰斯特拉(Dijkstra)算法</h1><p>参考博客：<br><a href="https://blog.csdn.net/wenqiang1208/article/details/76473984">https://blog.csdn.net/wenqiang1208/article/details/76473984</a></p><p>每次找到离源点最近的一个顶点，然后以该顶点为中心，然后得到源点到其他顶点的最短路径。<br>即一步步求出源点终点之间的顶点的最短路径</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Dijkstra 算法的基本思想是：将顶点集合 V 分成两个集合，一类是生长点的集合 S,包括源点和已经确定最短路径的顶点;另一类是非生长点的集合 V-S,包括所有尚未确定最短路径的顶点,并使用一个待定路径表,存储当前从源点v到每个非生长点v的最短路径。初始时,S只包含源点v,对vi∈V-S,待定路径表为从源点v到v1的有向边。然后在待定路径表中找到当前最短路径v…vk,将vk加入集合S中,对u∈V-S,将路径v…vkvi 与待定路径表中从源点v到vi;的最短路径相比较,取路径长度较小者为当前最短路径。重复上述过程，直到集合 V 中全部顶点加入到集合 S 中。<br>例：<br><a href="https://sm.ms/image/QCkDr4olYhTZUzu" target="_blank"><img src="https://s2.loli.net/2021/12/25/QCkDr4olYhTZUzu.jpg" style="width:50%"></a><br><a href="https://sm.ms/image/S8mTGXwvfHjtNLE" target="_blank"><img src="https://s2.loli.net/2021/12/25/S8mTGXwvfHjtNLE.jpg" style="width:80%"></a></p><h2 id="代码解读"><a href="#代码解读" class="headerlink" title="代码解读"></a>代码解读</h2><p>算法代码从87行开始</p><p>final数组是为了表示v0到某顶点vw是否求得了最短路径，如果有结果，final[w] = 1</p><p>最短路径下标 P<br>用于存储到各点最短路径的权值和 D</p><p>91-96 初始化数据<br>      (<em>D)[v] = G.arc[v0][v];/</em> 将与v0点有连线的顶点加上权值 */<br>      (<em>P)[v] = -1;                /</em> 初始化路径数组P为-1  */</p><p>101-123主循环每次循环求得v0与一个顶点的最小路径，<strong>所以v从1开始</strong></p><p>104-113 循环找到D中最小值，记录为min，并将此顶点计入最短路径中，并以此结点修数组D、P，新路径为min+需要走的路径长度</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">#include &quot;stdio.h&quot;    </span><br><span class="line">#include &quot;stdlib.h&quot;   </span><br><span class="line">#include &quot;io.h&quot;  </span><br><span class="line">#include &quot;math.h&quot;  </span><br><span class="line">#include &quot;time.h&quot;</span><br><span class="line"></span><br><span class="line">#define OK 1</span><br><span class="line">#define ERROR 0</span><br><span class="line">#define TRUE 1</span><br><span class="line">#define FALSE 0</span><br><span class="line"></span><br><span class="line">#define MAXEDGE 20</span><br><span class="line">#define MAXVEX 20</span><br><span class="line">#define GRAPH_INFINITY 65535</span><br><span class="line"></span><br><span class="line">typedef int Status;/* Status是函数的类型,其值是函数结果状态代码，如OK等 */ </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">int vexs[MAXVEX];</span><br><span class="line">int arc[MAXVEX][MAXVEX];</span><br><span class="line">int numVertexes, numEdges;</span><br><span class="line">&#125;MGraph;</span><br><span class="line"></span><br><span class="line">typedef int Patharc[MAXVEX];    /* 用于存储最短路径下标的数组 */</span><br><span class="line">typedef int ShortPathTable[MAXVEX];/* 用于存储到各点最短路径的权值和 */</span><br><span class="line"></span><br><span class="line">/* 构件图 */</span><br><span class="line">void CreateMGraph(MGraph *G)</span><br><span class="line">&#123;</span><br><span class="line">int i, j;</span><br><span class="line"></span><br><span class="line">/* printf(&quot;请输入边数和顶点数:&quot;); */</span><br><span class="line">G-&gt;numEdges=16;</span><br><span class="line">G-&gt;numVertexes=9;</span><br><span class="line"></span><br><span class="line">for (i = 0; i &lt; G-&gt;numVertexes; i++)/* 初始化图 */</span><br><span class="line">&#123;</span><br><span class="line">G-&gt;vexs[i]=i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (i = 0; i &lt; G-&gt;numVertexes; i++)/* 初始化图 */</span><br><span class="line">&#123;</span><br><span class="line">for ( j = 0; j &lt; G-&gt;numVertexes; j++)</span><br><span class="line">&#123;</span><br><span class="line">if (i==j)</span><br><span class="line">G-&gt;arc[i][j]=0;</span><br><span class="line">else</span><br><span class="line">G-&gt;arc[i][j] = G-&gt;arc[j][i] = GRAPH_INFINITY;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">G-&gt;arc[0][1]=1;</span><br><span class="line">G-&gt;arc[0][2]=5; </span><br><span class="line">G-&gt;arc[1][2]=3; </span><br><span class="line">G-&gt;arc[1][3]=7; </span><br><span class="line">G-&gt;arc[1][4]=5; </span><br><span class="line"></span><br><span class="line">G-&gt;arc[2][4]=1; </span><br><span class="line">G-&gt;arc[2][5]=7; </span><br><span class="line">G-&gt;arc[3][4]=2; </span><br><span class="line">G-&gt;arc[3][6]=3; </span><br><span class="line">G-&gt;arc[4][5]=3;</span><br><span class="line"></span><br><span class="line">G-&gt;arc[4][6]=6;</span><br><span class="line">G-&gt;arc[4][7]=9; </span><br><span class="line">G-&gt;arc[5][7]=5; </span><br><span class="line">G-&gt;arc[6][7]=2; </span><br><span class="line">G-&gt;arc[6][8]=7;</span><br><span class="line"></span><br><span class="line">G-&gt;arc[7][8]=4;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for(i = 0; i &lt; G-&gt;numVertexes; i++)</span><br><span class="line">&#123;</span><br><span class="line">for(j = i; j &lt; G-&gt;numVertexes; j++)</span><br><span class="line">&#123;</span><br><span class="line">G-&gt;arc[j][i] =G-&gt;arc[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*  Dijkstra算法，求有向网G的v0顶点到其余顶点v的最短路径P[v]及带权长度D[v] */    </span><br><span class="line">/*  P[v]的值为前驱顶点下标,D[v]表示v0到v的最短路径长度和 */  </span><br><span class="line">void ShortestPath_Dijkstra(MGraph G, int v0, Patharc *P, ShortPathTable *D)</span><br><span class="line">&#123;    </span><br><span class="line">int v,w,k,min;    </span><br><span class="line">int final[MAXVEX];/* final[w]=1表示求得顶点v0至vw的最短路径 */</span><br><span class="line">for(v=0; v&lt;G.numVertexes; v++)    /* 初始化数据 */</span><br><span class="line">&#123;        </span><br><span class="line">final[v] = 0;/* 全部顶点初始化为未知最短路径状态 */</span><br><span class="line">(*D)[v] = G.arc[v0][v];/* 将与v0点有连线的顶点加上权值 */</span><br><span class="line">(*P)[v] = -1;/* 初始化路径数组P为-1  */       </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(*D)[v0] = 0;  /* v0至v0路径为0 */  </span><br><span class="line">final[v0] = 1;    /* v0至v0不需要求路径 */        </span><br><span class="line">/* 开始主循环，每次求得v0到某个v顶点的最短路径 */   </span><br><span class="line">for(v=1; v&lt;G.numVertexes; v++)   </span><br><span class="line">&#123;</span><br><span class="line">min=GRAPH_INFINITY;    /* 当前所知离v0顶点的最近距离 */        </span><br><span class="line">for(w=0; w&lt;G.numVertexes; w++) /* 寻找离v0最近的顶点 */    </span><br><span class="line">&#123;            </span><br><span class="line">if(!final[w] &amp;&amp; (*D)[w]&lt;min)             </span><br><span class="line">&#123;                   </span><br><span class="line">k=w;                    </span><br><span class="line">min = (*D)[w];    /* w顶点离v0顶点更近 */            </span><br><span class="line">&#125;        </span><br><span class="line">&#125;        </span><br><span class="line">final[k] = 1;    /* 将目前找到的最近的顶点置为1 */</span><br><span class="line">for(w=0; w&lt;G.numVertexes; w++) /* 修正当前最短路径及距离 */</span><br><span class="line">&#123;</span><br><span class="line">/* 如果经过v顶点的路径比现在这条路径的长度短的话 */</span><br><span class="line">if(!final[w] &amp;&amp; (min+G.arc[k][w]&lt;(*D)[w]))   </span><br><span class="line">&#123; /*  说明找到了更短的路径，修改D[w]和P[w] */</span><br><span class="line">(*D)[w] = min + G.arc[k][w];  /* 修改当前路径长度 */               </span><br><span class="line">(*P)[w]=k;        </span><br><span class="line">&#125;       </span><br><span class="line">&#125;   </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;   </span><br><span class="line">int i,j,v0;</span><br><span class="line">MGraph G;    </span><br><span class="line">Patharc P;    </span><br><span class="line">ShortPathTable D; /* 求某点到其余各点的最短路径 */   </span><br><span class="line">v0=0;</span><br><span class="line"></span><br><span class="line">CreateMGraph(&amp;G);</span><br><span class="line"></span><br><span class="line">ShortestPath_Dijkstra(G, v0, &amp;P, &amp;D);  </span><br><span class="line"></span><br><span class="line">printf(&quot;最短路径倒序如下:\n&quot;);    </span><br><span class="line">for(i=1;i&lt;G.numVertexes;++i)   </span><br><span class="line">&#123;       </span><br><span class="line">printf(&quot;v%d - v%d : &quot;,v0,i);</span><br><span class="line">j=i;</span><br><span class="line">while(P[j]!=-1)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d &quot;,P[j]);</span><br><span class="line">j=P[j];</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;    </span><br><span class="line">printf(&quot;\n源点到各顶点的最短路径长度为:\n&quot;);  </span><br><span class="line">for(i=1;i&lt;G.numVertexes;++i)        </span><br><span class="line">printf(&quot;v%d - v%d : %d \n&quot;,G.vexs[0],G.vexs[i],D[i]);     </span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="弗洛伊德-Floyd-算法"><a href="#弗洛伊德-Floyd-算法" class="headerlink" title="弗洛伊德(Floyd)算法"></a>弗洛伊德(Floyd)算法</h1><p>参考博客:<br><a href="https://www.cnblogs.com/wangyuliang/p/9216365.html">https://www.cnblogs.com/wangyuliang/p/9216365.html</a></p><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>弗洛伊德（Floyd）算法过程：</p><p>１、用D[v][w]记录每一对顶点的最短距离。</p><p>２、依次扫描每一个点，并以其为基点再遍历所有每一对顶点D[][]的值，看看是否可用过该基点让这对顶点间的距离更小。</p><p>即公式<br>D(n+1)[v][w] = min{D(n)[v][w],D(n)[v][0]+D(n)[0][w]}</p><p><strong>Floyd所求的是所有顶点到所有顶点的最短路径。</strong></p><h2 id="代码解读-1"><a href="#代码解读-1" class="headerlink" title="代码解读"></a>代码解读</h2><p>9-16<br>初始化时数组D为邻接矩阵，数组P为P[i][j] = j</p><p>17-30<br>主循环，k=i时，程序判断以ki为中转点是否有更短的路径，如果有，则修改D[v][w]为新的路径值，并将P[v][w]改为P[v][k]</p><p>34-50<br>输出最小路径代码<br>算法运算完毕时，D[i][j] 表示vi到vj的最短路径权值和,P[i][j] 表示从vi到vj需要经过vP[i][j]</p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">typedef int Patharc[MAXVEX][MAXVEX];</span><br><span class="line">typedef int ShortPathTable[MAXVEX][MAXVEX];</span><br><span class="line"></span><br><span class="line">  /* Floyd算法，求网图G中各顶点v到其余顶点w的最短路径P[v][w]及带权长度D[v][w]。 */    </span><br><span class="line">void ShortestPath_Floyd(MGraph G, Patharc *P, ShortPathTable *D)</span><br><span class="line">&#123;    </span><br><span class="line">int v,w,k;    </span><br><span class="line">for(v=0; v&lt;G.numVertexes; ++v) /* 初始化D与P */  </span><br><span class="line">&#123;        </span><br><span class="line">for(w=0; w&lt;G.numVertexes; ++w)  </span><br><span class="line">&#123;</span><br><span class="line">(*D)[v][w]=G.arc[v][w];/* D[v][w]值即为对应点间的权值 */</span><br><span class="line">(*P)[v][w]=w;/* 初始化P */</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(k=0; k&lt;G.numVertexes; ++k)   </span><br><span class="line">&#123;</span><br><span class="line">for(v=0; v&lt;G.numVertexes; ++v)  </span><br><span class="line">&#123;        </span><br><span class="line">for(w=0; w&lt;G.numVertexes; ++w)    </span><br><span class="line">&#123;</span><br><span class="line">if ((*D)[v][w]&gt;(*D)[v][k]+(*D)[k][w])</span><br><span class="line">&#123;/* 如果经过下标为k顶点路径比原两点间路径更短 */</span><br><span class="line">(*D)[v][w]=(*D)[v][k]+(*D)[k][w];/* 将当前两点间权值设为更小的一个 */</span><br><span class="line">(*P)[v][w]=(*P)[v][k];/* 路径设置为经过下标为k的顶点 */</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  //输出代码</span><br><span class="line">printf(&quot;各顶点间最短路径如下:\n&quot;);    </span><br><span class="line">for(v=0; v&lt;G.numVertexes; ++v)   </span><br><span class="line">&#123;        </span><br><span class="line">for(w=v+1; w&lt;G.numVertexes; w++)  </span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;v%d-v%d weight: %d &quot;,v,w,D[v][w]);</span><br><span class="line">k=P[v][w];/* 获得第一个路径顶点下标 */</span><br><span class="line">printf(&quot; path: %d&quot;,v);/* 打印源点 */</span><br><span class="line">while(k!=w)/* 如果路径顶点下标不是终点 */</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot; -&gt; %d&quot;,k);/* 打印路径顶点 */</span><br><span class="line">k=P[k][w];/* 获得下一个路径顶点下标 */</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot; -&gt; %d\n&quot;,w);/* 打印终点 */</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对网来说，最短路径是指两顶点之间经过边上权值之和最少的路径，并且我们称路径上的第一个顶点是源点，最后一个是终点。&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="http://akkaduilin.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="算法" scheme="http://akkaduilin.com/categories/%E7%BC%96%E7%A8%8B/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="图论" scheme="http://akkaduilin.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="Dijkstra" scheme="http://akkaduilin.com/tags/Dijkstra/"/>
    
    <category term="Floyd" scheme="http://akkaduilin.com/tags/Floyd/"/>
    
    <category term="动态规划" scheme="http://akkaduilin.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>图的相关基础知识</title>
    <link href="http://akkaduilin.com/2021/12/22/%E5%9B%BE%E7%9A%84%E7%9B%B8%E5%85%B3/"/>
    <id>http://akkaduilin.com/2021/12/22/%E5%9B%BE%E7%9A%84%E7%9B%B8%E5%85%B3/</id>
    <published>2021-12-21T17:07:35.000Z</published>
    <updated>2022-01-08T03:50:21.546Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://sm.ms/image/8wFJZCRKifYUsz9" target="_blank"><img src="https://s2.loli.net/2021/12/24/8wFJZCRKifYUsz9.jpg" style="width:70%"></a></p><p><strong>前言</strong><br>整理一下图论相关的基础知识和代码<br>参考博客:<br><a href="https://blog.csdn.net/weixin_37853880/article/details/80320765">https://blog.csdn.net/weixin_37853880/article/details/80320765</a><br><a href="https://www.jianshu.com/p/bce71b2bdbc8">https://www.jianshu.com/p/bce71b2bdbc8</a></p><span id="more"></span><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p><a href="https://sm.ms/image/tuLMcfye9HkTaCx" target="_blank"><img src="https://s2.loli.net/2021/12/24/tuLMcfye9HkTaCx.jpg" style="width:50%"></a></p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>在计算机科学中，一个图就是一些顶点的集合，这些顶点通过一系列边结对（连接）。顶点用圆圈表示，边就是这些圆圈之间的连线。顶点之间通过边连接。</p><p>图有各种形状和大小。边可以有权重（weight），即每一条边会被分配一个正数或者负数值。考虑一个代表航线的图。各个城市就是顶点，航线就是边。那么边的权重可以是飞行时间，或者机票价格。</p><p>树是特殊的图</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ol><li>有向图、无向图</li></ol><p>如果边是有方向的则称为有向图，如果边没有方向则称为无向图</p><ol start="2"><li>简单图</li></ol><p>不含平行边与环的图</p><ol start="3"><li>完全图</li></ol><p><strong>任意两个顶点</strong>之间都存在一条边的简单图</p><p>无向完全图的边数为1/2<em>n</em>(n-1)</p><p>有向完全图的边数为n*(n-1)</p><ol start="4"><li>补图</li></ol><p>将图G补全成为完全图的G’</p><ol start="5"><li>连通图</li></ol><p>只有一个连通分支的图</p><p>强连通图:<br>有向图，任意一对结点相互互达</p><p>弱连通图:<br>有向图，略去方向所得无向图是连通图</p><ol start="6"><li>最大子图</li></ol><p>图所有结点用最少边相连的子图</p><p><a href="https://sm.ms/image/segQfnWRANqyvi4" target="_blank"><img src="https://s2.loli.net/2021/12/24/segQfnWRANqyvi4.jpg" style="width:50%"></a> </p><ol start="7"><li>路/回路</li></ol><p>若顶点vp和vq可以由若干条边连通，则称vp到vq存在一条路径</p><p>无权图的路径长就是路径上经过边数</p><p>带权图的路径长要乘以每条边的权</p><p>简单路径：除了起点和终点可以为同一个顶点外，其余顶点均不相同</p><p>起点和终点为同一个顶点的简单路径称为回路或环</p><ol start="8"><li>权</li></ol><p>与图的边相关的数</p><ol start="9"><li>度</li></ol><p>对于无向图，顶点v的度定义为和v相关联的边数</p><p>对于有向图，顶点v的度分为入度和出度</p><ol start="10"><li>点/边割集</li></ol><p>连通图G</p><p>V1 为G点/边割集</p><p>删除V1集合中所有 结点/边 ，使新的图G’不是连通图 且 删去V1子集所有 结点/边 G’仍为连通图(最大集合)</p><h2 id="矩阵表示"><a href="#矩阵表示" class="headerlink" title="矩阵表示"></a>矩阵表示</h2><p>完全关联矩阵/邻接矩阵/可达性矩阵<br><a href="https://sm.ms/image/POis6Sw3Ap5VBWI" target="_blank"><img src="https://s2.loli.net/2021/12/24/POis6Sw3Ap5VBWI.jpg" style="width:60%"></a> </p><h1 id="储存结构"><a href="#储存结构" class="headerlink" title="储存结构"></a>储存结构</h1><h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><p><a href="https://sm.ms/image/PeyuIZXrlOGpRaU" target="_blank"><img src="https://s2.loli.net/2021/12/24/PeyuIZXrlOGpRaU.jpg" style="width:50%"></a><br><a href="https://sm.ms/image/OB7hrixzskNUe6f" target="_blank"><img src="https://s2.loli.net/2021/12/24/OB7hrixzskNUe6f.jpg" style="width:50%"></a> </p><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">MGraph&lt;DataType&gt;::MGraph(DataType a[ ],int n, int e)&#123;</span><br><span class="line">    int i,j,k;</span><br><span class="line">    vertexNum = n;</span><br><span class="line">    edgeNum = e;</span><br><span class="line">    for(i=0;i&lt;vertexNum;i++)&#123;</span><br><span class="line">        vertex[i] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for(i=0;i&lt;vertexNum;i++)&#123;</span><br><span class="line">        for(j=0;j&lt;vertexNum;j++)&#123;</span><br><span class="line">            edge[i][j] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(k=0;k&lt;edgeNum;k++)&#123;</span><br><span class="line">        cin &gt;&gt; i &gt;&gt; j;</span><br><span class="line">        edge[i][j] = 1;</span><br><span class="line">        edge[j][i] = 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><p><a href="https://sm.ms/image/OyGYE7N8rDxtnF3" target="_blank"><img src="https://s2.loli.net/2021/12/24/OyGYE7N8rDxtnF3.jpg" style="width:50%"></a> </p><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ALGraph&lt;DataType&gt; :: ALGraph(DataType a[ ], int n, int e)&#123;</span><br><span class="line">    int i,j,k;</span><br><span class="line">    EdgeNode* s =nullptr;</span><br><span class="line">    vertexNum = n;</span><br><span class="line">    edgeNum = e;</span><br><span class="line">    for(i = 0;i&lt;vertexNum;i++)&#123;</span><br><span class="line">        adjlist[i].vertex = a[i];</span><br><span class="line">        adjlist[i].firstEdge = nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">    for(k = 0;k&lt;edgeNum;k++)&#123;</span><br><span class="line">        cin &gt;&gt; i &gt;&gt; j;</span><br><span class="line">        s = new EdgeNode;</span><br><span class="line">        s -&gt; next = adjlist[i].firstEdge;</span><br><span class="line">        adjlist[i].firstEdge = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h2><p>顶点表：           </p><p><a href="https://sm.ms/image/LzaYdCybNtjqrES" target="_blank"><img src="https://s2.loli.net/2021/12/24/LzaYdCybNtjqrES.jpg" style="width:50%"></a></p><p>firstin：入边表头指针，指向顶点入边表的第一个节点</p><p>firstout：出边表头指针，指向顶点出边表的第一个节点</p><p>边表：       </p><p><a href="https://sm.ms/image/PVqNWfJEkvwesSH" target="_blank"><img src="https://s2.loli.net/2021/12/24/PVqNWfJEkvwesSH.jpg" style="width:50%"></a> </p><p>tailvex是边起点在顶点表的下标，headvex边终点在顶点表的下标</p><p>headlink入边表指针，指向终点相同的下一条入边；taillink出边表指针，指向起点相同的下一条出边     </p><p><a href="https://sm.ms/image/AGIm63x5eN1vSXg" target="_blank"><img src="https://s2.loli.net/2021/12/24/AGIm63x5eN1vSXg.jpg" ></a>   </p><h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><h2 id="深度优先遍历DFS"><a href="#深度优先遍历DFS" class="headerlink" title="深度优先遍历DFS"></a>深度优先遍历DFS</h2><p>从图G中任选一顶点v作为初始出发点，首先访问出发点v，并将其标记为已访问过；然后依次搜索v的每个邻接点w，若w未曾访问过，则以w作为新的出发点，继续进行深度优先遍历，直到图中所有和v有路径相通的顶点都被访问到；若此时仍有顶点未被访问到（非连通图），则另选一个未访问过的顶点作为起点，重复上述过程，直到图中所有顶点都被访问到为止。</p><p><a href="https://sm.ms/image/cmJ5tTu2UqpICVA" target="_blank"><img src="https://s2.loli.net/2021/12/24/cmJ5tTu2UqpICVA.jpg" style="width:50%"></a> </p><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename DataType&gt; </span><br><span class="line">void MGraph&lt;DataType&gt;::DFTraverse_(int v)&#123;</span><br><span class="line">    cout &lt;&lt; vertex[v] ;</span><br><span class="line">    visited[v] = 1;</span><br><span class="line">    for(int j = 0;j&lt;vertexNum;j++)&#123;</span><br><span class="line">        if(edge[v][j] == 1 &amp;&amp; visited[j] == 0) &#123;</span><br><span class="line">            DFTraverse(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="广度优先遍历BFS"><a href="#广度优先遍历BFS" class="headerlink" title="广度优先遍历BFS"></a>广度优先遍历BFS</h2><p>广度优先搜索是一种按层次遍历的方法，基本思想是：从图G中任选一顶点Vi作为初始出发点，首先访问出发点Vi，接着依次访问Vi的所有未被访问过的邻接点Vi1，Vi2，…，Vit并均标记为已访问过，然后再按照Vi1，Vi2，…，Vit的次序，访问每一个顶点的所有未被访问过的邻接点并均标记为已访问过，依次类推，直到图中所有和Vi有路径相通的顶点都被访问到；若此时仍有顶点未被访问到（非连通图），则另选一个未访问过的顶点作为起点，重复上述过程，直到图中所有顶点都被访问到为止。</p><p><a href="https://sm.ms/image/pRf2EOKCJW8YtoH" target="_blank"><img src="https://s2.loli.net/2021/12/24/pRf2EOKCJW8YtoH.jpg" style="width:50%"></a> </p><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">template&lt;typename DataType&gt; </span><br><span class="line">void MGraph&lt;DataType&gt; :: BFTraverse(int v)&#123;</span><br><span class="line">    clear();</span><br><span class="line">    int w,j,Q[MaxSize];</span><br><span class="line">    int front = -1, rear = -1;</span><br><span class="line">    cout &lt;&lt; vertex[v] ;</span><br><span class="line">    visited[v] = 1;</span><br><span class="line">    Q[++rear] = v;</span><br><span class="line">    while(front != rear)&#123;</span><br><span class="line">        w = Q[++front];</span><br><span class="line">        for(j = 0;j&lt;vertexNum;j++)&#123;</span><br><span class="line">            if(edge[w][j]==1 &amp;&amp; visited[j] == 0)&#123;</span><br><span class="line">                cout &lt;&lt; vertex[j];</span><br><span class="line">                visited[j] = 1;</span><br><span class="line">                Q[++rear] = j;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="邻接矩阵-1"><a href="#邻接矩阵-1" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MaxSize = 10;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">template&lt;typename DataType&gt; </span><br><span class="line">class MGraph&#123;</span><br><span class="line">public:</span><br><span class="line">    MGraph(DataType a[ ],int n, int e);</span><br><span class="line">    ~MGraph()&#123;&#125;;</span><br><span class="line">    void DFTraverse(int v)&#123;</span><br><span class="line">        clear();</span><br><span class="line">        DFTraverse(v);</span><br><span class="line">    &#125;;//深度优点遍历</span><br><span class="line">    void DFTraverse_(int v);</span><br><span class="line">    void BFTraverse(int v);</span><br><span class="line">    void Prim(int v);</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    DataType vertex[MaxSize];</span><br><span class="line">    int edge[MaxSize][MaxSize];</span><br><span class="line">    int visited[MaxSize] = &#123;0&#125;;</span><br><span class="line">    int vertexNum,edgeNum;</span><br><span class="line">    void clear()&#123;</span><br><span class="line">        for(int i=0;i&lt;MaxSize;i++)&#123;</span><br><span class="line">            visited[i] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename DataType&gt; </span><br><span class="line">MGraph&lt;DataType&gt;::MGraph(DataType a[ ],int n, int e)&#123;</span><br><span class="line">    int i,j,k;</span><br><span class="line">    vertexNum = n;</span><br><span class="line">    edgeNum = e;</span><br><span class="line">    for(i=0;i&lt;vertexNum;i++)&#123;</span><br><span class="line">        vertex[i] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for(i=0;i&lt;vertexNum;i++)&#123;</span><br><span class="line">        for(j=0;j&lt;vertexNum;j++)&#123;</span><br><span class="line">            edge[i][j] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(k=0;k&lt;edgeNum;k++)&#123;</span><br><span class="line">        cin &gt;&gt; i &gt;&gt; j;</span><br><span class="line">        edge[i][j] = 1;</span><br><span class="line">        edge[j][i] = 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename DataType&gt; </span><br><span class="line">void MGraph&lt;DataType&gt;::DFTraverse_(int v)&#123;</span><br><span class="line">    cout &lt;&lt; vertex[v] ;</span><br><span class="line">    visited[v] = 1;</span><br><span class="line">    for(int j = 0;j&lt;vertexNum;j++)&#123;</span><br><span class="line">        if(edge[v][j] == 1 &amp;&amp; visited[j] == 0) &#123;</span><br><span class="line">            DFTraverse(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">template&lt;typename DataType&gt; </span><br><span class="line">void MGraph&lt;DataType&gt; :: BFTraverse(int v)&#123;</span><br><span class="line">    clear();</span><br><span class="line">    int w,j,Q[MaxSize];</span><br><span class="line">    int front = -1, rear = -1;</span><br><span class="line">    cout &lt;&lt; vertex[v] ;</span><br><span class="line">    visited[v] = 1;</span><br><span class="line">    Q[++rear] = v;</span><br><span class="line">    while(front != rear)&#123;</span><br><span class="line">        w = Q[++front];</span><br><span class="line">        for(j = 0;j&lt;vertexNum;j++)&#123;</span><br><span class="line">            if(edge[w][j]==1 &amp;&amp; visited[j] == 0)&#123;</span><br><span class="line">                cout &lt;&lt; vertex[j];</span><br><span class="line">                visited[j] = 1;</span><br><span class="line">                Q[++rear] = j;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="邻接表-1"><a href="#邻接表-1" class="headerlink" title="邻接表"></a>邻接表</h2><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MaxSize = 10;</span><br><span class="line">int visited[MaxSize] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">struct EdgeNode</span><br><span class="line">&#123;</span><br><span class="line">    int adjvex;</span><br><span class="line">    EdgeNode* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename DataType&gt; </span><br><span class="line">struct VertexNode</span><br><span class="line">&#123;</span><br><span class="line">    DataType vertex;</span><br><span class="line">    EdgeNode* firstEdge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename DataType&gt; </span><br><span class="line">class ALGraph&#123;</span><br><span class="line">public:</span><br><span class="line">    ALGraph(DataType a[ ], int n, int e);</span><br><span class="line">    ~ALGraph();</span><br><span class="line">    void DFTraverse(int v)&#123;</span><br><span class="line">        clear();</span><br><span class="line">        DFTraverse(v);</span><br><span class="line">    &#125;;//深度优点遍历</span><br><span class="line">    void DFTraverse_(int v);</span><br><span class="line">    void BFTraverse(int v);</span><br><span class="line">    void clear()&#123;</span><br><span class="line">        for(int i=0;i&lt;MaxSize;i++)&#123;</span><br><span class="line">            visited[i] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">private:</span><br><span class="line">    VertexNode&lt;DataType&gt; adjlist[MaxSize];</span><br><span class="line">    int vertexNum, edgeNum;</span><br><span class="line">    int MaxSize = 10;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename DataType&gt; </span><br><span class="line">ALGraph&lt;DataType&gt; :: ALGraph(DataType a[ ], int n, int e)&#123;</span><br><span class="line">    int i,j,k;</span><br><span class="line">    EdgeNode* s =nullptr;</span><br><span class="line">    vertexNum = n;</span><br><span class="line">    edgeNum = e;</span><br><span class="line">    for(i = 0;i&lt;vertexNum;i++)&#123;</span><br><span class="line">        adjlist[i].vertex = a[i];</span><br><span class="line">        adjlist[i].firstEdge = nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">    for(k = 0;k&lt;edgeNum;k++)&#123;</span><br><span class="line">        cin &gt;&gt; i &gt;&gt; j;</span><br><span class="line">        s = new EdgeNode;</span><br><span class="line">        s -&gt; next = adjlist[i].firstEdge;</span><br><span class="line">        adjlist[i].firstEdge = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;       </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">template&lt;typename DataType&gt; </span><br><span class="line">ALGraph&lt;DataType&gt;::~ALGraph()&#123;</span><br><span class="line">    EdgeNode*p = nullptr;</span><br><span class="line">    EdgeNode*q = nullptr;</span><br><span class="line">    for(int i = 0; i&lt;vertexNum; i++)&#123;</span><br><span class="line">        p = q = adjlist[i].firstEdge;</span><br><span class="line">        while(p != nullptr)&#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            delete q;</span><br><span class="line">            q = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">template&lt;typename DataType&gt; </span><br><span class="line">void ALGraph&lt;DataType&gt; :: DFTraverse_(int v)&#123;</span><br><span class="line">    int j;</span><br><span class="line">    EdgeNode *p = nullptr;</span><br><span class="line">    cout &lt;&lt; adjlist[v].vertex;</span><br><span class="line">    visited[v] = 1;</span><br><span class="line">    p = adjlist[v].firstEdge;</span><br><span class="line">    while(p != nullptr)&#123;</span><br><span class="line">        j = p -&gt; adjvex;</span><br><span class="line">        if(visited[j]==0)&#123;</span><br><span class="line">            DFTraverse_(j);</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">template&lt;typename DataType&gt;</span><br><span class="line">void ALGraph&lt;DataType&gt;::BFTraverse(int v)&#123;</span><br><span class="line">    int w,j,Q[MaxSize];</span><br><span class="line">    int front = -1,rear = -1;</span><br><span class="line">    clear();</span><br><span class="line">    EdgeNode *p = nullptr;</span><br><span class="line">    cout &lt;&lt; adjlist[v].vertex;</span><br><span class="line">    visited = 1;</span><br><span class="line">    Q[++rear] = v;</span><br><span class="line">    while(front != rear)&#123;</span><br><span class="line">        w = Q[++front];</span><br><span class="line">        p = adjlist[w].firstEdge;</span><br><span class="line">        while(p != nullptr)&#123;</span><br><span class="line">            j = p-&gt;adjvex;</span><br><span class="line">            if(visited[j] == 0 )&#123;</span><br><span class="line">                cout &lt;&lt; adjlist[j].vertex;</span><br><span class="line">                visited[j] = 1;</span><br><span class="line">                Q[++rear] = j;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><p>最小生成树：在连通网的所有生成树中，所有边的代价和最小的生成树，称为最小生成树。</p><a href="/2021/12/24/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/" title="最小生成树问题">最小生成树问题</a><a href="/2021/12/24/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/" title="最小生成树">最小生成树</a><h1 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h1><p>用于计算一个节点到其他所有节点的最短路径。主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。</p><a href="/2021/12/22/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/" title="最短路径">最短路径</a><a href="/2021/12/22/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/" title="最短路径">最短路径</a><h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><p>拓扑排序是对DAG（有向无环图）上的节点进行排序，使得对于每一条有向边 v -&gt; j ， v 都在 j 之前出现。简单地说，是在不破坏节点先后顺序的前提下，把DAG拉成一条链。如果以游戏中的科技树（虽然名字带树，其实常常不是树而只是DAG）举例，拓扑排序就是找到一种可能的点科技树的顺序。</p><a href="/2021/12/22/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/" title="拓扑排序">拓扑排序</a><a href="/2021/12/22/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/" title="拓扑排序">拓扑排序</a><h1 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h1><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://sm.ms/image/8wFJZCRKifYUsz9&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://s2.loli.net/2021/12/24/8wFJZCRKifYUsz9.jpg&quot; style=&quot;width:70%&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;br&gt;整理一下图论相关的基础知识和代码&lt;br&gt;参考博客:&lt;br&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_37853880/article/details/80320765&quot;&gt;https://blog.csdn.net/weixin_37853880/article/details/80320765&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.jianshu.com/p/bce71b2bdbc8&quot;&gt;https://www.jianshu.com/p/bce71b2bdbc8&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="http://akkaduilin.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="数据结构" scheme="http://akkaduilin.com/categories/%E7%BC%96%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="C++" scheme="http://akkaduilin.com/tags/C/"/>
    
    <category term="DFS" scheme="http://akkaduilin.com/tags/DFS/"/>
    
    <category term="图论" scheme="http://akkaduilin.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="BFS" scheme="http://akkaduilin.com/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>平衡二叉树详解</title>
    <link href="http://akkaduilin.com/2021/12/15/AVL%E6%A0%91/"/>
    <id>http://akkaduilin.com/2021/12/15/AVL%E6%A0%91/</id>
    <published>2021-12-15T09:12:03.000Z</published>
    <updated>2021-12-15T15:27:33.347Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言</strong></p><p>总结一下平衡二叉树 AVL树的一些用法和代码</p><p>引用文章：<br><a href="https://www.cnblogs.com/wasi-991017/p/13824039.html">https://www.cnblogs.com/wasi-991017/p/13824039.html</a></p><p><a href="https://sm.ms/image/Ag1Owom6QxB5c2s" target="_blank"><img src="https://s2.loli.net/2021/12/15/Ag1Owom6QxB5c2s.jpg" alt="RL.jpg"></a></p><span id="more"></span><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>平衡二叉树可以理解为是二叉排序树的优化版本，在二叉排序树的应用过程中会出现子树间深度差距大而导致查找性能下降的情况，所以就有了平衡二叉树这种优化方法。</p><p>可以得出平衡二叉树的定义</p><ol><li><p>基于二叉排序树</p></li><li><p>左右子树的深度之差的绝对值不超过1</p></li><li><p>左右子树都是平衡二叉树</p></li></ol><p>定义平衡因子为本根节点的 左子树深度 - 右子树深度</p><h1 id="关键部分-————-调整方法"><a href="#关键部分-————-调整方法" class="headerlink" title="关键部分 ———— 调整方法"></a>关键部分 ———— 调整方法</h1><h2 id="LL型"><a href="#LL型" class="headerlink" title="LL型"></a>LL型</h2><p>左子树平衡因子 大于 右子树 且 左子树的左子树平衡因子 大于 左子树的右子树平衡因子 ——两个子树也可用<br><img src="https://s2.loli.net/2021/12/15/QKY3xkvubPqNjgJ.jpg" alt="" style="width:100%" /> </p><h2 id="RR型"><a href="#RR型" class="headerlink" title="RR型"></a>RR型</h2><p>右子树平衡因子 大于 左子树 且 右子树的右子树平衡因子 大于 右子树的左子树——两个子树也可用<br><a href="https://sm.ms/image/lZ15qnmcpzQ7uM4" target="_blank"><img src="https://s2.loli.net/2021/12/15/lZ15qnmcpzQ7uM4.jpg" alt="RR.jpg"></a> </p><h2 id="LR型"><a href="#LR型" class="headerlink" title="LR型"></a>LR型</h2><p>左子树平衡因子 大于 右子树 且 左子树的右子树平衡因子 大于 左子树的左子树<br><a href="https://sm.ms/image/nOhJW9jx7ARqTlu" target="_blank"><img src="https://s2.loli.net/2021/12/15/nOhJW9jx7ARqTlu.jpg" alt="LR.jpg"></a></p><h2 id="RL型"><a href="#RL型" class="headerlink" title="RL型"></a>RL型</h2><p>右子树平衡因子 大于 左子树 且 右子树的左子树平衡因子 大于 右子树的右子树<br><a href="https://sm.ms/image/Ag1Owom6QxB5c2s" target="_blank"><img src="https://s2.loli.net/2021/12/15/Ag1Owom6QxB5c2s.jpg" alt="RL.jpg"></a></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>转自：<a href="https://www.cnblogs.com/wasi-991017/p/13824039.html">https://www.cnblogs.com/wasi-991017/p/13824039.html</a></p><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p>124 - 142 排序二叉树的插入操作 插入后做平衡操作者<br>209 - 230 平衡操作 判断情况并调用不同情况函数 LL RR LR RL<br>237 - 271 不同情况对应函数<br>注意旋转操作和插入操作都返回一个根节点(学习！！！)<br>eg：<br>subRoot-&gt;rChild = Insert(subRoot-&gt;rChild, k);</p><p>BalanceFactor() 返回某结点的平衡因子</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br></pre></td><td class="code"><pre><span class="line">/*******平衡二叉树（AVL）***********/</span><br><span class="line">#pragma once</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">///平衡二叉树结点结构</span><br><span class="line">struct AVLNode &#123;</span><br><span class="line">int data;</span><br><span class="line">AVLNode *lChild, *rChild;</span><br><span class="line">AVLNode(int a) &#123;</span><br><span class="line">data = a;</span><br><span class="line">lChild = NULL;</span><br><span class="line">rChild = NULL;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class AVLTree &#123;</span><br><span class="line">public:</span><br><span class="line">AVLTree() &#123;</span><br><span class="line">root = NULL;</span><br><span class="line">&#125;</span><br><span class="line">~AVLTree() &#123;</span><br><span class="line">destroy(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">///从命令行接受数据创建AVL树。使用其他方式创建原理一致</span><br><span class="line">void Create() &#123;</span><br><span class="line">cout &lt;&lt; &quot;input numbers to create AVL: &quot; &lt;&lt; endl;</span><br><span class="line">int temp;</span><br><span class="line">while (cin &gt;&gt; temp) &#123;</span><br><span class="line">root=Insert(root, temp);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; &quot;AVL创建完成！&quot; &lt;&lt; endl;</span><br><span class="line">Print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">///返回某结点为根节点的子树高度</span><br><span class="line">int Height(AVLNode *p) &#123;</span><br><span class="line">if (p == NULL)</span><br><span class="line">return 0;</span><br><span class="line">int i = Height(p-&gt;lChild);</span><br><span class="line">int j = Height(p-&gt;rChild);</span><br><span class="line">return i &gt; j ? i + 1 : j + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">///输出该排序树</span><br><span class="line">void Print() &#123;</span><br><span class="line">cout &lt;&lt; &quot;中序遍历为： &quot;;</span><br><span class="line">MidOrder(root);</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;先序遍历为： &quot;;</span><br><span class="line">PreOrder(root);</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">///先序遍历输出</span><br><span class="line">void PreOrder(AVLNode *p) &#123;</span><br><span class="line">if (p != NULL) &#123;</span><br><span class="line">cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;;</span><br><span class="line">PreOrder(p-&gt;lChild);</span><br><span class="line">PreOrder(p-&gt;rChild);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">///中序遍历输出</span><br><span class="line">void MidOrder(AVLNode *p) &#123;</span><br><span class="line">if (p != NULL) &#123;</span><br><span class="line">MidOrder(p-&gt;lChild);</span><br><span class="line">cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;;</span><br><span class="line">MidOrder(p-&gt;rChild);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">///简化版插入函数</span><br><span class="line">void Insert(const int x) &#123;</span><br><span class="line">root = Insert(root, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">///简化版删除函数</span><br><span class="line">void Remove(int x) &#123;</span><br><span class="line">root=Remove(root, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">///返回值为x的结点指针</span><br><span class="line">AVLNode* Search(int x) &#123;</span><br><span class="line">AVLNode *p = root;</span><br><span class="line">while (p) &#123;</span><br><span class="line">if (p-&gt;data == x)</span><br><span class="line">break;</span><br><span class="line">else if (p-&gt;data &lt; x)</span><br><span class="line">p = p-&gt;rChild;</span><br><span class="line">else</span><br><span class="line">p = p-&gt;lChild;</span><br><span class="line">&#125;</span><br><span class="line">return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">///返回子树最大值结点的指针</span><br><span class="line">AVLNode* TreeMax(AVLNode* subTree) &#123;</span><br><span class="line">if (!subTree)</span><br><span class="line">return NULL;</span><br><span class="line">while (subTree-&gt;rChild) &#123;</span><br><span class="line">subTree = subTree-&gt;rChild;</span><br><span class="line">&#125;</span><br><span class="line">return subTree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">///返回子树最小值结点的指针</span><br><span class="line">AVLNode* TreeMin(AVLNode* subTree) &#123;</span><br><span class="line">if (!subTree)</span><br><span class="line">return NULL;</span><br><span class="line">while (subTree-&gt;lChild) &#123;</span><br><span class="line">subTree = subTree-&gt;lChild;</span><br><span class="line">&#125;</span><br><span class="line">return subTree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">///根节点</span><br><span class="line">AVLNode *root;</span><br><span class="line"></span><br><span class="line">///插入（视为在某结点为根节点的子树上进行插入）</span><br><span class="line">//对子树上进行插入操作后都需要平衡操作，可能会改变该子树的根节点，</span><br><span class="line">//因此设置返回值记录完成操作后子树的根结点指针)</span><br><span class="line">AVLNode* Insert(AVLNode* subRoot, const int k) &#123;</span><br><span class="line">if (subRoot == NULL) &#123;</span><br><span class="line">subRoot = new AVLNode(k);</span><br><span class="line">&#125;</span><br><span class="line">else if (k &gt; subRoot-&gt;data) //需要在右子树上插入新的结点</span><br><span class="line">&#123;</span><br><span class="line">subRoot-&gt;rChild = Insert(subRoot-&gt;rChild, k);</span><br><span class="line">//在右子树上插入结点后可能导致不平衡，故需要对右子树进行平衡操作</span><br><span class="line">//而平衡操作可能会导致子树根结点产生变化，故需更新当前的子树根节点</span><br><span class="line">subRoot = Balancee(subRoot);</span><br><span class="line">&#125;</span><br><span class="line">else if (k &lt; subRoot-&gt;data) &#123; //需要在左子树上插入新的结点</span><br><span class="line">subRoot-&gt;lChild = Insert(subRoot-&gt;lChild, k);</span><br><span class="line">//和上面同理</span><br><span class="line">subRoot = Balancee(subRoot);</span><br><span class="line">&#125;</span><br><span class="line">//将新的子树根结点指针返回供原父节点更新孩子指针</span><br><span class="line">return subRoot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">///删除结点（视为在该结点为根节点的树上进行删除操作）</span><br><span class="line">AVLNode* Remove(AVLNode* subRoot, int x) &#123;</span><br><span class="line">if (!Search(x)) &#123;//不存在x的结点则直接返回</span><br><span class="line">cout &lt;&lt; &quot;不存在值为&quot; &lt;&lt; x &lt;&lt; &quot;的结点！&quot; &lt;&lt; endl;</span><br><span class="line">return root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (!root)  //root为空指针都直接返回NULL</span><br><span class="line">return root;</span><br><span class="line"></span><br><span class="line">if (subRoot-&gt;data == x)  //情况1：要删除的就是该树的根节点</span><br><span class="line">&#123;</span><br><span class="line">if (subRoot-&gt;lChild &amp;&amp; subRoot-&gt;rChild)//情况1.1：该树的左右子树都存在</span><br><span class="line">&#123;</span><br><span class="line">if (BalanceFactor(subRoot)&gt;0) </span><br><span class="line">&#123;</span><br><span class="line">//左子树高于右子树，则根节点的值替换为其直接前驱的值，然后转化为删除</span><br><span class="line">//其直接前驱(其位于左子树上，也就意味着去降低左子树高度)</span><br><span class="line">AVLNode *tmp = TreeMax(subRoot-&gt;lChild); //直接前驱就是左子树的最大值</span><br><span class="line">subRoot-&gt;data = tmp-&gt;data;</span><br><span class="line">//递归调用Remove()删除subRoot的左子树上的前驱结点后，Remove()返回可能为</span><br><span class="line">//新的subRoot的左子树根节点供subRoot更新左孩子结点((Remove()会调用Balance()函数平衡其操作的树))。</span><br><span class="line">subRoot-&gt;lChild = Remove(subRoot-&gt;lChild, tmp-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">//右子树高于左子树，则根节点的值替换为其直接后继的值，</span><br><span class="line">//然后转化为删除其直接后继(其位于右子树上，也就意味着去降低右子树高度)</span><br><span class="line">AVLNode *tmp = TreeMin(subRoot-&gt;rChild);</span><br><span class="line">subRoot-&gt;data = tmp-&gt;data;</span><br><span class="line">subRoot-&gt;rChild = Remove(subRoot-&gt;rChild, tmp-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else //情况1.2：只存在一颗子树或者都不存在</span><br><span class="line">&#123;</span><br><span class="line">//直接将根节点更新为其孩子结点(都不存在则为NULL)</span><br><span class="line">AVLNode * tmp = subRoot;</span><br><span class="line">subRoot = (subRoot-&gt;lChild) ? (subRoot-&gt;lChild) : (subRoot-&gt;rChild);</span><br><span class="line">delete tmp;</span><br><span class="line">tmp = NULL;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else if (x &lt; subRoot-&gt;data) &#123; //情况2：要删除的节点位于左子树上</span><br><span class="line">//递归调用,在subRoot的左子树上进行删除操作，并返回新的左子树根节点供subRoot更新左孩子指针</span><br><span class="line">subRoot-&gt;lChild = Remove(subRoot-&gt;lChild, x);</span><br><span class="line">//在subRoot的左子树上完成删除操作后,可能导致该树不平衡,故需要进行平衡操作并更新当前根节点</span><br><span class="line">if (BalanceFactor(subRoot) &lt; -1)</span><br><span class="line">subRoot = Balancee(root);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;//情况3：要删除的节点位于右子树上</span><br><span class="line">//递归调用,在subRoot的右子树上进行删除操作，并返回新的右子树根节点供subRoot更新右孩子指针</span><br><span class="line">subRoot-&gt;rChild = Remove(subRoot-&gt;rChild, x);</span><br><span class="line">//在subRoot的右子树上完成删除操作后,可能导致该树不平衡,故需要进行平衡操作并更新当前根节点</span><br><span class="line">if (BalanceFactor(subRoot) &gt;1)</span><br><span class="line">subRoot = Balancee(subRoot);</span><br><span class="line">&#125;</span><br><span class="line">//返回该树当前根节点供其父节点更新孩子节点</span><br><span class="line">return subRoot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">///返回某个节点的平衡因子</span><br><span class="line">int BalanceFactor(AVLNode *p) &#123;</span><br><span class="line">return Height(p-&gt;lChild) - Height(p-&gt;rChild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">///对某个结点进行平衡操作（根据平衡因子调用四种不同的旋转操作）</span><br><span class="line">AVLNode* Balancee(AVLNode* subRoot) &#123;</span><br><span class="line">int bf = BalanceFactor(subRoot);</span><br><span class="line">if (bf &gt; 1) //左子树更高</span><br><span class="line">&#123;</span><br><span class="line">if (BalanceFactor(subRoot-&gt;lChild) &gt; 0)</span><br><span class="line">//左孩子结点平衡因子&gt;0说明新节点多在了左子树上，因此调用LL_Rotation</span><br><span class="line">subRoot = LL_Rotation(subRoot);</span><br><span class="line">else</span><br><span class="line">//左孩子结点平衡因子&lt;0说明新节点多在了右子树上，因此调用LR_Rotation</span><br><span class="line">subRoot = LR_Rotation(subRoot);</span><br><span class="line">&#125;</span><br><span class="line">else if (bf &lt; -1) //右子树更高</span><br><span class="line">&#123;</span><br><span class="line">if (BalanceFactor(subRoot-&gt;rChild) &gt; 0)</span><br><span class="line">        //右孩子结点平衡因子&gt;0说明新节点多在了左子树上，因此调用RL_Rotation</span><br><span class="line">subRoot = RL_Rotation(subRoot);</span><br><span class="line">else</span><br><span class="line">    //右孩子结点平衡因子&lt;0说明新节点多在了右子树上上，因此调用RR_Rotation</span><br><span class="line">subRoot = RR_Rotation(subRoot);</span><br><span class="line">&#125;</span><br><span class="line">//对分支结点进行平衡操作后可能会更新该分支节点，故将新的分支结点返回供原父结点更新孩子指针</span><br><span class="line">return subRoot;</span><br><span class="line">&#125;</span><br><span class="line">/*****************************</span><br><span class="line">          四种旋转操作</span><br><span class="line">******************************/</span><br><span class="line">/// LL平衡旋转(右单旋转)</span><br><span class="line">//在左孩子(L)的左子树(L)上插入导致不平衡，需要向右旋转一次实现平衡</span><br><span class="line">AVLNode* LL_Rotation(AVLNode *subRoot) &#123;</span><br><span class="line">AVLNode* temp = subRoot-&gt;lChild;</span><br><span class="line">subRoot-&gt;lChild = temp-&gt;rChild;</span><br><span class="line">temp-&gt;rChild = subRoot;</span><br><span class="line">//完成旋转操作之后，该处分支结点(原为subRoot)发生了变化，</span><br><span class="line">//因此要返回新的分支节点指针供其父节点更新孩子指针</span><br><span class="line">return temp;</span><br><span class="line">&#125;</span><br><span class="line">/// RR平衡旋转(左单旋转)</span><br><span class="line">//在右孩子(R)的右子树(R)上插入导致不平衡，需要向左旋转一次实现平衡</span><br><span class="line">AVLNode* RR_Rotation(AVLNode *subRoot) &#123;</span><br><span class="line">AVLNode* temp = subRoot-&gt;rChild;</span><br><span class="line">subRoot-&gt;rChild = temp-&gt;lChild;</span><br><span class="line">temp-&gt;lChild = subRoot;</span><br><span class="line">//完成旋转操作之后，该处分支结点(原为subRoot)发生了变化，</span><br><span class="line">//因此要返回新的分支节点指针供其父节点更新孩子指针</span><br><span class="line">return temp;</span><br><span class="line">&#125;</span><br><span class="line">/***********下面两种情况可看作是对根节点和子节点进行上两种旋转操作的组合*****************/</span><br><span class="line">/// RL平衡旋转(先右后左双旋转)</span><br><span class="line">//在右孩子(R)的左子树(L)上插入导致不平衡，需要先对分支结点的右孩子进行一次右旋(LL_Rotation),</span><br><span class="line">//再对分支结点进行一次左旋(RR_Rotation)</span><br><span class="line">AVLNode* RL_Rotation(AVLNode *subRoot) &#123;</span><br><span class="line">//对subRoot右孩子结点LL旋转后，更新subRoot右结点指针</span><br><span class="line">subRoot-&gt;rChild=LL_Rotation(subRoot-&gt;rChild);  </span><br><span class="line">return RR_Rotation(subRoot);//返回新的分支结点供原分支节点的父节点更新孩子指针</span><br><span class="line">&#125;</span><br><span class="line">/// LR平衡旋转(先左后右双旋转)</span><br><span class="line">//在左孩子(L)的右子树(R)上插入导致不平衡,需要先对分支结点的左孩子进行一次左旋(RR_Rotation),</span><br><span class="line">//再对分支结点进行一次右旋(LL_Rotation)</span><br><span class="line">AVLNode* LR_Rotation(AVLNode *subRoot) &#123;</span><br><span class="line">//对subRoot左结点RR旋转后，更新subRoot左结点指针</span><br><span class="line">subRoot-&gt; lChild = RR_Rotation(subRoot-&gt;lChild);  </span><br><span class="line">return LL_Rotation(subRoot);//返回新的分支结点供原分支节点的父节点更新孩子指针</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">///销毁该树</span><br><span class="line">void destroy(AVLNode* p) &#123;</span><br><span class="line">if (p) &#123;</span><br><span class="line">destroy(p-&gt;lChild);</span><br><span class="line">destroy(p-&gt;rChild);</span><br><span class="line">delete p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;总结一下平衡二叉树 AVL树的一些用法和代码&lt;/p&gt;
&lt;p&gt;引用文章：&lt;br&gt;&lt;a href=&quot;https://www.cnblogs.com/wasi-991017/p/13824039.html&quot;&gt;https://www.cnblogs.com/wasi-991017/p/13824039.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://sm.ms/image/Ag1Owom6QxB5c2s&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://s2.loli.net/2021/12/15/Ag1Owom6QxB5c2s.jpg&quot; alt=&quot;RL.jpg&quot;&gt;&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="http://akkaduilin.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="算法" scheme="http://akkaduilin.com/categories/%E7%BC%96%E7%A8%8B/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="树" scheme="http://akkaduilin.com/tags/%E6%A0%91/"/>
    
    <category term="查找" scheme="http://akkaduilin.com/tags/%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>树相关知识集合</title>
    <link href="http://akkaduilin.com/2021/12/13/Bitree/"/>
    <id>http://akkaduilin.com/2021/12/13/Bitree/</id>
    <published>2021-12-13T15:57:30.000Z</published>
    <updated>2022-01-08T03:46:59.550Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://sm.ms/image/xrORW4XFJqaLNTo" target="_blank"><img src="https://s2.loli.net/2021/12/15/xrORW4XFJqaLNTo.png" ></a></p><p><strong>前言</strong></p><p>整理一下二叉树的知识点</p><p><em>不定期更新  ︿(￣︶￣)︿</em></p><span id="more"></span><h1 id="二叉树基础"><a href="#二叉树基础" class="headerlink" title="二叉树基础"></a>二叉树基础</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>一棵二叉树是结点的一个有限集合，该集合或者为空，或者是由一个根结点加上两棵分别称为左子树和右子树的、互不相交的二叉树组成。二又树的特点是每个结点最多有两个子女，分别称为该结点的左子女和右子女。在二又树中不存在度大于2的结点，并且二又树的子树有左、右之分，其子树的次序不能颠倒。二又树是分支数最大不超过2的有根有序树。它可能有5种不同的形态。</p><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ol><li>在二叉树的第i层最多有2^(i-1)个结点</li><li>深度为k的二叉树最有2^k - 1 个结点 </li><li>叶子结点数等于度为2的结点数加1</li></ol><h1 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>一棵深度为k的有n个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为i（1≤i≤n）的结点与满二叉树中编号为i的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树。</p><h2 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h2><ol><li><p> 具有n个结点的完全二叉树的深度log2(n+1)</p></li><li><p>如果对一棵有n个结点的完全二叉树的结点按层序编号, 则对任一结点i (1≤i≤n) 有:<br> 如果i=1, 则结点i是二叉树的根, 无双亲;<br> 如果i&gt;1, 则其双亲parent (i) 是结点[i/2].<br> 如果2i&gt;n, 则结点i无左孩子, 否则其左孩子lchild (i) 是结点2i;<br> 如果2i+1&gt;n, 则结点i无右孩子, 否则其右孩子rchild (i) 是结点2i+1.</p></li><li><p>具有n个结点的完全二叉树的深度为log2(n)+1</p></li></ol><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>前中后序非递归<br><a href="https://blog.csdn.net/weixin_45599288/article/details/122345321">https://blog.csdn.net/weixin_45599288/article/details/122345321</a></p><figure class="highlight plaintext"><figcaption><span>[二叉树] [lang:C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template&lt;typename DataType&gt; </span><br><span class="line">struct BiNode</span><br><span class="line">&#123;</span><br><span class="line">    DataType data;</span><br><span class="line">    BiNode&lt;DataType&gt;*lchild, *rchild;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename DataType&gt; </span><br><span class="line">class BiTree&#123;</span><br><span class="line">public:</span><br><span class="line">    BiTree()&#123;root = Creat();&#125;</span><br><span class="line">    BiTree(BiTree&lt;DataType&gt;* b)&#123;</span><br><span class="line">        root = Copy(b-&gt;root);</span><br><span class="line">    &#125;</span><br><span class="line">    ~BiTree()&#123;Release(root);&#125;</span><br><span class="line">    void PreOrder()&#123;PreOrder(root);&#125;</span><br><span class="line">    void InOrder()&#123;InOrder(root);&#125;</span><br><span class="line">    void PostOrder()&#123;PostOrder(root);&#125;</span><br><span class="line">    int Leaf_count()&#123;</span><br><span class="line">        int ans =  Leaf_count(root);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    int Node_count()&#123;</span><br><span class="line">        int ans = Node_count(root);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    int Deep()&#123;</span><br><span class="line">        int ans = Deep(root);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void Judge_sort()&#123;</span><br><span class="line">        if(Judge_sort(root))&#123;</span><br><span class="line">            cout &lt;&lt; &quot;ture&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            cout &lt;&lt; &quot;fales&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void Find_bro(DataType x)&#123;</span><br><span class="line">        find_bro(root,x);</span><br><span class="line">    &#125;</span><br><span class="line">    bool Empty()&#123;</span><br><span class="line">        if(root == nullptr)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void insert(DataType insert_data, DataType step_data)&#123;</span><br><span class="line">        insert(root,insert_data, step_data);</span><br><span class="line">    &#125;</span><br><span class="line">    void LevelOrder();//层序遍历</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    int flag = 0;</span><br><span class="line">    BiNode&lt;DataType&gt;* root;</span><br><span class="line">    BiNode&lt;DataType&gt;* Creat();</span><br><span class="line">    BiNode&lt;DataType&gt;* Copy(BiNode&lt;DataType&gt;* node);</span><br><span class="line">    int Leaf_count(BiNode&lt;DataType&gt;* node);//计算叶子结点数</span><br><span class="line">    int Node_count(BiNode&lt;DataType&gt;* node);//计算结点数</span><br><span class="line">    int Deep(BiNode&lt;DataType&gt;* node);//计算深度</span><br><span class="line">    void Release(BiNode&lt;DataType&gt;* node);//析构函数</span><br><span class="line">    void PreOrder(BiNode&lt;DataType&gt;* node);//前序遍历</span><br><span class="line">    void InOrder(BiNode&lt;DataType&gt;* node);//中序遍历</span><br><span class="line">    void PostOrder(BiNode&lt;DataType&gt;* node);//后序遍历</span><br><span class="line">    void find_bro(BiNode&lt;DataType&gt;* node,DataType x);</span><br><span class="line">    bool Judge_sort(BiNode&lt;DataType&gt;* node);</span><br><span class="line">    </span><br><span class="line">    void inorDer();//非递归遍历</span><br><span class="line">    void insert(BiNode&lt;DataType&gt;* root, DataType insert_data, DataType step_data);//在指定值之后插入</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename DataType&gt; </span><br><span class="line">BiNode&lt;DataType&gt;* BiTree&lt;DataType&gt;::Creat()&#123;</span><br><span class="line">    BiNode&lt;DataType&gt;* node;</span><br><span class="line">    char cin_data;</span><br><span class="line">    cin &gt;&gt; cin_data;</span><br><span class="line">    //cin_data = my_data[i++];</span><br><span class="line">    if(cin_data==&#x27;#&#x27;)&#123;</span><br><span class="line">        node = nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        node = new BiNode&lt;DataType&gt;;</span><br><span class="line">        node-&gt;data = cin_data;</span><br><span class="line">        node-&gt;lchild = Creat();//左递归建造子树</span><br><span class="line">        node-&gt;rchild = Creat();//右递归建造子树</span><br><span class="line">    &#125;</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename DataType&gt; </span><br><span class="line">BiNode&lt;DataType&gt;* BiTree&lt;DataType&gt;::Copy(BiNode&lt;DataType&gt;* node)&#123;</span><br><span class="line">    if(node == nullptr)&#123;</span><br><span class="line">        return nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">    BiNode&lt;DataType&gt;* copy_node ;</span><br><span class="line">    copy_node-&gt;data = node-&gt;data;</span><br><span class="line">    copy_node-&gt;lchild = Copy(node-&gt;lchild);</span><br><span class="line">    copy_node-&gt;rchild = Copy(node-&gt;rchild);</span><br><span class="line">    return copy_node;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename DataType&gt; </span><br><span class="line">int BiTree&lt;DataType&gt;::Leaf_count(BiNode&lt;DataType&gt;* node)&#123;</span><br><span class="line">    int count ;</span><br><span class="line">    if(node == nullptr)&#123;</span><br><span class="line">        count = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(node-&gt;lchild == nullptr &amp;&amp; node-&gt;rchild == nullptr)&#123;</span><br><span class="line">        count = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        count = Leaf_count(node-&gt;lchild) + Leaf_count(node-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename DataType&gt; </span><br><span class="line">int BiTree&lt;DataType&gt;::Node_count(BiNode&lt;DataType&gt;* node)&#123;</span><br><span class="line">    int count ;</span><br><span class="line">    if(node == nullptr) count = 0;</span><br><span class="line">    else&#123;</span><br><span class="line">        count = Node_count(node-&gt;lchild) + Node_count(node-&gt;rchild) +1;</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename DataType&gt;</span><br><span class="line">int BiTree&lt;DataType&gt;::Deep(BiNode&lt;DataType&gt;* node)&#123;</span><br><span class="line">    int deep=0;</span><br><span class="line">    if(node)</span><br><span class="line">    &#123;</span><br><span class="line">        int leftdeep=Deep(node-&gt;lchild);</span><br><span class="line">        int rightdeep=Deep(node-&gt;rchild);</span><br><span class="line">        deep = leftdeep&gt;=rightdeep?leftdeep+1:rightdeep+1;</span><br><span class="line">    &#125;</span><br><span class="line">    return deep;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename DataType&gt; </span><br><span class="line">void BiTree&lt;DataType&gt;::Release(BiNode&lt;DataType&gt;* node)&#123;</span><br><span class="line">    if(node == nullptr) return;</span><br><span class="line">    else&#123;</span><br><span class="line">        Release(node-&gt;lchild);</span><br><span class="line">        Release(node-&gt;rchild);</span><br><span class="line">        delete node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename DataType&gt; </span><br><span class="line">void BiTree&lt;DataType&gt;::PreOrder(BiNode&lt;DataType&gt;* node)&#123;</span><br><span class="line">    if(node == nullptr) return;</span><br><span class="line">    else&#123;</span><br><span class="line">        cout &lt;&lt; node-&gt;data&lt;&lt;&#x27; &#x27;;</span><br><span class="line">        PreOrder(node-&gt;lchild);</span><br><span class="line">        PreOrder(node-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename DataType&gt; </span><br><span class="line">void BiTree&lt;DataType&gt;::InOrder(BiNode&lt;DataType&gt;* node)&#123;</span><br><span class="line">    if(node == nullptr) return;</span><br><span class="line">    else&#123;</span><br><span class="line">        </span><br><span class="line">        InOrder(node-&gt;lchild);</span><br><span class="line">        cout &lt;&lt; node-&gt;data&lt;&lt;&#x27; &#x27;;</span><br><span class="line">        InOrder(node-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename DataType&gt; </span><br><span class="line">void BiTree&lt;DataType&gt;::PostOrder(BiNode&lt;DataType&gt;* node)&#123;</span><br><span class="line">    if(node == nullptr) return;</span><br><span class="line">    else&#123;</span><br><span class="line">        </span><br><span class="line">        PostOrder(node-&gt;lchild);</span><br><span class="line">        PostOrder(node-&gt;rchild);</span><br><span class="line">        cout &lt;&lt; node-&gt;data&lt;&lt;&#x27; &#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename DataType&gt; </span><br><span class="line">bool BiTree&lt;DataType&gt;::Judge_sort(BiNode&lt;DataType&gt;* node)&#123;</span><br><span class="line">     if(!node || (!(node-&gt;lchild)&amp;&amp;!(node-&gt;rchild)))             </span><br><span class="line">        return true;</span><br><span class="line">    else if((node-&gt;lchild)&amp;&amp;!(node-&gt;rchild))&#123;  </span><br><span class="line">        if(node-&gt;lchild-&gt;data&gt;node-&gt;data)</span><br><span class="line">            return false;</span><br><span class="line">        else</span><br><span class="line">            return Judge_sort(node-&gt;lchild);</span><br><span class="line">    &#125;</span><br><span class="line">    else if((node-&gt;rchild)&amp;&amp;!(node-&gt;lchild))&#123;  </span><br><span class="line">        if(node-&gt;rchild-&gt;data&lt;node-&gt;data)</span><br><span class="line">            return false;</span><br><span class="line">        else</span><br><span class="line">            return Judge_sort(node-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;                           </span><br><span class="line">        if((node-&gt;lchild-&gt;data &gt; node-&gt;data) || (node-&gt;rchild-&gt;data &lt; node-&gt;data))</span><br><span class="line">            return false;</span><br><span class="line">        else</span><br><span class="line">            return (Judge_sort(node-&gt;lchild) &amp;&amp; Judge_sort(node-&gt;rchild));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename DataType&gt; </span><br><span class="line">void BiTree&lt;DataType&gt;::find_bro(BiNode&lt;DataType&gt;* node,DataType x)&#123;</span><br><span class="line">    if(node == nullptr) return;</span><br><span class="line">    else&#123;</span><br><span class="line">        if(node-&gt;lchild!=nullptr&amp;&amp;node-&gt;rchild!=nullptr)&#123;</span><br><span class="line">            if(node-&gt;lchild-&gt;data==x)&#123;</span><br><span class="line">                BiNode&lt;DataType&gt;* r = node-&gt;rchild;</span><br><span class="line">                cout &lt;&lt; r-&gt;data &lt;&lt; &quot;---&quot;&lt;&lt;r &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(node-&gt;rchild-&gt;data==x)&#123;</span><br><span class="line">               BiNode&lt;DataType&gt;* l = node-&gt;lchild;</span><br><span class="line">                cout &lt;&lt; l-&gt;data &lt;&lt; &quot;---&quot;&lt;&lt;l &lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        find_bro(node-&gt;lchild,x);</span><br><span class="line">        find_bro(node-&gt;rchild,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename DataType&gt;</span><br><span class="line">void BiTree&lt;DataType&gt;::LevelOrder()&#123;</span><br><span class="line">BiNode&lt;DataType&gt;*Q[100],*q=nullptr;</span><br><span class="line">int front = -1,rear = -1;</span><br><span class="line">if(root == nullptr)return;</span><br><span class="line">Q[++rear] = root;</span><br><span class="line">while(front!=rear)&#123;</span><br><span class="line">q = Q[++front];</span><br><span class="line">cout&lt;&lt;q-&gt;data&lt;&lt;&quot; &quot;;</span><br><span class="line">if(q-&gt;lchild != nullptr) Q[++rear] = q-&gt;lchild;</span><br><span class="line">if(q-&gt;rchild != nullptr) Q[++rear] = q-&gt;rchild;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename DataType&gt;</span><br><span class="line">void BiTree&lt;DataType&gt;::inorDer()&#123;</span><br><span class="line">if(root != nullptr)&#123;</span><br><span class="line">stack&lt;BiNode&lt;DataType&gt;*&gt; s;</span><br><span class="line">BiNode&lt;DataType&gt;*p = root;</span><br><span class="line">while(!s.empty() || p !=nullptr)&#123;</span><br><span class="line">while( p!= nullptr)&#123;</span><br><span class="line">s.push(p);</span><br><span class="line">p = p-&gt;lchild;</span><br><span class="line">&#125;</span><br><span class="line">if(!s.Empty())&#123;</span><br><span class="line">p = s.pop();</span><br><span class="line">cout &lt;&lt; p-&gt;data;</span><br><span class="line">p = p-&gt;rchild;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename DataType&gt;</span><br><span class="line">void BiTree&lt;DataType&gt;::insert(BiNode&lt;DataType&gt;* node, DataType insert_data, DataType step_data)&#123;</span><br><span class="line">        if(node == nullptr) return;</span><br><span class="line">    else&#123;</span><br><span class="line">        if(node-&gt;data == step_data)&#123;</span><br><span class="line">            BiNode&lt;DataType&gt;* node1;</span><br><span class="line">            BiNode&lt;DataType&gt;* node2;</span><br><span class="line">            //cout &lt;&lt; 233;</span><br><span class="line">            node1 = node-&gt;lchild;</span><br><span class="line">            </span><br><span class="line">            node2-&gt;data = insert_data;</span><br><span class="line">            node2-&gt;lchild = node1;</span><br><span class="line">            node2-&gt;rchild = nullptr;</span><br><span class="line">            node-&gt;lchild = node2;</span><br><span class="line">            </span><br><span class="line">           </span><br><span class="line">            //return;</span><br><span class="line">        &#125;</span><br><span class="line">        //cout &lt;&lt; node-&gt;data&lt;&lt;&#x27; &#x27;;</span><br><span class="line">        insert(node-&gt;lchild,insert_data,step_data);</span><br><span class="line">        insert(node-&gt;rchild,insert_data,step_data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="森林-二叉树互换"><a href="#森林-二叉树互换" class="headerlink" title="森林/二叉树互换"></a>森林/二叉树互换</h1><h2 id="树-gt-二叉树"><a href="#树-gt-二叉树" class="headerlink" title="树 -&gt;二叉树"></a>树 -&gt;二叉树</h2><ol><li>加线<br>在所有兄弟间加连线</li><li>去线<br>对树中每个结点，保留它与第一个孩子结点的连线</li><li>层次调整<br><a href="https://sm.ms/image/zSFrsZubHTy3gk6" target="_blank"><img src="https://s2.loli.net/2021/12/15/zSFrsZubHTy3gk6.jpg" ></a></li></ol><h2 id="二叉树-gt-树"><a href="#二叉树-gt-树" class="headerlink" title="二叉树 -&gt;树"></a>二叉树 -&gt;树</h2><ol><li>加线<br>若某结点左孩子存在，将次左孩子的n个右孩子结点等作为此结点的孩子连线</li><li>去线<br>删除原二叉树中所有结点与其右孩子的连线</li><li>调整层次<br><a href="https://sm.ms/image/XxcBefKZyNmoE81" target="_blank"><img src="https://s2.loli.net/2021/12/15/XxcBefKZyNmoE81.jpg" ></a></li></ol><h2 id="森林-gt-二叉树"><a href="#森林-gt-二叉树" class="headerlink" title="森林 -&gt; 二叉树"></a>森林 -&gt; 二叉树</h2><ol><li><p>将每个树转化为二叉树  </p></li><li><p>第一棵二叉树不动，从第二棵开始，依次把后一棵二叉树的根节点作为前一棵二叉树根节点的右孩子，连接<br><a href="https://sm.ms/image/RdUKizQjAZrnMph" target="_blank"><img src="https://s2.loli.net/2021/12/15/RdUKizQjAZrnMph.jpg" ></a></p></li></ol><h2 id="二叉树-gt-森林"><a href="#二叉树-gt-森林" class="headerlink" title="二叉树 -&gt; 森林"></a>二叉树 -&gt; 森林</h2><ol><li><p>从根节点开始若右孩子存在，则将其与右孩子的连线删除。 </p></li><li><p>对每一个分离后的二叉树，重复步骤1</p></li><li><p>再将分离后的二叉树转为树<br><a href="https://sm.ms/image/zqXHDlR62ZY5xiV" target="_blank"><img src="https://s2.loli.net/2021/12/15/zqXHDlR62ZY5xiV.jpg" ></a></p></li></ol><h1 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h1><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><p>一棵空树，或者是具有下列性质的二叉树：</p><ol><li>若左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>左、右子树也分别为二叉排序树；</li><li>没有键值相等的结点。</li></ol><img src="https://bkimg.cdn.bcebos.com/pic/94cad1c8a786c9179df9bed6c93d70cf3ac75763?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U4MA==,g_7,xp_5,yp_5/format,f_auto" alt="" style="width:100%" />  <h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h3 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h3><ol><li>若根结点的关键字值等于查找的关键字，成功。</li><li>否则，若小于根结点的关键字值，递归查左子树。</li><li>若大于根结点的关键字值，递归查右子树。</li><li>若子树为空，查找不成功。</li></ol><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>每个结点的C(i)为该结点的层次数。最坏情况下，当先后插入的关键字有序时，构成的二叉排序树蜕变为单支树，树的深度为其平均查找长度(n+1)/2(和顺序查找相同），最好的情况是二叉排序树的形态和折半查找的判定树相同，其平均查找长度和log 2 (n)成正比。<br>也就是说，最好情况下的算法时间复杂度为O(1)，最坏情况下的算法时间复杂度为O(n)。</p><h1 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h1><h2 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h2><p>平衡二叉查找树：简称平衡二叉树。由前苏联的数学家 Adelse-Velskil 和 Landis 在 1962 年提出的高度平衡的二叉树，根据科学家的英文名也称为 AVL 树。它具有如下几个性质：</p><ol><li>可以是空树。</li><li>假如不是空树，任何一个结点的左子树与右子树都是平衡二叉树，并且高度之差的绝对值不超过 1。</li></ol><h2 id="平衡二叉树调整"><a href="#平衡二叉树调整" class="headerlink" title="平衡二叉树调整"></a>平衡二叉树调整</h2><p>引用：<br><a href="https://www.cnblogs.com/zhangbaochong/p/5164994.html">https://www.cnblogs.com/zhangbaochong/p/5164994.html</a></p><ol><li>单旋转<img src="https://images2015.cnblogs.com/blog/805461/201601/805461-20160127220751410-639565779.jpg" alt="" style="width:100%" /> k2结点不满足平衡性，它的左子树k1比右子树z深两层，k1子树中更深的是k1的左子树x，因此属于左左情况。</li></ol><p>为了恢复平衡，我们把x上移一层，并把z下移一层，但此时实际已经超出了AVL树的性质要求。为此，重新安排结点以形成一颗等价的树。为使树恢复平衡，我们把k2变成这棵树的根节点，因为k2大于k1，把k2置于k1的右子树上，而原本在k1右子树的Y大于k1，小于k2，就把Y置于k2的左子树上，这样既满足了二叉查找树的性质，又满足了平衡二叉树的性质。</p><ol start="2"><li>双旋转<img src="https://images2015.cnblogs.com/blog/805461/201601/805461-20160127221858707-881408395.jpg" alt="" style="width:100%" /> 对于上图情况，为使树恢复平衡，我们需要进行两步，第一步，把k1作为根，进行一次右右旋转，旋转之后就变成了左左情况，所以第二步再进行一次左左旋转，最后得到了一棵以k2为根的平衡二叉树。</li></ol><h1 id="最大二叉树"><a href="#最大二叉树" class="headerlink" title="最大二叉树"></a>最大二叉树</h1><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>给定一个不含重复元素的整数数组 nums 。一个以此数组直接递归构建的 最大二叉树 定义如下：</p><ol><li>二叉树的根是数组 nums 中的最大元素。</li><li>左子树是通过数组中 最大值左边部分 递归构造出的最大二叉树。</li><li>右子树是通过数组中 最大值右边部分 递归构造出的最大二叉树。</li></ol><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/maximum-binary-tree">https://leetcode-cn.com/problems/maximum-binary-tree</a></p><img src="https://img-blog.csdnimg.cn/20210612003134409.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80ODI3NjI5OA==,size_16,color_FFFFFF,t_70>" alt="" style="width:100%" /> <h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight plaintext"><figcaption><span>[最大二叉树] [lang:C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void max_BiTree(int first,int max_index,int last)&#123;</span><br><span class="line">    int max_l = first,max_r = last-1;</span><br><span class="line">    if(first == last)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=first;i&lt;max_index;i++)&#123;</span><br><span class="line">        if(arr1[i]&gt;arr1[max_l])&#123;</span><br><span class="line">            max_l = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int j=max_index+1;j&lt;last;j++)&#123;</span><br><span class="line">        if(arr1[j]&gt;arr1[max_r])&#123;</span><br><span class="line">            max_r = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; arr1[max_index]&lt;&lt;&#x27; &#x27;;</span><br><span class="line">    max_BiTree(first,max_l,max_index);</span><br><span class="line">    max_BiTree(max_index+1,max_r,last);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h1><h2 id="定义与原理"><a href="#定义与原理" class="headerlink" title="定义与原理"></a>定义与原理</h2><p>给定N个权值作为N个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。</p><p>参考博客：<br><a href="http://c.biancheng.net/view/3398.html">http://c.biancheng.net/view/3398.html</a><br><a href="https://blog.csdn.net/Mr_GYF/article/details/121707714?utm_source=app&amp;app_version=4.20.0">https://blog.csdn.net/Mr_GYF/article/details/121707714?utm_source=app&amp;app_version=4.20.0</a></p><h2 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h2><h1 id=""><a href="#" class="headerlink" title=""></a></h1><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://sm.ms/image/xrORW4XFJqaLNTo&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://s2.loli.net/2021/12/15/xrORW4XFJqaLNTo.png&quot; &gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;整理一下二叉树的知识点&lt;/p&gt;
&lt;p&gt;&lt;em&gt;不定期更新  ︿(￣︶￣)︿&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="http://akkaduilin.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="数据结构" scheme="http://akkaduilin.com/categories/%E7%BC%96%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="树" scheme="http://akkaduilin.com/tags/%E6%A0%91/"/>
    
    <category term="C++" scheme="http://akkaduilin.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>一些胡思乱想</title>
    <link href="http://akkaduilin.com/2021/12/06/thinking1/"/>
    <id>http://akkaduilin.com/2021/12/06/thinking1/</id>
    <published>2021-12-05T16:46:26.000Z</published>
    <updated>2022-01-25T15:22:48.155Z</updated>
    
    <content type="html"><![CDATA[<img src="https://cdn.pixabay.com/photo/2016/05/06/01/22/couple-1375125_960_720.jpg" alt="" style="width:100%" />  <p><strong>前言</strong></p><p><strong>属于是不知道最近想了些什么一一列举出来记录一下吧</strong></p><p><strong>深夜emo警告！！！</strong></p><p><strong>一切的一切仅为个人观点，瞎想的，别认真</strong></p><span id="more"></span><h1 id="网上乱七八糟杂谈"><a href="#网上乱七八糟杂谈" class="headerlink" title="网上乱七八糟杂谈"></a>网上乱七八糟杂谈</h1><h2 id="2021-12-5"><a href="#2021-12-5" class="headerlink" title="2021.12.5"></a>2021.12.5</h2><p>感觉近几年有关于“女拳”的事情是越演越烈了啊，最开始也就是当看个热闹，不想深入，但现在出什么事情大家好像都在莫名其妙的往女权这条路上引啊。。。但还是觉得有些事情和女性有但没有到关于女性社会地位的地步，在我看来，小红楼事件关乎的是更深的道德层面的恶劣，这种事情发生的本质难道不是这种不应存在经济链条的问题吗。这已经不是关于女性社会地位的问题了，这是上升到国家法律法治的重大案件，在这个案例中，无辜的女性成为的是被摆布的棋子，这种迫害女性的想法是自古以来人类留存的难以改变的观点，我很反感大家还称现在的社会为男权社会，但我承认现在还是女性弱势的时代，这种情况不止是因为我们个人的意愿所导致的。我们不得不承认大部分情况下在社会取得令人铭记的成就时男性的功劳远远超过女性，这种人类社会天生存有的仰慕高能力的想法导致大家会忘记女性在社会中的重要性，我不知道怎么样改变这种情况，但我觉得社会已经在尽可能的改变了。我们不能因为某些道德恶劣的人的行经就上升到全社会。此处引用空间流传很广的说说中一句话<br><em>不论你是哪个阶层的女性，这是一个男性可以指认任何女性为妓女的时代！这是一个男性可以强迫女性然后指认她为妓女的时代！这是一个受害女性不敢站出来的时代！</em><br>这种言论在我看来和不理智的引战言论并无二样，我不知道这种情况越演越烈会造成什么，但我相信的是这种情况会让社会中的矛盾更加突出，使两性的问题更加得不到解决。还是希望大家可以理智对待事情，只能说现在这个社会不可能成为我们想象中的完美世界，总会有形形色色的人一次次干令人愤怒的事情，刷新自己的世界观，对于这种人，强烈批判，审视自我，不要因为垃圾的恶臭而腐败自己的心智才为最重要。</p><h2 id="2021-12-7"><a href="#2021-12-7" class="headerlink" title="2021.12.7"></a>2021.12.7</h2><p>今天突然发现身边的人好像很少有谈恋爱的了，无论是生活压力的剧增还是“女拳”盛行的结果，我能感觉到现在的年轻一代在渐渐远离真正的爱情，抛开爱情过后的生育等问题不谈，现在的年轻人很少有心思去认真开启一段感情了，这可能也是我自己坚持异地这么久的原因之一吧。未来，两性间那种只为上床的快餐感情会不会越来越多呢？我们这一代本就大部分都是独生子女，比起其他年代的人同龄间亲密的关系本就少，缺爱的我们可能只会越来越难受孤僻吧。</p><img src="https://cdn.pixabay.com/photo/2021/09/25/12/52/boho-art-6654957_960_720.jpg" alt="" style="width:50%" />  <h2 id="2021-12-20"><a href="#2021-12-20" class="headerlink" title="2021.12.20"></a>2021.12.20</h2><p>发现今年一年娱乐圈爆出来的瓜也太多了了吧，这种频率真的让人怀疑真的是纸包不住火了吗，还是有资本另有企图？<br>第一点显然是最有可能的，比起之前娱乐圈恶臭的新闻没能出现在大众的视野中很大一部分是大家的信息传播没有那么广泛，而且和现在社会中女性敢于向大家发出自己的处境有关。这是头顶头的好事，希望社会中受欺压的人们都可以将那黑暗的一面曝光出来，让我们醒悟，现在的社会问题还是很多，作为一个成年人，我们不能像小朋友一样成天幻想生活在一个完美的社会中，有些问题可能不是我们一个人所能更改的，但是要明白那些污染社会的小人的阴险，更不能成为他们。当然也和这乱成一锅粥的中国娱乐圈本身多年以来的不良风气有关，老话说的真的对，人怕出名猪怕壮，当一个人有了名气之后会不免想要更高的权力和物欲，这点也体现在贪污的官员身上。所以，我不追求多大的名气，我俗，有钱能养活自己，让自己快快活活活着不就挺好？</p><p>当然还有网上的一些评价让我更深层次的认识这些娱乐圈事件。仔细想来也蛮有道理，每次这种娱乐圈爆出的新闻总是能出现在一些高地位企业出现事故的情况之时。这不免让人想到会不会是这些企业为了转移大众视线呢？ 对于现在的大资本企业，我只能说我更相信他们能做出来这样的事情。但是身处于这种资本垄断的社会中，有钱有资本真的可以为所欲为，你又能怎么样呢？ 你不去追随资本，你哪来的生活？ 以前我还对国企嗤之以鼻，现在想想还是太年轻了啊，那有什么自由创造的工作环境，想要有资本，就得趟这潭浑水，一边是官场的尔虞我诈，一边是资本家的敲骨吸髓，现在想要生活，你没得选，可能怎么样才能出淤泥而不染，会成为我以后更想要思考的事情吧。</p><h2 id="未完待续。。。。。。"><a href="#未完待续。。。。。。" class="headerlink" title="未完待续。。。。。。"></a>未完待续。。。。。。</h2><h1 id="记校赛"><a href="#记校赛" class="headerlink" title="记校赛"></a>记校赛</h1><p>前前后后忙了一个多月，在经历一次延期之后，校赛终于是办完了。。。<br>这次算是自己第一次以负责人的身份举办这么大型的活动，真的得到了很多的锻炼。</p><p>无论是第一次处理发票，第一次叫救护车，第一次经历手机没电陌生老乡送来充电宝，第一次进行裁判员培训……<br>还是在经历各种突发情况之后保安大叔的帮助，裁判同行的协助。这些都让我体会到了一个活动举办的不易。<br>当然这次比赛还有很多没做好的地方，但是能听到大家对这次比赛的认可内心是真的很开心啊。<br>忙碌就这样告一段落叭，要好好准备考试了哦！！</p><h1 id="关于疫情和大学"><a href="#关于疫情和大学" class="headerlink" title="关于疫情和大学"></a>关于疫情和大学</h1><pre><code>困了，下次一定，嘻嘻</code></pre><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://cdn.pixabay.com/photo/2016/05/06/01/22/couple-1375125_960_720.jpg&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;属于是不知道最近想了些什么一一列举出来记录一下吧&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;深夜emo警告！！！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一切的一切仅为个人观点，瞎想的，别认真&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="日常" scheme="http://akkaduilin.com/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
    <category term="想法" scheme="http://akkaduilin.com/tags/%E6%83%B3%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>五种排序</title>
    <link href="http://akkaduilin.com/2021/12/01/%E6%8E%92%E5%BA%8F/"/>
    <id>http://akkaduilin.com/2021/12/01/%E6%8E%92%E5%BA%8F/</id>
    <published>2021-12-01T09:19:51.000Z</published>
    <updated>2022-01-07T09:22:11.311Z</updated>
    
    <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p><em>关于顺序储存结构——数组结构中实现的五种常用排序算法</em></p><pre><code>void InsertSort();//插入排序void SelectSort();//选择排序void QuickSort(int first,int last);//快排void HeapSort();//堆排序void MergeSort(int first,int last);//归并排序</code></pre><span id="more"></span><!-- toc --><h1 id="1-代码"><a href="#1-代码" class="headerlink" title="1.代码"></a><strong>1.代码</strong></h1><figure class="highlight plaintext"><figcaption><span>[排序] [lang:C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line">class Sort&#123;</span><br><span class="line">public:</span><br><span class="line">Sort(int arr[],int len)&#123;</span><br><span class="line">data = new int[len];</span><br><span class="line">for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">data[i] = arr[i];</span><br><span class="line">&#125;</span><br><span class="line">length = len;</span><br><span class="line">&#125;;</span><br><span class="line">void Print()&#123;</span><br><span class="line"></span><br><span class="line">// for(int i=0;i&lt;length;i++)&#123;</span><br><span class="line">// cout &lt;&lt; data[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">// &#125;</span><br><span class="line">// cout &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;key count&quot; &lt;&lt; count1&lt;&lt;  &quot;  moving count&quot; &lt;&lt; count2 &lt;&lt;endl;</span><br><span class="line">&#125;;</span><br><span class="line">void InsertSort();//插入排序</span><br><span class="line">void SelectSort();//选择排序</span><br><span class="line">void QuickSort(int first,int last);//快排</span><br><span class="line">void HeapSort();//堆排序</span><br><span class="line">void MergeSort(int first,int last);//归并排序</span><br><span class="line">long long count1;//关键字查找次数</span><br><span class="line">long long count2;//记录移动次数</span><br><span class="line">private:</span><br><span class="line">int part(int first,int last);</span><br><span class="line">void merge(int first,int last1,int last2);</span><br><span class="line">void Heap(int i,int last);</span><br><span class="line">int *data;</span><br><span class="line">int length;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void Sort::InsertSort()&#123;</span><br><span class="line">int j,temp;</span><br><span class="line">count1=0,count2=0;</span><br><span class="line">for(int i=1;i&lt;length;i++)&#123;</span><br><span class="line">temp = data[i];</span><br><span class="line">for(j = i-1;j&gt;=0&amp;&amp;temp&lt;data[j];j--)&#123;</span><br><span class="line">data[j+1] = data[j];</span><br><span class="line">count1++;</span><br><span class="line">&#125;</span><br><span class="line">data[j+1] = temp;</span><br><span class="line">count2++;</span><br><span class="line">&#125;</span><br><span class="line">//cout &lt;&lt; &quot;InsertSort:key count&quot; &lt;&lt; count1&lt;&lt;  &quot;  moving count&quot; &lt;&lt; count2 &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Sort::part(int first,int last)&#123;</span><br><span class="line">int i=first,j=last,temp;</span><br><span class="line">while(i&lt;j)&#123;</span><br><span class="line">while(i&lt;j&amp;&amp;data[i]&lt;=data[j])&#123;</span><br><span class="line">count1++;</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line">if(i&lt;j)&#123;</span><br><span class="line">temp = data[i];</span><br><span class="line">data[i] = data[j];</span><br><span class="line">data[j] = temp;</span><br><span class="line">count2++;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">while(i&lt;j&amp;&amp;data[i]&lt;=data[j])&#123;</span><br><span class="line">count1++;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">if(i&lt;j)&#123;</span><br><span class="line">temp = data[i];</span><br><span class="line">data[i] = data[j];</span><br><span class="line">data[j] = temp;</span><br><span class="line">count2++;</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Sort::QuickSort(int first,int last)&#123;</span><br><span class="line">if(first&gt;=last) return;</span><br><span class="line">else&#123;</span><br><span class="line">int locate = Sort::part(first,last);</span><br><span class="line">QuickSort(first,locate-1);</span><br><span class="line">QuickSort(locate+1,last);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Sort::SelectSort()&#123;</span><br><span class="line">int step,temp;</span><br><span class="line">for(int i=0;i&lt;length-1;i++)&#123;</span><br><span class="line">step = i;</span><br><span class="line">for(int j=i;j&lt;length;j++)&#123;</span><br><span class="line">count1++;</span><br><span class="line">if(data[j]&lt;data[step])&#123;</span><br><span class="line">step = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(step != i)&#123;</span><br><span class="line">temp = data[i];</span><br><span class="line">data[i] = data[step];</span><br><span class="line">data[step] = temp;</span><br><span class="line">count2++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Sort::Heap(int i,int last)&#123;</span><br><span class="line">int temp  = data[i];</span><br><span class="line">for(int k  = i*2+1;k&lt;last;k=k*2+1)&#123;</span><br><span class="line">if(k+1&lt;last&amp;&amp;data[k]&lt;data[k+1])&#123;</span><br><span class="line">k++;</span><br><span class="line">count1++;</span><br><span class="line">&#125;</span><br><span class="line">if(data[k]&gt;temp)&#123;</span><br><span class="line">data[i] = data[k];</span><br><span class="line">i=k;</span><br><span class="line">count2++;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">data[i] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Sort::HeapSort()&#123;</span><br><span class="line">int temp;</span><br><span class="line">    for(int i=length/2-1;i&gt;=0;i--)&#123;</span><br><span class="line">Heap(i,length);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//Print();</span><br><span class="line">for(int j=length-1;j&gt;0;j--)&#123;</span><br><span class="line">temp = data[0];</span><br><span class="line">data[0] = data[j];</span><br><span class="line">data[j] = temp;</span><br><span class="line">Heap(0,j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Sort::merge(int first,int mid,int last)&#123;</span><br><span class="line">    int *temp = new int [length];</span><br><span class="line">    int i = first,j = mid+1,step = first;</span><br><span class="line">    while(i&lt;=mid&amp;&amp;j&lt;=last)&#123;</span><br><span class="line">        count1++;</span><br><span class="line">        if(data[i]&lt;data[j])&#123;</span><br><span class="line">            temp[step++] = data[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            temp[step++] = data[j++];</span><br><span class="line">            count2++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while(i&lt;=mid)&#123;</span><br><span class="line">        temp[step++] = data[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    while(j&lt;=last)&#123;</span><br><span class="line">        temp[step++] = data[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    for(i=first;i&lt;=last;i++)&#123;</span><br><span class="line">        data[i] = temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    delete[]  temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Sort::MergeSort(int first,int last)&#123;</span><br><span class="line">    if(first == last) return ;</span><br><span class="line">    else&#123;</span><br><span class="line">        int mid = (first+last)/2;</span><br><span class="line">        MergeSort(first,mid);</span><br><span class="line">        MergeSort(mid+1,last);</span><br><span class="line">        merge(first,mid,last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure><!-- toc --><h1 id="2-可视化过程"><a href="#2-可视化过程" class="headerlink" title="2.可视化过程"></a><strong>2.可视化过程</strong></h1><p> <a href="https://visualgo.net/en/sorting">https://visualgo.net/en/sorting</a></p><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;关于顺序储存结构——数组结构中实现的五种常用排序算法&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void InsertSort();//插入排序
void SelectSort();//选择排序
void QuickSort(int first,int last);//快排
void HeapSort();//堆排序
void MergeSort(int first,int last);//归并排序
&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    <category term="编程" scheme="http://akkaduilin.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="算法" scheme="http://akkaduilin.com/categories/%E7%BC%96%E7%A8%8B/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C++" scheme="http://akkaduilin.com/tags/C/"/>
    
    <category term="排序" scheme="http://akkaduilin.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>链表下的归并排序</title>
    <link href="http://akkaduilin.com/2021/11/28/%E9%93%BE%E8%A1%A8%E5%BD%92%E5%B9%B6/"/>
    <id>http://akkaduilin.com/2021/11/28/%E9%93%BE%E8%A1%A8%E5%BD%92%E5%B9%B6/</id>
    <published>2021-11-28T14:07:07.000Z</published>
    <updated>2022-01-17T04:19:32.772Z</updated>
    
    <content type="html"><![CDATA[<p><em>链表下的归并排序</em><br><em>属于是不知道为什么老师会安排这种作业了</em></p><span id="more"></span><h1 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h1><p><em>原理两个函数可以解决</em><br><em>66行——生成可移动的头节点 并不影响返回调用头节点</em><br><em>49-54 快慢指针寻找链表的中点</em></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight plaintext"><figcaption><span>[链表的归并排序] [lang:C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename DataType&gt;</span><br><span class="line">void LinkList&lt;DataType&gt; ::merge_sort()&#123;</span><br><span class="line">    recursive_merge_sort(first);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename DataType&gt;</span><br><span class="line">void LinkList&lt;DataType&gt; ::recursive_merge_sort(Node&lt;DataType&gt; * &amp;sub_list)&#123;</span><br><span class="line">    divide_from(sub_list);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename DataType&gt;</span><br><span class="line">Node&lt;DataType&gt; *LinkList&lt;DataType&gt; ::divide_from(Node&lt;DataType&gt; *sub_list)&#123;</span><br><span class="line">    </span><br><span class="line">    Node&lt;DataType&gt;* fast = sub_list-&gt;next;</span><br><span class="line">    Node&lt;DataType&gt;* slow = sub_list;</span><br><span class="line">    Node&lt;DataType&gt;* head = slow;</span><br><span class="line">    </span><br><span class="line">    if(sub_list-&gt;next==nullptr||sub_list==nullptr)&#123;</span><br><span class="line">        return sub_list;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    while (fast != nullptr &amp;&amp; fast-&gt;next != nullptr) &#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    Node&lt;DataType&gt;* tmp = slow-&gt;next;</span><br><span class="line">    slow-&gt;next = nullptr;</span><br><span class="line">    </span><br><span class="line">    Node&lt;DataType&gt; *pa = divide_from(head);</span><br><span class="line">    //test(head);</span><br><span class="line">    Node&lt;DataType&gt; *pb = divide_from(tmp);</span><br><span class="line">    //test(tmp);</span><br><span class="line">    return merge(pa,pb);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename DataType&gt;</span><br><span class="line">Node&lt;DataType&gt; * LinkList&lt;DataType&gt;::merge(Node&lt;DataType&gt; *pa, Node&lt;DataType&gt; *pb)&#123;</span><br><span class="line"></span><br><span class="line">    Node&lt;DataType&gt;*  res = new Node&lt;DataType&gt;;</span><br><span class="line">    Node&lt;DataType&gt;* cur = res;</span><br><span class="line">    Node&lt;DataType&gt; * cur1=pa;</span><br><span class="line">    Node&lt;DataType&gt; * cur2=pb;</span><br><span class="line">    while(cur1!=nullptr&amp;&amp;cur2!=nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        if(cur1-&gt;data&lt;=cur2-&gt;data)</span><br><span class="line">        &#123;</span><br><span class="line">            cur-&gt;next=cur1;</span><br><span class="line">            cur1=cur1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            cur-&gt;next=cur2;</span><br><span class="line">            cur2=cur2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur=cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    if(cur1==nullptr)                </span><br><span class="line">        cur-&gt;next=cur2;</span><br><span class="line">    else</span><br><span class="line">        cur-&gt;next=cur1;</span><br><span class="line">    //cout &lt;&lt; cur-&gt;data&lt;&lt;&quot;---&quot;;</span><br><span class="line">    //test(res-&gt;next);</span><br><span class="line">    //cout &lt;&lt; res-&gt;next-&gt;next-&gt;data&lt;&lt;endl;</span><br><span class="line">    return res-&gt;next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr />]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;em&gt;链表下的归并排序&lt;/em&gt;&lt;br&gt;&lt;em&gt;属于是不知道为什么老师会安排这种作业了&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="http://akkaduilin.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="算法" scheme="http://akkaduilin.com/categories/%E7%BC%96%E7%A8%8B/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C++" scheme="http://akkaduilin.com/tags/C/"/>
    
    <category term="排序" scheme="http://akkaduilin.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
    <category term="线性表" scheme="http://akkaduilin.com/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>编程用笔记(更新ing)</title>
    <link href="http://akkaduilin.com/2021/11/08/my-note/"/>
    <id>http://akkaduilin.com/2021/11/08/my-note/</id>
    <published>2021-11-08T09:33:01.000Z</published>
    <updated>2022-01-08T03:51:30.867Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言</strong></p><p><em>收集一些经常要搜的编程小知识</em><br><em>不定期更新  ︿(￣︶￣)︿</em></p> <img src="https://s2.loli.net/2021/12/15/2eoquz8pm6ArHMQ.jpg" style="width:50%"><span id="more"></span><h1 id="vscode-常用快捷键"><a href="#vscode-常用快捷键" class="headerlink" title="vscode 常用快捷键"></a>vscode 常用快捷键</h1><p>链接指路<br><a href="https://blog.csdn.net/hypon2016/article/details/80831266?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163767461216780265485668%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163767461216780265485668&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-80831266.first_rank_v2_pc_rank_v29&amp;utm_term=vscode%E5%BF%AB%E6%8D%B7%E9%94%AE&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/hypon2016/article/details/80831266?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163767461216780265485668%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163767461216780265485668&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-80831266.first_rank_v2_pc_rank_v29&amp;utm_term=vscode%E5%BF%AB%E6%8D%B7%E9%94%AE&amp;spm=1018.2226.3001.4187</a></p><p>Shift+Alt + ↓ / ↑    向上/向下复制行 Copy line up/down<br>Ctrl+Home    转到文件开头 Go to beginning of file<br>Ctrl+End    转到文件末尾 Go to end of file<br>Ctrl+Enter    在下面插入行 Insert line below<br>Ctrl+Shift+Enter    在上面插入行 Insert line above<br>Ctrl+Shift+\    跳到匹配的括号 Jump to matching bracket<br>Ctrl+Shift+K    删除行 Delete line</p><p>Ctrl+Shift+[    折叠（折叠）区域 Fold (collapse) region<br>Ctrl+Shift+]    展开（未折叠）区域 Unfold (uncollapse) region<br>Ctrl+K Ctrl+[    折叠（未折叠）所有子区域 Fold (collapse) all subregions<br>Ctrl+K Ctrl+]    展开（未折叠）所有子区域 Unfold (uncollapse) all subregions<br>Ctrl+K Ctrl+0    折叠（折叠）所有区域 Fold (collapse) all regions<br>Ctrl+K Ctrl+J    展开（未折叠）所有区域 Unfold (uncollapse) all regions多光标和选择 Multi-cursor and selection</p><p>Alt +单击    插入光标 Insert cursor<br>Ctrl + Alt +↑/↓    在上/下插入光标 Insert cursor above / below<br>Ctrl + U    撤消上一个光标操作 Undo last cursor operation<br>Shift + Alt + I    在选定的每一行的末尾插入光标 Insert cursor at end of each line selected<br>Shift + Alt + →    展开选择 Expand selection<br>Shift + Alt + ←    缩小选择 Shrink selection</p><h1 id="C-时间函数"><a href="#C-时间函数" class="headerlink" title="C++ 时间函数"></a>C++ 时间函数</h1><p>头文件：<br>#include &lt;windows.h&gt;</p><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">clock_t time_start, time_end;</span><br><span class="line"></span><br><span class="line">/* 获取开始时间 */</span><br><span class="line">time_start = GetTickCount(); //从操作系统启动经过的毫秒数</span><br><span class="line"></span><br><span class="line">time_end = GetTickCount();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;Time = &quot; &lt;&lt; (time_end - time_start) &lt;&lt; &quot;ms\n &quot;;</span><br></pre></td></tr></table></figure><h1 id="C-随机函数"><a href="#C-随机函数" class="headerlink" title="C++ 随机函数"></a>C++ 随机函数</h1><p>#define random(x) (rand()%x)<br>要取得[0,n)  就是rand（）%n     表示 从0到n-1的数</p><p>要取得[a,b)的随机整数，使用(rand() % (b-a))+ a;<br>要取得[a,b]的随机整数，使用(rand() % (b-a+1))+ a;<br>要取得(a,b]的随机整数，使用(rand() % (b-a))+ a + 1;<br>通用公式:a + rand() % n；其中的a是起始值，n是整数的范围。<br>要取得a到b之间的随机整数，另一种表示：a + (int)b * rand() / (RAND_MAX + 1)。<br>要取得0～1之间的浮点数，可以使用rand() / double(RAND_MAX)。</p><h1 id="malloc解析"><a href="#malloc解析" class="headerlink" title="malloc解析"></a>malloc解析</h1><p>引用：<br><a href="https://zhuanlan.zhihu.com/p/105090421">https://zhuanlan.zhihu.com/p/105090421</a></p><p>头文件：#include &lt;malloc.h&gt; 或 #include &lt;alloc.h&gt; (注意：alloc.h 与 malloc.h 的内容是完全一致的。)</p><p>功能：分配长度为num_bytes字节的内存块</p><p>说明：如果分配成功则返回指向被分配内存的指针，否则返回空指针NULL。</p><p>当内存不再使用时，应使用free()函数将内存块释放。</p><p>解析：<br>malloc的意义是向 堆区 要了一块sizeof(int) * N 这么大的空间。<br>返回的是指针，所以在后期使用时要解引用。</p><p>代码：</p><figure class="highlight plaintext"><figcaption><span>[malloc解析] [lang:C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">    int i = 0;</span><br><span class="line">    int N = 0;</span><br><span class="line">    int* arr;</span><br><span class="line"></span><br><span class="line">    printf(&quot;请输入数组的大小\n&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;N);</span><br><span class="line"></span><br><span class="line">    arr = (int*)malloc(sizeof(int) * N);</span><br><span class="line"></span><br><span class="line">    printf(&quot;请输入%d个数</span><br></pre></td></tr></table></figure><h1 id="auto的循环用法"><a href="#auto的循环用法" class="headerlink" title="auto的循环用法"></a>auto的循环用法</h1><p>for(auto &amp;a :b)</p><p>输出的结果就是0—9这十个数。</p><p>for(auto &amp;a : arr)中“auto &amp;a”就是变量名就和上一个for循环中的“int i”一样，</p><p>与for(int i=0;i&lt;sizeof(arr)/sizeof(arr[0]);i++)是一样的。</p><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int arr[10];</span><br><span class="line">for(int i=0;i&lt;10;i++)</span><br><span class="line">&#123;</span><br><span class="line">  arr[i]=i;</span><br><span class="line">&#125;</span><br><span class="line">for(auto &amp;a:arr)</span><br><span class="line">&#123;</span><br><span class="line">  cout &lt;&lt; a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>未完待续 (°ー°〃)</strong></p><hr />版权信息]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;收集一些经常要搜的编程小知识&lt;/em&gt;&lt;br&gt;&lt;em&gt;不定期更新  ︿(￣︶￣)︿&lt;/em&gt;&lt;/p&gt;
 &lt;img src=&quot;https://s2.loli.net/2021/12/15/2eoquz8pm6ArHMQ.jpg&quot; style=&quot;width:50%&quot;&gt;</summary>
    
    
    <content src="https://s2.loli.net/2021/12/15/2eoquz8pm6ArHMQ.jpg" type="image"/>
    
    
    <category term="编程" scheme="http://akkaduilin.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="笔记" scheme="http://akkaduilin.com/categories/%E7%BC%96%E7%A8%8B/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="C++" scheme="http://akkaduilin.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>hexo使用指南</title>
    <link href="http://akkaduilin.com/2021/11/01/hexo-note/"/>
    <id>http://akkaduilin.com/2021/11/01/hexo-note/</id>
    <published>2021-11-01T09:46:11.000Z</published>
    <updated>2022-01-08T03:52:03.573Z</updated>
    
    <content type="html"><![CDATA[<img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.zyiz.net%2Fupload%2F202002%2F18%2F202002182223498227.png&refer=http%3A%2F%2Fwww.zyiz.net&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1640944017&t=77d83c28c44b14310d74a639bf7b5d62/" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>记录一下hexo搭建博客的操作和一些小知识 </p><span id="more"></span><h1 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a><strong>常用操作</strong></h1><figure class="highlight plaintext"><figcaption><span>[] []</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">hexo d 上传至github</span><br><span class="line">hexo new [layout] &lt;title&gt;</span><br><span class="line">eg: hexo new post name 新建页面</span><br><span class="line">hexo help  # 查看帮助</span><br><span class="line">hexo version  #查看Hexo的版本</span><br><span class="line">hexo algolia  # 更新search庫</span><br><span class="line">hexo clean #清除部署緩存</span><br><span class="line">hexo n == hexo new #新建文章</span><br><span class="line">hexo g == hexo generate #生成静态页面至public目录</span><br><span class="line">hexo s == hexo server #开启预览访问端口（默认端口4000，&#x27;ctrl + c&#x27;关闭server）</span><br><span class="line">hexo d == hexo deploy #将.deploy目录部署到GitHub</span><br><span class="line">hexo d -g #生成加部署</span><br><span class="line">hexo s -g #生成加预览</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="常用语言用法"><a href="#常用语言用法" class="headerlink" title="常用语言用法"></a>常用语言用法</h1><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    代码块</span><br><span class="line">    &lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;figcaption&gt;&lt;span&gt;[xxxxxx] [lang:]&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;&lt;code&gt;图片</span><br><span class="line">&amp;lt;img src=&amp;quot;&amp;quot; alt=&amp;quot;&amp;quot; style=&amp;quot;width:100%&amp;quot; /&amp;gt; </span><br><span class="line"></span><br><span class="line">博客内页面跳转</span><br><span class="line">&amp;#123;% post_link 最小生成树 %&amp;#125;</span><br><span class="line">&amp;#123;% post_link 最小生成树 最小生成树 %&amp;#125;</span><br><span class="line"></span><br><span class="line">&amp;lt;table&amp;gt;</span><br><span class="line">    &amp;lt;tr&amp;gt;</span><br><span class="line">        &amp;lt;td &amp;gt;&amp;lt;center&amp;gt;&amp;lt;img src=&amp;quot;&amp;quot; &amp;gt;图1 &amp;lt;/center&amp;gt;&amp;lt;/td&amp;gt;</span><br><span class="line">        &amp;lt;td &amp;gt;&amp;lt;center&amp;gt;&amp;lt;img src=&amp;quot;&amp;quot; &amp;gt;图2 &amp;lt;/center&amp;gt;&amp;lt;/td&amp;gt;</span><br><span class="line">    &amp;lt;/tr&amp;gt;</span><br><span class="line"></span><br><span class="line">&amp;lt;/table&amp;gt;</span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.zyiz.net%2Fupload%2F202002%2F18%2F202002182223498227.png&amp;refer=http%3A%2F%2Fwww.zyiz.net&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1640944017&amp;t=77d83c28c44b14310d74a639bf7b5d62/&quot; alt=&quot;&quot; style=&quot;width:100%&quot; /&gt;  

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;记录一下hexo搭建博客的操作和一些小知识 &lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="http://akkaduilin.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="博客" scheme="http://akkaduilin.com/categories/%E7%BC%96%E7%A8%8B/%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="hexo" scheme="http://akkaduilin.com/tags/hexo/"/>
    
  </entry>
  
</feed>
