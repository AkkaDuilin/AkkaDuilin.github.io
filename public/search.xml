<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计算机网络-物理层</title>
      <link href="/2022/09/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%89%A9%E7%90%86%E5%B1%82/"/>
      <url>/2022/09/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%89%A9%E7%90%86%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><span id="more"></span><h1 id="通信系统的模型"><a href="#通信系统的模型" class="headerlink" title="通信系统的模型"></a>通信系统的模型</h1><p>源点<br>发送机<br>接收器<br>终点</p><p>目的：传送消息<br>数据是实体</p><h1 id="信道"><a href="#信道" class="headerlink" title="信道"></a>信道</h1><p>信道：一般用来表示向某一方向传送信息的媒体</p><p>单向通信(单工通信)：只能有一个方向的通信，无反向交互</p><p>双向交替通信(半双工通信) ：双方不能同时发送/接收</p><p>双向同时通信(全双工通信)：双方可以同时发送和接收信息</p><p>基带信号：<br>来自信源的信号<br>包含低频和直流</p><p>调制：<br>基带调制<br>带通调制</p><h1 id="传输媒体"><a href="#传输媒体" class="headerlink" title="传输媒体"></a>传输媒体</h1><h2 id="导引型"><a href="#导引型" class="headerlink" title="导引型"></a>导引型</h2><ol><li>双绞线</li><li>同轴电缆</li><li>光缆</li></ol><p>非导引型</p><hr />版权信息]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> 数据通信 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-概论</title>
      <link href="/2022/09/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%AE%BA/"/>
      <url>/2022/09/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><span id="more"></span><h1 id="xx0x"><a href="#xx0x" class="headerlink" title="xx0x"></a>xx0x</h1><h1 id="xx2x"><a href="#xx2x" class="headerlink" title="xx2x"></a>xx2x</h1><h1 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h1><p>1、速率</p><p>数据量单位 数据率单位</p><p>8 比特 = 1 字节 比特/秒(b/s,bps)</p><p>KB = 2^10 B kb/s = 10^3 b/s</p><p>MB = 2^20 B Mb/s = 10^6 b/s</p><p>GB = 2^30 B Gb/s = 10^9 b/s</p><p>2、带宽</p><p>用来表示网络的通信线路所能传送数据的能力，因此网络带宽表示在单位时间内从网络中的某一点到另一点所能通过的“最高数据率” (单位：b/s,kb/s ，Mb/s……)</p><p>在模拟信号系统中的意义：信号所包含的各种不同频率成分所占据的频率范围。单位：HZ\KHZ\MHZ</p><p>3、吞吐量</p><p>表示在单位时间内通过某个网络（或信道、接口）的数据量。 受网络的带宽或额定速率的限制</p><p>4、时延</p><p>发送时延、传播时延、处理时延</p><p>5、时延带宽积</p><p>时延带宽积 = 传播时延 * 带宽</p><p>6、往返时间(RTT)</p><p>双向通信的往返时间</p><p>7、利用率</p><p>信道利用率：用来表示某信道由百分之几的时间是被利用的（由数据通过）。其并非越高越好</p><p>网络利用率：全网络的信道利用率加权平均</p><p>8、丢包率</p><p>即分组丢失率，是指在一一定时间范围内，传输过程中丢失的分组数量与总分组数量的比率。</p><p>分为：接口丢包率、结点丢包率、链路丢包率、路径丢包率、网络丢包率</p><p>误码、网络拥塞时会出现分组丢失。</p><h1 id="xx3x"><a href="#xx3x" class="headerlink" title="xx3x"></a>xx3x</h1><hr />版权信息]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> 概论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-概论</title>
      <link href="/2022/08/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%AE%BA/"/>
      <url>/2022/08/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>操作系统概论/操作系统结构</p><span id="more"></span><h1 id="操作系统设计目标"><a href="#操作系统设计目标" class="headerlink" title="操作系统设计目标"></a>操作系统设计目标</h1><p>操作系统是管理计算机硬件的程序， 为应用程序提供基础， 并且充当计算机硬件和计算机用户的中介。</p><p>运行用户程序 —— 核心目标</p><p>系统面向用户 —— 方便解决用户问题，使计算机方便使用</p><p>面向系统 —— 高效方式使用计算机硬件</p><p>资源分配器 —— 管理资源、分配资源</p><p>控制程序 —— 管理用户程序的运行</p><p>CPU管理 内存管理 文件管理 设备管理</p><h1 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h1><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>计算机开始运行的时候，通常需要运行一个初始化程序/引导程序(bootstrap program)，通常位于 ROM 或 EEPROM 中，称为计算机硬件中的固件。</p><p>它负责初始化系统中的所有部分，包括：CPU 寄存器， 设备控制器， 内存内容。它必须知道如果装入系统并开始执行系统，定位操作系统内核并把他装入内存，然后操作系统就开始初始化。</p><p><strong>中断</strong></p><p>现在的操作系统都是以中断为驱动的。</p><p>事件的发生通常通过硬件或软件中断(interrupt)来表示，硬件可以随时通过系统总线向 CPU 发出信号，触发中断，而软件通过执行特别操作如系统调用(system call)/监视器调用(monitor call)</p><p>中断是计算机结构的重要组成部分。中断必须将控制转移到合适的中断处理程序，简单的方法就是调用一个通用的子程序检查中断信息，然后调用对应的中断处理程序。</p><h2 id="批处理系统"><a href="#批处理系统" class="headerlink" title="批处理系统"></a>批处理系统</h2><p>一次运行称为作业</p><p>一批无需人机交互的作业批量运行称为批处理</p><p>在批处理系统中，用户所提交的作业都先存放在外存上并排成一个队列，称为“后备队列”。然后，由作业调度程序按一定的算法从后备队列中选择若干个作业调入内存，使它们共享CPU和系统中的各种资源。</p><p>简单批处理系统-系统对作业的处理是成批进行的，但内存中始终保持一道作业。</p><p>多道程序系统-在内存中同时存放多个作业，一个时刻只有一个作业运行，使得CPU总有一个作业可执行，这些作业共享CPU和外部设备等资源。</p><p>目的：使得CPU和设备在所有时间内尽可能忙碌，从而提高CPU和设备的利用率，充分发挥计算机系统各个部件的并行性</p><p><strong>并行和并发</strong><br>并行： 两个或多个作业在同一时刻运行<br>并发： 两个或多个作业在同一时间间隔内依次运行</p><h2 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a>分时系统</h2><p>时间片： 一段CPU时间按固定单位分割，每个分割的时间段为一个时间片</p><p>在一段把时间内，每个作业依次轮流运行一个时间片</p><p>·多路性：系统允许将多台终端同时连接到一台主机上，并按分时原则为每个终端分配系统资源，提高资源利用率，降低使用费用。</p><p>·独立性：各终端之间相互独立，互不干扰，每个用户都感觉像一人独占主机一样。</p><p>·及时性：用户的请求能在很短的时间内就得到响应。</p><p>·交互性：用户可通过终端与系统进行人机对话，例如请求多方面的服务。</p><p><em>平均响应速度</em><br><a href="https://www.programminghunter.com/article/79041754246/">https://www.programminghunter.com/article/79041754246/</a><br>进程响应时间：<br>单个进程从用户提交到系统首次响应所用的时间</p><h2 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h2><h1 id="计算机系统体系结构"><a href="#计算机系统体系结构" class="headerlink" title="计算机系统体系结构"></a>计算机系统体系结构</h1><ol><li>单处理器系统</li></ol><p>只有一个通用 CPU<br>还包含其他特定目的微处理器， 用来克服主 CPU 超载问题</p><ol start="2"><li>多处理器系统(并行系统 Parallel system, 紧耦合系统 tightly coupled system)</li></ol><p>拥有多个紧密通信的 CPU，共享计算机总线，时钟，内存和外设</p><p>优点：<br><strong>增加吞吐量</strong><br><strong>规模经济</strong><br><strong>增加可靠性</strong><br>计算机系统不断增加的可靠性是很关键的，这种能提供与正常工作的硬件成正比的服务的能力称为适度退化(graceful degradation)。超出适度退化的能力被称为容错(fault tolerant)</p><p>多处理器系统主要分为</p><p>非对称多处理(asymmetric multiprocessing) ： 主从处理器</p><p>对称多处理(symmetric multiprocessing， SMP) 现代多数操作系统支持</p><p>概念： 刀片服务器(blade server) 每个刀片处理器独立启动并运行各自的系统</p><ol start="3"><li>集群系统：</li></ol><p><strong>由两个或多个独立的系统耦合起来的</strong></p><p>松耦合系统</p><p>通过局域网连接或更快的内部连接(InfiniBand)<br>用途： 提供高可用性(high availability)服务</p><p>分类：对称与非对称</p><p>非对称集群(asymmetric clustering)中， 一台机器处于热备份状态(hot standby mode)，另一台运行程序。</p><p>对称集群(symmetric clustering)，两个或多个主机都运行程序并互相监视。</p><p>还有并行集群和 WAN 集群。</p><p>并行集群中通常需要分布式锁管理器(distributed lock manager， DLM)</p><h2 id="双重模式操作"><a href="#双重模式操作" class="headerlink" title="双重模式操作"></a>双重模式操作</h2><p><strong>区分操作系统代码和用户自定义代码的执行</strong>，通常提供硬件支持以允许区分各种执行模式(在计算机硬件增加一个模式位(mode bit)来区分)</p><p>用户模式(user mode)<br>内核模式：监督程序模式(monitor mode)[也称为管理模式(supervisor mode)]、系统模式(system mode)或特权模式(privileged mode)<br>只要操作系统获得了对计算机的控制，就处于内核模式。</p><p>某些特权指令(privileged instruction)只能在内核模式执行。</p><p>特权指令：可以引起损害的机器指令，如切换到用户模式、I/O 的控制、定时器的管理和中断管理</p><p>系统调用通常采用陷阱到中断向量中的一个指定位置的方式。</p><p><strong>双重模式为操作系统提供了保护手段，以防止操作系统和用户程序受到错误用户程序的影响。</strong></p><p><strong>定时器</strong> 设置为在指定周期后中断计算机</p><h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><p>进程：处于执行中的程序</p><p>需要一定的资源</p><p>程序本身不是进程，程序时被动的实体。</p><p>单线程进程具有一个程序计数器来明确下一个执行的指令，这样程序的执行必须时连续的。</p><p>进程时系统工作的单元。系统由多个进程组成，其中一些事操作系统进程，其他是用户进程。</p><p>操作系统需要负责：</p><p>创建和删除用户进程和系统进程<br>挂起和重启进程<br>提供进程同步机制<br>提供进程通讯机制<br>提供死锁处理机制</p><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>内存是现代计算机操作系统的中心，是 CPU 和 I/O 设备共同快速访问的数据仓库，通常也是 CPU 可以直接寻址和访问的唯一大容量存储器。 </p><p>操作系统负责下列有关的内存管理的活动：</p><p>记录内存的哪部分正在被使用和被谁使用<br>当有内存空间是，决定哪些进程可以装入内存<br>根据需要分配和释放内存空间</p><h1 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h1><h2 id="文件系统管理"><a href="#文件系统管理" class="headerlink" title="文件系统管理"></a>文件系统管理</h2><p>操作系统负责：<br>创建和删除文件<br>创建和删除目录来组织文件<br>提供操作文件和目录的原语<br>将文件映射到二级存储上<br>在稳定存储介质上备份文件</p><h2 id="大容量存储器管理"><a href="#大容量存储器管理" class="headerlink" title="大容量存储器管理"></a>大容量存储器管理</h2><p>操作系统负责：<br>空闲空间管理<br>存储空间分配<br>硬盘调度</p><hr />版权信息]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="/2022/08/29/Git/"/>
      <url>/2022/08/29/Git/</url>
      
        <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>Git/Github 相关学习笔记</p><p>git协同开发流程</p><p>参考博客：<br><a href="https://www.jiyik.com/w/git">https://www.jiyik.com/w/git</a></p><p><a href="https://www.cnblogs.com/failymao/p/14929004.html#step-3%E6%8A%8A%E8%87%AA%E5%B7%B1%E5%BC%80%E5%8F%91%E8%80%85%E4%BB%93%E5%BA%93clone%E5%88%B0%E6%9C%AC%E5%9C%B0">https://www.cnblogs.com/failymao/p/14929004.html#step-3%E6%8A%8A%E8%87%AA%E5%B7%B1%E5%BC%80%E5%8F%91%E8%80%85%E4%BB%93%E5%BA%93clone%E5%88%B0%E6%9C%AC%E5%9C%B0</a></p><span id="more"></span><h1 id="仓库操作"><a href="#仓库操作" class="headerlink" title="仓库操作"></a>仓库操作</h1><p>一个Git仓库是项目的一个虚拟存储。它允许您保存代码的版本，可以在需要时访问这些版本。</p><p>Git 有一个额外的保存机制，称为“ stash ”。stash 是一个临时存储区域，用于存储尚未准备好提交的更改。</p><table><thead><tr><th align="left">序号</th><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">git init</td><td align="left">创建新仓库</td></tr><tr><td align="left">2</td><td align="left">git clone <repo> <directory></td><td align="left">创建仓库副本 –branch 克隆特定标签</td></tr><tr><td align="left">3</td><td align="left">git add</td><td align="left">将修改添加到暂存区  可以是文件和文件夹</td></tr><tr><td align="left">4</td><td align="left">git commit</td><td align="left">将暂存提交到项目历史记录 -am 立即创建所有暂存更改的提交并附加提交消息</td></tr><tr><td align="left">5</td><td align="left">git stash</td><td align="left">时搁置（或隐藏）对工作副本所做的更改</td></tr><tr><td align="left">6</td><td align="left">git diff</td><td align="left">比较更改</td></tr><tr><td align="left">7</td><td align="left">git status</td><td align="left">显示工作目录和暂存区的状态</td></tr><tr><td align="left">8</td><td align="left">git log</td><td align="left">显示已提交的快照的所有的历史信息</td></tr><tr><td align="left">8</td><td align="left">git tag</td><td align="left">标签 -a 添加注释 -m -f更新 -d删除</td></tr></tbody></table><h1 id="撤销更改"><a href="#撤销更改" class="headerlink" title="撤销更改"></a>撤销更改</h1><p>先使用 git log –oneline 查看修订的ID</p><ol><li>使用 git checkout ID  查看此ID的提交 检出特定的提交将使仓库处于“分离 HEAD ”状态</li></ol><p>从分离的HEAD 状态，我们可以执行git checkout -b new_branch_jiyik 命令。 这将创建一个名为 new_branch_jiyik 的新分支并切换到该状态。</p><ol start="2"><li>git revert HEAD</li></ol><p>撤消对仓库提交历史的更改</p><p>创建一个与上次提交相反的新提交</p><ol start="3"><li>git reset</li></ol><ol start="4"><li> <a href="https://blog.csdn.net/weixin_44137575/article/details/108142088">https://blog.csdn.net/weixin_44137575/article/details/108142088</a><br>git clean 清理仓库</li></ol><p>git clean 从你的工作目录中删除所有没有 tracked，没有被管理过的文件。</p><p>n ：显示将要被删除的文件</p><p>d ：删除未被添加到 git 路径中的文件（将 .gitignore 文件标记的文件全部删除）</p><p>f ：强制运行</p><p>x ：删除没有被 track 的文件</p><h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><ol><li><p>git remote<br>git remote 命令本质上是一个接口，用于管理存储在仓库的 ./.git/config 文件中的远程条目列表。</p></li><li><p>git fetch <remote><br>从仓库中获取所有分支。 这还会从其他仓库下载所有必需的提交和文件。</p></li></ol><p>git fetch <remote> <branch><br>与上面的命令相同，但仅获取指定的分支。</p><p>git fetch –all<br>获取所有已注册远程分支</p><p>git fetch –dry-run<br>–dry-run 选项将执行命令的演示运行。 它将输出在获取期间将采取的操作示例，但不应用它们。</p><ol start="3"><li>git push <remote> <branch><br>将指定的分支以及所有必要的提交和内部对象推送到远程仓库的分支 。 这会在目标仓库中创建一个本地分支。 为了防止你覆盖提交，当发现推送的分支的提交不是最新的提交，也就是慢于远程分支的提交时，Git 不会让你推送。</li></ol><p>git push <remote> –force<br>该命令上面的命令相同，但是它是强制推送，即使当前要推送的分支的提交慢于远程仓库的提交版本。除非你绝对确定自己知道自己在做什么，否则不要使用 –force 选项。</p><p>git push <remote> –all<br>将所有的本地分支推送到远程。</p><p>git push <remote> –tags<br>当推送分支或者使用 –all 选项时，Git 并不会对本地的标签（tag）进行推送。如果要将本地的标签推送的远程仓库，则需要–tags 选项。</p><ol start="4"><li>git pull <remote><br>获取当前分支的指定远程分支并立即将其合并到本地分支中。 这与 git fetch <remote> 后再执行 git merge origin/<current-branch> 相同。</li></ol><p>git pull –no-commit <remote><br>与默认调用类似，获取远程内容但不创建新的合并提交。</p><p>git pull –rebase <remote><br>与上一个 pull 相同，单不是使用 git merge 将远程分支与本地分支合并，而是使用 git rebase。</p><p>git pull –verbose<br>显示在拉取期间的下载的内容和合并的详细信息。</p><h1 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h1><p>git中，分支操作则是每个开发人员日常工作流。<br>每个开发者的仓库都有自己的分支路线，而这些分支路线会通过代码汇总映射到源仓库中去。</p><p>分为</p><ol><li><p>永久性分支<br>master branch：主分支<br>develop branch：开发分支 每个开发者的仓库相当于源仓库的一个镜像<br>开发者把功能做好以后，是存放到自己的develop中，当测试完以后，可以向管理者发起一个pull request，请求把自己仓库的develop分支合并到源仓库的develop中。</p></li><li><p>临时性分支<br>feature branch：功能分支 用于开发项目的功能的分支 该分支上进行功能的开发，开发完成以后再合并到develop分支上 命名一般为feature-*<br>release branch：预发布分支<br>hotfix branch：bug修复分支</p></li></ol><h2 id="git-branch-常见选项"><a href="#git-branch-常见选项" class="headerlink" title="git branch 常见选项"></a>git branch 常见选项</h2><ol><li><p>git branch<br>或者<br>git branch –list<br>列出仓库中的所有分支。</p></li><li><p>git branch <branch><br>创建一个名为<branch>的新分支。这并没有检出新的分支。</p></li><li><p>git branch -d <branch><br>删除指定的分支。这是一个“安全”操作，因为 Git 会阻止我们删除具有未合并更改的分支。</p></li><li><p>git branch -D <branch><br>强制删除指定的分支，即使它有未合并的更改。如果想永久丢弃与特定开发线相关的所有提交，则可以使用此命令。</p></li><li><p>git branch -m <branch><br>将当前分支重命名为<branch>。</p></li><li><p>git branch -a<br>列出所有远程分支。</p></li></ol><h2 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h2><p>git checkout 在分支上使用时会改变 HEAD 引用的目标。 它可用于创建分支、切换分支和检出远程分支。</p><ol><li><p>切换分支 git checkout branch_id</p></li><li><p>创建分支并切换 git checkout -b <new-branch></p></li></ol><h2 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h2><p>将多个提交序列合并为一个统一的历史记录</p><p><a href="https://www.jiyik.com/w/git/git-merge">https://www.jiyik.com/w/git/git-merge</a></p><h1 id="git协同开发"><a href="#git协同开发" class="headerlink" title="git协同开发"></a>git协同开发</h1><p><a href="https://developer.aliyun.com/article/604633">https://developer.aliyun.com/article/604633</a></p><hr />版权信息]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
          <category> Github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编代码</title>
      <link href="/2022/08/01/x86-64%E6%B1%87%E7%BC%96/"/>
      <url>/2022/08/01/x86-64%E6%B1%87%E7%BC%96/</url>
      
        <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>汇编代码和原始的C代码相差比较大，一些通常对C语言程序员隐蔽的处理器状态是可见的：</p><p>程序计数器(PC，用 %eip 表示)指示将要执行的下一条指令在存储器中的地址。<br>整数寄存器文件包含 8 个命名的位置，分别存储 32 位的值。这些寄存器可以存储地址(对应于 C 语言的指针)或证书数据。有的寄存器被用来记录某些重要的程序状态，而其他的寄存器则用来保存临时数据。<br>条件码(codition code)寄存器保存着最近执行的算术或逻辑指令的状态信息。它们用来实现控制或数据流中的条件变化。<br>一组浮点寄存器存放浮点数据。</p><span id="more"></span><h1 id="CPU基本功能"><a href="#CPU基本功能" class="headerlink" title="CPU基本功能"></a>CPU基本功能</h1><ol><li>执行机器指令</li><li>暂存少量数据</li><li>访问存储器</li></ol><h1 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h1><p><a href="https://sm.ms/image/JV4Sr8Dpyq9HzZx" target="_blank"><img src="https://s2.loli.net/2022/08/02/JV4Sr8Dpyq9HzZx.png" ></a></p><h1 id="操作数指示符"><a href="#操作数指示符" class="headerlink" title="操作数指示符"></a>操作数指示符</h1><p>大多数指令有一个或多个操作数(operand)，指示出执行一个操作中要引用的源数据值，以及放置结果的目标位置。操作数可能被分为三种类型：</p><ol><li>立即数(immediate)，也就是常数值</li><li>寄存器(register)，表示某个寄存器的内容</li><li>存储器(memory)引用，它会根据计算出来的地址访问某个存储器位置</li></ol><p><a href="https://sm.ms/image/bJ84KYTCsHigZP7" target="_blank"><img src="https://s2.loli.net/2022/08/02/bJ84KYTCsHigZP7.png" ></a></p><h1 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h1><p><a href="https://sm.ms/image/jLvqNehi8JEPsUr" target="_blank"><img src="https://s2.loli.net/2022/08/02/jLvqNehi8JEPsUr.png" ></a></p><h1 id="算术逻辑操作"><a href="#算术逻辑操作" class="headerlink" title="算术逻辑操作"></a>算术逻辑操作</h1><p><a href="https://sm.ms/image/JV4Sr8Dpyq9HzZx" target="_blank"><img src="https://s2.loli.net/2022/08/02/JV4Sr8Dpyq9HzZx.png" ></a></p><h1 id="xx2x"><a href="#xx2x" class="headerlink" title="xx2x"></a>xx2x</h1><h1 id="xx3x"><a href="#xx3x" class="headerlink" title="xx3x"></a>xx3x</h1><hr />版权信息]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理-储存系统</title>
      <link href="/2022/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%82%A8%E5%AD%98%E7%B3%BB%E7%BB%9F/"/>
      <url>/2022/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E5%82%A8%E5%AD%98%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p><a href="https://sm.ms/image/GqxMmSXHt5fobK4" target="_blank"><img src="https://s2.loli.net/2022/06/25/GqxMmSXHt5fobK4.png" ></a></p><p>三级存储结构：高速缓冲存储器、内存、外存</p><p><a href="https://sm.ms/image/fAi3R8N9DSa1dTz" target="_blank"><img src="https://s2.loli.net/2022/06/24/fAi3R8N9DSa1dTz.png" ></a> </p><span id="more"></span><h1 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h1><p>Cache：高速缓冲存储器<br>容量小：几百KB~几MB<br>cache采用静态存储器技术，每位至少需要6个晶体管，直接用触发器方式维持固定的逻辑，所以不需要刷新<br>与内核紧密相连，采用高速同步运行</p><h1 id="执行原理"><a href="#执行原理" class="headerlink" title="执行原理"></a>执行原理</h1><p><a href="https://sm.ms/image/1IScn824AOelkrE" target="_blank"><img src="https://s2.loli.net/2022/06/24/1IScn824AOelkrE.png" ></a></p><p>CPU从内存访问第一条指令<br>同时将第一条指令所在的页内容复制到cache中</p><p>CPU从cache中查找下一条要执行的指令<br>查找到(命中)，从cache中取指令，执行</p><p>查找不到，从内存中取指令<br>同时将该指令所在的页内容复制到cache中</p><p><a href="https://sm.ms/image/71bFwBuyXfI3aOg" target="_blank"><img src="https://s2.loli.net/2022/06/24/71bFwBuyXfI3aOg.png" ></a></p><h1 id="访问原理"><a href="#访问原理" class="headerlink" title="访问原理"></a>访问原理</h1><h2 id="直接映射"><a href="#直接映射" class="headerlink" title="直接映射"></a>直接映射</h2><p><a href="https://sm.ms/image/DcJoZ5kjd9bfMNK" target="_blank"><img src="https://s2.loli.net/2022/06/24/DcJoZ5kjd9bfMNK.png" ></a></p><p>把主存的每一块映射到一个固定的Cache槽中。<br>j=i mod 2c，<br>j为Cache槽号<br>i为主存的块号，<br>2c为Cache的槽数。<br>优点：实现简单、花费少。<br>缺点：Cache利用率不高。</p><h2 id="全相联"><a href="#全相联" class="headerlink" title="全相联"></a>全相联</h2><p>通过允许每个主存块装入到Cache的任何一槽中来克服直接映射的缺点</p><h2 id="组相联映射"><a href="#组相联映射" class="headerlink" title="组相联映射"></a>组相联映射</h2><p><a href="https://sm.ms/image/JtmLc9T6D3MbCrv" target="_blank"><img src="https://s2.loli.net/2022/06/24/JtmLc9T6D3MbCrv.png" ></a><br>上述两种方案的折中。<br>按号分组 组内随意放<br>把Cache分成2C’组<br>每组有2r个槽<br>2C =2C’×2r<br>j=(i mod 2C’)* 2r +k<br>(k=0，1，…，2r-1)</p><h1 id="替换算法"><a href="#替换算法" class="headerlink" title="替换算法"></a>替换算法</h1><p><a href="https://sm.ms/image/KEGcbyUmNiJzu7Y" target="_blank"><img src="https://s2.loli.net/2022/06/24/KEGcbyUmNiJzu7Y.png" ></a></p><p><a href="https://sm.ms/image/GubwWY1dnm85Dr2" target="_blank"><img src="https://s2.loli.net/2022/06/24/GubwWY1dnm85Dr2.png" ></a></p><p><a href="https://sm.ms/image/KtrxRQVGBmcWay5" target="_blank"><img src="https://s2.loli.net/2022/06/24/KtrxRQVGBmcWay5.png" ></a></p><h1 id="写策略"><a href="#写策略" class="headerlink" title="写策略"></a>写策略</h1><p>主存和cache中数据一致性问题的解决办法：<br>  写通过（Write through）：所有的写操作对主存和Cache同时进行。<br>  <strong>直写法不需要维护位</strong></p><p>  回写（write back）：只在Cache中修改，当进行修改时，设置与槽有关的修改位。因此，当某个块被替换时，当且仅当修改位被设置时，才将它写回主存。<br>  <strong>写回法需要一位的维护位</strong></p><p>当系统中存在多个Cache时，解决多个Cache中数据的一致性问题的方法：<br>  总线监视法<br>  硬件监视法<br>  划出不可高速缓存存储区法</p><h1 id="虚拟储存器"><a href="#虚拟储存器" class="headerlink" title="虚拟储存器"></a>虚拟储存器</h1><p>虚拟存储器指的是“主存-辅存”层次，它能使计算机具有辅存的容量，接近于主存的速度和辅存的每位成本。使程序员可以按比主存大得多的空间来编制程序，即按虚存空间编址。</p><hr />版权信息]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理-中央处理器</title>
      <link href="/2022/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/"/>
      <url>/2022/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p><a href="https://sm.ms/image/q3H5Q21hRClFuIp" target="_blank"><img src="https://s2.loli.net/2022/06/23/q3H5Q21hRClFuIp.png" ></a></p><p><a href="https://www.bilibili.com/video/BV1BE411D7">https://www.bilibili.com/video/BV1BE411D7</a></p><span id="more"></span><h1 id="中央处理器的功能和组成"><a href="#中央处理器的功能和组成" class="headerlink" title="中央处理器的功能和组成"></a>中央处理器的功能和组成</h1><p>指令控制：程序的顺序控制<br>操作控制：一条指令有若干操作信号实现<br>时间控制：指令各个操作实施时间的定时<br>数据加工：算术运算和逻辑运算</p><p><strong>运算器：</strong><br>数据加工 </p><p><strong>控制器：</strong><br>①取指令 ②翻译指令 ③发送信号执行指令</p><p><strong>根本任务就是从应用程序中取指令并执行。</strong></p><h1 id="运算器-控制器"><a href="#运算器-控制器" class="headerlink" title="运算器/控制器"></a>运算器/控制器</h1><p><a href="https://sm.ms/image/ZGMEuWvyVO1irja" target="_blank"><img src="https://s2.loli.net/2022/06/23/ZGMEuWvyVO1irja.png" ></a></p><h2 id="运算器基本结构"><a href="#运算器基本结构" class="headerlink" title="运算器基本结构"></a>运算器基本结构</h2><p>定点运算器是数据的加工处理部件，<br>是CPU的重要组成部分。</p><p>包括：ALU算术/逻辑单元 ，阵列乘法器、阵列除法器、移位电路、寄存器组、选择电路、数据总线（内部总线），…… 等逻辑电路构成。</p><p><a href="https://sm.ms/image/hQplsKOZ7uGRHTv" target="_blank"><img src="https://s2.loli.net/2022/06/23/hQplsKOZ7uGRHTv.png" ></a></p><h2 id="控制器基本结构"><a href="#控制器基本结构" class="headerlink" title="控制器基本结构"></a>控制器基本结构</h2><p>控制器的功能：<br>        取指令<br>        分析指令<br>        执行指令<br>        控制程序和数据的输入与输出<br>        对异常和请求进行处理</p><p>控制器的组成：<br>        程序计数器（PC）<br>        指令寄存器（IR）<br>        地址寄存器（MAR）<br>        数据缓冲寄存器（MDR）<br>        指令译码器（I-decoder）<br>        脉冲源和启停线路<br>        时序控制信号形成部件</p><p><a href="https://sm.ms/image/5UuHYnQ68s4WNdV" target="_blank"><img src="https://s2.loli.net/2022/06/23/5UuHYnQ68s4WNdV.png" ></a></p><p><a href="https://sm.ms/image/V9IBsav6ljLkRXh" target="_blank"><img src="https://s2.loli.net/2022/06/27/V9IBsav6ljLkRXh.png" ></a></p><h1 id="指令的执行过程"><a href="#指令的执行过程" class="headerlink" title="指令的执行过程"></a>指令的执行过程</h1><p><a href="https://sm.ms/image/eWaRlAn9srFwpt1" target="_blank"><img src="https://s2.loli.net/2022/06/23/eWaRlAn9srFwpt1.png" ></a></p><p><a href="https://sm.ms/image/58InB7T3ZFapjNu" target="_blank"><img src="https://s2.loli.net/2022/06/23/58InB7T3ZFapjNu.png" ></a></p><h1 id="微程序"><a href="#微程序" class="headerlink" title="微程序"></a>微程序</h1><p>微指令：由同时发出的控制信号所执行的一组微操作。<br>    例如：<br>加法指令的执行可分为：取指、计算地址、取操作数和加法运算四步，每一步都由一组微操作实现。这一组能同时执行的微操作就构成一条微指令。</p><p>微程序：一组微指令的集合。这样：<br>程序由一组指令组成<br>指令由一个微程序实现<br>微程序由一组微指令实现<br>微指令由一组微操作实现</p><p><a href="https://sm.ms/image/byHGVLgcBQqlJuM" target="_blank"><img src="https://s2.loli.net/2022/06/23/byHGVLgcBQqlJuM.png" ></a></p><ol><li>将每个控制信号用1bit表示，当该位为1时，表示有控制信号；为0时，表示无控制信号。</li><li>对M/IO#、W/R#，则当该位为1时，分别表示访问存储器和写；当该位为0时，分别表示IO访问和读。</li><li> 每条微指令执行完后，需要给出下条微指令执行的地址。</li></ol><p><strong>基本结构</strong><br><a href="https://sm.ms/image/yWT27H4VsfIvw1S" target="_blank"><img src="https://s2.loli.net/2022/06/23/yWT27H4VsfIvw1S.png" ></a></p><p><strong>格式</strong><br><a href="https://sm.ms/image/OD6Fxvcz7U1IsuP" target="_blank"><img src="https://s2.loli.net/2022/06/23/OD6Fxvcz7U1IsuP.png" ></a></p><p><strong>编码方式</strong></p><p><a href="https://sm.ms/image/bO2VIUrWYnGfBTl" target="_blank"><img src="https://s2.loli.net/2022/06/23/bO2VIUrWYnGfBTl.png" ></a></p><p><a href="https://sm.ms/image/EFtsVHRleOXjYGz" target="_blank"><img src="https://s2.loli.net/2022/06/23/EFtsVHRleOXjYGz.png" ></a></p><p><a href="https://sm.ms/image/FnYSmG6Th1Dy7OX" target="_blank"><img src="https://s2.loli.net/2022/06/23/FnYSmG6Th1Dy7OX.png" ></a></p><p><a href="https://sm.ms/image/lBfQGSecj1xbRir" target="_blank"><img src="https://s2.loli.net/2022/06/23/lBfQGSecj1xbRir.png" ></a></p><hr />版权信息]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理-指令系统</title>
      <link href="/2022/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"/>
      <url>/2022/06/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>指令：要求计算机完成某种操作的命令。<br><strong>指令系统：1台计算机所能执行的全部指令的集合。</strong></p><p>计算机的性能与它所设置的指令系统有很大关系，而指令系统的设置又与机器的硬件结构密切相关。<br>机器指令的基本要素：<br>操作码<br>操作数的地址<br>操作结果的存储地址<br>下一条指令的地址</p><p><a href="https://sm.ms/image/ZBzuHGcbDaMfi3v" target="_blank"><img src="https://s2.loli.net/2022/06/22/ZBzuHGcbDaMfi3v.png" ></a></p><span id="more"></span><h1 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h1><p>计算机的指令格式与机器的字长、存储器的容量及指令的功能都有很大关系。</p><p>从机器指令的基本要素可知，一条指令包括两种信息：<strong>操作码和地址码</strong>。</p><p>操作码（operation code）：用来表示指令所要完成的操作(如加、减、乘、除、数据传送等)，其长度取决于指令系统中指令的条数。</p><p>地址码：用来描述指令的操作对象。或者直接给出操作数、或者指出操作数的存储地址或寄存器地址(即寄存器名)。</p><p><a href="https://sm.ms/image/xWrsiaveQNfA6E7" target="_blank"><img src="https://s2.loli.net/2022/06/21/xWrsiaveQNfA6E7.png" ></a></p><p>n位操作码可以定义2^n 条指令</p><h1 id="拓展操作码"><a href="#拓展操作码" class="headerlink" title="拓展操作码"></a>拓展操作码</h1><p>器字长位16位，用15/15/15扩展法可以设计一个具有15条三地址指令、15条双地址指令、15条单地址指令和16条零地址指令的指令系统</p><p><a href="https://sm.ms/image/nKU4ZgGrDqh1bBW" target="_blank"><img src="https://s2.loli.net/2022/06/21/nKU4ZgGrDqh1bBW.png" ></a></p><p>拓展思路：<br>设地址长度为n<br>上一层留出m种状态，下一层可拓展m*2^n种状态</p><p><a href="https://sm.ms/image/EDqNY35sZ9AWUi1" target="_blank"><img src="https://s2.loli.net/2022/06/21/EDqNY35sZ9AWUi1.png" ></a></p><h1 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h1><p>方式                 算法                 优点                     缺点           访存次数(执行期间)<br>立即               操作数=A           无存储器访问            操作数大小受限          0<br>直接               EA=A                   简单                   地址范围有限        1<br>间接               EA=(A)             大的地址范围            多重存储器访问          2<br>寄存器             EA=R                无存储器访问             地址范围有限          0<br>寄存器间接          EA=(R)              大的地址范围            额外地址访问           1<br>偏移               EA=A+(R)               灵活                    复杂               1<br>堆栈               EA=栈顶              无存储器访问              应用有限</p><p><a href="https://sm.ms/image/k6ZWhsAXx7BjClS" target="_blank"><img src="https://s2.loli.net/2022/06/22/k6ZWhsAXx7BjClS.png" ></a></p><p><a href="https://sm.ms/image/nS9tfvlFGAdrmiN" target="_blank"><img src="https://s2.loli.net/2022/06/22/nS9tfvlFGAdrmiN.png" ></a></p><p><a href="https://sm.ms/image/TBQYOV3H1s7cod9" target="_blank"><img src="https://s2.loli.net/2022/06/22/TBQYOV3H1s7cod9.png" ></a></p><p><a href="https://sm.ms/image/pjioez9wXZJ37Em" target="_blank"><img src="https://s2.loli.net/2022/06/22/pjioez9wXZJ37Em.png" ></a></p><p><a href="https://sm.ms/image/pqOaijgm4QP1BWk" target="_blank"><img src="https://s2.loli.net/2022/06/22/pqOaijgm4QP1BWk.png" ></a></p><p><a href="https://sm.ms/image/SHP3uXbOAWslLq1" target="_blank"><img src="https://s2.loli.net/2022/06/22/SHP3uXbOAWslLq1.png" ></a></p><p><a href="https://sm.ms/image/Lu76NVml8rbAItc" target="_blank"><img src="https://s2.loli.net/2022/06/22/Lu76NVml8rbAItc.png" ></a></p><p><a href="https://sm.ms/image/75dqoFezIgmlTZ8" target="_blank"><img src="https://s2.loli.net/2022/06/22/75dqoFezIgmlTZ8.png" ></a></p><h1 id="CISC-和-RISC"><a href="#CISC-和-RISC" class="headerlink" title="CISC 和 RISC"></a>CISC 和 RISC</h1><p>1、CISC计算机<br>CISC：复杂指令系统(集)计算机 (complex instruction set computer)的缩写。<br>一条指令完成一个复杂的功能<br>  DEC公司的VAX11/780计算机、Intel公司的80x86微处理器、IBM公司的大、中型计算机都是CISC。<br>2、RISC计算机<br>   RISC：精简指令系统(集)计算机 (reduced instruction set computer)的缩写。<br>   一条指令完成一个基本动作 多条指令组合完成一个复杂的基本功能</p><hr />版权信息]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库-关系数据</title>
      <link href="/2022/06/15/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE/"/>
      <url>/2022/06/15/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>关系：笛卡尔积的一个子集，是一张二维表。没有重复的元组。</p><p>关系模式：用于定义关系，记作 [公式] 。<br>R：关系名，U：属性名集合，D：属性的域（的集合？)，DOM属性向域的映象集合（？什么鬼，是指属性和域的对应关系吗？），F：属性间数据依赖关系的集合（数据依赖后文会定义）。</p><p>关系数据库：基于关系模型的数据库，形式上由一组关系组成。</p><p>关系数据库模式：定义这组关系的关系模式全体，关系模式的集合。</p><p>数据依赖：包括函数依赖和多值依赖</p><p><strong>函数依赖：某个属性集决定另一个属性集时，称另一属性集依赖于该属性集。</strong></p><span id="more"></span><h1 id="码"><a href="#码" class="headerlink" title="码"></a>码</h1><p>候选码、主属性、非主属性、全码、主码：</p><p>被整个属性组完全函数依赖的属性组是候选码。</p><p>候选码包含的属性就是主属性，反之为非主属性。</p><p>全码：整个属性组都是候选码。</p><p>主码：候选码里选一个喜欢的当主码。</p><p>可以当主码的就是候选码，属于候选码的属性是主属性</p><h1 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h1><p><a href="https://blog.csdn.net/lqiqil/article/details/102801521?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-102801521-blog-124936003.pc_relevant_downloadblacklistv1&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3">https://blog.csdn.net/lqiqil/article/details/102801521?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-102801521-blog-124936003.pc_relevant_downloadblacklistv1&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3</a></p><h2 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h2><p>部分函数依赖：设X,Y是关系R的两个属性集合，存在X→Y，若X’是X的真子集，存在X’→Y，则称Y部分函数依赖于X。</p><p>完全函数依赖：设X,Y是关系R的两个属性集合，X’是X的真子集，存在X→Y，但对每一个X’都有X’!→Y，则称Y完全函数依赖于X。</p><p>传递函数依赖：设X,Y,Z是关系R中互不相同的属性集合，存在X→Y(Y !→X),Y→Z，则称Z传递函数依赖于X。</p><h2 id="四个范式"><a href="#四个范式" class="headerlink" title="四个范式"></a>四个范式</h2><p>1NF：如果一个关系模式R的所有属性都是不可分的基本数据项，则R∈1NF。可能存在增删改异常和数据冗余。</p><p>2NF：若关系模式R∈1NF，并且每一个非主属性都完全函数依赖于R的候选码，则R∈2NF。可能存在增删改异常和数据冗余。</p><p>3NF：若关系模式R∈2NF，并且非主属性都不传递依赖于R的候选码。基本上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。可能存在增删改异常和数据冗余。</p><p>BCNF：若关系模式R∈3NF，并且主属性也不传递依赖或部分依赖于R的候选码。每个属性都不部分依赖于候选码也不传递依赖于候选码，那么R是BC范式 。</p><h1 id="xx3x"><a href="#xx3x" class="headerlink" title="xx3x"></a>xx3x</h1><hr />版权信息]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> 关系数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库设计</title>
      <link href="/2022/06/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/"/>
      <url>/2022/06/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>•按照规范设计法，考虑数据库及其应用系统开发全过<br>程，可将数据库设计分为以下六个阶段：<br>• 需求分析阶段<br>  分析用户数据需求与处理需求。<br>• 概念结构设计阶级<br>  对用户需求进行综合、归纳与抽象，形成独立于<br>  具体DBMS的概念模型(E-R图)<br>• 逻辑结构设计阶段<br>  首先将E-R图转换成具体的DBMS支持的数据模型，如关系模型，形成数据库逻辑模式<br>  •然后根据用户处理的要求、安全性的考虑，在基本表的基础上再建立必要的视图(View)，形成数据的外模式<br>• 物理结构设计阶段<br>  为逻辑数据模型选取一个最适合应用环境的物理结构（包括存储结构和存取方法）<br>• 数据库实施阶段<br>  设计人员运用DBMS提供的数据语言及宿主语言，根据逻辑设计和物理设计的结果<br>  •建立数据库<br>  •编制与调试应用程序<br>  •组织数据入库<br>  •并进行试运行<br>• 数据库运行和维护阶段<br>  数据库应用系统经过试运行后即可投入正式运行，在数据库系统运行过程中不断进行评价、调整、修改等维护工作。<br>•需求分析和概念设计独立于任何数据库管理系统<br>•逻辑设计和物理设计与选用的DBMS密切相关</p><span id="more"></span><h1 id="ER模型"><a href="#ER模型" class="headerlink" title="ER模型"></a>ER模型</h1><p>三要素：<br>•实体<br>•联系<br>•属性</p><h2 id="模型结构"><a href="#模型结构" class="headerlink" title="模型结构"></a>模型结构</h2><p>（1） 实体集用矩形框表示，矩形框内写上实体名。</p><p>（2） 实体的属性用椭圆框表示，框内写上属性名，并用无向边与其实体集相连。</p><p>（3） 实体间的联系用菱形框表示，联系以适当的含义命名，名字写在菱形框中，用无向连线将参加联系的实体矩形框分别与菱形框相连，并在连线上标明联系的类型，即1—1、1—N或M—N。</p><p>（4）主键的名称下加实线</p><p><a href="https://sm.ms/image/6V4iWbL7QKJMmYO" target="_blank"><img src="https://s2.loli.net/2022/06/26/6V4iWbL7QKJMmYO.png" ></a></p><p><a href="https://sm.ms/image/XQFPUhOfybRjTu6" target="_blank"><img src="https://s2.loli.net/2022/06/26/XQFPUhOfybRjTu6.png" ></a></p><p><a href="https://sm.ms/image/3wh6u7oJRtpGZOm" target="_blank"><img src="https://s2.loli.net/2022/06/26/3wh6u7oJRtpGZOm.png" ></a></p><h2 id="弱实体和强实体"><a href="#弱实体和强实体" class="headerlink" title="弱实体和强实体"></a>弱实体和强实体</h2><p>弱实体：一个实体必须依赖于另一个实体存在，那么前者是弱实体，后者是强实体，弱实体必须依赖强实体存在，例如学生实体和成绩单实体，成绩单依赖于学生实体而存在，因此学生是强实体，而成绩单是弱实体。</p><p>弱实体和强实体的联系必然只有1：N或者1：1，这是由于弱实体完全依赖于强实体，强实体不存在，那么弱实体就不存在，所以弱实体是完全参与联系的，<strong>因此弱实体与联系之间的联系也是用的双线菱形</strong>。</p><p>复合实体：复合实体也称联合实体或桥接实体，常常用于实现两个或多个实体间的M：N联系，它由每个关联实体的主玛组成，用长方体内加一个菱形来表示</p><p><a href="https://sm.ms/image/AtzIeaLgbcdrNxX" target="_blank"><img src="https://s2.loli.net/2022/06/26/AtzIeaLgbcdrNxX.png" ></a></p><h1 id="xx2x"><a href="#xx2x" class="headerlink" title="xx2x"></a>xx2x</h1><h1 id="xx3x"><a href="#xx3x" class="headerlink" title="xx3x"></a>xx3x</h1><hr />版权信息]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> 数据库设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库-事务</title>
      <link href="/2022/06/13/%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/"/>
      <url>/2022/06/13/%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>把多条语句作为一个整体进行操作的功能，被称为数据库事务。数据库事务可以确保该事务范围内的所有操作都可以全部成</p><p>功或者全部失败。如果事务失败，那么效果就和没有执行这些SQL一样，不会对数据库数据有任何改动。</p><p><a href="https://blog.csdn.net/qq_42192693/article/details/109963032">https://blog.csdn.net/qq_42192693/article/details/109963032</a></p><span id="more"></span><h1 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h1><p>数据库事务具有ACID这4个特性：</p><p>A：Atomic，原子性，将所有SQL作为原子工作单元执行，要么全部执行，要么全部不执行；<br>C：Consistent，一致性，事务完成后，所有数据的状态都是一致的，即A账户只要减去了100，B账户则必定加上了100；<br>I：Isolation，隔离性，如果有多个事务并发执行，每个事务作出的修改必须与其他事务隔离；<br>D：Duration，持久性，即事务完成后，对数据库数据的修改被持久化存储。</p><p>对于单条SQL语句，数据库系统自动将其作为一个事务执行，这种事务被称为<strong>隐式事务</strong>。</p><p>要手动把多条SQL语句作为一个事务执行，使用BEGIN开启一个事务，使用COMMIT提交一个事务，这种事务被称为<strong>显式事务</strong></p><h1 id="rollback-commit"><a href="#rollback-commit" class="headerlink" title="rollback/commit"></a>rollback/commit</h1><ol><li><p>使用 <strong>begin + transaction_name</strong> 来创建一个事务</p></li><li><p>commit 指提交事务，即尝试将事务内的SQL做出的修改尝试保存。</p></li><li><p>rollback 指回滚，主动让事务失败，事务内的SQL语句不生效</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BEGIN TRANsaction </span><br><span class="line">     Update student set sage=sage+1 where sno=’0001’</span><br><span class="line">     Select * from student where sno=’0002’</span><br><span class="line"></span><br><span class="line">ROLLBACK  TRANsaction</span><br><span class="line"></span><br><span class="line">commit transaction</span><br></pre></td></tr></table></figure><h1 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h1><p>事务是并发控制的基本单位</p><h2 id="封锁协议"><a href="#封锁协议" class="headerlink" title="封锁协议"></a>封锁协议</h2><p><a href="https://blog.csdn.net/weixin_40448140/article/details/115269643">https://blog.csdn.net/weixin_40448140/article/details/115269643</a></p><p>S锁 - 排他锁、写锁 只允许读取事务和修改数据对象</p><p>X锁 - 共享锁、读锁 只允许读取数据对象但不能修改数据对象</p><p><strong>第一类封锁协议</strong><br>第一类封锁协议指的是在对数据进行修改操作时需要对数据添加X锁.第一类封锁协议相当于把数据的读取和修改看成一个整体,在事务完成之前其他事务都不能对数据进行修改操作.</p><p><strong>第二类封锁协议</strong><br>第二类封锁协议是在第一类封锁协议的基础上加入了S锁.在读取数据前需要对数据添加S锁, 当数据读取完成后释放S锁 .如果一个事务读取数据并添加了S锁,另一个事务添加了X锁,那么添加X锁的那个事务必须等待添加了S锁的事务释放S锁后才能对数据进行修改操作.</p><p><strong>第三类封锁协议</strong><br>第三类封锁协议是在第一类封锁协议的基础上加入了S锁,在读取数据前需要对数据添加S锁, <strong>当事务结束后释放S锁</strong>.第三类封锁协议同时解决了数据的修改丢失,不可重复读和读脏数据问题.</p><h2 id="活锁-死锁"><a href="#活锁-死锁" class="headerlink" title="活锁/死锁"></a>活锁/死锁</h2><p><a href="https://sm.ms/image/DzEbiMu4OVh8XWm" target="_blank"><img src="https://s2.loli.net/2022/06/15/DzEbiMu4OVh8XWm.png" ></a></p><p>避免活锁：采用先来先服务的策略；当多个事务请求封锁同一数据对象时，按请求封锁的先后次序对这些事务排队，该数据对象上的锁一旦释放，首先批准申请队列中第一个事务获得锁。</p><p><a href="https://sm.ms/image/3OpRzWXJSKM4YoP" target="_blank"><img src="https://s2.loli.net/2022/06/15/3OpRzWXJSKM4YoP.png" ></a></p><p>解决死锁方法： 预防死锁（一次性封锁法和顺序封锁法）、诊断死锁并解除（超时法和等待图法）。<br>一次性封锁法：每个事务必须将所要求的数据对象全部上锁后才能执行读写操作，否则释放占用的资源。<br>顺序封锁法：对所有数据对象规定一个封锁顺序，所有事务均按这个顺序实行封锁。</p><h2 id="可串行性"><a href="#可串行性" class="headerlink" title="可串行性"></a>可串行性</h2><p><strong>可串行化调度</strong>：多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行这些事务时的结果相同。</p><p>可串行性是并发事务正确调度的准则，一个给定的并发调度，当且仅当它是可串行化的，才认为是正确调度。对若干个事务，不同的并发调度策略其最终的执行结果不一定完全相同。但只要它们的调度是可串行化的，则都是正确调度。                                                           </p><p><strong>冲突操作</strong>：是指不同的事务对同一数据的读写操作和写写操作。</p><p>一个调度Sc在保证冲突操作的次序不变的情况下，通过交换两个事务不冲突操作的次序得到另一个调度Sc’，如果Sc’是串行的，称调度Sc是<strong>冲突可串行化的调度</strong>。</p><p><strong>冲突可串行化调度是可串行化调度的充分条件</strong>，不是必要条件。还有不满足冲突可串行化条件的可串行化调度。</p><h2 id="两段锁协议"><a href="#两段锁协议" class="headerlink" title="两段锁协议"></a>两段锁协议</h2><p>数据库管理系统普遍采用两段锁协议的方法实现并发调度的可串行性，从而保证调度的正确性</p><p>两段封锁协议（也称两相上锁协议，简写2PL）指所有事务必须分两个阶段对数据项加锁和解锁。</p><p>（1）在对任何数据进行读、写操作之前，事务首先要申请并获得对该数据的封锁（读时S锁，写时X锁）；</p><p>（2）在释放一个封锁之后，事务不再申请和获得新的封锁。</p><p> “两段”锁的含义是事务分为两个阶段</p><p>第一阶段是获得封锁，也称为扩展阶段事务可以申请获得任何数据项上的任何类型的锁，但是不能释放任何锁<br>第二阶段是释放封锁，也称为收缩阶段事务可以释放任何数据项上的任何类型的锁，但是不能再申请任何锁<br>若所有事务都遵守两段封锁协议，则对这些事务的任何并发调度策略都是可串行化的。</p><h2 id="粒度"><a href="#粒度" class="headerlink" title="粒度"></a>粒度</h2><p>封锁的粒度：封锁对象的大小。可以是数据库、表、记录、字段等。</p><p>封锁粒度与系统的并发度和并发控制的开销密切相关。封锁的粒度越大，数据库所能够封锁的数据单元就越少，并发度就越小，系统开销也越小；封锁的粒度越小，并发度较高，但系统开销也就越大。</p><h1 id="数据库恢复"><a href="#数据库恢复" class="headerlink" title="数据库恢复"></a>数据库恢复</h1><p>计算机硬件故障<br>软件的错误<br>操作员的失误<br>恶意的破坏<br>故障的影响<br>运行事务非正常中断，影响数据库中数据的正确性<br>破坏数据库；全部或部分丢失数据</p><h2 id="数据库的恢复"><a href="#数据库的恢复" class="headerlink" title="数据库的恢复"></a>数据库的恢复</h2><p>数据库管理系统必须具有把数据库从错误状态恢复到某一已知的正确状态（亦称为一致状态或完整状态）的功能，这就是数据库的恢复管理系统对故障的对策</p><p>恢复子系统是数据库管理系统的一个重要组成部分<br>恢复技术是衡量系统优劣的重要指标</p><h2 id="故障的种类"><a href="#故障的种类" class="headerlink" title="故障的种类"></a>故障的种类</h2><ol><li>事务内部的故障</li></ol><p>有的是可以通过事务程序本身发现的（转账事务的例子）。有的是非预期的，不能由事务程序处理的。（如运算溢出、并发事务发生死锁而被选中撤销该事务、违反了某些完整性限制等）</p><ol start="2"><li>系统故障</li></ol><p>称为软故障，是指造成系统停止运转的任何事件，使得系统要重新启动。如：整个系统的正常运行突然被破坏、所有正在运行的事务都非正常终止、不破坏数据库、内存中数据库缓冲区的信息全部丢失。常见原因：特定类型的硬件错误（如CPU故障）、操作系统故障、DBMS代码错误、系统断电等。</p><ol start="3"><li>介质故障</li></ol><p>称为硬故障，指外存故障，如：磁盘损坏、磁头碰撞、操作系统的某种潜在错误、瞬时强磁场干扰。介质故障破坏数据库或部分数据库，并影响正在存取这部分数据的所有事务。</p><p>介质故障比前两类故障的可能性小得多，但破坏性大得多。</p><ol start="4"><li>计算机病毒</li></ol><p>一种人为的故障或破坏，是一些恶作剧者研制的一种计算机程序。可以繁殖和传播，造成对计算机系统包括数据库的危害。</p><h2 id="恢复的实现技术"><a href="#恢复的实现技术" class="headerlink" title="恢复的实现技术"></a>恢复的实现技术</h2><p>恢复操作的基本原理：冗余</p><p>利用存储这系统其他地方的冗余数据来重建数据库中已被破坏或不正确的那部分数据</p><p>恢复的实现技术：复杂</p><p>一个大型数据库产品，恢复子系统的代码要占全部代码的10%以上</p><p>恢复机制涉及的关键问题</p><p>如何建立冗余数据（恢复方式）</p><p>数据转储（backup）转储是指DBA将整个数据库复制到磁带或另一个磁盘上保存起来的过程</p><p>备用的数据文本称为后备副本或后援副本</p><p><strong>登录日志文件（logging）日志文件（log）是用来记录事务对数据库的更新操作的文件</strong></p><p>如何利用这些冗余数据实施数据库恢复</p><h2 id="恢复策略"><a href="#恢复策略" class="headerlink" title="恢复策略"></a>恢复策略</h2><ol><li>事务故障：事务在运行至正常终止点前被终止。</li></ol><p>恢复策略：由恢复子系统利用日志文件撤消（ UNDO ）此事务已对数据库进行的修改，使得该事务像根本没有启 动过一样。</p><p>事务故障的恢复由系统自动完成，对用户是透明的，不需要用户干预</p><ol start="2"><li>系统故障 造成数据库不一致状态的原因：</li></ol><p>①未完成事务对数据库的更新已写入数据库</p><p>②已提交事务对数据库的更新还留 在 缓冲区没来得及写入数据库。</p><p>恢复策略：</p><p>①Undo 故障发生时未完成的事务</p><p>②Redo 已完成的事务 系统故障的恢复由系统在 重新启动时 自动完成，不需要用户干预</p><ol start="3"><li>介质故障: 称为硬故障，指外存故障，如：磁盘损坏、磁头碰撞、操作系统的某种潜在错误、瞬时强磁场干扰。</li></ol><p>恢复策略：</p><p>①重装数据库</p><p>②重做已完成的事务</p><p>介质故障的恢复需要 DBA 介入，DBA 的工作</p><p>①重装最近转储的数据库副本和有关的各日志文件副本</p><p>②执行系统 提供的恢复命令。具体的恢复操作仍由 DBMS 完成。</p><hr />版权信息]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>语法制导的翻译</title>
      <link href="/2022/06/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%9A%84%E7%BF%BB%E8%AF%91/"/>
      <url>/2022/06/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%9A%84%E7%BF%BB%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>将语义分析和中间代码生成统称为语义翻译，而语义翻译和语法分析统称为语法制导翻译</p><p><a href="https://blog.csdn.net/qq_33414271/article/details/95333962">https://blog.csdn.net/qq_33414271/article/details/95333962</a></p><span id="more"></span><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><ol><li>语法制导定义SDD：上下文无关文法+属性+规则</li></ol><p><strong>属性：和文法符号相关联</strong><br>每个文法符号都有一个相关的属性集，属性可以代表任何对象：字符串、数字、类型、内存单元或其他对象。<br>与这些属性相关的信息，即属性值可以在语法分析过程中计算和传递。属性加工的过程即语义的处理过程。</p><p><strong>规则：和产生式相关联</strong></p><ol start="2"><li><p>语法制导翻译方案SDT：文法产生式和语义规则交错<br>把语义规则用{}括起来，插入到规则右部的合适位置上，指明了语义规则的计算顺序，以便说明某些实现细节<br>高效、适合用于翻译的实现，一个语义动作在产生式中的位置决定了这个动作的执行时间<br>可以看作是对SDD的一种补充，是SDD的具体实施方案<br>显式地指明了语义规则的计算顺序，以便说明某些实现细节</p></li><li><p>综合属性<br>在分析树结点N上的非终结符A的综合属性只能通过N的子结点或N本身的属性值来定义<br>产生式 E → E1 + T<br>语义规则 E.val =E1.val + T.val<br><a href="https://sm.ms/image/hF23EsDWfGvrqBH" target="_blank"><img src="https://s2.loli.net/2022/06/17/hF23EsDWfGvrqBH.png" ></a></p></li><li><p>继承属性<br>在分析树结点N上的非终结符A的继承属性只能通过 N的父结点、N的兄弟结点或N本身的属性值来定义 。<br>产生式 D →T L<br>语义规则 L.inh= T.typeL<br><a href="https://sm.ms/image/ZkPwGbjzvAaRChV" target="_blank"><img src="https://s2.loli.net/2022/06/17/ZkPwGbjzvAaRChV.png" ></a><br>终结符没有继承属性。终结符从词法分析器处获得的属性值被归为综合属性值。</p></li><li><p>属性依赖图<br>给定一棵语法分析树和一个SDD，我们在各个语法分析树结点所关联的属性实例之间画上边，以指明位于边的头部的属性值要根据位于边的尾部的属性值计算得到。</p></li></ol><hr />版权信息]]></content>
      
      
      <categories>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语法制导翻译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理-语法分析</title>
      <link href="/2022/06/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/"/>
      <url>/2022/06/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><span id="more"></span><h1 id="上下文无关文法定义"><a href="#上下文无关文法定义" class="headerlink" title="上下文无关文法定义"></a>上下文无关文法定义</h1><p><a href="https://sm.ms/image/PNZyGmSsribpeCa" target="_blank"><img src="https://s2.loli.net/2022/06/17/PNZyGmSsribpeCa.png" ></a></p><p>由上下文无关文法生成的语言是上下文无关语言(CFL)。</p><h2 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h2><p><a href="https://sm.ms/image/PSjsKY7DxWOFQG2" target="_blank"><img src="https://s2.loli.net/2022/06/17/PSjsKY7DxWOFQG2.png" ></a></p><h1 id="语法错误处理机制"><a href="#语法错误处理机制" class="headerlink" title="语法错误处理机制"></a>语法错误处理机制</h1><p>一个文法，如果存在某个句子不止一棵分析树，或者说这个句子存在不止一种最左（最右）推导，那么称这个文法是二义的。</p><p><strong>消除二义性</strong></p><p>改写二义文法的关键步骤：</p><p>划分优先级和结合性<br>引入一个新的非终结符，增加一个子结构并提高一级优先级（优先级的判断）；<br>递归非终结符在终结符左边，运算具有左结合性，否则具有右结合性。</p><p><a href="https://sm.ms/image/t2vFunjK5AhaDVQ" target="_blank"><img src="https://s2.loli.net/2022/06/17/t2vFunjK5AhaDVQ.png" ></a></p><h2 id="消除左递归"><a href="#消除左递归" class="headerlink" title="消除左递归"></a>消除左递归</h2><p><a href="https://blog.csdn.net/qq2071114140/article/details/102787831">https://blog.csdn.net/qq2071114140/article/details/102787831</a></p><p>一个文法是左递归的，如果它有非终结符A，对某个串α，存在推导A =&gt; +Aα。</p><p>自顶向下语法分析不能处理左递归的方法，因此需要一个转换方法消除左递归。</p><p><a href="https://sm.ms/image/Wh7RnfweOJlZzpa" target="_blank"><img src="https://s2.loli.net/2022/06/17/Wh7RnfweOJlZzpa.png" ></a></p><p><a href="https://sm.ms/image/rj9nEzqmkOSKJif" target="_blank"><img src="https://s2.loli.net/2022/06/17/rj9nEzqmkOSKJif.png" ></a></p><p>不是之间左递归则转换为直接左递归</p><p>eg：<br>S → Aa | b<br>A → Aad | bd | ε</p><p>S → Aa | b<br>A → bdA’ | A’<br>A’→ adA’ | ε</p><h1 id="自顶向下语法分析"><a href="#自顶向下语法分析" class="headerlink" title="自顶向下语法分析"></a>自顶向下语法分析</h1><h2 id="first-follow集"><a href="#first-follow集" class="headerlink" title="first/follow集"></a>first/follow集</h2><p><a href="https://blog.csdn.net/RENSRM/article/details/111595754">https://blog.csdn.net/RENSRM/article/details/111595754</a></p><p>FIRST(α)被定义为可从α推导得到的串的首符号的集合，其中α是任意的文法符号串<br><a href="https://sm.ms/image/Cr9wlYHtuSze1da" target="_blank"><img src="https://s2.loli.net/2022/06/17/Cr9wlYHtuSze1da.png" ></a><br><a href="https://sm.ms/image/DzglIiXdoB2QhMH" target="_blank"><img src="https://s2.loli.net/2022/06/17/DzglIiXdoB2QhMH.png" ></a></p><p>FOLLOW(A)被定义为可能在某些举行中紧跟在 A 右边的终结符号的集合。<br><a href="https://sm.ms/image/FjSOXfoWsV6iDPv" target="_blank"><img src="https://s2.loli.net/2022/06/17/FjSOXfoWsV6iDPv.png" ></a><br><a href="https://sm.ms/image/wXo9DnCaky1Kh2E" target="_blank"><img src="https://s2.loli.net/2022/06/17/wXo9DnCaky1Kh2E.png" ></a></p><h2 id="构造预测分析表"><a href="#构造预测分析表" class="headerlink" title="构造预测分析表"></a>构造预测分析表</h2><ol><li>当非终结符遇到其First集中的终结符时填入相应候选式</li><li>当非终结符的First集中含有ε元素时，遇到其Follow集中的终结符时填入 非终结符→ ε </li></ol><p><a href="https://sm.ms/image/DC9vnpNFqImTRGi" target="_blank"><img src="https://s2.loli.net/2022/06/17/DC9vnpNFqImTRGi.png" ></a><br><a href="https://sm.ms/image/3Co6gEQvVdpUfNS" target="_blank"><img src="https://s2.loli.net/2022/06/17/3Co6gEQvVdpUfNS.png" ></a></p><h1 id="自底向上语法分析"><a href="#自底向上语法分析" class="headerlink" title="自底向上语法分析"></a>自底向上语法分析</h1><p><a href="https://blog.csdn.net/qq_44202160/article/details/123145144">https://blog.csdn.net/qq_44202160/article/details/123145144</a><br><a href="https://blog.csdn.net/qq_30225253/article/details/106078803">https://blog.csdn.net/qq_30225253/article/details/106078803</a></p><p><a href="https://sm.ms/image/DEBv1YPoQe8LKRW" target="_blank"><img src="https://s2.loli.net/2022/06/17/DEBv1YPoQe8LKRW.png" ></a></p><h2 id="LR语法分析算法"><a href="#LR语法分析算法" class="headerlink" title="LR语法分析算法"></a>LR语法分析算法</h2><p>输入：一个输入串w和一个LR语法分析表。</p><p>输出：如果w在L(G)中，输出w的自底向上语法分析过程中的归约步骤；否则给出错误提示。</p><p>方法：最初，语法分析器栈中的内容为初试状态S0，输入缓冲区的内容为w $。然后，执行语法分析程序。</p><p><a href="https://sm.ms/image/3CDQ4lIWgakO78G" target="_blank"><img src="https://s2.loli.net/2022/06/17/3CDQ4lIWgakO78G.png" ></a><br><a href="https://sm.ms/image/SjPTMxwNdVRAKlz" target="_blank"><img src="https://s2.loli.net/2022/06/17/SjPTMxwNdVRAKlz.png" ></a></p><p>在当前状态(编号)下, 面对当前文法符号时, 该采取什么动作</p><p>ACTION表指明动作, GOTO表仅用于归约时的状态转换</p><p><a href="https://sm.ms/image/vc3yGxOuZDXCiTd" target="_blank"><img src="https://s2.loli.net/2022/06/17/vc3yGxOuZDXCiTd.png" ></a></p><h2 id="SLR分析表"><a href="#SLR分析表" class="headerlink" title="SLR分析表"></a>SLR分析表</h2><p>在右部的某个地方加点的产生式<br>加点的目的是用来表示分析过程中的状态</p><p>例，从A·XYZ文法可得到如下四个项目;<br>A ·XYZ<br>A -&gt; X·YZ<br>A -&gt; XY·Z<br>A -&gt; XYZ·</p><p>拓广文法<br>如果G是一个以S为开始符号的文法, 那么G的拓广文法G’就是在G中加上新开始符号S’和产生式S’ -&gt; S而得到的文法。</p><p>项集闭包的求法<br>如果I是文法G的一个项集，那么CLOSURE(I)就是根据下面的两个规则从I构造得到的项集:：</p><p>一开始，将I中的各个项加入到CLOSURE(I)中。<br>如果A -&gt; α•Bβ在CLOSURE(I)中，B-&gt;γ是一个产生式，并且B-&gt;•γ不在CLOSURE(I)中，就将这个项加入其中。不断应用这个规则，直至没有新项添加。（大概意思就是如果闭包里如果没有希望识别γ的状态，就添加这个状态）</p><p>构造SLR分析表</p><ol><li>构造LR(0)项目核心规范族</li></ol><p>从增广文法添加的那个文法开始求闭包得到 I0</p><p>在接收符号后 · 向后移一位 得到核心项目 非核心项目通过对核心项目求闭包得到 In</p><p><a href="https://sm.ms/image/5uY9VglcPLXp3D7" target="_blank"><img src="https://s2.loli.net/2022/06/17/5uY9VglcPLXp3D7.png" ></a><br><a href="https://sm.ms/image/yciMVDXSqOn7Qdh" target="_blank"><img src="https://s2.loli.net/2022/06/17/yciMVDXSqOn7Qdh.png" ></a></p><ol start="2"><li>构造分析表<br><a href="https://sm.ms/image/wZS4KlgcLC7FHbU" target="_blank"><img src="https://s2.loli.net/2022/06/17/wZS4KlgcLC7FHbU.png" ></a></li></ol><hr />版权信息]]></content>
      
      
      <categories>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语法分析 </tag>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java ArrayList</title>
      <link href="/2022/05/23/ArrayList/"/>
      <url>/2022/05/23/ArrayList/</url>
      
        <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>Java ArrayList 方法</p><p>sort函数的一些理解</p><p>Comparator接口的用法</p><span id="more"></span><h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><p>ArrayList是实现List接口的，底层采用数组实现。</p><p>ArrayList 实现了Cloneable接口，即覆盖了函数clone()，能被克隆。</p><p>ArrayList 实现java.io.Serializable接口，这意味着ArrayList支持序列化，能通过序列化去传输。</p><p>头文件<br>import java.util.ArrayList;</p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p><a href="https://blog.csdn.net/ly0724ok/article/details/117966154/">https://blog.csdn.net/ly0724ok/article/details/117966154/</a></p><p><a href="https://sm.ms/image/fOX4cxyuBvkgrKb" target="_blank"><img src="https://s2.loli.net/2022/05/23/fOX4cxyuBvkgrKb.png" ></a></p><h1 id="sort自定义排序"><a href="#sort自定义排序" class="headerlink" title="sort自定义排序"></a>sort自定义排序</h1><p>方法原型<br>void java.util.ArrayList.sort(Comparator&lt;? super Contury&gt; c)</p><p>Comparator接口具有比较的功能，接口注重容器<br>而Comparator接口中必须要实现的compare(T o1,T o2)有两个参数</p><p><strong>在数组sort中实现Comparator接口的重写</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">table.sort( new Comparator&lt;Contury&gt;() &#123;</span><br><span class="line">  @Override</span><br><span class="line">  // compare重写</span><br><span class="line">  public int compare(Contury c1,Contury c2)&#123;</span><br><span class="line">      if(c1.gold&gt;c2.gold)&#123;</span><br><span class="line">          return 0;</span><br><span class="line">      &#125;</span><br><span class="line">      else return -1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>直接重写Comparator接口</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class StudentComparator implements Comparator&lt;Student&gt;&#123;  </span><br><span class="line">    @Override  </span><br><span class="line">    public int compare(Student o1, Student o2) &#123;  </span><br><span class="line">        // TODO Auto-generated method stub  </span><br><span class="line">        if(o1.getScore()&gt;o2.getScore())  </span><br><span class="line">            return -1;  </span><br><span class="line">        else if(o1.getScore()&lt;o2.getScore())  </span><br><span class="line">            return 1;  </span><br><span class="line">        else&#123;  </span><br><span class="line">            if(o1.getAge()&gt;o2.getAge())  </span><br><span class="line">                return 1;  </span><br><span class="line">            else if(o1.getAge()&lt;o2.getAge())  </span><br><span class="line">                return -1;  </span><br><span class="line">            else   </span><br><span class="line">                return 0;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p><a href="https://blog.51cto.com/u_15338614/3582482">https://blog.51cto.com/u_15338614/3582482</a></p><h1 id="xx3x"><a href="#xx3x" class="headerlink" title="xx3x"></a>xx3x</h1><hr />版权信息]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java - ArrayList - Comparator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL-触发器</title>
      <link href="/2022/05/16/SQL-%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
      <url>/2022/05/16/SQL-%E8%A7%A6%E5%8F%91%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>触发器与存储过程非常相似，触发器也是 SQL 语句集，它是通过事件进行触发而被执行的，不能用 EXECUTE 语句调用；而存储过程可以通过存储过程名字而被直接调用。当对某一表进行诸如 UPDATE、INSERT、DELETE 这些操作时，SQL Server 就会自动执行触发器所定义的 SQL 语句，从而确保对数据的处理必须符合由这些 SQL 语句所定义的规则。</p><span id="more"></span><h1 id="DML触发器"><a href="#DML触发器" class="headerlink" title="DML触发器"></a>DML触发器</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ol><li><p>AFTER 触发器<br>又称后触发器。在执行了 INSERT、UPDATE 或 DELETE 语句操作之后执行 AFTER<br>触发器。如果仅指定 FOR 关键字，则 AFTER 为默认值。AFTER 触发器只能在表上指定，<br>可以为任何一个 DML 操作定义多个 AFTER 触发器</p></li><li><p>INSTEAD OF 触发器<br>又称替代触发器。INSTEAD OF 触发器在数据变动之前被触发，代替引起触发器执行<br>的 T-SQL 语句，即 INSTEAD OF 触发器执行时并不执行所定义的 INSERT、UPDATE 或<br>DELETE 操作，而仅执行触发器本身。</p></li></ol><h2 id="相关的逻辑表"><a href="#相关的逻辑表" class="headerlink" title="相关的逻辑表"></a>相关的逻辑表</h2><p>Inserted 表用于存储 INSERT 和 UPDATE 语句所影响的行的副本。在插入或更新事务<br>期间，新行将同时被添加到 Inserted 表和触发器表（即对其尝试执行了用户操作的表）。<br>Inserted 表中的行是触发器表中的新行的副本。<br>Deleted 表用于存储 DELETE 和 UPDATE 语句所影响的行的副本。在执行 DELETE<br>或 UPDATE 语句的过程中，行从触发器表中删除，并传输到 Deleted 表中。Deleted 表和触<br>发器表通常没有相同的行。</p><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER trigger_name </span><br><span class="line">ON &#123; OBJECT NAME &#125; </span><br><span class="line">&#123; FOR → AFTER → INSTEAD OF &#125; </span><br><span class="line">&#123;[INSERT][,][UPFATE][,][DELETE]&#125; </span><br><span class="line"> AS </span><br><span class="line">&#123; sql_statement [ ...n ] &#125;</span><br></pre></td></tr></table></figure><p>1） trigger_name ：指定触发器名称<br>2） OBJECT NAME ：要对其执行 DML 触发器的表或视图<br>3） { FOR → AFTER → INSTEAD OF } ：指定触发器的类型，如果仅指定 FOR 关键<br>字，则 AFTER 是默认值<br>4） {[INSERT][,][UPDATE][,][DELETE]} ：指定激活触发器的数据修改语句，必须至少<br>指定一项，在触发器定义中允许使用上述选项的任意顺序组合。<br>5） sql_statement：指定触发器所指定的 T-SQL 语句。<br>6） 在 DML 触发器中不允许使用下列 Transact-SQL 语句：CREATE /ALTER/ DROP<br>DATABASE、CREATE/DROP INDEX、DROP TABLE；用于执行以下操作的 ALTER TABLE：<br>添加、修改或删除列、添加或删除 PRIMARY KEY 或 UNIQUE 约束。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>创建一个触发器，在修改 SC 表中的 grade 列时，判断平均成绩是否大于 80，<br>如果大于 80，拒绝该修改操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER trgUpdateSC ON dbo.SC</span><br><span class="line">FOR UPDATE</span><br><span class="line">AS</span><br><span class="line">begin</span><br><span class="line">  IF UPDATE (Grade)</span><br><span class="line">    BEGIN</span><br><span class="line">    --判断平均 grade 是否大于 80，如果大于 80，回滚</span><br><span class="line">    if(select avg(Grade) from dbo.SC)&gt;80</span><br><span class="line">      begin</span><br><span class="line">      print &#x27;The average value of Grade cannot be more than 80&#x27;</span><br><span class="line">      rollback</span><br><span class="line">      end</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h1 id="DDL触发器"><a href="#DDL触发器" class="headerlink" title="DDL触发器"></a>DDL触发器</h1><p>DDL 触发器当服务器或者数据库中发生数据定义语言（DDL，CREATE、ALTER 和<br>DROP）事件时将被触发。</p><h2 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER trigger_name </span><br><span class="line">ON &#123; ALL SERVER → DATABASE &#125; </span><br><span class="line">[ WITH &lt;ddl_trigger_option&gt; [ ,...n ] ]</span><br><span class="line">&#123; FOR → AFTER &#125; &#123; event_type → event_group &#125; [ ,...n ]</span><br><span class="line">AS &#123; sql_statement [ ; ] [ ,...n ]&#125;</span><br></pre></td></tr></table></figure><p>1） DATABASE :将 DDL 触发器的作用域应用于当前数据库。如果指定了此参数，则<br>只要当前数据库中出现 event_type 或 event_group，就会激发该触发器。<br>2） ALL SERVER :将 DDL 触发器的作用域应用于当前服务器。如果指定了此参数，<br>则只要当前服务器中的任何位置上出现 event_type 或 event_group，就会激发该触发器。<br>3） event_type ：执行之后将导致激发 DDL 触发器的 T-SQL 语言事件的名称。<br>4） event_group ：预定义的 T-SQL 语言事件分组的名称。执行任何属于 event_group<br>的 T-SQL 语言事件之后，都将激发 DDL 触发器。</p><h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h2><p>为“Music”数据库创建 DDL 触发器，用于禁止对数据库中的表进行删除和修改操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER trg_safe ON DATABASE </span><br><span class="line">FOR DROP_TABLE, ALTER_TABLE </span><br><span class="line">AS </span><br><span class="line">PRINT &#x27;You must disable Trigger &quot; trg_safe&quot; to drop or alter tables!&#x27; </span><br><span class="line">ROLLBACK</span><br></pre></td></tr></table></figure><h1 id="管理触发器"><a href="#管理触发器" class="headerlink" title="管理触发器"></a>管理触发器</h1><h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec sp_helptext trg_delete</span><br></pre></td></tr></table></figure><h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ALTER TRIGGER trigger_name</span><br><span class="line">ON &#123; table → view &#125;</span><br><span class="line">&#123; &#123; FOR → AFTER → INSTEAD OF &#125;</span><br><span class="line">&#123; [DELETE] [,] [INSERT] [,] [UPDATE] &#125;</span><br><span class="line">AS</span><br><span class="line">&#123;sql_statement&#125;&#125;</span><br></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TRIGGER Trg_delete</span><br></pre></td></tr></table></figure><h2 id="禁用"><a href="#禁用" class="headerlink" title="禁用"></a>禁用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1）禁用对表的 DML 触发器</span><br><span class="line">DISABLE TRIGGER trg_delete ON Songs</span><br><span class="line"></span><br><span class="line">2）禁用对数据库的 DDL 触发器</span><br><span class="line">DISABLE TRIGGER trig_DDL ON DATABASE</span><br><span class="line"></span><br><span class="line">3）禁用以同一作用域定义的所有触发器</span><br><span class="line">DISABLE TRIGGER ALL ON ALL SERVER</span><br></pre></td></tr></table></figure><p>禁用之后的启用操作，应该使用语句 ENABLE TRIGGER，该语句的参数与对应的禁用语句相同。</p><hr />版权信息]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Transact-SQL</title>
      <link href="/2022/05/13/Transact-SQL/"/>
      <url>/2022/05/13/Transact-SQL/</url>
      
        <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>SQL Server 在支持标准 SQL 语言的同时，对其进行了扩充，引入了 T-SQL，即 Transact-SQL。通过 T-SQL，可以定义变量、使用流控制语句、自定义函数和存储过程，极大地扩展了 SQL Server 的功能。</p><span id="more"></span><h1 id="语法约定"><a href="#语法约定" class="headerlink" title="语法约定"></a>语法约定</h1><p><a href="https://sm.ms/image/ul2WgxJFGmYLaAs" target="_blank"><img src="https://s2.loli.net/2022/05/13/ul2WgxJFGmYLaAs.png" ></a></p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>注释语句不是可执行语句，不参与程序的编译、注释语句通常是用来说明代码的功能或<br>者对代码的实现方式给出简单的解释和提示。<br>在 T-SQL 中可使用两类注释符：</p><ol><li>“–”用于单行注释；</li><li>“/* */”用于多行注释。“/<em>”用于注释文字的开头，“</em>/”用于注释文字的结束。</li></ol><h1 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h1><p>SQL Server 有两类标识符：<br>1）常规标识符：符合标识符的格式规则。在 T-SQL 语句中使用常规标识符时不用将其<br>分隔开。<br><strong>常规标识符的定义规则如下：</strong><br>  1） 名称的长度可以从 1 到 128（对于本地临时表，标识符最多可以有 116 个字符）。<br>  2） 名称的第一个字符必须是一个字母或者“_”、“@”和“#”中的任意字符。<br>  3） 在中文版 SQL Server 中，可以直接使用中文名称。<br>  4） 名称中不能有空格<br>  5） 不允许使用 SQL Server 的保留字。<br>2）分隔标识符：在 T-SQL 中，不符合常规标识符定义规则的标识符必须用分隔符双引<br>号 (“) 或者方括号 ([ ])分隔，称为分隔标识符。例如：Select * from [my table]中，因为“my<br>table”中间含有空格，不符合常规标识符的定义规则，因此必须用分隔符 ([ ])进行分隔。</p><p><strong>使用</strong><br>[[[server.][database].][owner_name].] object_name<br>1）server：本地服务器；<br>2）database：当前数据库；<br>3）owner_name：在数据库中与当前连接会话登录标识相关联的数据库用户名或数据库<br>所有者（dbo）。<br>例如，需要引用 customer 数据库中 employee 表的 telephone 列，可指定 customer..<br>employee.telephone。</p><h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><ol><li><p>字符串<br>单引号内</p></li><li><p>Unicode字符串<br>与普通字符串类似，前面有N标识</p></li><li><p>二进制常量<br>前有 0x 标识</p></li><li><p>datetime 常量<br>datetime 常量使用特定格式的字符日期值来表示，并被单引号括起来。<br>下面是 datetime 常量的示例：<br>‘December 5, 1985’； ‘5 December, 1985’； ‘12/5/98’<br>‘851205’（其中的 0 不能省略）<br>下面是时间常量的示例：’14:30:24’； ‘04:24 PM’</p></li><li><p>int<br>不包含小数</p></li><li><p>decimal<br>包含小数点的数字</p></li><li><p>float/real<br>科学计数法表示</p></li><li><p>money<br>money 常量以前缀为可选的小数点和可选的货币符号的数字字符串来表示。money 常<br>量不使用引号括起。money 常量的示例：$542023.14，￥30。</p></li></ol><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>声明变量：<br>DECLARE @变量名 变量类型[,@变量名 变量类型…]</p><p>赋值：<br>SET @变量名=表达式<br>或：SELECT @局部变量=变量值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DECLARE @no varchar(10) </span><br><span class="line">--变量赋值</span><br><span class="line">SET @no=&#x27;Bj10001&#x27; </span><br><span class="line">--显示指定学生学号、姓名 </span><br><span class="line">SELECT Sid,Sname FROM student WHERE SID=@no</span><br></pre></td></tr></table></figure><p>全局变量是 SQL Server 系统内部使用的变量，其作用范围并不局限于某一程序，而是<br>任何程序均可随时调用。<br>格式：@@变量名。<br><a href="https://sm.ms/image/muU79kRgsFht4bn" target="_blank"><img src="https://s2.loli.net/2022/05/13/muU79kRgsFht4bn.png" alt="image.png"></a></p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><ol><li><p>ASCII 函数<br>函数格式：<br>ASCII（character_expression）<br>功能：求 character_expression（char 或 varchar 类型）左端第一个字符的 ASCII 码。<br>返回值数据类型：int。例如：<br>Select ASCII（’abcd’） –结果为字符 a 的 ASCII 码 97。</p></li><li><p>CHAR 函数<br>函数格式：<br>CHAR（integer_expression）<br>功能：求 ASCII 码 integer_expression 对应的字符，<br>integer_expression 的有效范围为[0,255]，如果超出范围，则返<br>回值 NULL。<br>返回值数据类型：CHAR。例如：<br>Select CHAR（97） –结果为’a’。<br>CHAR 可用于将控制字符插入字符串中。表 9- 8 显示了<br>一些常用的控制字符。<br>例9- 6: 使用回车符。<br>select ‘<strong>‘+char(13)+’</strong>*’<br>结果如图 9- 1 所示（注意，显示该结果时，在查询编辑器中，<br>需在查询工具栏选择“以文本格式显示结果”）。</p></li><li><p>UNICODE 函数<br>语法:<br>UNICODE ( ‘ncharacter_expression’ )<br>功能：按照 Unicode 标准的定义，返回输入表达式的第一个字<br>符的整数值。<br>返回类型：int。例如：<br>Select unicode(N’kerge’) –返回字符 k 的 unicode 值 107</p></li><li><p>NCHAR 函数<br>语法：NCHAR ( integer_expression )<br>功能: 根据 Unicode 标准所进行的定义，用给定整数代码返回 Unicode 字符。<br>integer_expression 介于 0 与 65535 之间的所有正整数。如果指定了超出此范围的值，将返<br>回 NULL。<br>返回类型：nchar(1)。例如：<br>select nchar(107) –返回 unicode 字符 k</p></li><li><p>CHARINDEX 函数<br>函数格式：<br>CHARINDEX（expression1, expression2[,start]）<br>功能：在 expression2 中由 start 指定的位置开始查找 expression1 第一次出现的位置，如<br>表 9- 8 控制字符及值<br>控制字符 值<br>制表符 CHAR(9)<br>换行符 CHAR(10)<br>回车 CHAR(13)<br>图 9- 1 char 函数示例<br>果没有找到，则返回 0。如果省略 start，或 start≤0，则从 expression2 的第一个字符开始。<br>返回类型：int。例如：<br>Select CHARINDEX(‘ab’, ‘123abc123abc’) –结果为 4。</p></li><li><p>LEFT 函数<br>函数格式：<br>LEFT（expression1,n）<br>功能：返回字符串 expression1 从左边开始 n 个字符组成的字符串。如果 n=0，则返回一<br>个空字符串。<br>返回类型：varchar。例如：<br>LEFT(‘abcde’, 3) –结果为’abc’。 例 9- 7：找出 dbo.student 中名字以’刘’开头的学生信息。<br>select sno,sname from dbo.student where left(sname,1)=’刘’</p></li><li><p>RIGHT 函数<br>函数格式：<br>RIGHT（expression1,n）<br>功能：返回字符串 expression1 从右边开始 n 个字符组成的字符串。如果 n=0，则返回一<br>个空字符串。<br>返回类型：varchar。例如：<br>Select RIGHT(‘abcde’, 3) –结果为’cde’。</p></li><li><p>SUBSTRING 函数<br>函数格式：<br>SUBSTRING（expression1,start,length）<br>功能：返回 expression1（数据类型为字符串、binary、text 或 image）中从 start 开始长<br>度为 length 个字符或字节的子串。<br>返回值：数据类型与 expression1 数据类型相同，但 text 类型返回值为 varchar，image 类<br>型返回值为 varbinary，next 类型返回值为 nvarchar。例如：<br>Select SUBSTRING(‘abcde123’,3,4) –结果为’cde1’。 例 9- 7 也可以写成：<br>select sno,sname from dbo.student where substring(sname,1,1)=’刘’</p></li><li><p>LEN 函数<br>函数格式：<br>LEN（expression1）<br>功能：返回字符串 expression1 中的字符个数，不包括字符串末尾的空格。<br>返回类型：int。例如：<br>Select LEN(‘abcde ‘) –结果为 5。<br>select len(‘刘’) –结果为 1。</p></li><li><p>DATALENGTH 函数<br>DATALENGTH ( expression )<br>功能：返回用于表示任何表达式的字节数。<br>返回类型：int。例如：<br>Select DATALENGTH(‘abcde ‘) –结果为 8（含 3 个空格）。<br>select DATALENGTH(‘刘’) –结果为 2。</p></li><li><p>LOWER 函数<br>函数格式：<br>LOWER（expression1）<br>功能：将字符串 expression1 中的大写字母替换为小写字母。<br>返回类型：varchar。例如：<br>Select LOWER(‘12ABC45*%^def’) –结果为’12abc45*%^def’。</p></li><li><p>UPPER 函数<br>函数格式：<br>UPPER（expression1）<br>功能：将字符串 expression1 中的小写字母替换为大写字母。<br>返回类型：varchar。例如：<br>Select UPPER(‘12ABC45*%^def’) –结果为’12ABC45 *%^DEF’。</p></li><li><p>LTRIM 函数<br>函数格式：<br>LTRIM（expression1）<br>功能：删除字符串 expression1 左端的空格。<br>返回类型：varchar。例如：<br>Select LTRIM(‘ 12AB’) –结果为’12AB’。</p></li><li><p>RTRIM 函数<br>函数格式：<br>RTRIM（expression1）<br>功能：删除字符串 expression1 末尾的空格。<br>返回类型：varchar。例如：<br>Select RTRIM(LTRIM(‘ 12AB ‘)) –结果为’12AB’。</p></li><li><p>REPLACE 函数<br>函数格式：<br>REPLACE（expression1, expression2, expression3）<br>功能：将字符串 expression1 中所有的子字符串 expression2 替换为 expression3。<br>返回值数据类型：varchar。例如：<br>Select REPLACE(‘abcde’,’de’,’12’) –结果为’abc12’。</p></li><li><p>STUFF 函数<br>语法:<br>STUFF (character_expression,start,length,character_expression )<br>功能：删除指定长度的字符并在指定的起始点插入另一组字符。<br>返回类型:如果 character_expression 是一个支持的字符数据类型，则返回字符数据。<br>例如：<br>Select STUFF(‘abcde’,4,2,’12’) –结果为’abc12’。</p></li><li><p>REVERSE 函数<br>函数格式：<br>REVERSE（expression1）<br>功能：按相反顺序返回字符串 expression1 中的字符。<br>返回值数据类型：varchar。例如：<br>Select REVERSE (‘edcba’) –结果为 abcde。</p></li><li><p>SPACE 函数<br>函数格式：<br>SPACE（n）<br>功能：返回包含 n 个空格的字符串，如果 n 为负数，则返回一个空字符串。<br>返回值数据类型：char。</p></li><li><p>STR 函数<br>函数格式：<br>STR（expression1[,length[,decimal]]）<br>功能：将数字数据转换为字符数据。length 为转换得到的字符串总长度，包括符号、小<br>数点、数字或空格。如果数字长度不够，则在左端加入空格补足长度，如果小数部分超过总<br>长度，则进行四舍五入，length 的默认值为 10，decimal 为小数位位数。<br>返回值数据类型：char。例如：<br>select str(123,6) –结果为’ 123’<br>select str(123.456,5) –结果为’ 123’<br>select str(123.456,5,2) –结果为’123.5’<br>select str(123.456,8,2) –结果为’ 123.46’</p></li><li><p>REPLICATE(character_expression,times)<br>语法：<br>REPLICATE(character_expression,times)<br>功能：返回多次复制后的字符表达式。times 参数的计算结果必须为整数。例如：<br>select replicate(‘<em>‘,3) –返回‘</em><em><em>’ 例 9- 8：以“</em>”方式输出菱形。<br>输出结果见 图 9- 2（在查询编辑器中以文本格式显示结果）。<br>declare @i int<br>set @i=1<br>while @i&lt;=4<br>begin<br>print space(4-@i)+<br>replicate(‘<em>‘,2</em>@i-1)<br>set @i=@i+1<br>end<br>set @i=1<br>while @i&lt;=3<br>begin<br>print space(@i)+replicate(‘*’,7-2</em>@i)<br>set @i=@i+1<br>end</p></li><li><p>CAST 函数<br>功能：将一种数据类型的表达式转换为另一种数据类型的表达式。<br>语法：<br>CAST ( expression AS data_type [ (length ) ])<br>例：</p></li></ol><p>–将日期时间类型转换为 char 类型<br>select cast(‘2010-3-2’ as char(10))</p><ol start="22"><li><p>CONVERT 函数<br>CONVERT 函数将一种数据类型的表达式转换为另一种数据类型的表达式。<br>语法：<br>CONVERT ( data_type [ ( length ) ] , expression [ , style ] )</p></li><li><p>ISDATE 函数<br>语法：<br>ISDATE( expression )<br>功能：如果 expression 是 datetime 或 smalldatetime 数据类型的有效日期或时间值，则<br>返回 1；否则，返回 0。例如：<br>select ISDATE(‘2009/2/29’) –返回 0</p></li><li><p>ISNULL ( check_expression , replacement_value )<br>语法：<br>ISNULL ( check_expression , replacement_value )<br>功能：如果 check_expression 不为 NULL，则返回它的值；否则，在将 replacement_value<br>隐式转换为 check_expression 的类型（如果这两个类型不同）后，则返回前者。例如：</p></li></ol><p>–如果成绩为 NULL，替换为 0<br>select grade as 成绩,ISNULL(grade,0) as ISNULL_结果 from sc</p><ol start="25"><li><p>NULLIF 函数<br>NULLIF ( expression , expression )<br>功能：如果两个指定的表达式相等，则返回空值。</p></li><li><p>ISNUMERIC 函数<br>语法：<br>ISNUMERIC ( expression )<br>功能：确定表达式是否为有效的数值类型。</p></li></ol><h2 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h2><ol><li>GETDATE 函数<br>函数格式：<br>图 9- 2 输出菱形<br>GETDATE（）<br>功能：按 SQL Server 内部标准格式返回系统日期和时间。<br>返回值数据类型：datetime。例如：<br>Select getdate() –结果为 2012-08-13 21:51:32.390</li><li>YEAR 函数<br>函数格式：<br>YEAR（date）<br>功能：返回指定日期 date 中年的整数。<br>返回值数据类型：int。例如：<br>Select year(‘2004-3-5’) –结果为 2004<br>例 9- 9：返回学生表中学生的年龄。<br>select sname as 学号, BirthDate as 出生日期,<br>YEAR(getdate())-YEAR(birthdate) as 年龄<br>from dbo.student<br>结果见图 9- 3 所示。</li><li>MONTH 函数<br>函数格式：<br>MONTH（date）<br>功能：返回指定日期 date 中月份的整数。<br>返回值数据类型：int。例如：<br>Select month(‘2004-3-5’) –结果为 3</li><li>DAY 函数<br>函数格式：<br>DAY（date）<br>功能：返回指定日期 date 中天的整数。<br>返回值数据类型：int。例如：<br>Select day(‘2004-3-5’) –结果为 5</li><li>DATENAME 函数<br>函数格式：<br>DATENAME（datepart,date）<br>功能：返回日期 date 中由 datepart 指定的日期部分的字符串。<br>返回类型：nvarchar。</li><li>DATEPART 函数<br>函数格式：<br>DATEPART（dateprrt,date）<br>功能：与 DATENAME 类似，只是返回值为整数。<br>返回值数据类型：int。</li><li>DATEADD 函数<br>函数格式：<br>DATEADD（dateprrt,n,date）<br>功能：在 date 指定日期时间的 datepart 部分加上 n，得到一个新的日期时间值。<br>返回值数据类型：datetime，如果参数 date 为 smalldatetime，则返回值为 smalldatetime<br>类型。参数 datepart 可以使用如表 9- 9 所示中的短语或缩写。例如：<br>Select dateadd(yy,2,’2012-3-4’) –结果为’2014-03-04 00:00:00.000’<br>Select dateadd(m,2,’2012-3-4’) –结果为’2012-05-04 00:00:00.000’<br>Select dateadd(d,2,’2012-3-4’) –结果为’2012-03-06 00:00:00.000’</li><li>DATEDIFF 函数<br>格式：<br>DATEDIFF ( datepart , startdate , enddate )<br>功能：返回指定的 startdate 和 enddate 之间所跨的指定 datepart 边界的计数（带符号<br>的整数）。<br>例 9- 9：返回学生表中学生的年龄。<br>select sname as 学号, BirthDate as 出生日期,<br>DATEDIFF(yy, birthdate,getdate()) as 年龄 from dbo.student</li></ol><p>datepart可选参数<br>日期部分 缩写 日期部分 缩写<br>年份 yy、yyyy 工作日 dw<br>季度 qq、q 小时 hh<br>月份 mm、m 分钟 mi、n<br>每年的某一日 dy、y 秒 ss、s<br>图 9- 3 YEAR 函数示例<br>日期 dd、d 毫秒 ms<br>星期 wk、ww 工作日 dw</p><h1 id="批处理和流程控制语句"><a href="#批处理和流程控制语句" class="headerlink" title="批处理和流程控制语句"></a>批处理和流程控制语句</h1><h2 id="IF…ELSE-语句"><a href="#IF…ELSE-语句" class="headerlink" title="IF…ELSE 语句"></a>IF…ELSE 语句</h2><ol><li>如果满足条件，则在 IF 关键字及其条件之后执行<br>T-SQL 语句。可选的 ELSE 关键字引入另一个 T-SQL 语句，当不满足 IF 条件时就执行该<br>语句。</li><li>在实际程序中，IF…ELSE 语句中不止包含一条语句，而是一组的 SQL 语句。为了可以<br>一次执行一组 SQL 语句，这时就需要使用 BEGIN…END 语句将多条语句封闭起来。</li></ol><p>eg 查找学号为 200215121 的成绩。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">DECLARE @message varchar(255),@grade_num int</span><br><span class="line">--得到 200215121 号同学的选修课程的数目</span><br><span class="line">SELECT @grade_num=COUNT(grade) FROM sc </span><br><span class="line">WHERE sno=&#x27;200215121&#x27;</span><br><span class="line">IF @grade_num=0</span><br><span class="line"> BEGIN</span><br><span class="line">  SET @message= &#x27;没有学生 200215121 的成绩&#x27;</span><br><span class="line">  PRINT @message</span><br><span class="line"> END</span><br><span class="line">ELSE</span><br><span class="line"> BEGIN</span><br><span class="line">  SET @message= &#x27;有学生 200215121 的&#x27;</span><br><span class="line">  + convert(char(2),@grade_num)+ &#x27;门课程的成绩。&#x27;</span><br><span class="line">  PRINT @message</span><br><span class="line"> END</span><br><span class="line">SET @message=&#x27;课程号查询完毕&#x27;</span><br><span class="line">PRINT @message</span><br><span class="line">GO</span><br></pre></td></tr></table></figure><h2 id="CASE-分支语句"><a href="#CASE-分支语句" class="headerlink" title="CASE 分支语句"></a>CASE 分支语句</h2><p>CASE 关键字可根据表达式的真假来确定是否返回某个值，可在允许使用表达式的任意<br>位置使用这一关键字。<br>eg 为学生表的每个院系添加说明。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT sname AS 学号,sdept AS 院系, &#x27;院系说明&#x27;=</span><br><span class="line">CASE sdept</span><br><span class="line">  --分别为各个院系添加说明</span><br><span class="line">  WHEN &#x27;IS&#x27; THEN &#x27;属于信息系&#x27;</span><br><span class="line">  WHEN &#x27;MA&#x27; THEN &#x27;属于数学院&#x27;</span><br><span class="line">  WHEN &#x27;CS&#x27; THEN &#x27;属于计算机科学与技术学院&#x27;</span><br><span class="line">ELSE &#x27;其他院系&#x27;</span><br><span class="line">END </span><br><span class="line">FROM student ORDER BY sname --按照姓名排序</span><br></pre></td></tr></table></figure><h2 id="WHILE-语句"><a href="#WHILE-语句" class="headerlink" title="WHILE 语句"></a>WHILE 语句</h2><p>设置重复执行 SQL 语句或语句块的条件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">WHILE 逻辑表达式</span><br><span class="line">Begin</span><br><span class="line"> T-SQL 语句组</span><br><span class="line">[break] /*终止整个语句的执行*/</span><br><span class="line">[continue] /*结束一次循环体的执行*/</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p>eg 求 1 到 10 之间偶数的和。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">DECLARE @i smallint,@sum smallint</span><br><span class="line">SET @i=0</span><br><span class="line">SET @sum=0</span><br><span class="line">WHILE @i&gt;=0</span><br><span class="line">BEGIN</span><br><span class="line"> SET @i=@i+1</span><br><span class="line"> IF @i&gt;10</span><br><span class="line"> BEGIN</span><br><span class="line">SELECT &#x27;1 到之间偶数的和&#x27;=@sum</span><br><span class="line"> BREAK</span><br><span class="line"> END</span><br><span class="line"> IF (@i%2)!=0</span><br><span class="line"> CONTINUE</span><br><span class="line"> ELSE</span><br></pre></td></tr></table></figure><h2 id="GOTO-语句"><a href="#GOTO-语句" class="headerlink" title="GOTO 语句"></a>GOTO 语句</h2><p>GOTO 语句将执行语句无条件跳转到标签处，并从标签位置继续处理。GOTO 语句和标<br>签可在过程、批处理或语句块中的任何位置使用。其语法格式为：<br>GOTO label</p><h2 id="WAITFOR-语句"><a href="#WAITFOR-语句" class="headerlink" title="WAITFOR 语句"></a>WAITFOR 语句</h2><p>WAITFOR 语句，称为延迟语句，就是暂停执行一个指定的时间间隔或者到一个指定的时间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">WAITFOR </span><br><span class="line">&#123; </span><br><span class="line">DELAY &#x27;time_to_pass&#x27; /* 设定等待时间 */</span><br><span class="line"></span><br><span class="line">| TIME &#x27;time_to_execute&#x27; /* 设定等待到某一时刻 */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">延迟 30 秒执行查询。</span><br><span class="line">WAITFOR DELAY &#x27;00:00:30&#x27;</span><br><span class="line">SELECT * FROM student</span><br></pre></td></tr></table></figure> <h2 id="TRY-CATCH"><a href="#TRY-CATCH" class="headerlink" title="TRY-CATCH"></a>TRY-CATCH</h2><p>TRY 块包含一组 T-SQL 语句。如果 TRY 块的语句中发生任何错误，控制将传递给CATCH 块。CATCH 块包含另外一组语句，这些语句在错误发生时执行。如果 TRY 块中没有错误，控制将传递到关联的 END CATCH 语句后紧跟的语句。如果 END CATCH 语句是存储过程或触发器中的最后一条语句，控制将传递到调用该存储过程或触发器的语句。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">BEGIN TRY </span><br><span class="line">&#123; sql_statement | statement_block &#125; </span><br><span class="line">END TRY</span><br><span class="line">BEGIN CATCH </span><br><span class="line">&#123; sql_statement | statement_block &#125; </span><br><span class="line">END CATCH [ ; ]</span><br><span class="line"></span><br></pre></td></tr></table></figure> <h2 id="Raiserror"><a href="#Raiserror" class="headerlink" title="Raiserror"></a>Raiserror</h2><p>有时会遇到 SQL SERVER 实际并不知道的一些错误，但我们希望能在客户端产生运行错误，而客户端使用的时候能够唤醒异常处理并进行相应的处理。RAISERROR 生成的错误与数据库引擎代码生成的错误的运行方式相同。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">RAISERROR(&lt;message ID | message_string&gt;, &lt;severity #级别 &gt;,&lt;state #状态 &gt; [,&lt;argument&gt; </span><br><span class="line">[,&lt;…n&gt;]]) </span><br><span class="line">[WITH option[,…n]]</span><br></pre></td></tr></table></figure><h1 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h1><p>游标（Cursor）是一种从包括多条数据记录的结果集中每次提取一条记录以便处理的机<br>制，可以看做是查询结果的记录指针。<br><strong>游标的作用：</strong><br>1） 允许定位在结果集的特定行。<br>2） 从结果集的当前位置检索一行或一部分行。<br>3） 支持对结果集中当前位置的行进行数据修改。<br>4） 为由其他用户对显示在结果集中的数据所做的更改提供不同级别的可见性支持。<br>5） 提供脚本、存储过程和触发器中用于访问结果集中的数据的 T-SQL 语句。</p><p><strong>@@FETCH_STATUS 全局变量</strong>返回上次执行 FETCH 命令的状态。在每次用 FETCH 从<br>游标中读取数据时，都应检查该变量，以确定上次 FETCH 操作是否成功，来决定如何进行<br>下一步处理。@@FETCH_STATUS 变量有三个不同的返回值: 1）返回值为 0，说明 FETCH 语句成功。<br>2）返回值为-1，说明 FETCH 语句失败或行不在结果集中。<br>3）返回值为-2，说明提取的行不存在。</p><p>利用游标将成绩表（SC）中不及格的成绩改为 60 分。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">--声明变量</span><br><span class="line">declare @v_sno varchar(10),</span><br><span class="line">@v_cno varchar(10),@v_grade int</span><br><span class="line">--声明游标</span><br><span class="line">declare cur scroll cursor</span><br><span class="line">for select sno,cno,grade from sc</span><br><span class="line">--打开游标</span><br><span class="line">open cur</span><br><span class="line">--取出第一行记录</span><br><span class="line">fetch next from cur into @v_sno,@v_cno,@v_grade</span><br><span class="line">--循环取值</span><br><span class="line">while @@FETCH_STATUS=0</span><br><span class="line">begin</span><br><span class="line">--判断当前记录的成绩值</span><br><span class="line">if @v_grade&lt;60</span><br><span class="line"> begin </span><br><span class="line">--显示修改前的成绩</span><br><span class="line"> select sno as 学号,cno as 课程号,grade as 更改前的成绩</span><br><span class="line"> from sc where sno=@v_sno and cno=@v_cno</span><br><span class="line">--修改游标所在行的成绩</span><br><span class="line">update sc set grade=60 where current of cur</span><br><span class="line">--显示修改后的成绩</span><br><span class="line"> select sno as 学号,cno as 课程号,grade as 更改后的成绩</span><br><span class="line"> from sc where sno=@v_sno and cno=@v_cno</span><br><span class="line"> end</span><br><span class="line">--取下一行记录</span><br><span class="line">fetch next from cur into @v_sno,@v_cno,@v_grade</span><br><span class="line">end</span><br><span class="line">--关闭游标</span><br><span class="line">close cur</span><br><span class="line">--释放游标</span><br><span class="line">deallocate cur</span><br></pre></td></tr></table></figure><hr />版权信息]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理-运算方法</title>
      <link href="/2022/04/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/"/>
      <url>/2022/04/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>计算机组成与结构课程笔记</p><span id="more"></span><h1 id="原码、反码、补码"><a href="#原码、反码、补码" class="headerlink" title="原码、反码、补码"></a>原码、反码、补码</h1><ol><li>原码<br>原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:</li></ol><p>[+1]原 = 0000 0001</p><p>[-1]原 = 1000 0001</p><p>第一位是符号位. 因为第一位是符号位, 所以8位二进制数的取值范围就是:</p><p>[1111 1111 , 0111 1111]</p><p>即</p><p>[-127 , 127]</p><p>原码是人脑最容易理解和计算的表示方式.</p><ol start="2"><li>反码<br>反码的表示方法是:</li></ol><p>正数的反码是其本身</p><p>负数的反码是在其原码的基础上, 符号位不变，其余各个位取反.</p><p>[+1] = [00000001]原 = [00000001]反</p><p>[-1] = [10000001]原 = [11111110]反</p><p>可见如果一个反码表示的是负数, 人脑无法直观的看出来它的数值. 通常要将其转换成原码再计算.</p><ol start="3"><li>补码<br>补码的表示方法是:</li></ol><p>正数的补码就是其本身</p><p>负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)</p><p>[+1] = [00000001]原 = [00000001]反 = [00000001]补</p><p>[-1] = [10000001]原 = [11111110]反 = [11111111]补</p><p>对于负数, 补码表示方式也是人脑无法直观看出其数值的. 通常也需要转换成原码在计算其数值.</p><h1 id="加减法溢出处理"><a href="#加减法溢出处理" class="headerlink" title="加减法溢出处理"></a>加减法溢出处理</h1><p><a href="https://sm.ms/image/nNip3D4zq6t8CIX" target="_blank"><img src="https://s2.loli.net/2022/04/25/nNip3D4zq6t8CIX.png" ></a></p><p>fa fb 两操作数的符号位<br>Cf 为符号位的进位<br>C 为数值最高位的进位</p><ol><li>符号相同，结果符号位与加数符号位不同，溢出</li><li>任意符号两数相加，Cf 不等于 C 溢出</li><li>双符号位f1 f2 正数为00 负数为11 符号位参与运算 结果 f1 f2 不相等，溢出<br><a href="https://sm.ms/image/Mc7uPzleO1vfNSR" target="_blank"><img src="https://s2.loli.net/2022/04/25/Mc7uPzleO1vfNSR.png" ></a></li></ol><h1 id="乘法、除法"><a href="#乘法、除法" class="headerlink" title="乘法、除法"></a>乘法、除法</h1><h2 id="定点乘法"><a href="#定点乘法" class="headerlink" title="定点乘法"></a>定点乘法</h2><ol><li><p>手工算法<br><a href="https://sm.ms/image/OYLmCwtvenBGKX4" target="_blank"><img src="https://s2.loli.net/2022/04/25/OYLmCwtvenBGKX4.png" ></a></p></li><li><p>定点原码一位乘法<br><a href="https://sm.ms/image/4VhK8T6pauRebyw" target="_blank"><img src="https://s2.loli.net/2022/04/25/4VhK8T6pauRebyw.png" ></a></p></li><li><p>定点补码一位乘法<br>布斯算法<br><a href="https://blog.csdn.net/qq_41844076/article/details/109594076">https://blog.csdn.net/qq_41844076/article/details/109594076</a></p></li></ol><h2 id="定点除法"><a href="#定点除法" class="headerlink" title="定点除法"></a>定点除法</h2><ol><li><p>手工算法<br><a href="https://sm.ms/image/5KX1bTh2tz9Ovj4" target="_blank"><img src="https://s2.loli.net/2022/04/25/5KX1bTh2tz9Ovj4.png" ></a></p></li><li><p>加减交替法<br><a href="https://sm.ms/image/w9F68ncKEaPxBUg" target="_blank"><img src="https://s2.loli.net/2022/04/25/w9F68ncKEaPxBUg.png" ></a></p></li></ol><h1 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h1><p><a href="http://kaito-kidd.com/2018/08/08/computer-system-float-point/">http://kaito-kidd.com/2018/08/08/computer-system-float-point/</a></p><p><a href="https://sm.ms/image/LiutGTOhM2p89Pq" target="_blank"><img src="https://s2.loli.net/2022/04/25/LiutGTOhM2p89Pq.png" ></a></p><p>Ms 为符号位 0正1负<br>E 为阶码 8位以2为底，阶码 = 阶码真值 + 127<br>M 为尾数 23位，采用隐含尾数最高位1的表示方法，<br>实际尾数24位，尾数真值 = 1 + 尾数</p><p>单精度浮点数 float：32 位，符号位 Ms 占 1 bit，指数 E 占 8 bit，尾数 M 占 23 bit<br>双精度浮点数 float：64 位，符号位 Ms 占 1 bit，指数 E 占 11 bit，尾数 M 占 52 bit</p><p><a href="https://sm.ms/image/wSd3TPiebLayWMI" target="_blank"><img src="https://s2.loli.net/2022/04/25/wSd3TPiebLayWMI.png" ></a></p><h2 id="移码"><a href="#移码" class="headerlink" title="移码"></a>移码</h2><p>阶码采用移码<br>尾数采用原码或补码</p><p>移码：<br><strong>补码的符号位取反</strong><br>最高位为符号位<br>只执行加减运算，加以2^n的修正量<br><a href="https://sm.ms/image/2o4zguAIMrUP7lN" target="_blank"><img src="https://s2.loli.net/2022/04/25/2o4zguAIMrUP7lN.png" ></a><br><a href="https://sm.ms/image/IAx7zFtaqHSn4TP" target="_blank"><img src="https://s2.loli.net/2022/04/26/IAx7zFtaqHSn4TP.png" ></a></p><h2 id="精度、范围"><a href="#精度、范围" class="headerlink" title="精度、范围"></a>精度、范围</h2><p><a href="https://blog.csdn.net/l1028386804/article/details/113065755">https://blog.csdn.net/l1028386804/article/details/113065755</a></p><p><a href="https://sm.ms/image/UG82NABqjEu1tKp" target="_blank"><img src="https://s2.loli.net/2022/04/25/UG82NABqjEu1tKp.png" ></a></p><p>单精度浮点数 32 位<br>符号位1位，阶码8位，尾数23位。<br>精度24位，范围 -2^127 - (1-(2^-23))*2^127</p><h2 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h2><ol><li><p>对阶</p></li><li><p>尾数的计算(加减乘除)</p></li><li><p>规格化处理<br>如果<strong>结果的两个符号位的值不同</strong>,表示运算尾数结果溢出,应“右规”,即尾数结果右移一位,阶码+1。</p></li></ol><p>如果<strong>最高数值位与符号位相同</strong>,应“左规”,此时尾数连续左移,直到最高数值位与符号位的值不同为止;同时从阶码中减去移位的位数。</p><ol start="4"><li><p>舍入<br>截断处理:无条件地丢掉正常尾数最低位之后的全部数值<br>舍入处理:运算过程中保留右移中移出的若干高位的值,然而再按某种规则用这些位上的值修正尾数</p></li><li><p>判断溢出</p></li></ol><hr />版权信息]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运算方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成笔记-主存储器</title>
      <link href="/2022/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E7%AC%94%E8%AE%B0-%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8/"/>
      <url>/2022/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E7%AC%94%E8%AE%B0-%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>计算机组成原理</p><p>主存储器</p><p><a href="https://sm.ms/image/UQvDjshEwNZuA92" target="_blank"><img src="https://s2.loli.net/2022/04/23/UQvDjshEwNZuA92.jpg" ></a></p><span id="more"></span><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><a href="https://sm.ms/image/nJjHB8GmbpCu14X" target="_blank"><img src="https://s2.loli.net/2022/04/23/nJjHB8GmbpCu14X.jpg" alt="Screenshot 2022-04-12 144845.jpg"></a></p><ol><li><p>主要指标：主存容量、储存器存储时间(启动一次读写操作到完成该操作的时间)、存储周期(连续启动两次独立的储存器操作所需间隔的最小时间)</p></li><li><p>一个字节 = 8个二进制位</p></li><li><p>总线：地址总线、数据总线、控制总线 连接主存储器和CPU</p></li><li><p>AR(地址寄存器)K位 DR(数码寄存器)n位 允许主存包含2^K个可寻址的字节 在一个存储周期内，CPU和主存通过总线进行n位数据传送。</p></li></ol><h1 id="RAM"><a href="#RAM" class="headerlink" title="RAM"></a>RAM</h1><p>半导体读/写存储器按存储元件在运行中能否长时间保存信息来分为静态存储器（SRAM）和动态存储器（DRAM）。<br>其中SRAM利用双稳态触发器来保存信息,而且只要不断电,信息不会丢失,<br>DRAM使用MOS电容来保存信息,使用时需要不断给电容充电。</p><p><a href="https://sm.ms/image/pu7XfFymj3beQW9" target="_blank"><img src="https://s2.loli.net/2022/04/23/pu7XfFymj3beQW9.jpg" ></a></p><h2 id="SRAM"><a href="#SRAM" class="headerlink" title="SRAM"></a>SRAM</h2><p>静态RAM是利用双稳态触发器来记忆信息的。六管静态MOS记忆单元电路中的T1～T4组成两个反相器，交叉耦合连接成一个触发器；T1～T6管构成一个记忆单元的主体，能存放一位二进制信息。</p><h3 id="SRAM的读写"><a href="#SRAM的读写" class="headerlink" title="SRAM的读写"></a>SRAM的读写</h3><p><a href="https://sm.ms/image/TcMNbC6OUJIL1ik" target="_blank"><img src="https://s2.loli.net/2022/04/23/TcMNbC6OUJIL1ik.png" ></a></p><p>存储单元未被选中时，字选择线保持低电位，两位线保持高电位；单元被选中时，字选择线保持高电位。<br><a href="https://sm.ms/image/LHjvTfwScrnu2X7" target="_blank"><img src="https://s2.loli.net/2022/04/23/LHjvTfwScrnu2X7.png" ></a></p><p>由存储单元组成的存储器结构和功能表如下:</p><p><a href="https://sm.ms/image/g1dLcKMHYA46eSX" target="_blank"><img src="https://s2.loli.net/2022/04/23/g1dLcKMHYA46eSX.png" ></a></p><h3 id="读写时序"><a href="#读写时序" class="headerlink" title="读写时序"></a>读写时序</h3><p><a href="https://sm.ms/image/1mBpUZ6OlN3zSoe" target="_blank"><img src="https://s2.loli.net/2022/04/23/1mBpUZ6OlN3zSoe.jpg" ></a></p><p><a href="https://sm.ms/image/9dAgNRVwfpqcYKF" target="_blank"><img src="https://s2.loli.net/2022/04/23/9dAgNRVwfpqcYKF.jpg" ></a></p><h2 id="DRAM"><a href="#DRAM" class="headerlink" title="DRAM"></a>DRAM</h2><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><strong>储存单元</strong></p><p><a href="https://sm.ms/image/8c2nm7i9VG1AJvs" target="_blank"><img src="https://s2.loli.net/2022/04/23/8c2nm7i9VG1AJvs.png" ></a></p><p><strong>写入</strong>: 字线为高电平,T导通<br>写1: 位线为低电平,VDD通过T对Cs充电，  电容中有电荷则保持不变。<br>写0: 位线为高电平,Cs通过T放电，电容中无电荷则不变。</p><p><strong>读出</strong>:位线预充电至高电平; 当字线出现高电平后,T导通,若原来Cs充有电荷,则Cs放电,使位线电位下降,经放大后,读出为1; 若原来Cs上无电荷,则位线无电位变化,放大器无输出,读出为0。<br>读出后,若原来Cs充有电荷也被放掉了,和没有充电一样,因此读出是破坏性的,故读出后要立即对单元进行“重写”,以恢复原信息。</p><p><strong>储存器</strong></p><p>16K由两个64*128矩阵组成<br>WE为允许信号，若为0，执行写操作，Din通过T7T8以及T5T6进入单元<br>为1执行读操作，单元的状态通过位线1 位线2和T7T8传至读放<br>若CS = 1 不进行读写操作<br><a href="https://sm.ms/image/BSKJy8L15fWlOd4" target="_blank"><img src="https://s2.loli.net/2022/04/23/BSKJy8L15fWlOd4.png" ></a></p><h3 id="刷新"><a href="#刷新" class="headerlink" title="刷新"></a>刷新</h3><p><a href="https://sm.ms/image/3jAh5Px18slzZIi" target="_blank"><img src="https://s2.loli.net/2022/04/23/3jAh5Px18slzZIi.jpg" ></a></p><h2 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h2><ol><li><p>SDRAM —— 同步动态随机读写存储器<br>将CPU与RAM通过一个相同的时钟信号锁在一起，使RAM和CPU能够共享一个时钟周期，以相同的速度同步工作。在每一个时钟脉冲的上升沿开始传送数据。</p></li><li><p>DDR —— 双倍数据传输速率同步动态随机存储器<br>是SDRAM的一种新技术。<br>可在同一时钟周期的上升和下降沿都能传送数据，同样时间内的数据传送量翻了一倍。</p></li></ol><h1 id="ROM"><a href="#ROM" class="headerlink" title="ROM"></a>ROM</h1><p>停电时信息不丢失的存储器称为非易失性存储器。<br>可分为ROM、 PROM、EPROM、 E2 PROM 和 flash memory。</p><p>芯片的内容在制造时已经输入，只能读，不能修改。<br>存储原理：是根据元件的有无来表示该存储单元的信息（1或0）。<br>存储元件：二极管或晶体管</p><h1 id="容量扩展"><a href="#容量扩展" class="headerlink" title="容量扩展"></a>容量扩展</h1><p>1 bit  = 8 位</p><p><strong>数据线数目 = 芯片位长</strong></p><p><strong>存储器容量=字数*位长</strong></p><p><strong>地址线数 = log2(字数)</strong></p><h2 id="位扩展"><a href="#位扩展" class="headerlink" title="位扩展"></a>位扩展</h2><p>位扩展指只在位数方向扩展（加大字长），而芯片的字数和存储器的字数是一致的。位扩展的连接方式是将各存储芯片的地址线、片选线和读/写线相应地并联起来，而将各芯片的数据线单独列出。</p><p>eg:</p><p>两个16K* 4位的芯片采用位扩展方式扩展成一16K * 8 位的存储器。如下图所示。 16K * 4位的芯片的字长为4位，所以有4条数据线，分别用D0<del>D3和D4</del>D7表示；容量为16K = 2^14 ，有14条地址线，用A0~A13 表示。</p><p><a href="https://sm.ms/image/9GQzPrZYRTU6dtp" target="_blank"><img src="https://s2.loli.net/2022/04/23/9GQzPrZYRTU6dtp.png" ></a></p><h2 id="字扩展"><a href="#字扩展" class="headerlink" title="字扩展"></a>字扩展</h2><p>字扩展是指仅在容量方向扩展，而位数不变。字扩展将芯片的地址线、数据线、读/写线并联，由片选信号来区分各个芯片。64K<em>8位的存储器需要4个16K</em>8位芯片组成，连接图如下。</p><p><a href="https://sm.ms/image/CBHkpyxucihlNUZ" target="_blank"><img src="https://s2.loli.net/2022/04/23/CBHkpyxucihlNUZ.png" ></a></p><p>数据线D0 - D7线与各片的数据端相连，地址总线（共16条）低位A0 -A13 与各芯片的14个地址端相连，两位高位A14和A15经过译码器和4个片选端相连。<br>在同一时间内四个芯片中只能有一个芯片被选中。</p><h2 id="同时扩展"><a href="#同时扩展" class="headerlink" title="同时扩展"></a>同时扩展</h2><p>当构成一个容量较大的存储器时，往往需要在字方向和位方向上同时扩展，这将是前两种扩展的组合，实现起来也是很容易的。</p><p>一个存储器的容量为M<em>N位，若使用L</em>K位存储器芯片，需要(M/L)*(N/K)个芯片</p><p>如用16K×4位的SRAM组成64K×8位的存储器，需要8个芯片。</p><h1 id="xx3x"><a href="#xx3x" class="headerlink" title="xx3x"></a>xx3x</h1><hr />版权信息]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 主存储器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>节点选择</title>
      <link href="/2022/04/04/%E8%8A%82%E7%82%B9%E9%80%89%E6%8B%A9/"/>
      <url>/2022/04/04/%E8%8A%82%E7%82%B9%E9%80%89%E6%8B%A9/</url>
      
        <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>问题描述</p><p>有一棵 n 个节点的树，树上每个节点都有一个正整数权值。如果一个点被选择了，那么在树上和它相邻的点都不能被选择。求选出的点的权值和最大是多少？</p><span id="more"></span><p>输入格式<br>第一行包含一个整数 n 。<br>接下来的一行包含 n 个正整数，第 i 个正整数代表点 i 的权值。<br>接下来一共 n-1 行，每行描述树上的一条边。</p><p>输出格式<br>输出一个整数，代表选出的点的权值和的最大值。</p><p>样例输入<br>5<br>1 2 3 4 5<br>1 2<br>1 3<br>2 4<br>2 5</p><p>样例输出<br>12</p><p>样例说明<br>选择3、4、5号点，权值和为 3+4+5 = 12 。</p><p>数据规模与约定<br>对于20%的数据， n &lt;= 20。<br>对于50%的数据， n &lt;= 1000。<br>对于100%的数据， n &lt;= 100000。<br>权值均为不超过1000的正整数</p><p><a href="https://www.cnblogs.com/program-ccc/p/5221932.html">https://www.cnblogs.com/program-ccc/p/5221932.html</a></p><p>状态转移方程：</p><p>dp[x][1] = dp[x][1] + dp[u][0]  (u为x的子结点)</p><p>dp[x][0] = dp[x][0] + max{dp[u][0],dp[u][1]}(u为x的子结点)</p><figure class="highlight plaintext"><figcaption><span>[结点选择] [lang:C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN=8;</span><br><span class="line">int w[MAXN]; // 各点的权值</span><br><span class="line">vector&lt;int&gt; tree[MAXN]; // 数组下标对应的向量存贮该下标结点的邻接点</span><br><span class="line">int n;</span><br><span class="line">int dp[MAXN][2]; //dp[u][1] 存储 选了自己结点u的权值最大值 dp[u][0]存储不选结点u权值和</span><br><span class="line">int vis[MAXN]; // 判断是否遍历过</span><br><span class="line"></span><br><span class="line">void dfs(int u) // 结点u的dfs</span><br><span class="line">&#123;</span><br><span class="line">    vis[u]=1; </span><br><span class="line">    dp[u][0]=0;</span><br><span class="line">    dp[u][1]=w[u];</span><br><span class="line">    int s0=0,s1=0;</span><br><span class="line">    for(int i=0;i&lt;tree[u].size();i++) // 遍历结点u邻接结点v</span><br><span class="line">    &#123;</span><br><span class="line">        int v=tree[u][i]; </span><br><span class="line">        if(!vis[v])</span><br><span class="line">        &#123;</span><br><span class="line">            dfs(v); // 结点v的dfs</span><br><span class="line">            s0+=max(dp[v][0],dp[v][1]);</span><br><span class="line">            s1+=dp[v][0];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[u][0]+=s0;</span><br><span class="line">    dp[u][1]+=s1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line"></span><br><span class="line">    for(int i=1;i&lt;=n;i++)</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;w[i]);</span><br><span class="line">    </span><br><span class="line">    for(int i=1;i&lt;=n-1;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int u,v;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;u,&amp;v);</span><br><span class="line">        tree[u].push_back(v);</span><br><span class="line">        tree[v].push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs(1);</span><br><span class="line">    </span><br><span class="line">    printf(&quot;%d\n&quot;,max(dp[1][0],dp[1][1]));</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr />版权信息]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 树形DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>归并排序实战——逆序对问题</title>
      <link href="/2022/04/04/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E9%80%86%E5%BA%8F%E5%AF%B9%E9%97%AE%E9%A2%98/"/>
      <url>/2022/04/04/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E9%80%86%E5%BA%8F%E5%AF%B9%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>关于逆序对问题的题解和思路</p><span id="more"></span><p><strong>归并排序原算法指路：</strong></p><a href="/2021/12/01/%E6%8E%92%E5%BA%8F/" title="五种排序">五种排序</a><a href="/2021/12/01/%E6%8E%92%E5%BA%8F/" title="排序">排序</a><p><strong>逆序对：设a[0…n]为包含n个不数的一个序列，如果n&lt;m，且a[n]&gt;a[m],则称(n,m)构成a中的一个逆序对；</strong></p><p><a href="https://www.jb51.net/article/55283.htm">https://www.jb51.net/article/55283.htm</a></p><p>归并排序思想，先递归分治至两个数组内再依次返回排序比较<br>注意若左边数组大于右边数组，总计数应加上 <strong>mid - index1 + 1</strong><br>因为右数组是有序的，当左指针移动时会出现多个逆序对的情况，所以加上中间指针下标减去右指针所在下标加上1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int array[] = &#123;3, 9, 7, 4, 5, 2&#125;;</span><br><span class="line">const int size = sizeof array / sizeof *array;</span><br><span class="line">int temp[size];</span><br><span class="line">//int numbers[size];</span><br><span class="line"></span><br><span class="line">int reversePair(int *numbers, int start, int last, int &amp;index, int &amp;count)</span><br><span class="line">&#123;</span><br><span class="line">  if(start == last)</span><br><span class="line">  return 0;</span><br><span class="line">  int mid = (last - start) / 2 + start;</span><br><span class="line">  //递归分治</span><br><span class="line">  reversePair(numbers, start, mid, index, count);</span><br><span class="line">  reversePair(numbers, mid + 1, last, index, count);</span><br><span class="line"></span><br><span class="line">  for(int i = start; i &lt;= last; i++)</span><br><span class="line">    temp[i] = numbers[i];</span><br><span class="line"></span><br><span class="line">  int index1 = start, index2 = mid + 1;</span><br><span class="line">  index = start;</span><br><span class="line">  while(index1 &lt;= mid &amp;&amp; index2 &lt;= last) &#123;</span><br><span class="line">    if(temp[index1] &gt; temp[index2]) &#123;</span><br><span class="line">      numbers[index] = temp[index2];//将值较小的优先排入数组，起到排序作用</span><br><span class="line">      count += mid - index1 + 1;</span><br><span class="line">      index++;</span><br><span class="line">      index2++;</span><br><span class="line">    &#125; </span><br><span class="line">    else if(temp[index1] == temp[index2]) &#123;</span><br><span class="line">      numbers[index] = temp[index1];</span><br><span class="line">      index++;</span><br><span class="line">      index1++;</span><br><span class="line">      index2++;</span><br><span class="line">    &#125; </span><br><span class="line">    else if(temp[index1] &lt; temp[index2]) &#123;</span><br><span class="line">      numbers[index] = temp[index1];</span><br><span class="line">      index++;</span><br><span class="line">      index1++;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(index1 &lt;= mid) &#123;</span><br><span class="line">      while(index1 &lt;= mid) &#123;</span><br><span class="line">        numbers[index] = temp[index1];</span><br><span class="line">        index++;</span><br><span class="line">        index1++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    else &#123;</span><br><span class="line">      while(index2 &lt;= last) &#123;</span><br><span class="line">        numbers[index] = temp[index2];</span><br><span class="line">        index++;</span><br><span class="line">        index2++;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">  int count = 0;</span><br><span class="line">  int index = 0;</span><br><span class="line">  reversePair(array, 0, size - 1, index, count);</span><br><span class="line">  cout &lt;&lt; &quot;count = &quot; &lt;&lt; count &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr />版权信息]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 归并排序 </tag>
            
            <tag> 逆序对 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java GUI</title>
      <link href="/2022/04/02/Java%20GUI/"/>
      <url>/2022/04/02/Java%20GUI/</url>
      
        <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>Swing 是一个为Java设计的GUI工具包。</p><p>Swing是JAVA基础类的一部分。</p><p>Swing包括了图形用户界面（GUI）器件如：文本框，按钮，分隔窗格和表。</p><p><a href="http://c.biancheng.net/view/1209.html">http://c.biancheng.net/view/1209.html</a></p><span id="more"></span><h1 id="JFrame"><a href="#JFrame" class="headerlink" title="JFrame"></a>JFrame</h1><p>JFrame 用来设计类似于 Windows 系统中窗口形式的界面。JFrame 是 Swing 组件的顶层容器，该类继承了 AWT 的 Frame 类，支持 Swing 体系结构的高级 GUI 属性。</p><table border="1">    <caption>        表1 JFrame类的常用方法</caption>    <tbody>        <tr>            <th>                方法名称</th>            <th>                概述</th>        </tr>        <tr>            <td>                getContentPane()</td>            <td>                返回此窗体的 contentPane 对象</td>        </tr>        <tr>            <td>                getDefaultCloseOperation()</td>            <td>                返回用户在此窗体上单击&ldquo;关闭&rdquo;按钮时执行的操作</td>        </tr>        <tr>            <td>                setContentPane(Container contentPane)</td>            <td>                设置 contentPane 属性</td>        </tr>        <tr>            <td>                setDefaultCloseOperation(int operation)</td>            <td>                设置用户在此窗体上单击&ldquo;关闭&rdquo;按钮时默认执行的操作</td>        </tr>        <tr>            <td>                setDefaultLookAndFeelDecorated (boolean<br />                defaultLookAndFeelDecorated)</td>            <td>                设置 JFrame 窗口使用的 Windows 外观（如边框、关<br />                闭窗口的 小部件、标题等）</td>        </tr>        <tr>            <td>                setIconImage(Image image)</td>            <td>                设置要作为此窗口图标显不的图像</td>        </tr>        <tr>            <td>                setJMenuBar( JMenuBar menubar)</td>            <td>                设置此窗体的菜单栏</td>        </tr>        <tr>            <td>                setLayout(LayoutManager manager)</td>            <td>                设置&nbsp;LayoutManager&nbsp;属性</td>        </tr>        <tr>            <td>                setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);</td>            <td>                设置用户在此窗体上发起 "close" 时默认执行的操作。必须指定以下选项之一：DO_NOTHING_ON_CLOSE（在 WindowConstants 中定义）：不执行任何操作；要求程序在已注册的WindowListener 对象的 windowClosing 方法中处理该操作。                HIDE_ON_CLOSE（在 WindowConstants 中定义）：调用任意已注册的 WindowListener 对象后自动隐藏该窗体。                DISPOSE_ON_CLOSE（在 WindowConstants 中定义）：调用任意已注册 WindowListener 的对象后自动隐藏并释放该窗体。                EXIT_ON_CLOSE（在 JFrame 中定义）：使用 System exit 方法退出应用程序。仅在应用程序中使用。            </td>        </tr>    </tbody></table><h1 id="JPanel"><a href="#JPanel" class="headerlink" title="JPanel"></a>JPanel</h1><p>JPanel 是一种中间层容器，它能容纳组件并将组件组合在一起，但它本身必须添加到其他容器中使用。JPanel 类的构造方法如下。</p><ol><li>JPanel()：使用默认的布局管理器创建新面板，默认的布局管理器为 FlowLayout。</li><li>JPanel(LayoutManagerLayout layout)：创建指定布局管理器的 JPanel 对象。</li></ol><table border="1">    <caption>        表2 JPanel类的常用方法</caption>    <tbody>        <tr>            <th>                方法名及返回值类型</th>            <th>                说明</th>        </tr>        <tr>            <td>                Component add(Component comp)</td>            <td>                将指定的组件追加到此容器的尾部</td>        </tr>        <tr>            <td>                void remove(Component comp)</td>            <td>                从容器中移除指定的组件</td>        </tr>        <tr>            <td>                void setFont(Font f)</td>            <td>                设置容器的字体</td>        </tr>        <tr>            <td>                void setLayout(LayoutManager mgr)</td>            <td>                设置容器的布局管理器</td>        </tr>        <tr>            <td>                void setBackground(Color c)</td>            <td>                设置组件的背景色</td>        </tr>    </tbody></table>wdas# xx3x<h1 id="布局管理器"><a href="#布局管理器" class="headerlink" title="布局管理器"></a>布局管理器</h1><h2 id="BorderLayout-边框布局管理器"><a href="#BorderLayout-边框布局管理器" class="headerlink" title="BorderLayout 边框布局管理器"></a>BorderLayout 边框布局管理器</h2><p>边框布局管理器将窗口分为 5 个区域：North、South、East、West 和 Center。<br>BorderLayout 布局管理器的构造方法如下所示。<br>BorderLayout()：创建一个 Border 布局，组件之间没有间隙。<br>BorderLayout(int hgap,int vgap)：创建一个 Border 布局，其中 hgap 表示组件之间的横向间隔；vgap 表示组件之间的纵向间隔，单位是像素。</p><h2 id="FlowLayout-流式布局管理器"><a href="#FlowLayout-流式布局管理器" class="headerlink" title="FlowLayout   流式布局管理器"></a>FlowLayout   流式布局管理器</h2><p>FlowLayout 布局管理器不限制它所管理组件的大小，而是允许它们有自己的最佳大小。<br>FlowLayout 布局管理器的构造方法如下。<br>FlowLayout()：创建一个布局管理器，使用默认的居中对齐方式和默认 5 像素的水平和垂直间隔。<br>FlowLayout(int align)：创建一个布局管理器，使用默认 5 像素的水平和垂直间隔。其中，align 表示组件的对齐方式，对齐的值必须是 FlowLayoutLEFT、FlowLayout.RIGHT 和 FlowLayout.CENTER，指定组件在这一行的位置是居左对齐、居右对齐或居中对齐。<br>FlowLayout(int align, int hgap,int vgap)：创建一个布局管理器，其中 align 表示组件的对齐方式；hgap 表示组件之间的横向间隔；vgap 表示组件之间的纵向间隔，单位是像素。</p><h2 id="CardLayout-卡片布局管理器"><a href="#CardLayout-卡片布局管理器" class="headerlink" title="CardLayout 卡片布局管理器"></a>CardLayout 卡片布局管理器</h2><p>CardLayout 布局管理器将容器分成许多层，每层的显示空间占据整个容器的大小，但是每层只允许放置一个组件。CardLayout 的构造方法如下。<br>CardLayout()：构造一个新布局，默认间隔为 0。<br>CardLayout(int hgap, int vgap)：创建布局管理器，并指定组件间的水平间隔（hgap）和垂直间隔（vgap）。</p><h2 id="GridLayout-网格布局管理器"><a href="#GridLayout-网格布局管理器" class="headerlink" title="GridLayout 网格布局管理器"></a>GridLayout 网格布局管理器</h2><p>GridLayout 布局管理器将组件分布在一个网格中，每个网格占据一个容器的尺寸。<br>GridLayout 的构造方法如下。<br>GridLayout()：创建一个新的网格布局，默认的行数为 1，默认的列数为 1，默认的水平间隔为 5 像素，默认的垂直间隔为 5 像素。<br>GridLayout(int rows, int cols,int hgap,int vgap)：创建一个新的网格布局，其中 rows 表示网格的行数，cols 表示网格的列数。并且可以指定组件之间横向（hgap）和纵向（vgap）的间隔，单位是像素。</p><h2 id="GridBagLayout-网格包布局管理器"><a href="#GridBagLayout-网格包布局管理器" class="headerlink" title="GridBagLayout 网格包布局管理器"></a>GridBagLayout 网格包布局管理器</h2><p>GridBagLayout 布局管理器将组件分布在一个网格中，每个网格占据一个容器的尺寸。GridBagLayout 不需要组件的尺寸一致，允许组件扩展到多行多列。<br>GridBagLayout 的构造方法如下。<br>GridBagLayout()：创建一个新的网格包布局，默认的行数为 1，默认的列数为 1，默认的水平间隔为 5 像素，默认的垂直间隔为 5 像素。</p><h2 id="BoxLayout-盒布局管理器"><a href="#BoxLayout-盒布局管理器" class="headerlink" title="BoxLayout 盒布局管理器"></a>BoxLayout 盒布局管理器</h2><p>BoxLayout 布局管理器将组件分布在一个盒子中，盒子的大小由组件的大小决定。<br>BoxLayout 的构造方法如下。<br>BoxLayout(int axis)：创建一个新的盒布局，其中 axis 表示组件的布局方向，对齐的值必须是 BoxLayout.X_AXIS 或 BoxLayout.Y_AXIS。</p><table border="1">    <caption>        表1 Box类设置组件间隔的静态方法</caption>    <tbody>        <tr>            <th>                网格包布局</th>            <th>                说明</th>        </tr>        <tr>            <td>                static Component createHorizontalGlue()</td>            <td>                创建一个不可见的、可以被水平拉伸和收缩的组件</td>        </tr>        <tr>            <td>                static Component createVerticalGlue()</td>            <td>                创建一个不可见的、可以被垂直拉伸和收缩的组件</td>        </tr>        <tr>            <td>                static Component createHorizontalStrut(int width)</td>            <td>                创建一个不可见的、固定宽度的组件</td>        </tr>        <tr>            <td>                static Component createVerticalStrut(int height)</td>            <td>                创建一个不可见的、固定高度的组件</td>        </tr>        <tr>            <td>                static Component createRigidArea(Dimension d)</td>            <td>                创建一个不可见的、总是具有指定大小的组件</td>        </tr>    </tbody></table><h1 id="标签组件"><a href="#标签组件" class="headerlink" title="标签组件"></a>标签组件</h1><p>JLabel()：创建无图像并且标题为空字符串的 JLabel。<br>JLabel(Icon image)：创建具有指定图像的 JLabel。<br>JLabel(String text)：创建具有指定文本的 JLabel。<br>JLabel(String textjcon image,int horizontalAlignment)：创建具有指定文本、图像和水平对齐方式的 JLabel，horizontalAlignment 的取值有 3 个，即 JLabel.LEFT、JLabel.RIGHT 和 JLabel.CENTER。</p><table border="1">    <caption>        表1 JLabel类的常用方法</caption>    <tbody>        <tr>            <th>                方法名称</th>            <th>                说明</th>        </tr>        <tr>            <td>                void setText(Stxing text)</td>            <td>                定义 JLabel 将要显示的单行文本</td>        </tr>        <tr>            <td>                void setIcon(Icon image)</td>            <td>                定义 JLabel 将要显示的图标</td>        </tr>        <tr>            <td>                void setIconTextGap(int iconTextGap)</td>            <td>                如果 JLabel 同时显示图标和文本，则此属性定义它们之间的间隔</td>        </tr>        <tr>            <td>                void setHorizontalTextPosition(int textPosition)</td>            <td>                设置 JLabel 的文本相对其图像的水平位置</td>        </tr>        <tr>            <td>                void setHorizontalAlignment(int alignment)</td>            <td>                设置标签内容沿 X 轴的对齐方式</td>        </tr>        <tr>            <td>                int getText()</td>            <td>                返回 JLabel 所显示的文本字符串</td>        </tr>        <tr>            <td>                Icon getIcon()</td>            <td>                返回 JLabel 显示的图形图像</td>        </tr>        <tr>            <td>                Component getLabelFor()</td>            <td>                获得将 JLabel 添加到的组件</td>        </tr>        <tr>            <td>                int getIconTextGap()</td>            <td>                返回此标签中显示的文本和图标之间的间隔量</td>        </tr>        <tr>            <td>                int getHorizontalTextPosition()</td>            <td>                返回 JLabel 的文本相对其图像的水平位置</td>        </tr>        <tr>            <td>                int getHorizontalAlignment()</td>            <td>                返回 JLabel 沿 X 轴的对齐方式</td>        </tr>    </tbody></table><h1 id="按钮组件"><a href="#按钮组件" class="headerlink" title="按钮组件"></a>按钮组件</h1><p>JButton()：创建一个无标签文本、无图标的按钮。<br>JButton(Icon icon)：创建一个无标签文本、有图标的按钮。<br>JButton(String text)：创建一个有标签文本、无图标的按钮。<br>JButton(String text,Icon icon)：创建一个有标签文本、有图标的按钮。</p><p><a href="http://c.biancheng.net/view/1217.html">http://c.biancheng.net/view/1217.html</a></p><h1 id="单行文本框组件"><a href="#单行文本框组件" class="headerlink" title="单行文本框组件"></a>单行文本框组件</h1><p>JTextField()：创建一个默认的文本框。<br>JTextField(String text)：创建一个指定初始化文本信息的文本框。<br>JTextField(int columns)：创建一个指定列数的文本框。<br>JTextField(String text,int columns)：创建一个既指定初始化文本信息，又指定列数的文本框。</p><h1 id="文本域组件"><a href="#文本域组件" class="headerlink" title="文本域组件"></a>文本域组件</h1><p>文本域与文本框的最大区别就是文本域允许用户输入多行文本信息。<br>JTextArea()：创建一个默认的文本域。<br>JTextArea(int rows,int columns)：创建一个具有指定行数和列数的文本域。<br>JTextArea(String text)：创建一个包含指定文本的文本域。<br>JTextArea(String text,int rows,int columns)：创建一个既包含指定文本，又包含指定行数和列数的多行文本域。</p><h1 id="选框组件"><a href="#选框组件" class="headerlink" title="选框组件"></a>选框组件</h1><p>JCheckBox()：创建一个默认的复选框，在默认情况下既未指定文本，也未指定图像，并且未被选择。<br>JCheckBox(String text)：创建一个指定文本的复选框。<br>JCheckBox(String text,boolean selected)：创建一个指定文本和选择状态的复选框。</p><p><strong>JRadioButton 通常位于一个 ButtonGroup 按钮组中，不在按钮组中的 JRadioButton 也就失去了单选按钮的意义。</strong><br>使用时先创建一个ButtonGroup实例，再将创建的JRadioButton加入到ButtonGroup中，这样就可以实现单选按钮的功能。</p><p>JRadioButton()：创建一个初始化为未选择的单选按钮，其文本未设定。<br>JRadioButton(Icon icon)：创建一个初始化为未选择的单选按钮，其具有指定的图像但无文本。<br>JRadioButton(Icon icon,boolean selected)：创建一个具有指定图像和选择状态的单选按钮，但无文本。<br>JRadioButton(String text)：创建一个具有指定文本但未选择的单选按钮。<br>JRadioButton(String text,boolean selected)：创建一个具有指定文本和选择状态的单选按钮。<br>JRadioButton(String text,Icon icon)：创建一个具有指定的文本和图像并初始化为未选择的单选按钮。<br>JRadioButton(String text,Icon icon,boolean selected)：创建一个具有指定的文本、图像和选择状态的单选按钮。</p><h1 id="下拉列表组件"><a href="#下拉列表组件" class="headerlink" title="下拉列表组件"></a>下拉列表组件</h1><p>JComboBox()：创建一个空的 JComboBox 对象。<br>JComboBox(ComboBoxModel aModel)：创建一个 JComboBox，其选项取自现有的 ComboBoxModel。<br>JComboBox(Object[] items)：创建包含指定数组中元素的 JComboBox。</p><p>JComboBox 能够响应 ItemEvent 事件和 ActionEvent 事件，其中 ItemEvent 触发的时机是当下拉列表框中的所选项更改时，ActionEvent 触发的时机是当用户在 JComboBox 上直接输入选择项并回车时。要处理这两个事件，需要创建相应的事件类并实现 ItemListener 接口和 ActionListener 接口。</p><h1 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h1><p>事件处理者（监听器）通常是一个类，该类如果能够处理某种类型的事件，就必须实现与该事件类型相对的接口。</p><h2 id="ActionEvent-动作事件监听器"><a href="#ActionEvent-动作事件监听器" class="headerlink" title="ActionEvent 动作事件监听器"></a>ActionEvent 动作事件监听器</h2><p>接口： ActionListener</p><p>方法</p><ol><li>addActionListener() 添加监听</li></ol><p>添加指定的动作侦听器，以接收发自此按钮的动作事件。当用户在此按钮上按下或释放鼠标时，发生动作事件。如果 l 为 null，则不抛出任何异常，也不执行任何动作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import javax.swing.*;</span><br><span class="line">import java.awt.*;</span><br><span class="line">import java.awt.event.*;</span><br><span class="line">public class FrameDemo</span><br><span class="line">&#123;</span><br><span class="line">    //定义该图形中所需的组件的引用</span><br><span class="line">    private Frame f;</span><br><span class="line">    private Button bt;</span><br><span class="line"></span><br><span class="line">    //方法</span><br><span class="line">    FrameDemo()//构造方法</span><br><span class="line">    &#123;</span><br><span class="line">        madeFrame();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void madeFrame()</span><br><span class="line">    &#123;</span><br><span class="line">        f = new Frame(&quot;My Frame&quot;);</span><br><span class="line"></span><br><span class="line">        //对Frame进行基本设置。</span><br><span class="line">        f.setBounds(300,100,600,500);//对框架的位置和大小进行设置</span><br><span class="line">        f.setLayout(new FlowLayout(FlowLayout.CENTER,5,5));//设计布局</span><br><span class="line"></span><br><span class="line">        bt = new Button(&quot;My Button&quot;);</span><br><span class="line"></span><br><span class="line">        //将组件添加到Frame中</span><br><span class="line">        f.add(bt);</span><br><span class="line"></span><br><span class="line">        //加载一下窗体上的事件</span><br><span class="line">        myEvent();</span><br><span class="line"></span><br><span class="line">        //显示窗体</span><br><span class="line">        f.setVisible(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void myEvent()</span><br><span class="line">    &#123;</span><br><span class="line">        f.addWindowListener(new WindowAdapter()//窗口监听</span><br><span class="line">        &#123;</span><br><span class="line">            public void windowClosing(WindowEvent e)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(&quot;窗体执行关闭！&quot;);</span><br><span class="line">                System.exit(0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        //让按钮具备关闭窗口的功能</span><br><span class="line">        bt.addActionListener(new ActionListener()</span><br><span class="line">        &#123;</span><br><span class="line">            public void actionPerformed(ActionEvent e)</span><br><span class="line">            &#123;</span><br><span class="line">                 System.out.println(&quot;按钮执行关闭窗口的功能&quot;);</span><br><span class="line">                 System.exit(0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] agrs)</span><br><span class="line">    &#123;</span><br><span class="line">        new FrameDemo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>removeActionListener() 删除监听</li></ol><h2 id="FocusEvent-焦点事件监听器"><a href="#FocusEvent-焦点事件监听器" class="headerlink" title="FocusEvent 焦点事件监听器"></a>FocusEvent 焦点事件监听器</h2><p>接口： FocusListener</p><p>FocusEvent 接口定义了两个方法，分别为 focusGained() 方法和 focusLost() 方法，其中 focusGained() 方法是在组件获得焦点时执行，focusLost() 方法是在组件失去焦点时执行。</p><p>方法</p><ol><li><p>addFocusListener() 添加监听</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">JTextField txtfield1 = new JTextField(20);</span><br><span class="line">txtfield1.addFocusListener(new FocusListener()</span><br><span class="line">&#123;</span><br><span class="line">@Override</span><br><span class="line">public void focusGained(FocusEvent arg0)</span><br><span class="line">&#123;</span><br><span class="line">// 获取焦点时执行此方法</span><br><span class="line">label.setText(&quot;文本框获得焦点，正在输入内容&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void focusLost(FocusEvent arg0)</span><br><span class="line">&#123;</span><br><span class="line">// 失去焦点时执行此方法</span><br><span class="line">label.setText(&quot;文本框失去焦点，内容输入完成&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>removeFocusListener() 删除监听</p></li></ol><h2 id="ListSelectionEvent-选择事件监听器"><a href="#ListSelectionEvent-选择事件监听器" class="headerlink" title="ListSelectionEvent 选择事件监听器"></a>ListSelectionEvent 选择事件监听器</h2><p>列表框控件 JList 会显示很多项供用户选择，通常在使用时会根据用户选择的列表项完成不同的操作.</p><p>接口： ListSelectionListener</p><ol><li><p>addListSelectionListener() 添加监听</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">JList list = new JList(new String[]&#123;&quot;Java&quot;, &quot;C++&quot;, &quot;C#&quot;, &quot;Python&quot;, &quot;PHP&quot;, &quot;JavaScript&quot;&#125;);</span><br><span class="line">list.addListSelectionListener(new ListSelectionListener()</span><br><span class="line">&#123;</span><br><span class="line">@Override</span><br><span class="line">public void valueChanged(ListSelectionEvent e)</span><br><span class="line">&#123;</span><br><span class="line">// 当选择项发生变化时执行此方法</span><br><span class="line">label.setText(&quot;选择了&quot; + list.getSelectedValue());</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>removeListSelectionListener() 删除监听</p></li></ol><h1 id="JSlider"><a href="#JSlider" class="headerlink" title="JSlider"></a>JSlider</h1><p>滑块（JSlider）是一个允许用户在有限区间内通过移动滑块来选择值的组件。</p><p><strong>JSlider(int min,int max,int value)</strong><br>用指定的最小值、最大值和初始值创建一个水平滑块。</p><h1 id="JProgressBar"><a href="#JProgressBar" class="headerlink" title="JProgressBar"></a>JProgressBar</h1><p>进度条（JProgressBar）是一种以可视化形式显示某些任务进度的组件。JProgressBar 类实现了一个用于为长时间的操作提供可视化指示器的 GUI 进度条。在任务的完成进度中，进度条显示该任务完成的百分比。</p><p>ProgressBar 类的常用构造方法和 JSlider 类的常用构造方法一样</p><h1 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h1><p>计时器（Timer）组件可以在指定时间间隔触发一个或多个 ActionEvent。</p><p>第一个参数为事件触发之间的间隔 单位为毫秒<br>第二个参数为ActionListener</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Timer timer = new Timer(1000, new ActionListener()</span><br><span class="line">&#123;</span><br><span class="line">@Override</span><br><span class="line">public void actionPerformed(ActionEvent e)</span><br><span class="line">&#123;</span><br><span class="line">// 每隔一秒执行一次</span><br><span class="line">label.setText(&quot;计时器触发了一次&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">timer.start();</span><br></pre></td></tr></table></figure><h1 id="JTable"><a href="#JTable" class="headerlink" title="JTable"></a>JTable</h1><p>JTable()：构造一个默认的 JTable，使用默认的数据模型、默认的列模型和默认的选择模型对其进行初始化。<br>JTable(int numRows,int numColumns)：使用 DefaultTableModel 构造具有 numRows 行和 numColumns 列个空单元格的 JTable。<br>JTable(Object[][] rowData,Object[] columnNames)：构造一个 JTable 来显示二 维数组 rowData 中的值，其列名称为 columnNames。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JTable table = new JTable(new Object[][]&#123;</span><br><span class="line">&#123;&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;&#125;,</span><br><span class="line">&#123;&quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;10&quot;&#125;&#125;,</span><br><span class="line">new Object[]&#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;&#125;);</span><br></pre></td></tr></table></figure><h1 id="其他组件"><a href="#其他组件" class="headerlink" title="其他组件"></a>其他组件</h1><h2 id="JMenu"><a href="#JMenu" class="headerlink" title="JMenu"></a>JMenu</h2><p>菜单由 Swing 中的 JMenu 类实现，可以包含多个菜单项和带分隔符的菜单。在菜单中，菜单项由 JMenuItem 类表示，分隔符由 JSeparator 类表示。</p><h2 id="弹出式菜单-JPopuMenu"><a href="#弹出式菜单-JPopuMenu" class="headerlink" title="弹出式菜单 JPopuMenu"></a>弹出式菜单 JPopuMenu</h2><p>弹出式菜单由 JPopupMenu 类实现，它是一个可弹出并显示一系列选项的小窗口。它还用于当用户选择菜单项并激活它时显示的“右拉式(pull-right)”菜单，可以在想让菜单显示的任何其他位置使用。</p><h2 id="JToolBar-工具栏组件"><a href="#JToolBar-工具栏组件" class="headerlink" title="JToolBar 工具栏组件"></a>JToolBar 工具栏组件</h2><p>工具栏提供了一个用来显示常用按钮和操作的组件</p><h2 id="JFileChooser-文件选择器"><a href="#JFileChooser-文件选择器" class="headerlink" title="JFileChooser 文件选择器"></a>JFileChooser 文件选择器</h2><p>文件选择器为用户能够操作系统文件提供了桥梁。swing 中使用 JFileChooser 类实现文件选择器，该类常用的构造方法如下。<br>JFileChooser()：创建一个指向用户默认目录的 JFileChooser。<br>JFileChooser(File currentDirectory)：使用指定 File 作为路径来创建 JFileChooser。<br>JFileChooser(String currentDirectoryPath)：创建一个使用指定路径的 JFileChooser。<br>JFileChooser(String currentDirectoryPath, FileSystemView fsv)：使用指定的当前目录路径和 FileSystem View 构造一个 JFileChooser。</p><h2 id="JColorChooser-颜色选择器"><a href="#JColorChooser-颜色选择器" class="headerlink" title="JColorChooser 颜色选择器"></a>JColorChooser 颜色选择器</h2><p>JColorChooser()：创建初始颜色为白色的颜色选取器窗格。<br>JColorChooser(Color initialColor)：创建具有指定初始颜色的颜色选取器窗格。<br>JColorChooser(ColorSelectionModel model)：创建具有指定 ColorSelectionModel 颜色选取器窗格。</p><h2 id="JOptionPane"><a href="#JOptionPane" class="headerlink" title="JOptionPane"></a>JOptionPane</h2><p>对话框通常用作从用户处接收附加信息，或者提供发生了某种事件的通知。Java 提供了 JOptionPane 类，用来创建标准对话框，也可以通过扩展 JDialog 类创建自定义的对话框。JOptionPane 类可以用来创建 4 种类型的标准对话框：确认对话框、消息对话框、输入对话框和选项对话框。</p><h2 id="JTabbedPane-选项卡组件"><a href="#JTabbedPane-选项卡组件" class="headerlink" title="JTabbedPane 选项卡组件"></a>JTabbedPane 选项卡组件</h2><p>使用选项卡可以在有限的布局空间内展示更多的内容。Swing 使用 JTabbedPane 类实现选项卡。</p><p>JTabbedPane 类创建的选项卡可以通过单击标题或者图标在选项卡之间进行切换。JTabbedPane 类的常用构造方法如下所示。<br>JTabbedPane()：创建一个具有默认 JTabbedPane.TOP 布局的空 TabbedPane。<br>JTabbedPane(int tabPlacement)：创建一个空的 TabbedPane，使其具有以下指定选项卡布局中的一种：JTabbedPane.TOP、JTabbedPane.BOTTOM、JTabbedPane.LEFT 或 JTabbedPane.RIGHT。</p><hr />         版权信息]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java - GUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关系代数</title>
      <link href="/2022/03/24/%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0/"/>
      <url>/2022/03/24/%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>数据库笔记 ——  关系代数</p><span id="more"></span><h1 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h1><p><a href="https://sm.ms/image/6TerPQDAohzCOqf" target="_blank"><img src="https://s2.loli.net/2022/03/24/6TerPQDAohzCOqf.png" ></a></p><h2 id="传统运算"><a href="#传统运算" class="headerlink" title="传统运算"></a>传统运算</h2><ol><li><p>并：假设有两个关系 R1 和 R2,R1 和 R2 的并运算产生一个新关系 R3。R3 是 由属于关系 R1 或 R2 的所有不同元组所组成，记为 R3=R1∪R2。 </p></li><li><p>差：假设有两个关系 R1 和 R2，R1 和 R2 的差运算产生一个新关系 R3。R3 是由属于关系关系 R1，但不属于 R2 的元组组成，记为 R3=R1-R2。 </p></li><li><p>交：假设有两个关系 R1 和 R2，R1 和 R2 的交运算产生一个新关系 R3。R3 是由既属于关系 R1，同时又属于 R2 的元组组成，记为 R3=R1∩R2。</p></li><li><p>笛卡尔积：假设有两个关系 R1 和 R2，且 R1 为 m 元关系，R2 为 n 元关系， R1 和 R2 的笛卡尔积产生一个新关系 R3，记作 R3=R1✖R2。R3 是由 R1 和 R2 的所有元组连接而成的具有(m+n)个分量的元组组成。</p></li></ol><h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><p>关系代数中用符号 σ（西格玛，sigma）来描述选择语句。选择是根据某些条件对关系做水平切割<br>此外我们可以在 select 的同时，添加限制条件（即 where），使用例如下：</p><p><a href="https://sm.ms/image/fmZdWqKQ8Peuo6k" target="_blank"><img src="https://s2.loli.net/2022/03/24/fmZdWqKQ8Peuo6k.png" ></a></p><p>等价与</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from student where AGE=19;</span><br></pre></td></tr></table></figure><h2 id="投影"><a href="#投影" class="headerlink" title="投影"></a>投影</h2><p>投影与选择正好相反，是对关系的一种垂直切割</p><p>在关系代数中的投影语句相当于 SQL 中的字段筛选，可以选择特定的字段进行查询，格式如下：<br><a href="https://sm.ms/image/GuvKOoS2LVZQ8RF" target="_blank"><img src="https://s2.loli.net/2022/03/24/GuvKOoS2LVZQ8RF.png" ></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select sno, age, sname from student;</span><br></pre></td></tr></table></figure><p>当选择和投影连用时<br>可以和where联动 相当于一个完整的selec语句<br><a href="https://sm.ms/image/P5sA9udivbH7YRZ" target="_blank"><img src="https://s2.loli.net/2022/03/24/P5sA9udivbH7YRZ.png" ></a><br>select sname from student where AGE=19;</p><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><p><a href="https://sm.ms/image/DxoWVwcfCKZEYRm" target="_blank"><img src="https://s2.loli.net/2022/03/25/DxoWVwcfCKZEYRm.png" ></a><br>连接运算：从两个关系的笛卡尔积中选取属性间满足一定条件的元组，用(R ⋈ S）表示。<br>连接分为两种，<br>一种是等值连接(θ 为 = 关系)<br>另一种是自然连接 根据R与S共同的属性进行选择 结果中去掉重复属性列 自然联接是特殊的的等值联接</p><p><a href="https://sm.ms/image/HUV3amCqj2ngelx" target="_blank"><img src="https://s2.loli.net/2022/03/25/HUV3amCqj2ngelx.jpg" ></a></p><p>自然连接时，被舍弃的元组称为<strong>悬浮元组</strong>，如果将悬浮元组也保存在结果中，在其他属性保持空值，称为<strong>外连接</strong>，只保留左边R中的悬浮元组称为<strong>左外连接</strong>，只保留右边S中的悬浮元组称为<strong>右外连接</strong></p><p><a href="https://sm.ms/image/buEwmhMo6UJ7yN1" target="_blank"><img src="https://s2.loli.net/2022/03/28/buEwmhMo6UJ7yN1.jpg" ></a></p><h2 id="除运算"><a href="#除运算" class="headerlink" title="除运算"></a>除运算</h2><p><a href="https://sm.ms/image/NfL7kYnJmTgaA53" target="_blank"><img src="https://s2.loli.net/2022/03/23/NfL7kYnJmTgaA53.png" ></a></p><h3 id="象集"><a href="#象集" class="headerlink" title="象集"></a>象集</h3><p>象集：本质上是一次选择行的运算和一次选择列的运算。<br>求x1在表A中的象集，就是先选出所有x属性中x=x1的那些行，然后选择出不包含x1的那些列。</p><p>如A：<br>X     Y     Z<br>a1    b1    c2<br>a2    b3    c7<br>a3    b4    c6<br>a1    b2    c3<br>a4    b6    c6<br>a2    b2    c3<br>a1    b2    c1<br>a1在A中的象集为{(b1,c2),(b2,c3),(b2,c1)}</p><h3 id="除运算-1"><a href="#除运算-1" class="headerlink" title="除运算"></a>除运算</h3><p>设关系R除以关系S的结果为关系T，则T包含所有在R但是不在S中的属性及其值，且T的元组与S的元组的所有集合都在R中</p><p>R与S的除运算构成新的关系P(X),P是R中满足下列条件的元组在X属性列上的投影，元组在X上分量值x的象集Yx包含S在Y上投影的集合。</p><p><a href="https://sm.ms/image/JXj2BdQ31NFn4SE" target="_blank"><img src="https://s2.loli.net/2022/03/26/JXj2BdQ31NFn4SE.png" ></a></p><hr />版权信息]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 关系代数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL数据查询</title>
      <link href="/2022/03/23/SQL%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2/"/>
      <url>/2022/03/23/SQL%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2/</url>
      
        <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>SQL的查询相关代码</p><p><a href="https://blog.csdn.net/weixin_44176696/article/details/112586831">https://blog.csdn.net/weixin_44176696/article/details/112586831</a></p><span id="more"></span><h1 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h1><h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><p>数据查询是数据库的核心操作，SQL 使用 SELECT 语句进行数据库的查询，其一般格式<br>为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT [ ALL｜DISTINCT ] &lt; 目标列表达式 &gt; [，&lt;目标列表达式 &gt; …] </span><br><span class="line">FROM &lt; 表名或视图名 &gt; [，&lt;表名或视图名&gt;… ] </span><br><span class="line">[ WHERE &lt; 条件表达式&gt; ]</span><br><span class="line">[ GROUP BY &lt; 列名列表&gt; [ HAVING &lt; 条件表达式&gt; ] ]</span><br><span class="line">[ ORDER BY &lt; 列名&gt; [ ASC ｜DESC ] ]；</span><br></pre></td></tr></table></figure><p>（1） []：表示[]中的内容是可选的，比如[ WHERE &lt; 条件表达式&gt; ]，表示可以使用 WHERE 也可以不使用</p><p>（2） &lt;&gt;：表示&lt;&gt;中的内容必须出现。比如&lt; 表名或视图名 &gt;，这个部分表示从哪个地方获取数据，是不可或缺的。</p><p>（3） ｜：表示选择其一，例如 &lt; 列名 2&gt; [ ASC ｜DESC ] ]，表示列名 2 后只能用ASC或者DESC其中之一来进行结果的排序，前者代表升序，后者代表降序。</p><p>（4） [，…]：表示括号中的内容可以重复出现 1 至多次。</p><p>（5） * 表示相应范围内的所有内容 select * 表示查找表中所有数据</p><h2 id="列操作"><a href="#列操作" class="headerlink" title="列操作"></a>列操作</h2><h3 id="查询列"><a href="#查询列" class="headerlink" title="查询列"></a>查询列</h3><p>在 SQL 语句中，用 FROM 子句指定要操纵的表，SELECT 子句给出要投影的列，对应的 SQL 语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select A,B </span><br><span class="line">from T_A</span><br><span class="line"></span><br><span class="line">select * </span><br><span class="line">from T_B</span><br></pre></td></tr></table></figure><p>SELECT 语句的执行结果是一个新表，这个表没有名字，是个临时表，它的关系模式由SELECT 子句里的属性列构成</p><p>select * 表示查找全部列</p><h3 id="列别名"><a href="#列别名" class="headerlink" title="列别名"></a>列别名</h3><p>有时候，我们希望查询结果中的某些列名不同于基本表中的列名，这时，可以在 SELECT<br>子句中增加列别名。<br>SQL 语句使用 AS 关键词对列设置“别名”。AS 使用格式如下：</p><p>旧名 AS 别名</p><p>eg：<br>查询曲库里的所有歌曲的详细信息，请把表中的各个列名：SongID，Name，Lyricist，Composer，Lang 分别替换成：歌曲编号、歌曲名称、词作者、曲作者、语言类别。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT SongID AS 歌曲编号, Name AS 歌曲名称, Lyricist AS 词作者,Composer AS 曲作者, Lang AS 语言类别</span><br><span class="line">FROM Songs;</span><br></pre></td></tr></table></figure><h3 id="查询计算列"><a href="#查询计算列" class="headerlink" title="查询计算列"></a>查询计算列</h3><p>SELECT 子句的&lt;目标列表达式&gt;不仅可以是表中真实存在的列，也可以是一个表达式。可以使用常量计算表达式或者函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT SongID, SingerID, Circulation*10000 as NewCirculation</span><br><span class="line">FROM Track</span><br><span class="line"></span><br><span class="line">SELECT Name as 姓名, Birth as 出生日期, 2012-Year（Birth） as 年龄</span><br><span class="line">FROM Singers</span><br></pre></td></tr></table></figure><h3 id="过滤重复列"><a href="#过滤重复列" class="headerlink" title="过滤重复列"></a>过滤重复列</h3><p>两条本来并不完全相同的元组，投影到某些列上后，可能变成相同的行了，可以用DISTINCT 关键字过滤它们。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT Style</span><br><span class="line">FROM Track;</span><br></pre></td></tr></table></figure><h2 id="where-子句"><a href="#where-子句" class="headerlink" title="where 子句"></a>where 子句</h2><p>WHERE 子句用于表达关系代数中选择运算的选择条件。<br><a href="https://sm.ms/image/dJUMtu5DN2VwaYr" target="_blank"><img src="https://s2.loli.net/2022/03/24/dJUMtu5DN2VwaYr.png" ></a></p><p>逻辑运算符 AND 和 OR 可以用来联结多个查询条件。<strong>AND 的优先级高于 OR</strong>，但用户可以用括号来改变优先级。</p><h3 id="确定范围"><a href="#确定范围" class="headerlink" title="确定范围"></a>确定范围</h3><p>比较运算符包括：=（等于），&gt;（大于），&lt;(小于)，&gt;=（大于等于），&lt;=（小于等于），!=<br>或者&lt;&gt;（不等于）。</p><p>谓词 BETWEEN…AND 用于查询列值在指定范围内]的元组，其中 BETWEEN 后面跟的<br>是范围下限，AND 后跟的是范围的上限。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT Name, Birth</span><br><span class="line">FROM Singers</span><br><span class="line">Where Birth&lt;1967</span><br><span class="line"></span><br><span class="line">求查询出生年份不在 1970~1980 之间的歌手的姓名与性别</span><br><span class="line">SELECT Name, Gender</span><br><span class="line">FROM Singers</span><br><span class="line">WHERE Birth NOT BETWEEN 1970 AND 1980;</span><br></pre></td></tr></table></figure><h3 id="字段匹配"><a href="#字段匹配" class="headerlink" title="字段匹配"></a>字段匹配</h3><p>谓词 LIKE 可以用来进行字符串的匹配。 其一般语法格式如下：</p><p>列名 [NOT] LIKE ‘&lt;匹配串&gt;’ [ESCAPE ‘&lt;换码字符&gt;’]</p><p>其含义是查找列值与&lt;匹配串&gt;相匹配的元组。通常，&lt;匹配串&gt;中可以使用通配符“%”（百分号）和“_”（下横线）。<br>其中：<br>%：代表任意长度（长度可以为 0）的字符串。例如，a%b 表示以 a 开头、以 b 结尾的<br>任意长度的字符串。字符串 ab、axb、agxb 都满足该匹配串。<br>_：代表任意单个字符。例如，a_b 表示以 a 开头，以 b 结尾，中间夹一个字符的任意字<br>符串。如 axb、a!b 等都满足要求。</p><p>如果用户要查询的字符串本身就含有%或_，这时就要使用’ESCAPE&lt;换码字符&gt;’对通配<br>符进行转义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">查询歌手编号以“GC”开头的歌手姓名、性别。</span><br><span class="line">SELECT Name, Gender</span><br><span class="line">FROM Singers</span><br><span class="line">WHERE SingerID like ‘GC%’</span><br><span class="line"></span><br><span class="line">查询以”John_”开头的歌手的详细信息。</span><br><span class="line">SELECT *</span><br><span class="line">FROM Singers</span><br><span class="line">WHERE Name like ‘John\_%’ ESCAPE ’\’;</span><br></pre></td></tr></table></figure><h3 id="确定集合-判空"><a href="#确定集合-判空" class="headerlink" title="确定集合/判空"></a>确定集合/判空</h3><p>谓词 IN 用来查找某个列值属于指定集合的元组，格式为：</p><p>列名 IN/NOTT IN 集合 (x , x , x , x )</p><p>谓词 IS NULL 用于判断某列的值是否为空值，格式如下：</p><p>列名 IS NULL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">查询曲目表中既不属于“乡村”、“爵士”也不是“摇滚”曲风的专辑详细信息。</span><br><span class="line">SELECT SongID, SingerID</span><br><span class="line">FROM Track</span><br><span class="line">WHERE Style NOT IN (‘乡村’, ‘爵士’ , ‘摇滚’);</span><br><span class="line"></span><br><span class="line">查询曲目表中缺少发行量信息的记录。</span><br><span class="line">SELECT *</span><br><span class="line">FROM Track</span><br><span class="line">WHERE Circulation IS NULL;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="order-by-子句"><a href="#order-by-子句" class="headerlink" title="order by 子句"></a>order by 子句</h2><p>由 SELECT-FROM-WHERE 构成的 SELECT 查询语句完成对表的选择和投影操作，得到一个新的结果表，还可以对得到的新表做进一步的操作。</p><p>ORDER BY 子句用于对查询结果进行排序。<strong>可以按照一个或者多个属性列进行升序（ASC）或者降序(DESC)排列</strong>，默认将按照升序排列。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">查询曲目表中的歌手编号、歌曲编号和曲风类别，将查询结果按照发行时间降序排列。</span><br><span class="line"></span><br><span class="line">SELECT SongID, SingerID, Style</span><br><span class="line">FROM Track</span><br><span class="line">ORDER BY PubYear DESC,SingerID ASC;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="聚集函数"><a href="#聚集函数" class="headerlink" title="聚集函数"></a>聚集函数</h2><p>AVG()：返回某列的平均值</p><p>COUNT()：返回某列的行数</p><p>MAX()：返回某列的最大值</p><p>MIN()：返回某列的最小值</p><p>SUM()：返回某列值之和<br>如果指定 DISTINCT 标识符，则表示计算时要取消指定列中的重复值。如果不指定DISTINCT 或指定 ALL（ALL 为缺省），则表示不取消重复值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">查询 Track 表中的记录总数，最早发行时间、最近发行时间和整个发行量的总和。</span><br><span class="line"></span><br><span class="line">SELECT Count(*) as 记录总数, MIN(PubYear) as ‘最早发行量’, MAX(PubYear) as ‘最近发行</span><br><span class="line">时间’, SUM(Circulation) as ‘发行量总和’</span><br><span class="line"></span><br><span class="line">FROM Track</span><br></pre></td></tr></table></figure><h2 id="group-by-子句"><a href="#group-by-子句" class="headerlink" title="group by 子句"></a>group by 子句</h2><p>聚合函数是对查询结果（一个元组集）中的值进行统计。在有的查询中，我们要把具有相同特征的元组分成若干子集，然后需要再对每个子集中的值进行统计，此时就要用到SELECT 句型中的分组子句“GROUP BY”，格式为:</p><p>GROUP BY &lt;列名列表&gt;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM access_log;</span><br><span class="line">+-----+---------+-------+------------+</span><br><span class="line">| aid | site_id | count | date       |</span><br><span class="line">+-----+---------+-------+------------+</span><br><span class="line">|   1 |       1 |    45 | 2016-05-10 |</span><br><span class="line">|   2 |       3 |   100 | 2016-05-13 |</span><br><span class="line">|   3 |       1 |   230 | 2016-05-14 |</span><br><span class="line">|   4 |       2 |    10 | 2016-05-14 |</span><br><span class="line">|   5 |       5 |   205 | 2016-05-14 |</span><br><span class="line">|   6 |       4 |    13 | 2016-05-15 |</span><br><span class="line">|   7 |       3 |   220 | 2016-05-15 |</span><br><span class="line">|   8 |       5 |   545 | 2016-05-16 |</span><br><span class="line">|   9 |       3 |   201 | 2016-05-17 |</span><br><span class="line">+-----+---------+-------+------------+</span><br><span class="line">9 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">统计 access_log 各个 site_id 的访问量：</span><br><span class="line">SELECT site_id, SUM(access_log.count) AS nums</span><br><span class="line">FROM access_log GROUP BY site_id;</span><br></pre></td></tr></table></figure><p>在用分组语句时，SELECT 后跟的列只能是聚集函数或者是出现在 GROUP BY 之后的分组列。</p><h2 id="having-子句"><a href="#having-子句" class="headerlink" title="having 子句"></a>having 子句</h2><p>在 SQL 中增加 HAVING 子句原因是，WHERE 关键字无法与聚合函数一起使用。</p><p>HAVING 子句可以让我们筛选分组后的各组数据。</p><p><a href="https://www.runoob.com/sql/sql-having.html">https://www.runoob.com/sql/sql-having.html</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT column_name, aggregate_function(column_name)</span><br><span class="line">FROM table_name</span><br><span class="line">WHERE column_name operator value</span><br><span class="line">GROUP BY column_name</span><br><span class="line">HAVING aggregate_function(column_name) operator value;</span><br></pre></td></tr></table></figure><h2 id="笛卡儿积和连接"><a href="#笛卡儿积和连接" class="headerlink" title="笛卡儿积和连接"></a>笛卡儿积和连接</h2><p>SQL 在一个查询中建立几个表的联系的方法非常简单，只要在 FROM 子句中列出所有<br>涉及到的表就可以了。从概念上讲，FROM 子句先对这些表做笛卡尔积操作，得到一个临<br>时表，以后的选择、投影等操作都是针对这个临时表，从而将多表查询转换为单表查询。</p><p>一般格式为</p><p><strong>[&lt;表名 1&gt;.]&lt;列名 1&gt; &lt;比较运算符&gt; [&lt;表名 2&gt;.]&lt;列名 2&gt;</strong></p><h2 id="join-子句"><a href="#join-子句" class="headerlink" title="join 子句"></a>join 子句</h2><p><a href="https://sm.ms/image/KJqzfrO1AQtiM9u" target="_blank"><img src="https://s2.loli.net/2022/03/30/KJqzfrO1AQtiM9u.jpg" ></a></p><h3 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h3><p>在非 ANSI 标准的实现中，连接是在 WHERE 子句中执行的（即在 WHERE 子句中指定表间的连接条件）；在 ANSI SQL-92 中，连接是在 JOIN 子句中执行的。前者称为Theta 连接，后者称为 ANSI 连接。</p><p>ANSI 内连接的语法格式：<br>FROM 表 1 [INNER] JOIN 表 2 ON &lt;连接条件&gt;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">eg ：列出曲库中所有演唱过歌曲的歌手名，歌曲名和发行量。</span><br><span class="line"></span><br><span class="line">Theta 方式的 SQL 语句：</span><br><span class="line">SELECT Songs.Name AS 歌曲名, Singers.Name AS 歌手名,Circulation AS 发行量</span><br><span class="line">FROM Songs,Track,Singers</span><br><span class="line">WHERE Songs.SongID=Track.SongID AND Track.SingerID=Singers.SingerID</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ANSI 方式的 SQL 语句为：</span><br><span class="line">SELECT Songs.Name AS 歌曲名, Singers.Name AS 歌手名,Circulation AS 发行量</span><br><span class="line">FROM Songs JOIN Track ON Songs.SongID=Track.SongID</span><br><span class="line">JOIN Singers ON Track.SingerID=Singers.SingerID</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="自身连接"><a href="#自身连接" class="headerlink" title="自身连接"></a>自身连接</h3><p><strong>连接操作不仅可以在两个表之间进行，也可以与其自身进行连接，称为表的自身连接。</strong></p><p>可以为表提供别名，其格式如下：<br>FROM &lt;源表名&gt; [AS] &lt;表别名&gt;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT FIRST.CNumber， SECOND.PCNumber</span><br><span class="line">FROM Course FIRST， Course SECOND</span><br><span class="line">WHERE FIRST.PCNumber=SECOND.CNumber；</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><p>外连接之限制一张表中的数据必须满足连接条件，而另一张表中的数据可以不满足连接<br>条件。</p><p>Theta 方式的外连接语法格式为：<br>左外连接：FROM 表 1，表 2 WHERE [表 1.]列名(+)=[表 2.]列名<br>右外连接：FROM 表 1，表 2 WHERE [表 1.]列名=[表 2.]列名(+)</p><p>ANSI 方式的外连接语法格式为：<br>FROM 表 1 LEFT | RIGHT JOIN [OUTER] 表 2 ON &lt;连接条件&gt;</p><p>SQL SERVER 支持 ANSI 方式的外连接，但 ORACLE 支持的是 Theta 方式的外连接。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SELECT column_name(s)</span><br><span class="line">FROM table1</span><br><span class="line">FULL OUTER/RIGHT/LEFT JOIN table2</span><br><span class="line">ON table1.column_name=table2.column_name;</span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>在实际应用中，经常有一些 SELECT 语句需要使用其他 SELECT 语句的查询结果，此时就需要用到子查询。</p><h3 id="IN谓词子查询"><a href="#IN谓词子查询" class="headerlink" title="IN谓词子查询"></a>IN谓词子查询</h3><p>其格式如下：<br>SELECT &lt;列名&gt; [,&lt;列名&gt;] …<br>FROM &lt;表名&gt;<br>WHERE &lt;表达式&gt; &lt;[NOT] IN | 其它比较运算符&gt;<br>(<br>  SELECT &lt;列名&gt;<br>  FROM &lt;表名&gt;<br>  WHERE &lt;条件&gt;<br>）</p><p>NOT IN 执行的是集合运算 其他运算符执行比较运算</p><p>使用 IN 运算时，如果表达式的值与集合中的某个值相等，则此运算结果为真；如果表达式的值与集合中的所有值均不相等，则运算结果为假。由关键字 IN 引入的子查询的 SELECT 后的列名只允许有 1 项内容，即只能是一个列名或者是表达式。</p><p>使用子查询进行比较运算时，通过比较运算符（=、&lt;&gt;、&lt;、&gt;、&lt;=、&gt;=），将一个表达式的值与子查询返回的值进行比较。如果比较运算的结果为真，则比较运算返回 TRUE。使用子查询进行比较测试时，要求子查询语句必须是返回单值的查询语句。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">查询歌唱风格是“摇滚”的歌手信息。</span><br><span class="line"></span><br><span class="line">SELECT *</span><br><span class="line">FROM Singers</span><br><span class="line">WHERE SingerID IN</span><br><span class="line">(</span><br><span class="line">  SELECT DISTINCT SingerID</span><br><span class="line">  FROM Track</span><br><span class="line">  WHERE Style =’摇滚’ </span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="带有比较运算符的子查询"><a href="#带有比较运算符的子查询" class="headerlink" title="带有比较运算符的子查询"></a>带有比较运算符的子查询</h3><p>使用子查询进行比较运算时，通过比较运算符（=、&lt;&gt;、&lt;、&gt;、&lt;=、&gt;=），将一个表达式的值与子查询返回的值进行比较。如果比较运算的结果为真，则比较运算返回 TRUE。使用子查询进行比较测试时，要求子查询语句必须是返回单值的查询语句。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">查询年龄最大的歌手的信息</span><br><span class="line"></span><br><span class="line">SELECT *</span><br><span class="line">FROM Singers</span><br><span class="line">WHERE Birth =</span><br><span class="line">(</span><br><span class="line">  SELECT MAX(Birth)</span><br><span class="line">  FROM Singers</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="带有ANY或ALL谓词的子查询"><a href="#带有ANY或ALL谓词的子查询" class="headerlink" title="带有ANY或ALL谓词的子查询"></a>带有ANY或ALL谓词的子查询</h3><p><a href="https://sm.ms/image/UVIQPu9qDElgR6o" target="_blank"><img src="https://s2.loli.net/2022/03/30/UVIQPu9qDElgR6o.jpg" ></a></p><p><a href="https://blog.csdn.net/qq_38157534/article/details/108527994">https://blog.csdn.net/qq_38157534/article/details/108527994</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">【例】查询非计算机科学系中比计算机科学系任意一个学生年龄小的学生姓名和年龄</span><br><span class="line">select Sname，Sage </span><br><span class="line">from student</span><br><span class="line">where Sage &lt; ANY</span><br><span class="line">  ( select  Sage </span><br><span class="line">    from student </span><br><span class="line">    where Sdept  = &quot;CS&quot;) </span><br><span class="line">AND Sdept &lt;&gt; &quot;CS&quot;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="带有EXISTS谓词的子查询"><a href="#带有EXISTS谓词的子查询" class="headerlink" title="带有EXISTS谓词的子查询"></a>带有EXISTS谓词的子查询</h3><p>相关子查询通常使用 EXISTS 谓词，其形式为：<br>SELECT &lt;列名&gt; [,&lt;列名&gt;] …<br>FROM &lt;表名&gt;<br>WHERE<br>WHERE [NOT] EXISTS<br>(<br>  SELECT *<br>  FROM &lt;表名&gt;<br>  WHERE &lt;条件&gt;<br>)</p><p>带有 EXISTS 谓词的子查询不返回任何数据，只产生逻辑真值“true”或逻辑假值“false”：<br><em>若内层查询结果非空，则外层的 WHERE 子句返回真值</em><br><em>若内层查询结果为空，则外层的 WHERE 子句返回假值</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">查询歌唱风格是“摇滚”的歌手信息。</span><br><span class="line"></span><br><span class="line">SELECT *</span><br><span class="line">FROM Singers X</span><br><span class="line">WHERE EXISTS</span><br><span class="line">(</span><br><span class="line">SELECT *</span><br><span class="line">FROM Track</span><br><span class="line">WHERE Track.SingerID=X.SingerID and Style =’摇滚’ )</span><br></pre></td></tr></table></figure><h2 id="集合查询"><a href="#集合查询" class="headerlink" title="集合查询"></a>集合查询</h2><p>SELECT 查询操作的对象是集合，结果也是集合。集合操作主要包括并操作 UNION，交操作 INTERSECT 和差操作 EXCEPT。</p><p>注意： 参加集合操作的各查询结果的列数必须相同；对应项的数据类型也要相同。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">查询中国歌手和出生日期晚于 1960 年的歌手。</span><br><span class="line"></span><br><span class="line">SELECT *</span><br><span class="line">FROM Singers</span><br><span class="line">WHERE Nation=’中国’</span><br><span class="line">UNION</span><br><span class="line">SELECT *</span><br><span class="line">FROM Singers</span><br><span class="line">WHERE Birth&gt;=1960</span><br></pre></td></tr></table></figure><h1 id="xx3x"><a href="#xx3x" class="headerlink" title="xx3x"></a>xx3x</h1><hr />版权信息]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 关系代数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自动机基础</title>
      <link href="/2022/03/10/%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/03/10/%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>编译原理语法分析和自动机笔记</p><span id="more"></span><h1 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h1><ol><li>词法记号：由记号名和属性值构成的二元组，属性值不是必须项，记号名是语法分析的输入符号。</li><li>模式：一个记号的模式描述属于该记号的词法单元的形式。和一个给定模式匹配的字（字符串）的集合成为该模式的语言。</li><li>词法单元：是源程序中匹配一个记号模式的字符序列，由词法分析器识别为该记号的一个实例。<br><a href="https://sm.ms/image/uPWla5wI7JXTDYb" target="_blank"><img src="https://s2.loli.net/2022/04/10/uPWla5wI7JXTDYb.png" ></a></li></ol><h1 id="有限自动机"><a href="#有限自动机" class="headerlink" title="有限自动机"></a>有限自动机</h1><p>词法单元的识别<br><a href="https://sm.ms/image/gv2d78rL1SQahHc" target="_blank"><img src="https://s2.loli.net/2022/04/10/gv2d78rL1SQahHc.png" ></a></p><h2 id="状态转换图"><a href="#状态转换图" class="headerlink" title="状态转换图"></a>状态转换图</h2><ol><li>圆圈表示状态，开始状态由一条没有出发节点、标号为“开始”的边指明</li><li>双层圆圈表示接受状态，表示已识别一个记号</li><li>有向边表示从一个状态到另一状态</li><li>每条边的标号包含一个或多个符号，若离开状态s的某边上标号为other，则它表示离开s的其他边所指示的字符以外的任意字符</li><li>*表示输入指针必须回退的转态</li></ol><p><a href="https://sm.ms/image/Cwu4Y2OULmiG1IJ" target="_blank"><img src="https://s2.loli.net/2022/04/10/Cwu4Y2OULmiG1IJ.png" ></a></p><p>使用*installNum()*来获取要返回的记号名和属性</p><h2 id="不确定的有限自动机（NFA）"><a href="#不确定的有限自动机（NFA）" class="headerlink" title="不确定的有限自动机（NFA）"></a>不确定的有限自动机（NFA）</h2><p><em>不确定的含义是存在这样的状态，对于某个输入符号，存在不止一种的转换</em></p><p><a href="https://sm.ms/image/QKDBcj7fCsMP59F" target="_blank"><img src="https://s2.loli.net/2022/04/10/QKDBcj7fCsMP59F.png" ></a></p><p><strong>手工构造NFA</strong><br><a href="https://sm.ms/image/GJVDSbQnlEvoU34" target="_blank"><img src="https://s2.loli.net/2022/04/10/GJVDSbQnlEvoU34.png" ></a></p><p><strong>转换表表示在NFA输入是a时，状态i所能到达的状态集合。</strong></p><h2 id="确定的有限自动机（DFA）"><a href="#确定的有限自动机（DFA）" class="headerlink" title="确定的有限自动机（DFA）"></a>确定的有限自动机（DFA）</h2><p>是不确定自动机的特殊情况</p><ol><li>任何状态不存在空转换</li><li>对任何状态s和输入符号a，最多只有一条标记为a的边离开s，即转换函数move最多只有一个，并且可以是不分函数</li><li>如果用转换表来表示DFA，表中每个条目最多只有一个状态。</li></ol><p><a href="https://sm.ms/image/b2lZOW4RVk5xnBi" target="_blank"><img src="https://s2.loli.net/2022/04/10/b2lZOW4RVk5xnBi.png" ></a></p><p><a href="https://sm.ms/image/gQ5wBUqhaXrbkiR" target="_blank"><img src="https://s2.loli.net/2022/04/10/gQ5wBUqhaXrbkiR.png" ></a></p><h1 id="从正则表达式到NFA"><a href="#从正则表达式到NFA" class="headerlink" title="从正则表达式到NFA"></a>从正则表达式到NFA</h1><p><strong>MYT算法构造NFA</strong></p><h2 id="构造识别空和字母表中一个符号的NFA"><a href="#构造识别空和字母表中一个符号的NFA" class="headerlink" title="构造识别空和字母表中一个符号的NFA"></a>构造识别空和字母表中一个符号的NFA</h2><p><a href="https://sm.ms/image/S2cYgyePsK37BFZ" target="_blank"><img src="https://s2.loli.net/2022/04/11/S2cYgyePsK37BFZ.png" ></a></p><h2 id="构造识别主算符为选择正则式的NFA"><a href="#构造识别主算符为选择正则式的NFA" class="headerlink" title="构造识别主算符为选择正则式的NFA"></a>构造识别主算符为选择正则式的NFA</h2><p><a href="https://sm.ms/image/jl8qX65Q9fFSWDN" target="_blank"><img src="https://s2.loli.net/2022/04/11/jl8qX65Q9fFSWDN.png" ></a></p><h2 id="造识别主算符为闭包正则式的NFA"><a href="#造识别主算符为闭包正则式的NFA" class="headerlink" title="造识别主算符为闭包正则式的NFA"></a>造识别主算符为闭包正则式的NFA</h2><p><a href="https://sm.ms/image/oszIn5VJFXSbWRv" target="_blank"><img src="https://s2.loli.net/2022/04/11/oszIn5VJFXSbWRv.png" ></a></p><h1 id="从NFA到DFA"><a href="#从NFA到DFA" class="headerlink" title="从NFA到DFA"></a>从NFA到DFA</h1><p><strong>子集构造法</strong></p><p>从第一个状态集合{0} 开始，寻找通过对应的的输入符号所达到的新的状态集合</p><p><a href="https://sm.ms/image/dakmJMfp6csuWOS" target="_blank"><img src="https://s2.loli.net/2022/04/11/dakmJMfp6csuWOS.png" ></a></p><p><a href="https://sm.ms/image/f7G4CmQtKMcugVn" target="_blank"><img src="https://s2.loli.net/2022/04/11/f7G4CmQtKMcugVn.png" ></a></p><h1 id="DFA最简化"><a href="#DFA最简化" class="headerlink" title="DFA最简化"></a>DFA最简化</h1><p>D＇的开始状态是包含了D的开始状态的组的代表<br>D＇的接受状态是包含了D的接受状态的组的代表<br>如果D＇有死状态，则删除它<br>从开始状态不可达的状态也删除<br>从任何其他状态到死状态的转换都改成无定义</p><p>例：<br>为正则表达式(a|b)*a(a|b)(a|b)构造NFA。并将NFA转换为DFA<br><a href="https://sm.ms/image/cCKnjfMRz7u9bUy" target="_blank"><img src="https://s2.loli.net/2022/04/11/cCKnjfMRz7u9bUy.png" ></a></p><hr />版权信息]]></content>
      
      
      <categories>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
            <tag> 概念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库完整性</title>
      <link href="/2022/03/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7/"/>
      <url>/2022/03/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>SQL Server 为了保证数据完整性共提供了以下 6 种约束。</p><ol><li>非空（NOT NULL）约束</li><li>主键（PRIMARY KEY）约束</li><li>外键（FOREIGN KEY）约束</li><li>唯一性（UNIQUE）约束</li><li>检查（CHECK）约束</li><li>默认（DEFAULT）约束</li></ol><span id="more"></span><h1 id="实体完整性及其实现"><a href="#实体完整性及其实现" class="headerlink" title="实体完整性及其实现"></a>实体完整性及其实现</h1><p>规则：若属性A是基本关系R的主属性，则属性A不能取空值</p><h2 id="PRIMARY-KEY-约束"><a href="#PRIMARY-KEY-约束" class="headerlink" title="PRIMARY KEY 约束"></a>PRIMARY KEY 约束</h2><p>表通常具有包含唯一标识表中每一行值的一列或一组列，这样的一列或多列称为表的主键（PRIMARY KEY）。</p><p><strong>一个表只能有一个 PRIMARY KEY 约束，并且 PRIMARY KEY 约束中的列不能接受空值。</strong> </p><p><strong>如果对多列定义了 PRIMARY KEY 约束，则一列中的值可能会重复，但来自 PRIMARY KEY 约束定义中所有列的任何值组合必须唯一。</strong></p><p><strong>当定义主键约束时，SQL Server 在主键列上建立唯一聚簇索引，以加快查询速度。</strong></p><ol><li><p>单一主键的约束<br>CREATE TABLE 或 ALTER TABLE 中使用 PRIMARY KEY 关键字</p></li><li><p>组合主键的约束<br>PRIMARY KEY(列名1，列名2)</p></li></ol><p>代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CREATE TABLE Track</span><br><span class="line">(SongID CHAR(10) not null，</span><br><span class="line">SingerID CHAR(10) not null,</span><br><span class="line">Album VARCHAR(50),</span><br><span class="line">Style VARCHAR(20) default(&#x27;流行&#x27;), /*DEFAULT 约束*/</span><br><span class="line">Circulation INTEGER, PubYear INTEGER,</span><br><span class="line">PRIMARY KEY(SongID, SingerID)) /*主键约束，该约束是表级完整性约束*/</span><br><span class="line"></span><br><span class="line">ALTER TABLE Persons</span><br><span class="line">ADD PRIMARY KEY (P_Id)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="UNIQUE-约束"><a href="#UNIQUE-约束" class="headerlink" title="UNIQUE 约束"></a>UNIQUE 约束</h2><p>唯一约束被用来增强非主键列的唯一性。设置了唯一约束的列不能有重复值，可以但最<br>多允许一个 NULL 值。</p><p><strong>主键约束与唯一约束的异同：</strong><br>两者都要求约束的列不能有重复值；<br>主键约束要求主键列不能为空；唯一约束允许有空值，但只允许一个 NULL 值。</p><p><strong>在一个表上可以定义多个 UNIQUE 约束；</strong></p><p><strong>可以在多个列上定义一个 UNIQUE 约束，表示这些列组合起来不能有重复值。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CREATE TABLE Singer(</span><br><span class="line">-- 主键约束</span><br><span class="line">SingerID char(10) NOT NULL PRIMARY KEY,</span><br><span class="line">-- 唯一约束 </span><br><span class="line">Name varchar(50) NOT NULL UNIQUE, </span><br><span class="line">Gender varchar(2) NULL, Birth datetime NULL,</span><br><span class="line">Nation varchar(20) NULL)</span><br><span class="line"></span><br><span class="line">ALTER TABLE Persons</span><br><span class="line">ADD UNIQUE (P_Id)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="检查和违约"><a href="#检查和违约" class="headerlink" title="检查和违约"></a>检查和违约</h2><ol><li><p>检查主码值是否唯一，如果不唯一则拒绝插入或修改。</p></li><li><p>检查主码的各个属性是否为空，只要有一个为空就拒绝插入或修改。</p></li></ol><h1 id="用户定义完整性及实现"><a href="#用户定义完整性及实现" class="headerlink" title="用户定义完整性及实现"></a>用户定义完整性及实现</h1><p>用户定义的完整性是通过检查约束来实现的。<br>约束条件应是逻辑表达式，多个条件可以用 AND 或 OR 组合。<br>NUll<br>UNIQUE</p><h2 id="CHECK约束"><a href="#CHECK约束" class="headerlink" title="CHECK约束"></a>CHECK约束</h2><p>1） 列级的约束只能引用被约束的列上的值，一个列上可以有任意多个 CHECK 约束，<br>多个 CHECK 约束按创建顺序进行验证。<br>2） 可以在表上建立一个可以在多个列上使用的 CHECK 约束，但是表级约束只能引用<br>同一表中的列。<br>3） 不能在 text、ntext 或 image 列上定义 CHECK 约束。<br>4） CHECK 可以使用 IN、LIKE、BETWEEN 关键字。<br>5)  ADD CONSTRAINT CK_name 命名约束</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>常用约束</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CREATE TABLE Singer(</span><br><span class="line">SingerID char(10) NOT NULL PRIMARY KEY, /* 主键约束 */</span><br><span class="line">Name varchar(50) NOT NULL /* 非空约束 */</span><br><span class="line">UNIQUE, /* 唯一约束 */</span><br><span class="line">Gender varchar(2) NULL CHECK(Gender in(’男’,’女’)), /* 检查约束 */</span><br><span class="line">Birth datetime NULL, Nation varchar(20) NULL)</span><br><span class="line"></span><br><span class="line">WEIGHTNUMERIC(9,2) CHECK(WEIGHT&gt;0 AND WEIGHT&lt;=100 // 体重大于0小于100</span><br><span class="line">SSEXCHAR(2)CHECK(SSEX=&#x27;male&#x27; OR SSEX=&#x27;female&#x27;) // 性别男或女</span><br><span class="line">SAGESMALLINT CHECK(SAGE&gt;=15 AND SAGE&lt;=45)</span><br><span class="line"></span><br><span class="line">ALTER TABLE Persons ADD CONSTRAINT chk_Person CHECK (Id_P&gt;0 AND City=&#x27;Sandnes&#x27;) //命名约束</span><br><span class="line">ALTER TABLE Persons DROP CHECK chk_Person // 删除约束</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="检查和违约-1"><a href="#检查和违约-1" class="headerlink" title="检查和违约"></a>检查和违约</h2><p>当往表中插入元组或修改属性的值时，关系数据库管理系统将检查属性上的约束条件是否满足，不满足被拒绝执行</p><h1 id="参照完整性及实现"><a href="#参照完整性及实现" class="headerlink" title="参照完整性及实现"></a>参照完整性及实现</h1><p>参照完整性主要通过主键与外键的联系来实现的。主键所在的表称为主表，外键所在的<br>表称为子表。外键的取值参照主键的取值，即外键列的值有两种可能：一是等于主键的某个<br>值；二是为空值，否则将返回违反外键约束的错误信息。</p><h2 id="FOREIGN-KEY"><a href="#FOREIGN-KEY" class="headerlink" title="FOREIGN KEY"></a>FOREIGN KEY</h2><ol><li>FOREIGN KEY 约束只能引用同一个服务器上的同一数据库中的表。跨数据库的参照完整性必须通过触发器实现。</li><li>FOREIGN KEY 可引用同一个表中的其他列，这称为自引用。</li><li>FOREIGN KEY 约束并不仅仅可以与另一表的 PRIMARY KEY 约束相链接，它还可以定义为引用另一表的 UNIQUE 约束。</li><li>不能更改定义了 FOREIGN KEY 约束的列的长度，因为外键列和主键列的数据类型和长度需一致。</li></ol><p>利用 <strong>FOREIGN KEY……REFERENCES</strong> 关键字设置参照完整性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE Track</span><br><span class="line">(/*外键约束*/</span><br><span class="line">SongID CHAR(10) not null FOREIGN KEY REFERENCES Songs(SongID), </span><br><span class="line">/*外键约束*/</span><br><span class="line">SingerID CHAR(10) not null</span><br><span class="line">FOREIGN KEY REFERENCES Singers(SingerID),</span><br><span class="line">Album VARCHAR(50),</span><br><span class="line">Style VARCHAR(20) default(&#x27;流行&#x27;), /*DEFAULT 约束*/ </span><br><span class="line">Circulation INTEGER, PubYear INTEGER,</span><br><span class="line">PRIMARY KEY(SongID, SingerID) ) /*主键约束*/</span><br><span class="line"></span><br><span class="line">ALTER TABLE Orders</span><br><span class="line">ADD FOREIGN KEY (P_Id)</span><br><span class="line">REFERENCES Persons(P_Id)</span><br></pre></td></tr></table></figure><h2 id="ON-UPDATE-和-ON-DELETE"><a href="#ON-UPDATE-和-ON-DELETE" class="headerlink" title="ON UPDATE 和 ON DELETE"></a>ON UPDATE 和 ON DELETE</h2><p>SQL Server 2008 中 ，可以 在 CREATE TABLE 语 句和 ALTER TABLE 语 句的<br>REFERENCES 子句中使用 ON DELETE 子句和 ON UPDATE 子句来定义当用户试图删<br>除或更新现有外键指向的主键值时，SQL Server 执行的操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">REFERENCES referenced_table_name [ ( ref_column ) ]</span><br><span class="line">[ ON DELETE &#123; NO ACTION → CASCADE → SET NULL → SET DEFAULT &#125; ]</span><br><span class="line">[ ON UPDATE &#123; NO ACTION → CASCADE → SET NULL → SET DEFAULT &#125; ]</span><br><span class="line"></span><br><span class="line">//为 Track 表添加约束，且指定当主表进行 update 操作时，子表级联更新。</span><br><span class="line">alter table Track add foreign key(SongID) references Songs(Songid) on update cascade</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="检查和违约-2"><a href="#检查和违约-2" class="headerlink" title="检查和违约"></a>检查和违约</h2><p><a href="https://blog.csdn.net/weixin_43524214/article/details/122850808?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_ecpm_v1~rank_v31_ecpm-3-122850808.pc_agg_new_rank&amp;utm_term=%E8%BF%9D%E5%8F%8D%E5%8F%82%E7%85%A7%E5%AE%8C%E6%95%B4%E6%80%A7%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F&amp;spm=1000.2123.3001.4430">https://blog.csdn.net/weixin_43524214/article/details/122850808?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_ecpm_v1~rank_v31_ecpm-3-122850808.pc_agg_new_rank&amp;utm_term=%E8%BF%9D%E5%8F%8D%E5%8F%82%E7%85%A7%E5%AE%8C%E6%95%B4%E6%80%A7%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F&amp;spm=1000.2123.3001.4430</a></p><p><a href="https://sm.ms/image/bsyC7qtdueGkoQ4" target="_blank"><img src="https://s2.loli.net/2022/03/10/bsyC7qtdueGkoQ4.png"  style="width:80%"></a></p><p>（1） 拒绝（NO ACTION）执行<br>不允许该操作执行。该策略一般设置为默认策略<br>（2） 级联（CASCADE）操作<br>当删除或修改被参照表（Student）的一个元组造成了与参照表（SC）的不一致，则删除或修改参照表中的所有造成不一致的元组<br>（3）设置为空值（SET-NULL）<br>当删除或修改被参照表的一个元组时造成了不一致，则将参照表中的所有造成不一致的元组的对应属性设置为空值。</p><hr />版权信息]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL基础</title>
      <link href="/2022/03/10/SQL%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/03/10/SQL%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p><strong>SQL学习笔记</strong></p><p><strong>持续更新ing</strong><br><a href="https://www.runoob.com/sql/sql-tutorial.htmlhttps://www.runoob.com/sql/sql-tutorial.html">https://www.runoob.com/sql/sql-tutorial.htmlhttps://www.runoob.com/sql/sql-tutorial.html</a><br><a href="https://www.liaoxuefeng.com/wiki/1177760294764384">https://www.liaoxuefeng.com/wiki/1177760294764384</a></p><span id="more"></span><h1 id="数据定义"><a href="#数据定义" class="headerlink" title="数据定义"></a>数据定义</h1><h2 id="数据库的定义"><a href="#数据库的定义" class="headerlink" title="数据库的定义"></a>数据库的定义</h2><h3 id="使用T-SQL创建"><a href="#使用T-SQL创建" class="headerlink" title="使用T-SQL创建"></a>使用T-SQL创建</h3><p>使用 SSMS 可以方便地创建数据库，但是，有些情况下不能使用图形化方式创建数据<br>库。比如在设计一个应用程序时，开发人员需要在程序代码中创建数据库及其他数据库对象，<br>而不用在制作应用程序安装包时再放置数据库或让用户自行创建，这就需要采用 T-SQL 语<br>句来创建数据库。</p><p>当使用 SSMS 向导创建数据库后，用户可以查看创建该数据库的 T-SQL 语句。方法是：<br>点击“对象资源管理器”→Music，点击右键快捷菜单中的“编写数据库脚本为”→“Create<br>到”→“新查询编辑器窗口”选项，在打开的查询编辑器窗口中，可以看到创建该数据库的<br>T-SQL 语句</p><p><strong>创建语句</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE database_name /* 指定数据库逻辑文件名*/</span><br><span class="line">[ON</span><br><span class="line">  [PRIMARY]</span><br><span class="line">  [&lt;filespec&gt; [1,…n]]</span><br><span class="line">  [,&lt;filegroup&gt; [1,…n]]</span><br><span class="line">]</span><br><span class="line">/* ON 子句指定数据库的数据文件属性和文件组属性；其中 PRIMARY 指定关联的&lt;filespec&gt;列表定义主文件，如果没有定义 PRIMARY, 则 CREATE DATABASE语句中列出的第一个文件成为主文件 */</span><br><span class="line"></span><br><span class="line">[LOG ON &#123;&lt;filespec&gt; [1,…n]&#125;] /* LOG ON 子句指定事务日志文件属性*/</span><br></pre></td></tr></table></figure><h3 id="修改数据库"><a href="#修改数据库" class="headerlink" title="修改数据库"></a>修改数据库</h3><p>在 SQL Server 中，可用 ALTER DATABASE 语句修改数据库</p><p>其中&lt; filespec &gt;的格式同 CREATE DATABASE 中的&lt; filespec &gt;。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">ALTER DATABASE database</span><br><span class="line"></span><br><span class="line">ADD FILE &lt; filespec &gt; [ ,...n ]</span><br><span class="line">/* 添加新的数据文件 */</span><br><span class="line">[ TO FILEGROUP filegroup_name ]</span><br><span class="line">/* 将要添加的数据文件添加到指</span><br><span class="line">定的文件组中 */</span><br><span class="line"></span><br><span class="line">ADD LOG FILE &lt; filespec &gt; [ ,...n ]</span><br><span class="line">/* 添加新的事务日志文件 */</span><br><span class="line">| REMOVE FILE logical_file_name</span><br><span class="line">/* 删除某一文件 */</span><br><span class="line"></span><br><span class="line">ADD FILEGROUP filegroup_name </span><br><span class="line">/* 添加一个文件组 */</span><br><span class="line"></span><br><span class="line">REMOVE FILEGROUP filegroup_name</span><br><span class="line">/* 删除一个文件组 */</span><br><span class="line"></span><br><span class="line">MODIFY FILE &lt; filespec &gt; </span><br><span class="line">/* 修改某个文件的属性 */</span><br><span class="line"></span><br><span class="line">MODIFY NAME = new_dbname </span><br><span class="line">/* 修改数据库的名字 */</span><br><span class="line"></span><br><span class="line">MODIFY FILEGROUP filegroup_name &#123;filegroup_property|NAME= new_filegroup_name &#125;</span><br><span class="line">/* 修改某个文件组的属性或为文件组定义一个新名字。文件组的属性有三种：READONLY（只读）、READWRITE（读写）、Default（默认） */</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><p>使用 DROP DATABASE 语句删除数据库的语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">DROP DATABASE database_name [,…n]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>创建 Employee 数据库，要求如下：<br>1）主数据库文件名为 Employee，物理文件名为 Employee.mdf，初始大小为 5MB，最大文件大小为100MB，增长幅度为 1MB；<br>2 ） 在 文 件 组 usergroup1 上 建 立 辅 助 数 据 文 件 Employee_dat ， 物 理 文 件 名 为<br>Employee_dat.ndf，初始大小为 3MB，最大为无限大，增幅为 1MB；<br>3）日志文件逻辑文件名和物理文件名均为 Employee_log，初始大小为 3MB，最大为<br>20MB，增幅为 10%。以上文件均存储在为 E:\mssql2008\data 文件夹中。<br>4）为Employee数据库的usergroup2文件组添加一个辅助数据文件Employee_dat2，<br>要求：文件存储在 E:\mssql2008\data 文件夹下，初始大小为 10MB，最大为 20MB，增<br>幅为 5MB<br>5）删除 Employee 数据库的文件组 usergroup2<br>6）修改 Employee 中的数据文件 Employee_dat,将其初始大小改为 10MB，最大容<br>量改为 20MB，增幅设为 2MB。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE Employee </span><br><span class="line">--定义主数据文件</span><br><span class="line">ON PRIMARY </span><br><span class="line">( NAME =Employee, FILENAME = &#x27;E:\mssql2008\data\Employee.mdf&#x27; , </span><br><span class="line">SIZE = 5, MAXSIZE = 100 , FILEGROWTH = 1KB ), </span><br><span class="line"></span><br><span class="line">--定义辅助数据文件</span><br><span class="line">FILEGROUP usergroup1 </span><br><span class="line">( NAME = Employee_dat, </span><br><span class="line">FILENAME = &#x27;E:\mssql2008\data\Employee_dat.ndf&#x27; , </span><br><span class="line">SIZE = 3 , MAXSIZE = UNLIMITED, FILEGROWTH = 1)</span><br><span class="line"></span><br><span class="line">--定义日志文件</span><br><span class="line">LOG ON </span><br><span class="line">(NAME = Employee_log, </span><br><span class="line">FILENAME = &#x27;E:\mssql2008\data\Employee_log.ldf&#x27; , </span><br><span class="line">SIZE = 3, MAXSIZE = 20, FILEGROWTH = 10%)</span><br><span class="line"></span><br><span class="line">--添加数据文件</span><br><span class="line">Alter DATABASE employee</span><br><span class="line">Add file ( NAME = employee_dat2,</span><br><span class="line">FILENAME=&#x27;E:\mssql2008\data\Employee_dat2.mdf&#x27;,</span><br><span class="line">SIZE = 10, MAXSIZE = 50, FILEGROWTH = 5) to filegroup usergroup2</span><br><span class="line"></span><br><span class="line">--删除文件组</span><br><span class="line">--删除文件组中的文件</span><br><span class="line">alter database employee remove file employee_dat2</span><br><span class="line">--删除文件组</span><br><span class="line">alter database employee remove filegroup usergroup2</span><br><span class="line"></span><br><span class="line">--修改数据文件</span><br><span class="line">AlTER DATABASE employee</span><br><span class="line">MODIFY FILE</span><br><span class="line">(NAME = Employee_dat, SIZE = 10, MAXSIZE = 20, FILEGROWTH = 2)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="基本表的定义"><a href="#基本表的定义" class="headerlink" title="基本表的定义"></a>基本表的定义</h2><p>SQL Server 中，可以从两种角度来对表进行分类。</p><ol><li><p>按照数据存储的时间分类：<br>1）永久表<br>表建立后，除非人工删除，否则一直保存。在 master、model、msdb 和用户数据库中建<br>立的表都是永久表。<br>2）临时表<br>临时表的数据只在数据库运行期间临时保存数据，临时表存储在 tempdb 中。</p></li><li><p>按照表的用途来分类<br>1）用户表<br>用户创建的，用于开发各种数据库应用系统的表。<br>2）系统表<br>维护 SQL Server 服务器和数据库正常工作的数据表。每个数据库都会建立很多系统表，<br>这些表不允许用户进行更改，只能由 DBMS 自行维护。<br>3）临时表<br>SQL Server 的临时表有两种类型：本地临时表和全局临时表。<br>本地临时表只对于创建者是可见的。当用户与 SQL Server 实例断开连接后，将删除本<br>地临时表。<br>全局临时表在创建后对任何用户和任何连接都是可见的，当引用该表的所有用户都与<br>SQL Server 实例断开连接后，将删除全局临时表。<br>如果 SQL Server 服务器关闭，则所有的本地和全局临时表都被清空、关闭。<br>从表名称上来看，本地临时表的名称前面有一个“#”符号；而全局临时表的名称前面<br>有两个“##”符号 。</p></li></ol><p><em>说明：临时表的作用——当对数据库执行大数据量的排序等操作时，要产生大量的中间运算结果，因此需要消耗大量的内存资源。如果内存资源不够用，那么 SQL Server 将在临时数据库 tempdb中创建临时表用于存放这些中间结果。</em><br> 4）分区表<br>当一个表中的数据量过于庞大时，可以使用分区表。分区表是将数据水平划分为多个单<br>元的表，这些单元可以分布到数据库中的多个文件组中。在维护整个集合的完整性时，使用<br>分区可以快速而有效地访问或管理数据子集，从而使大型表或索引更易于管理。</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><table><thead><tr><th align="left">序号</th><th align="left">数据类型</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">char(n)</td><td align="left">长度为n的定长字符串</td></tr><tr><td align="left">2</td><td align="left">varchar(n)</td><td align="left">最大程度为n的变长字符串</td></tr><tr><td align="left">3</td><td align="left">clob</td><td align="left">字符串大对象</td></tr><tr><td align="left">4</td><td align="left">blob</td><td align="left">二进制大对象</td></tr><tr><td align="left">5</td><td align="left">int</td><td align="left">长整数(4 字节)</td></tr><tr><td align="left">6</td><td align="left">smallint</td><td align="left">短整数(2 字节)</td></tr><tr><td align="left">7</td><td align="left">bigint</td><td align="left">大整数(8 字节)</td></tr><tr><td align="left">8</td><td align="left">Numeric(10,2)</td><td align="left">指字段是数字型,长度为10 小数为两位的</td></tr><tr><td align="left">9</td><td align="left">Date</td><td align="left">YYYY-mm-dd</td></tr><tr><td align="left">10</td><td align="left">time</td><td align="left">HH:ii:ss</td></tr><tr><td align="left">11</td><td align="left">Datetime</td><td align="left">YYYY-mm-dd HH:ii:ss</td></tr><tr><td align="left">12</td><td align="left">Timestamp</td><td align="left">时间戳类型 不为空 默认值为当前时间</td></tr><tr><td align="left">13</td><td align="left">float</td><td align="left">浮点型，含字节数为4，32bit，数值范围为-3.4E38~3.4E38（7个有效位）</td></tr><tr><td align="left">14</td><td align="left">double</td><td align="left">双精度实型，含字节数为8，64bit数值范围-1.7E308~1.7E308（15个有效位）</td></tr><tr><td align="left">15</td><td align="left">decimal</td><td align="left">数字型，128bit，不存在精度损失，常用于银行帐目计算。（28个有效位）</td></tr></tbody></table><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">create table &lt;表名&gt; (</span><br><span class="line">&lt;列名&gt;&lt;数据类型&gt;[列级完整性约束条件]，</span><br><span class="line">&lt;列名&gt;&lt;数据类型&gt;[列级完整性约束条件]，</span><br><span class="line">...</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>eg：<br><a href="https://sm.ms/image/ywXh2P7sROeGqfn" target="_blank"><img src="https://s2.loli.net/2022/03/10/ywXh2P7sROeGqfn.png" ></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE Singer(</span><br><span class="line">SingerID char(10) NOT NULL,</span><br><span class="line">Name varchar(50) NOT NULL,</span><br><span class="line">Gender varchar(2) NULL,</span><br><span class="line">Birth datetime NULL,</span><br><span class="line">Nation varchar(20) NULL</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="列属性的设置"><a href="#列属性的设置" class="headerlink" title="列属性的设置"></a>列属性的设置</h3><ol><li><p>NULL<br>NULL（空值）表示数值未知或将在以后添加的数据。</p></li><li><p>DEFAULT<br>默认值是指当向表中插入数据时，如果用户没有明确给出某列的值，SQL Server 自动为<br>该列添加的值。</p></li><li><p>IDENTITY<br>使用 IDENTITY 关键字定义的字段又称标识字段。开发人员可以为标识字段指定标识<br>种子（Identity Seed 属性）和标识增量（Identity Increment 属性），系统按照给定的种子和增<br>量自动生成标识号，该标识号是唯一的。<br>使用 IDENTITY 属性时要注意：<br>一个表只能有一个使用 IDENTITY 属性定义的列;<br>IDENTITY 只适用于 decimal（小数部分为 0）、int、numeric（小数部分为 0）、smallint、bigint 或 tinyint 数据类型；<br>标识种子和增量的默认值均为 1；  标识符列不能允许为空值，也不能包含 DEFAULT 定义或对象；<br>标识符列不能更新；<br>如果在经常进行删除操作的表中存在标识符列，那么标识值之间可能会出现断缺。</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">create table Student</span><br><span class="line">(</span><br><span class="line">sno int not null identity(201102001,1), /*设置 IDENTITY*/</span><br><span class="line">sname varchar(50) not null,</span><br><span class="line">sex varchar(2),</span><br><span class="line">hometown varchar(50) null default(&#x27;江苏&#x27;), /*设置默认值*/</span><br><span class="line">introuction varchar(50) null,</span><br><span class="line">birthdate datetime not null )</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="修改-删除表"><a href="#修改-删除表" class="headerlink" title="修改/删除表"></a>修改/删除表</h3><p>表建立好后，一般不会再修改，但随着应用环境和需求的变化，偶尔也要修改已建立好<br>的表，SQL 语言用 ALTER TABLE 语句修改表，其一般格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE &lt;表名&gt;</span><br><span class="line"></span><br><span class="line">[ ADD &lt;新列名&gt; &lt;数据类型&gt; &lt;完整性约束&gt;] /*增加新列*/</span><br><span class="line"></span><br><span class="line">[DROP COLUMN &lt;列名&gt;] /*删除列*/</span><br><span class="line"></span><br><span class="line">[ALTER COLUMN &lt;列名&gt; &lt;数据类型&gt;] /*修改列定义*/</span><br><span class="line"></span><br><span class="line">[ADD &lt;完整性约束&gt;] /*添加约束*/</span><br><span class="line"></span><br><span class="line">[DROP &lt;完整性约束&gt;] /*删除约束*/</span><br><span class="line"></span><br><span class="line">// 当某个表不再需要时，可以使用 DROP TABLE 语句删除它。其一般格式为：</span><br><span class="line"></span><br><span class="line">DROP TABLE &lt;表名&gt;</span><br></pre></td></tr></table></figure><p>其中&lt;表名&gt;是要修改的表，ADD 子句用于增加新列和新的完整性约束条件，DROP 子句用于删除指定的完整性约束条件，ALTER COLUMN 子句用于修改原有的列定义，包括修改列名和数据类型。</p><h2 id="数据完整性的实现"><a href="#数据完整性的实现" class="headerlink" title="数据完整性的实现"></a>数据完整性的实现</h2><a href="/2022/03/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7/" title="数据库完整性">数据库完整性</a><a href="/2022/03/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%8C%E6%95%B4%E6%80%A7/" title="数据库完整性">数据库完整性</a><h1 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h1><a href="/2022/03/23/SQL%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2/" title="SQL数据查询">SQL数据查询</a><a href="/2022/03/23/SQL%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2/" title="SQL数据查询">SQL数据查询</a><h1 id="数据更新"><a href="#数据更新" class="headerlink" title="数据更新"></a>数据更新</h1><h2 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h2><p>元组插入语句的一般格式：<br>INSERT INTO &lt;表名&gt; ( &lt;列名 1&gt; [ , &lt;列名 2&gt;] …)<br>VALUES<br>(&lt;常量 1&gt; [, &lt;常量 2&gt; ]…)<br>(&lt;常量 11&gt; [, &lt;常量 22&gt; ]…)<br>(&lt;常量 111&gt; [, &lt;常量 222&gt; ]…)<br>或者<br>INSERT INTO &lt;表名&gt; ( &lt;列名 1&gt; [ , &lt;列名 2&gt;] …)<br>&lt;子查询&gt;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">假设另有一张歌手表 S，表结构与 Singer 一致，现在要求把 S 表中所有没有在</span><br><span class="line">Singer 表里出现过的男歌星加入到 Singer 表中。</span><br><span class="line"></span><br><span class="line">INSERT INTO Singers (SingerID, Name, Gender, Nation, Birth)</span><br><span class="line">(</span><br><span class="line">  SELECT (SingerID, Name, Gender, Nation, Birth)</span><br><span class="line">  FROM S</span><br><span class="line">  WHERE S.Gender=’男’ and NOT EXISTS (S.SingerID=Singers.SingerID)</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h2><p>SQL 删除语句的格式：</p><p>DELETE FROM &lt;表名&gt; ［WHERE &lt;条件&gt;］</p><p>如果没有 WHERE 子句，将会删除表中所有数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">删除歌手表中不是中国国籍的歌手</span><br><span class="line">DELETE FROM Singers</span><br><span class="line">WHERE Nation&lt;&gt;’中国’</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="修改操作"><a href="#修改操作" class="headerlink" title="修改操作"></a>修改操作</h2><p>当需要修改关系中元组的某些值时，可以用 UPDATE 语句实现。SQL 的 UPDATE 语句的<br>格式：</p><p>UPDATE &lt;表名&gt;<br>SET &lt;列名&gt;＝&lt;值表达式&gt;［，&lt;列名&gt;＝&lt;值表达式&gt;］… [WHERE &lt;条件&gt;］</p><p>如果省略 WHERE 子句，将会修改表中所有的元组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">将 Singers 表中歌手编号为“GC002”的 Birth 属性值修改为 1978。</span><br><span class="line"></span><br><span class="line">UPDATE Singers</span><br><span class="line">SET Birth＝1978</span><br><span class="line">WHERE SingerID＝&#x27; GC002</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="索引与视图"><a href="#索引与视图" class="headerlink" title="索引与视图"></a>索引与视图</h1><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>建立索引以加快查询速度</p><ol><li>在表上创建一个简单的索引。允许使用重复的值：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX index_name</span><br><span class="line">ON table_name (column_name)</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li>在表上创建一个唯一的索引。不允许使用重复的值：唯一的索引意味着两个行不能拥有相同的索引值<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE UNIQUE INDEX index_name</span><br><span class="line">ON table_name (column_name)</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li>修改索引<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter index index_name rename to new_name</span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li>删除索引<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop index index_name</span><br></pre></td></tr></table></figure></li></ol><h2 id="视图-view"><a href="#视图-view" class="headerlink" title="视图 view"></a>视图 view</h2><p>在 SQL 中，视图是基于 SQL 语句的结果集的可视化的表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW view_name AS</span><br><span class="line">SELECT column_name(s)</span><br><span class="line">FROM table_name</span><br><span class="line">WHERE condition</span><br></pre></td></tr></table></figure><p>通过 DROP VIEW 命令来删除视图。<br>通过select 语句查询<br>通过update 语句更新 并不是所有视图都可以更新</p><hr />版权信息]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面向对象</title>
      <link href="/2022/03/07/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
      <url>/2022/03/07/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<p><strong>前言</strong></p><p><strong>Java 面向对象编程 笔记</strong></p><p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1260451488854880">https://www.liaoxuefeng.com/wiki/1252599548343744/1260451488854880</a><br><a href="https://www.cnblogs.com/hellojava/archive/2013/02/27/2935450.html">https://www.cnblogs.com/hellojava/archive/2013/02/27/2935450.html</a><br><a href="https://www.runoob.com/java/java-tutorial.html">https://www.runoob.com/java/java-tutorial.html</a></p><span id="more"></span><h1 id="类的声明"><a href="#类的声明" class="headerlink" title="类的声明"></a>类的声明</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[public | protected | private ][abstract|final] class className [extends superclassName] [implements interfaceNameList]&#123;……&#125;</span><br></pre></td></tr></table></figure><p>其中，修饰符public,abstract,final 说明了类的属性，<br>className为类名，<br>superclassName为类的父类的名字，用于继承<br>interfaceNameList为类所实现的接口列表。</p><h2 id="abstract-抽象类"><a href="#abstract-抽象类" class="headerlink" title="abstract 抽象类"></a>abstract 抽象类</h2><p>如果一个class定义了方法，但没有具体执行代码，这个方法就是抽象方法<br>抽象类除了<strong>不能实例化对象</strong>之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。<br>可以用于继承，即定义新的类父类是一个抽象类</p><h1 id="成员变量和成员方法"><a href="#成员变量和成员方法" class="headerlink" title="成员变量和成员方法"></a>成员变量和成员方法</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class className&#123;</span><br><span class="line">    [public | protected | private ] [static] [final] [transient] [volatile] type variableName;//成员变量</span><br><span class="line">    [public | protected | private ] [static] [final | abstract] [native] [synchronized] returnType methodName([paramList]) [throws exceptionList]&#123;</span><br><span class="line">        statements</span><br><span class="line">    &#125;//成员方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>成员变量限定词的含义：</strong></p><p>static: 静态变量（类变量）<br>final: 常量；<br>transient: 暂时性变量，用于对象存档，用于对象的串行化<br>volatile: 贡献变量，用于并发线程的共享</p><p>方法的实现也包括两部分内容：方法声明和方法体。</p><p>方法声明</p><p><strong>方法声明中的限定词的含义：</strong></p><p>static: 类方法，可通过类名直接调用<br>abstract: 抽象方法，没有方法体<br>final: 方法不能被重写、继承<br>native: 集成其它语言的代码<br>synchronized: 控制多个并发线程的访问</p><h2 id="abstract-抽象方法"><a href="#abstract-抽象方法" class="headerlink" title="abstract 抽象方法"></a>abstract 抽象方法</h2><p>如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是让子类去覆写它，那么，可以把父类的方法声明为抽象方法</p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p><strong>this代表本类的对象</strong></p><p>没有在构造方法中初始化字段时，引用类型的字段默认是null，数值类型的字段用默认值，int类型默认值是0，布尔类型默认值是false</p><p>可以定义多个构造方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Person p1 = new Person(&quot;Xiao Ming&quot;, 15); // 既可以调用带参数的构造方法</span><br><span class="line">        Person p2 = new Person(); // 也可以调用无参数构造方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public Person() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Person(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = 12;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Person(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return this.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="面向对象的基本特征"><a href="#面向对象的基本特征" class="headerlink" title="面向对象的基本特征"></a>面向对象的基本特征</h1><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>在面向对象程式设计方法中，封装（英语：Encapsulation）是指一种将抽象性函式接口的实现细节部分包装、隐藏起来的方法。<br>封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。<br>要访问该类的代码和数据，必须通过严格的接口控制。<br>封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。<br>适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。</p><p><a href="https://www.runoob.com/java/java-encapsulation.html">https://www.runoob.com/java/java-encapsulation.html</a></p><p>private：类中限定为private的成员，只能被这个类本身访问。如果一个类的构造方法声明为private,则其它类不能生成该类的一个实例。<br>default：类中不加任何访问权限限定的成员属于缺省的（default）访问状态，可以被这个类本身和同一个包中的类所访问。<br>protected：类中限定为protected的成员，可以被这个类本身、它的子类（包括同一个包中以及不同包中的子类）和同一个包中的所有其他的类访问。<br>public：类中限定为public的成员，可以被所有的类访问。<br><a href="https://sm.ms/image/TKfdORlCGaQgJVD" target="_blank"><img src="https://s2.loli.net/2022/03/08/TKfdORlCGaQgJVD.jpg" ></a></p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>解决代码重复和便于维护</p><h3 id="继承格式"><a href="#继承格式" class="headerlink" title="继承格式"></a>继承格式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class 父类 &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class 子类 extends 父类 &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>子类拥有父类 <strong>非 private</strong> 的属性、方法。</p><p>子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。</p><p>子类可以用自己的方式实现父类的方法。</p><p><strong>Java支持多重继承，不支持多继承</strong><br><a href="https://sm.ms/image/lNnouWEYDSv2U13" target="_blank"><img src="https://s2.loli.net/2022/03/08/lNnouWEYDSv2U13.jpg" ></a></p><h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><p>我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">  void eat() &#123;</span><br><span class="line">    System.out.println(&quot;animal : eat&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line">  void eat() &#123;</span><br><span class="line">    System.out.println(&quot;dog : eat&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  void eatTest() &#123;</span><br><span class="line">    this.eat();   // this 调用自己的方法</span><br><span class="line">    super.eat();  // super 调用父类方法</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类是不继承父类的构造器（构造方法或者构造函数）的，它只是调用（隐式或显式）。如果父类的构造器带有参数，则必须在子类的构造器中显式地通过 super 关键字调用父类的构造器并配以适当的参数列表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class SuperClass &#123;</span><br><span class="line">  private int n;</span><br><span class="line">  SuperClass()&#123;</span><br><span class="line">    System.out.println(&quot;SuperClass()&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  SuperClass(int n) &#123;</span><br><span class="line">    System.out.println(&quot;SuperClass(int n)&quot;);</span><br><span class="line">    this.n = n;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// SubClass 类继承</span><br><span class="line">class SubClass extends SuperClass&#123;</span><br><span class="line">  private int n;</span><br><span class="line">  </span><br><span class="line">  SubClass()&#123; // 自动调用父类的无参数构造器</span><br><span class="line">    System.out.println(&quot;SubClass&quot;);</span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  public SubClass(int n)&#123;</span><br><span class="line">    super(300);  // 调用父类中带有参数的构造器</span><br><span class="line">    System.out.println(&quot;SubClass(int n):&quot;+n);</span><br><span class="line">    this.n = n;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class TestSuperSub&#123;</span><br><span class="line">  public static void main (String args[])&#123;</span><br><span class="line">    System.out.println(&quot;------SubClass 类继承------&quot;);</span><br><span class="line">    SubClass sc1 = new SubClass();</span><br><span class="line">    SubClass sc2 = new SubClass(100);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为<br>——SubClass 类继承——<br>SuperClass()<br>SubClass<br>SuperClass(int n)<br>SubClass(int n):100</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p><a href="https://sm.ms/image/z3q1aP4sbDHMUx8" target="_blank"><img src="https://s2.loli.net/2022/03/08/z3q1aP4sbDHMUx8.jpg" ></a><br>方法名相同、参数不同（数量不同、类型不同、顺序不同）、同一作用域。<br>返回值类型可以相同也可以不相同，无法以返回型别作为重载函数的区分标准。</p><h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><p>重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。<strong>即外壳不变，核心重写！</strong></p><p><strong>当需要在子类中调用父类的被重写方法时，要使用 super 关键字。</strong></p><p><strong>重写规则</strong></p><ol><li><p>参数列表与被重写方法的参数列表必须完全相同。</p></li><li><p>返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。</p></li><li><p>访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。</p></li><li><p>父类的成员方法只能被它的子类重写。</p></li><li><p>声明为 final 的方法不能被重写。</p></li><li><p>声明为 static 的方法不能被重写，但是能够被再次声明。</p></li><li><p>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。</p></li><li><p>子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。</p></li><li><p>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。</p></li><li><p>构造方法不能被重写。</p></li><li><p>如果不能继承一个类，则不能重写该类的方法。</p></li></ol><h3 id="重载重写区别"><a href="#重载重写区别" class="headerlink" title="重载重写区别"></a>重载重写区别</h3><ol><li><p>方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载(Overloading)。</p></li><li><p>方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写(Overriding)。</p></li><li><p>方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。</p></li></ol><p><a href="https://sm.ms/image/vecY2Ql85H7sOEk" target="_blank"><img src="https://s2.loli.net/2022/03/08/vecY2Ql85H7sOEk.jpg" ></a></p><h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><p>虚函数的存在是为了多态。<br>Java 中其实没有虚函数的概念，它的普通函数就相当于 C++ 的虚函数，动态绑定是Java的默认行为。如果 Java 中不希望某个函数具有虚函数特性，可以加上 final 关键字变成非虚函数。</p><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1260456790454816">https://www.liaoxuefeng.com/wiki/1252599548343744/1260456790454816</a></p><p>如果一个抽象类没有字段，所有方法全部都是抽象方法，就可以把该抽象类改写为接口：<strong>interface</strong></p><p>所谓interface，就是比抽象类还要抽象的纯抽象接口，因为它连字段都不能有。因为接口定义的所有方法默认都是<strong>public abstract</strong>的，所以这两个修饰符不需要写出来（写不写效果都一样）</p><h2 id="接口声明和实现"><a href="#接口声明和实现" class="headerlink" title="接口声明和实现"></a>接口声明和实现</h2><p>Interface关键字用来声明一个接口。</p><p>类使用implements关键字实现接口。在类声明中，Implements关键字放在class声明后面。<br>当类实现接口的时候，类要实现接口中所有的方法。否则，类必须声明为抽象的类。</p><p>类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    void run();</span><br><span class="line">    String getName();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student implements Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public Student(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(this.name + &quot; run&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口特性"><a href="#接口特性" class="headerlink" title="接口特性"></a>接口特性</h2><ol><li><p>接口文件保存在 .java 结尾的文件中，文件名使用接口名</p></li><li><p>当一个具体的class去实现一个interface时，需要使用<strong>implements</strong>关键字</p></li><li><p><strong>一个类可以实现多个interface</strong></p></li><li><p>接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。</p></li><li><p>接口中每一个方法也是隐式抽象</p></li><li><p>接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是 public，用 private 修饰会报编译错误）</p></li><li><p>一个接口能继承另一个接口，这和类之间的继承比较相似。接口的继承使用extends关键字 <strong>并且接口允许多继承</strong><br>eg: public interface int extends int1, int2</p></li></ol><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><h2 id="Inner-Class"><a href="#Inner-Class" class="headerlink" title="Inner Class"></a>Inner Class</h2><p>如果一个类定义在另一个类的内部，这个类就是Inner Class<br>Inner Class 不能单独存在，必须依附于一个实例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Outer outer = new Outer(&quot;Nested&quot;); // 实例化一个Outer</span><br><span class="line">        Outer.Inner inner = outer.new Inner(); // 实例化一个Inner</span><br><span class="line">        inner.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Outer &#123;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    Outer(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class Inner &#123;</span><br><span class="line">        void hello() &#123;</span><br><span class="line">            System.out.println(&quot;Hello, &quot; + Outer.this.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Anonymous-Class"><a href="#Anonymous-Class" class="headerlink" title="Anonymous Class"></a>Anonymous Class</h2><p>在方法内部，通过匿名类（Anonymous Class）来定义Inner Class</p><p>Runnable本身是接口，接口是不能实例化的，所以这里实际上是定义了一个实现了Runnable接口的匿名类，并且通过new实例化该匿名类，然后转型为Runnable</p><p>不关心类名，简化代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Outer outer = new Outer(&quot;Nested&quot;);</span><br><span class="line">        outer.asyncHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Outer &#123;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    Outer(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void asyncHello() &#123;</span><br><span class="line">        Runnable r = new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;Hello, &quot; + Outer.this.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        new Thread(r).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Static-Nested-Class"><a href="#Static-Nested-Class" class="headerlink" title="Static Nested Class"></a>Static Nested Class</h2><p>使用static修饰，静态内部类</p><p>用static修饰的内部类不再依附于Outer的实例，而是一个完全独立的类，因此无法引用Outer.this，但它可以访问Outer的private静态字段和静态方法。<br><strong>用途，可以访问private的方法和变量</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Outer.StaticNested sn = new Outer.StaticNested();</span><br><span class="line">        sn.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Outer &#123;</span><br><span class="line">    private static String NAME = &quot;OUTER&quot;;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    Outer(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class StaticNested &#123;</span><br><span class="line">        void hello() &#123;</span><br><span class="line">            System.out.println(&quot;Hello, &quot; + Outer.NAME);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="包"><a href="#包" class="headerlink" title="包+"></a>包+</h1><p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1260467032946976">https://www.liaoxuefeng.com/wiki/1252599548343744/1260467032946976</a></p><p>将功能相似或相关的类或者接口组织在同一个包中，方便查找和使用。<br>防止命名冲突</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">packsge package_name // 申明包名</span><br><span class="line"></span><br><span class="line">public cless Cless_name&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 导入包</span><br><span class="line">package ming;</span><br><span class="line"></span><br><span class="line">// 导入完整类名:</span><br><span class="line">import mr.jun.Arrays;</span><br><span class="line"></span><br><span class="line">// 导入mr.jun包的所有class</span><br><span class="line">import mr.jun.*;</span><br><span class="line"></span><br><span class="line">public class Person &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        Arrays arrays = new Arrays();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr />版权信息]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理基础概念</title>
      <link href="/2022/03/01/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
      <url>/2022/03/01/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<p><strong>前言</strong></p><p><strong>编译原理笔记</strong></p><p>编译程序的组成及概念解释</p><p><a href="https://sm.ms/image/KEVZuPkjTrQ2UYa" target="_blank"><img src="https://s2.loli.net/2022/03/01/KEVZuPkjTrQ2UYa.jpg"  style="width:60%"></a></p><span id="more"></span><h1 id="语言处理系统"><a href="#语言处理系统" class="headerlink" title="语言处理系统"></a>语言处理系统</h1><p><a href="https://sm.ms/image/PDkWqNwRTOKUV9M" target="_blank"><img src="https://s2.loli.net/2022/03/01/PDkWqNwRTOKUV9M.jpg" style="width:60%"></a></p><h1 id="翻译器"><a href="#翻译器" class="headerlink" title="翻译器"></a>翻译器</h1><p>翻译器是能够完成从一种语言到另一种语言变换的软件</p><p><a href="https://sm.ms/image/LG9S8uT7lUOkjDi" target="_blank"><img src="https://s2.loli.net/2022/03/01/LG9S8uT7lUOkjDi.jpg" style="width:60%"></a></p><h1 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h1><p>编译器是指将<strong>源程序</strong>编译为目标<strong>可执行程序</strong>的系统</p><p>编译器的前端与后端<br>前端：只依赖于源语言<br>后端：依赖于目标机器，一般独立于源语言，与中间语言有关<br>前端+后端：组合<br>取一个编译器前端，重写它的后端以产生同一源语言在另一机器上的编译器<br>把几种不同的语言编译成同一种中间语言，让不同的前端使用同一后端，从而得到一台机器上的几个编译器<br>编译的几个阶段常用一趟/遍（pass）扫描来实现，一趟/遍扫描包括读一个输入文件和写一个输出文件</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><a href="https://sm.ms/image/yqvLdF9N1MsflIT" target="_blank"><img src="https://s2.loli.net/2022/03/01/yqvLdF9N1MsflIT.jpg" style="width:60%"></a></p><h2 id="分析部分-前端阶段任务"><a href="#分析部分-前端阶段任务" class="headerlink" title="分析部分(前端阶段任务)"></a>分析部分(前端阶段任务)</h2><p>前端：源程序 → 中间表示</p><ol><li><p><strong>词法分析</strong><br><a href="https://sm.ms/image/mLJdAs1lEK3IGeS" target="_blank"><img src="https://s2.loli.net/2022/03/01/mLJdAs1lEK3IGeS.jpg" style="width:60%"></a><br>识别最小语法单位并表示词性<br>逐个读构成源程序的字符，把它们组成词法单元(token)流</p></li><li><p><strong>语法分析</strong><br><a href="https://sm.ms/image/etIwzx8q5EZs3gu" target="_blank"><img src="https://s2.loli.net/2022/03/01/etIwzx8q5EZs3gu.jpg" style="width:60%"></a><br>根据单词词性分析语法<br>把词法记号流依照语言的语法结构按层次分组，以形成语法短语</p></li><li><p><strong>语义分析</strong><br>根据单词值分析语义是否正确<br>· 类型转换<br>· 类型检查<br>· 语法制导翻译</p></li><li><p><strong>中间代码生成</strong><br>生成中间代码<br>中间代码位于<strong>高级编程语言</strong>和<strong>机器语言</strong>（目标程序）之间</p></li></ol><h2 id="综合部分-后端阶段任务"><a href="#综合部分-后端阶段任务" class="headerlink" title="综合部分(后端阶段任务)"></a>综合部分(后端阶段任务)</h2><p>后端：中间表示 → 目标程序</p><ol><li><p><strong>代码优化</strong><br>对中间代码进行优化，以期产生更高效的目标代码。</p></li><li><p><strong>目标程序生成</strong><br>将中间代码转换成低级语言代码、机器代码或汇编码。</p></li><li><p><strong>符号表管理</strong><br>编译器的一项重要工作是记录源程序中使用的标识符，并收集每个标识符的各种属性。<br>符号表是为每个标识符保存一个记录的数据结构，记录的域是标识符的属性。</p></li><li><p><strong>出错管理</strong><br>每个阶段都可能发现源程序的错误。发现错误后，该阶段必须处理此错误，使得编译可以继续进行，以便进一步发现源程序的其他错误。</p></li></ol><h1 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h1><p>百度百科：<br>解释器（英语：Interpreter），又译为直译器，是一种电脑程序，能够把高级编程语言一行一行直接转译运行。解释器不会一次把整个程序转译出来，只像一位“中间人”，每次运行程序时都要先转成另一种语言再作运行，因此解释器的程序运行速度比较缓慢。它每转译一行程序叙述就立刻运行，然后再转译下一行，再运行，如此不停地进行下去。</p><p>编译器与解释器区别：</p><p>解释器不像编译器通过翻译来生成目标程序，而是直接执行源程序所指定的运算。</p><h1 id="混合编译器"><a href="#混合编译器" class="headerlink" title="混合编译器"></a>混合编译器</h1><p><a href="https://sm.ms/image/6qEwzlsM79CA1ki" target="_blank"><img src="https://s2.loli.net/2022/03/01/6qEwzlsM79CA1ki.jpg" style="width:60%"></a></p><hr />版权信息]]></content>
      
      
      <categories>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
            <tag> 概念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java文件操作 流(Stream)、文件(File)和IO</title>
      <link href="/2022/02/22/Java-io/"/>
      <url>/2022/02/22/Java-io/</url>
      
        <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>Java.io 包几乎包含了所有操作输入、输出需要的类。所有这些流类代表了输入源和输出目标。</p><p>Java.io 包中的流支持很多种格式，比如：基本类型、对象、本地化字符集等等。</p><p>一个流可以理解为一个数据的序列。输入流表示从一个源读取数据，输出流表示向一个目标写数据。</p><p>Java 为 I/O 提供了强大的而灵活的支持，使其更广泛地应用到文件传输和网络编程中。</p><span id="more"></span><h1 id="读取控制台"><a href="#读取控制台" class="headerlink" title="读取控制台"></a>读取控制台</h1><h2 id="读取输入"><a href="#读取输入" class="headerlink" title="读取输入"></a>读取输入</h2><p>Java 的控制台输入由 System.in 完成<br>可以封装在一个BufferedReader中<br>BufferedReader类从字符输入流中读取文本并缓冲字符，以便有效地读取字符，数组和行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">BufferedReader br = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">c = (char) br.read();</span><br><span class="line">System.out.println(c);</span><br><span class="line"></span><br><span class="line">str = br.readLine();</span><br><span class="line">System.out.println(str);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用 read() 方法从控制台读取一个字符，用 readLine() 方法读取一个字符串。</p><h2 id="控制台输出"><a href="#控制台输出" class="headerlink" title="控制台输出"></a>控制台输出</h2><p>控制台的输出由 print( ) 和 println() 完成,print()输出完毕后不换行，而println()输出完毕后会换行，<br>方法都由类 PrintStream 定义，System.out 是该类对象的一个引用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int b;</span><br><span class="line">b = &#x27;A&#x27;;</span><br><span class="line">System.out.println(b);</span><br><span class="line">System.out.println(&#x27;\n&#x27;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h1><h2 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h2><p>创建一个文件对象来创建一个输入流对象读取文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File f = new File(&quot;C:/java/hello&quot;);</span><br><span class="line">InputStream in = new FileInputStream(f);</span><br></pre></td></tr></table></figure><p>相关函数</p><table><thead><tr><th align="left">序号</th><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">close()</td><td align="left">关闭此文件输入流并释放与此流有关的所有系统资源</td></tr><tr><td align="left">2</td><td align="left">read(int r)</td><td align="left">从 InputStream 对象读取指定字节的数据。返回为整数值，返回下一字节数据，如果已经到结尾则返回-1</td></tr><tr><td align="left">3</td><td align="left">read(byte[] r)</td><td align="left">从输入流读取r.length长度的字节。返回读取的字节数。如果是文件结尾则返回-1</td></tr></tbody></table><h2 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h2><p>创建一个文件并向文件中写数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OutputStream f = new FileOutputStream(&quot;C:/java/hello&quot;)</span><br></pre></td></tr></table></figure><p>相关函数</p><table><thead><tr><th align="left">序号</th><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">close()</td><td align="left">关闭此文件输入流并释放与此流有关的所有系统资源</td></tr><tr><td align="left">2</td><td align="left">write(int w)</td><td align="left">写入指定字节的数据</td></tr><tr><td align="left">3</td><td align="left">write(byte[] w)</td><td align="left">写入w.length长度的字节</td></tr></tbody></table><h2 id="按行读取文件"><a href="#按行读取文件" class="headerlink" title="按行读取文件"></a>按行读取文件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public static void isLegalMagicSquare(String fileName) &#123;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            File myFile = new File(fileName);//通过字符串创建File类型对象，指向该字符串路径下的文件</span><br><span class="line"></span><br><span class="line">            if (myFile.isFile() &amp;&amp; myFile.exists()) &#123; //判断文件是否存在</span><br><span class="line"></span><br><span class="line">                InputStreamReader Reader = new InputStreamReader(new FileInputStream(myFile), &quot;UTF-8&quot;);</span><br><span class="line">                //考虑到编码格式，new FileInputStream(myFile)文件字节输入流，以字节为单位对文件中的数据进行读取</span><br><span class="line">                //new InputStreamReader(FileInputStream a, &quot;编码类型&quot;)</span><br><span class="line">                //将文件字节输入流转换为文件字符输入流并给定编码格式</span><br><span class="line"></span><br><span class="line">                BufferedReader bufferedReader = new BufferedReader(Reader);</span><br><span class="line">                //BufferedReader从字符输入流中读取文本，缓冲各个字符，从而实现字符、数组和行的高效读取。</span><br><span class="line">                //通过BuffereReader包装实现高效读取</span><br><span class="line"></span><br><span class="line">                String lineTxt = null;</span><br><span class="line"></span><br><span class="line">                while ((lineTxt = bufferedReader.readLine()) != null) &#123;</span><br><span class="line">                    //buffereReader.readLine()按行读取写成字符串</span><br><span class="line">                    System.out.println(lineTxt);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Reader.close();</span><br><span class="line"></span><br><span class="line">            &#125; else &#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(&quot;找不到指定的文件&quot;);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;读取文件内容出错&quot;);</span><br><span class="line"></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="xx3x"><a href="#xx3x" class="headerlink" title="xx3x"></a>xx3x</h1><hr />版权信息]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 学习笔记(基础篇)</title>
      <link href="/2022/02/21/java-note/"/>
      <url>/2022/02/21/java-note/</url>
      
        <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>Java 学习笔记(基础篇)</p><p>2022.2.21 </p><p>持续更新</p><span id="more"></span><h1 id="内置数据结构"><a href="#内置数据结构" class="headerlink" title="内置数据结构"></a>内置数据结构</h1><ol><li><p>byte<br>最小值是 -128（-2^7）；<br>最大值是 127（2^7-1）；<br>默认值是 0；</p></li><li><p>short<br>最小值是 -32768（-2^15）；<br>最大值是 32767（2^15 - 1）；<br>Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一；<br>默认值是 0；</p></li><li><p>int<br>最小值是 -2,147,483,648（-2^31）；<br>最大值是 2,147,483,647（2^31 - 1）；<br>一般地整型变量默认为 int 类型；<br>默认值是 0 ；</p></li><li><p>long<br>最小值是 -9,223,372,036,854,775,808（-2^63）；<br>最大值是 9,223,372,036,854,775,807（2^63 -1）；<br>这种类型主要使用在需要比较大整数的系统上；<br>默认值是 0L；</p></li><li><p>float<br>float 数据类型是单精度. 32位. 符合IEEE 754标准的浮点数；<br>float 在储存大型浮点数组的时候可节省内存空间；<br>默认值是 0.0f；</p></li><li><p>double：<br>double 数据类型是双精度. 64 位. 符合 IEEE 754 标准的浮点数；<br>浮点数的默认类型为 double 类型；<br>double类型同样不能表示精确的值，如货币；<br>默认值是 0.0d；</p></li><li><p>boolean<br>1 = true<br>0 = false<br>默认值为false</p></li><li><p>char<br>储存任何字符</p></li></ol><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><ol><li><p>声明变量<br>type identifier [ = value][, identifier [= value] …] ;</p></li><li><p>局部变量<br>局部变量声明在方法. 构造方法或者语句块中；</p></li></ol><p>局部变量在方法. 构造方法. 或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁；</p><p>局部变量只在声明它的方法. 构造方法或者语句块中可见；</p><ol start="3"><li>静态变量<br>类变量也称为静态变量，在类中以 static 关键字声明，但必须在方法之外。</li></ol><p>无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。</p><p>静态变量除了被声明为常量外很少使用，静态变量是指声明为 public/private，final 和 static 类型的变量。静态变量初始化后不可改变。</p><p>静态变量储存在静态存储区。经常被声明为常量，很少单独使用 static 声明变量。</p><p>静态变量在第一次被访问时创建，在程序结束时销毁。</p><p>静态变量可以通过：ClassName.VariableName的方式访问</p><ol start="4"><li>实例变量<br>实例变量声明在一个类中，但在方法. 构造方法和语句块之外；</li></ol><p>当一个对象被实例化之后，每个实例变量的值就跟着确定；</p><p>实例变量在对象创建的时候创建，在对象被销毁的时候销毁；</p><p>实例变量的值应该至少被一个方法. 构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息；</p><p>实例变量可以声明在使用前或者使用后；</p><p>。</p><h1 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h1><h2 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h2><p>public protected default private</p><h2 id="非访问修饰符"><a href="#非访问修饰符" class="headerlink" title="非访问修饰符"></a>非访问修饰符</h2><p>static 声明独立于对象的静态变量或者静态方法</p><p>final 变量一旦赋值后，不能被重新赋值<br>父类的final方法可以被子类继承，但不能被重写，final类不能被继承</p><p>abstract<br>抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。<br>抽象方法是一种没有任何实现的方法，该方法的具体实现由子类提供。</p><p>synchronized<br>关键字声明的方法同一时间只能被一个线程访问。synchronized 修饰符可以应用于四个访问修饰符。</p><p>transient </p><p>volatile</p><h1 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h1><p>variable x = (expression) ? value if true : value if false</p><h1 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h1><p>同C++写法</p><p>while( 布尔表达式 ) {<br>  //循环内容<br>}</p><p>do {<br>       //代码语句<br>}while(布尔表达式);</p><p>for(初始化; 布尔表达式; 更新) {<br>    //代码语句<br>}</p><p>break</p><p>continue</p><p><strong>增强for循环</strong> 主要用于数组</p><p>for(声明语句 : 表达式)<br>{<br>   //代码句子<br>}</p><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">   public static void main(String[] args)&#123;</span><br><span class="line">      int [] numbers = &#123;10, 20, 30, 40, 50&#125;;</span><br><span class="line"> </span><br><span class="line">      for(int x : numbers )&#123;</span><br><span class="line">         System.out.print( x );</span><br><span class="line">         System.out.print(&quot;,&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.print(&quot;\n&quot;);</span><br><span class="line">      String [] names =&#123;&quot;James&quot;, &quot;Larry&quot;, &quot;Tom&quot;, &quot;Lacy&quot;&#125;;</span><br><span class="line">      for( String name : names ) &#123;</span><br><span class="line">         System.out.print( name );</span><br><span class="line">         System.out.print(&quot;,&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h1><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">if(布尔表达式 1)&#123;</span><br><span class="line">   //如果布尔表达式 1的值为true执行代码</span><br><span class="line">&#125;else if(布尔表达式 2)&#123;</span><br><span class="line">   //如果布尔表达式 2的值为true执行代码</span><br><span class="line">&#125;else if(布尔表达式 3)&#123;</span><br><span class="line">   //如果布尔表达式 3的值为true执行代码</span><br><span class="line">&#125;else &#123;</span><br><span class="line">   //如果以上布尔表达式都不为true执行代码</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">switch(expression)&#123;</span><br><span class="line">    case value :</span><br><span class="line">       //语句</span><br><span class="line">       break; //可选</span><br><span class="line">    case value :</span><br><span class="line">       //语句</span><br><span class="line">       break; //可选</span><br><span class="line">    //你可以有任意数量的case语句</span><br><span class="line">    default : //可选</span><br><span class="line">       //语句</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Math-类"><a href="#Math-类" class="headerlink" title="Math 类"></a>Math 类</h1><table><thead><tr><th align="left">序号</th><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">xxxValue()</td><td align="left">将 Number 对象转换为xxx数据类型的值并返回。</td></tr><tr><td align="left">2</td><td align="left">equals()</td><td align="left">判断number对象是否与参数相等</td></tr><tr><td align="left">3</td><td align="left">valueOf()</td><td align="left">返回Number对象指定的内置数据类型</td></tr><tr><td align="left">4</td><td align="left">parseInt()</td><td align="left">将字符串解析为int类</td></tr><tr><td align="left">5</td><td align="left">toString()</td><td align="left">以字符串形式返回值</td></tr><tr><td align="left">6</td><td align="left">abs()</td><td align="left">返回参数的绝对值</td></tr><tr><td align="left">7</td><td align="left">ceil()</td><td align="left">返回大于等于给定参数的最小整数</td></tr><tr><td align="left">8</td><td align="left">floor()</td><td align="left">返回小于等于给定参数的最大整数</td></tr><tr><td align="left">9</td><td align="left">rint()</td><td align="left">返回与参数最接近的整数</td></tr><tr><td align="left">10</td><td align="left">round()</td><td align="left">四舍五入</td></tr><tr><td align="left">11</td><td align="left">max()/min()</td><td align="left">返回两个参数的最大/小值</td></tr><tr><td align="left">12</td><td align="left">exp()</td><td align="left">返回参数的自然数底数的对数值</td></tr><tr><td align="left">13</td><td align="left">log()</td><td align="left">返回参数的自然数底数的对数值</td></tr><tr><td align="left">14</td><td align="left">pow()</td><td align="left">x.pow(y) 返回 x的y次方</td></tr><tr><td align="left">15</td><td align="left">sqrt()</td><td align="left">求算术平方根</td></tr><tr><td align="left">16</td><td align="left">cos()/tan()/sin()/asin()</td><td align="left">三角函数相关</td></tr><tr><td align="left">17</td><td align="left">random()</td><td align="left">返回一个随机数</td></tr></tbody></table><h1 id="Character类"><a href="#Character类" class="headerlink" title="Character类"></a>Character类</h1><table><thead><tr><th align="left">序号</th><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">isLetter()</td><td align="left">是否为字母</td></tr><tr><td align="left">2</td><td align="left">isDigit()</td><td align="left">是否为数字字符</td></tr><tr><td align="left">3</td><td align="left">isWhitespace()</td><td align="left">是否为空白字符</td></tr><tr><td align="left">4</td><td align="left">isUpperCase()/isLowerCase()</td><td align="left">是否为大写/小写</td></tr><tr><td align="left">5</td><td align="left">toUpperCase()/toLowerCase()</td><td align="left">转换为大写/小写</td></tr></tbody></table><h1 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h1><p><a href="https://www.runoob.com/java/java-string.html">https://www.runoob.com/java/java-string.html</a></p><table><thead><tr><th align="left">序号</th><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">charAt(int index)</td><td align="left">返回指定索引处的char值</td></tr><tr><td align="left">2</td><td align="left">compareTo(String str)</td><td align="left">按字典顺序比较字符串 *Tip1</td></tr><tr><td align="left">3</td><td align="left">concat(String str)</td><td align="left">将指定字符串str连接到字符串末尾</td></tr><tr><td align="left">4</td><td align="left">endWith(startsWith)(String suffix)</td><td align="left">是否以指定后缀结束(开始)</td></tr><tr><td align="left">5</td><td align="left">equals(Object anObject)</td><td align="left">比较两个字符串的内容是否相等</td></tr><tr><td align="left">6</td><td align="left">indexOf(int ch(String str)， int fromIndex)</td><td align="left">返回指定字符在此字符串中第一次出现处的索引,从指定位置开始</td></tr><tr><td align="left">7</td><td align="left">lastIndexOf(int ch, int fromIndex)</td><td align="left">返回指定字符在此字符串中最后一次出现处的索引,从指定位置开始</td></tr><tr><td align="left">8</td><td align="left">length()</td><td align="left">返回字符串的长度</td></tr><tr><td align="left">9</td><td align="left">replace(char old, char new)</td><td align="left">返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的</td></tr><tr><td align="left">10</td><td align="left">replaceAll(replaceFirst)(String regex, String replacement)</td><td align="left">使用给定的 replacement 替换此字符串所有(第一个)匹配给定的正则表达式的子字符串</td></tr><tr><td align="left">11</td><td align="left">split(String regex)</td><td align="left">根据给定正则表达式的匹配拆分此字符串</td></tr><tr><td align="left">12</td><td align="left">substring(int beginIndex, int endIndex)</td><td align="left">返回字符串的子字符串 *Tip2</td></tr><tr><td align="left">13</td><td align="left">toUpperCase(toLowerCaes)(Locale locale)</td><td align="left">将字符串小(大)写字符转换为大(小)写</td></tr><tr><td align="left">14</td><td align="left">toCharArray()</td><td align="left">将此字符串转换为一个新的字符数组</td></tr><tr><td align="left">15</td><td align="left">isEmpty()</td><td align="left">判断字符串是否为空</td></tr></tbody></table><p>Tip1: 如果参数字符串等于此字符串，则返回值 0<br>如果此字符串小于字符串参数，则返回一个小于 0 的值；<br>如果此字符串大于字符串参数，则返回一个大于 0 的值。</p><p>Tip2:<br>beginIndex – 起始索引（包括）, 索引从 0 开始。<br>endIndex – 结束索引（不包括）</p><h2 id="判断字符串是否包含特殊字符"><a href="#判断字符串是否包含特殊字符" class="headerlink" title="判断字符串是否包含特殊字符"></a>判断字符串是否包含特殊字符</h2><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public static boolean isSpecialChar(String str) &#123;</span><br><span class="line">       String regEx = &quot;[ _`~!@#$%^&amp;*()+=|&#123;&#125;&#x27;:;&#x27;,\\[\\].&lt;&gt;/?~！@#￥%……&amp;*（）——+|&#123;&#125;【】‘；：”“’。，. ？]|\n|\r|\t&quot;;</span><br><span class="line">       Pattern p = Pattern.compile(regEx);</span><br><span class="line">       Matcher m = p.matcher(str);</span><br><span class="line">       return m.find();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Integer类"><a href="#Integer类" class="headerlink" title="Integer类"></a>Integer类</h1><p>可以在数据转换时使用<br>Interger做为一个包装类型或者说是一个引用类型的,可以传null<br><strong>常用方法</strong></p><ol><li><p>Integer(int value)和Integer(String s)<br>构造方法，肯定常用。</p></li><li><p>public static int parseInt(String s)<br>将字符串转换成整数。</p></li><li><p>public static String toBinaryString(int i)<br>将一个正整数转换成2进制字符串。</p></li></ol><p>public static String toOctalString(int i)<br>将一个正整数转换成8进制字符串。</p><p>public static String toHexString(int i)<br>将一个正整数转换成16进制字符串。</p><p>public static String toUnsignedString(int i, int radix)<br>将一个正整数转换成r进制字符串（r的范围是[2, 64]）。</p><ol start="4"><li>public static Integer valueOf(int i)<br>将一个整数转换成Integer类型对象，即装箱。</li></ol><p>public static Integer valueOf(String s)<br>将字符串数字转换成Integer类型对象，也是装箱。</p><h1 id="StringBuffer-和-StringBuilder"><a href="#StringBuffer-和-StringBuilder" class="headerlink" title="StringBuffer 和 StringBuilder"></a>StringBuffer 和 StringBuilder</h1><p><a href="https://www.runoob.com/manual/jdk11api/java.base/java/lang/StringBuilder.html">https://www.runoob.com/manual/jdk11api/java.base/java/lang/StringBuilder.html</a><br><a href="https://www.runoob.com/java/java-stringbuffer.html">https://www.runoob.com/java/java-stringbuffer.html</a><br>对字符串进行修改时使用<br>能够被多次的修改并且不产生新的未使用对象</p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="声明-创建数组"><a href="#声明-创建数组" class="headerlink" title="声明. 创建数组"></a>声明. 创建数组</h2><ol><li><p>dataType[] arrayRefVar = {value0, value1, …, valuek}; </p></li><li><p>dataType[] arrayRefVar = new dataType[arraySize];</p></li></ol><h2 id="for-each-循环遍历"><a href="#for-each-循环遍历" class="headerlink" title="for each 循环遍历"></a>for each 循环遍历</h2><p>for (double element: myList) {<br>   System.out.println(element);<br>}</p><h1 id="Scanner"><a href="#Scanner" class="headerlink" title="Scanner"></a>Scanner</h1><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>通过创建Scanner类来获取用户的输入<br>通过next() nextLine() 接收字符串<br>通过 hasnext() hasNextLine() 判断是否有输入的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner; </span><br><span class="line"> </span><br><span class="line">public class ScannerDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner scan = new Scanner(System.in);</span><br><span class="line">        // 从键盘接收数据</span><br><span class="line"> </span><br><span class="line">        // next方式接收字符串</span><br><span class="line">        System.out.println(&quot;next方式接收：&quot;);</span><br><span class="line">        // 判断是否还有输入</span><br><span class="line">        if (scan.hasNext()) &#123;</span><br><span class="line">            String str1 = scan.next();</span><br><span class="line">            //String str2 = scan.nextLine();</span><br><span class="line">            System.out.println(&quot;输入的数据为：&quot; + str1);</span><br><span class="line">        &#125;</span><br><span class="line">        scan.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="next-与-nextLine-区别"><a href="#next-与-nextLine-区别" class="headerlink" title="next() 与 nextLine() 区别"></a>next() 与 nextLine() 区别</h2><p>next():</p><ol><li><p>一定要读取到有效字符后才可以结束输入。</p></li><li><p>对输入有效字符之前遇到的空白，next() 方法会自动将其去掉。<br>3只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。<br>next() 不能得到带有空格的字符串。<br>nextLine()：</p></li><li><p>以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。</p></li><li><p>可以获得空白。</p></li></ol><h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作."></a>文件操作.</h1><a href="/2022/02/22/Java-io/" title="Java文件操作 流(Stream)、文件(File)和IO">Java文件操作 流(Stream)、文件(File)和IO</a><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p><a href="https://www.runoob.com/java/java-exceptions.html">https://www.runoob.com/java/java-exceptions.html</a></p><h2 id="遇到的报错记录"><a href="#遇到的报错记录" class="headerlink" title="遇到的报错记录"></a>遇到的报错记录</h2><h3 id="The-static-field-value-arr-should-be-accessed-in-a-static-way"><a href="#The-static-field-value-arr-should-be-accessed-in-a-static-way" class="headerlink" title="The static field value.arr should be accessed in a static way"></a>The static field value.arr should be accessed in a static way</h3><p>静态字段应以静态方式引用<br>接口中的变量前不需要加 this<br>关键字 this 是java为了区分本类属性与外部的冲突而引入的一个调用方式，<br>这个 this 严格意义上讲，应当是调用本类引用属性或方法时使用的，而静态字段更多的是一个常驻与内存中的不变量，所以没必要使用 this 这个关键字</p><h3 id="Cannot-make-a-static-reference-to-the-non-static-method"><a href="#Cannot-make-a-static-reference-to-the-non-static-method" class="headerlink" title="Cannot make a static reference to the non-static method"></a>Cannot make a static reference to the non-static method</h3><p><a href="https://blog.csdn.net/weixin_43914658/article/details/109262885">https://blog.csdn.net/weixin_43914658/article/details/109262885</a><br>main函数中只能调用静态函数，否则需要先实例化对象。</p><h3 id="java-lang-ArithmeticException-Non-terminating-decimal-expansion-no-exact-representable-decimal-result"><a href="#java-lang-ArithmeticException-Non-terminating-decimal-expansion-no-exact-representable-decimal-result" class="headerlink" title="java.lang.ArithmeticException: Non-terminating decimal expansion; no exact representable decimal result."></a>java.lang.ArithmeticException: Non-terminating decimal expansion; no exact representable decimal result.</h3><p>使用BigDecimal某些场景下对于如1/3会得到一个无穷小数，这个时候需要定义计算结果要保留到小数点后几位，否则就会抛出上面的异常。</p><p>public BigDecimal divide(BigDecimal divisor, int scale, int roundingMode)<br>BigDecimal b3 = b1.divide(b2, 4, BigDecimal.ROUND_HALF_UP);</p><hr /><p>版权信息</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>亦非亦林</title>
      <link href="/2022/01/26/her/"/>
      <url>/2022/01/26/her/</url>
      
        <content type="html"><![CDATA[<p><a href="https://sm.ms/image/AxWVizPOZgqN8cw" target="_blank"><img src="https://s2.loli.net/2021/12/24/AxWVizPOZgqN8cw.jpg" ></a> </p><p><strong>前言</strong></p><p><strong>对每一个男孩来说，总有一个女孩，会让你成长</strong></p><p><strong>释怀 感谢 祝福</strong></p><span id="more"></span><h1 id="一些小记"><a href="#一些小记" class="headerlink" title="一些小记"></a>一些小记</h1><h2 id="2021-12-2"><a href="#2021-12-2" class="headerlink" title="2021.12.2"></a>2021.12.2</h2><p>真的是，有那么一天晚上突然就破防了———— 记事本奉上<br><em>网易云那个点评</em><br><em>虽然只是数据的玩笑罢了（大概吧）可能这就是真的内在吧 哪怕做了三四遍结果也没能改变 现在的感觉就像小时候装作大人的样子，明明已经很努力的去付出改变了但好像最后也没得到什么…… 有时候也会想 明明自己也还稚嫩为什么要逼着自己成熟  想有人能给自己说一句你已经很棒了  而不是每天都在方方面面觉得自己不好  为什么内疚呢 会难过呢  因为自己又不满意了吗  怎样才能让你满意呢 不知道  只会做现在能做的的 害怕 害怕自己现在做的不够多会失去什么 害怕哪怕以后能做到却没了目标  这种明明做了很多还感觉自己不好 配不上现在的感觉也太可笑了  难道我感觉的不平 都是正常的吗  一边觉得自己做的这么好还得不到理解的不满  一边怀疑自己真的做好了的怀疑  一边害怕失去脑补各种结局的不安  不知道怎么办 也没有什么可以说的  说给谁呢  为什么不去说呢  你在怕什么  不知道  就是怕…  哦懂了  你害怕得到的答案是你这么做没感觉不对吗  你觉得你很好了吗？</em></p><p>内心挣扎后的现状(笑死 想这么多真就不想睡觉)：</p><p><em>好吧  说了  开始脑补结果了  真是闲</em></p><p><em>好了  什么都说了啊  早上能收到什么呢  不安</em></p><p>其实这种感觉好像也不止这一次了吧 总是能在晚上想到我们两个人以后怎么办 真正晚上想了这么多第二天也不知道该怎么和她去说 在一起真的以及快三年了啊<br>每次看到网上关于异地的评论都在一次次怀疑自己 每次和别人讨论起来基本没几个人能看好吧 说实话有时候觉得自己蛮累的 有时候觉得自己坚持不是为了自己 但是仔细静下心想想自己真的想要什么呢？ 可能就是那种哪怕忙了一天回家能和她一起做饭看电影的日子吧 是怕自己没有了了她真的会孤独吧 我还记得自己当时晚上因为一些小事泣不成声 感觉这么久了每次难过都和这份感情有联系 可能是自己喜欢多想 一遍遍强调自己要相信对方一次次还怀疑自己 可能这就是真正的爱吧 自从慢慢长大发现成年人的爱情真的很累啊 可能自己如果放弃这段感情真的会没有勇气去向前看吧 现在能想到的就只有坚持下去 可能变数真的很多 不安也有很多 那也只能这样了吧 </p><h2 id="2021-12-7"><a href="#2021-12-7" class="headerlink" title="2021.12.7"></a>2021.12.7</h2><p>好久没有打过视频了啊，看到屏幕对面几近崩溃的你真的有一种很无助的感觉，我不知道怎么能帮到现在的你，可能这种情况下你最需要的是一个深深的拥抱而已，但我却没有办法做到，这可能就是异地吧，明明是在最需要你的时候你却没有办法做任何事情，只能用你那笨拙的言语去安慰别人。有时候真的希望能出现在你的身边，大学几年越上越发现有些事情真的不是你想要能做到就能做到的。你学习的压力我已经能感觉快要压垮你了，我能怎么办呢，难道只能遥远的陪伴吗。。。我真的不知道，我害怕，又希望能出现比我更能照顾好你的人。可能对我来说，现在前进的动力是能让未来的我们过的更好。我总是喜欢往前看，这样就能忘记现在的难过。但是若现在的问题解决不了，未来又在哪里呢。。。。。。</p><h2 id="2021-12-19"><a href="#2021-12-19" class="headerlink" title="2021.12.19"></a>2021.12.19</h2><p>今天是该死大直男！<br>但是自己真的忘记了她最喜欢的明星是谁啊。。。。 说起来，这个事情也就是在之前逛街的时候随口提到了吧，只能说有点印象(再加上自己真对演艺明星认识的就少)。感觉好像哪怕在一起将近三年了对互相的了解也只是一点啊。可能和我们互相见面互相深入聊天的次数太少有关叭，好想找个时间可以一起好好聊一聊互相，聊一聊过去的自己。总有一天，会有这个机会吧。<br>记个笔记： 我们家小朋友最喜欢陈伟霆 记住名字！！！不要只认个脸 这么帅的脸你记不住吗？？？</p><h2 id="2022-1-1"><a href="#2022-1-1" class="headerlink" title="2022.1.1"></a>2022.1.1</h2><p>第一次断片，没想到会是因为这么一件小事，其实真的很想让你关心关心我吧，可是好像得到的就是简简单单的下次不要这样了。我真的没什么重要的。<br>补：<br>10月17号，你还会问我在干嘛，要不要打语音，我们还在吐槽身边的各种事情<br>18号，你安架子磨破了手，会怪我没有关心你，希望有人在你身边<br>24号，你叫我陪你一起听歌，会催我给你打视频，晚上会忙<br>26号，你说你有了同款礼物，好开心<br>27号，你很崩溃，我只能发几个抱抱，发消息安慰你，无助<br>31号，你说，你觉得给我发消息之后会猜到我说什么，我只能一遍一遍说我真的在乎你，距离真的会拉远两个人<br>11月1号，你会给我考试加加油，会在我考不好的时候安慰我<br>8号，你说2021所剩无几，时间流逝，我们还剩下什么?<br>16号，你被选上去见领导，参加那个形象大使比赛<br>21号，我帮你给视频消音，能帮到你真的很开心，原来，我在你心里也会很棒啊，<br>22号，你说你感觉你离我好远，我说，四年之后我会和你在一个城市，你给我发了一个爱心，那时的我，还坚定着自己的心<br>25号，你说你已经习惯了忙碌，我说，我们要一起加油<br>28号，你要我帮你领游戏，我们会有一起玩的机会吗？<br>29号，你说你不努力，你在疯狂的否定自己，但是在我心里，你一直都是最好的<br>12月1号，我给你发了网易云的截图，你说你承受了很多，我发了好多好多消息<br>2号，你说你梦到我了，你说我现在其实挺好的，原来付出是有回报的<br>5号，你开始在寝室喝酒，这一年你最忙的时间就要来了<br>6号，给你打视频你很崩溃，无助，胡思乱想<br>7号，你通过了初试，要去电视台参加复试<br>10号，帮你剪歌<br>11号，你上台表演了，并且很棒的进入了下一轮<br>14号，你收到了老师的贺卡，你真的好开心，如果我也能让你这么开心就好了<br>16号，你在否定自己，说自己不努力，真的有好多好多想说的，结果到最后就只有我一直都在而已<br>19号，我没能说出你最喜欢的明星，感觉自己真的对你了解有限，你给老猫说，我完全不懂你<br>22号，你说我在大学学到了很多，你什么都没学到<br>23号，你又在寝室喝酒，生活的压力逐渐把我们两个压垮，对我来说，这段感情最艰难的时候来了<br>24、25号，圣诞节，什么都没有收到，觉得自己很孤独，想要你陪陪我<br>26号，因为礼物寄的晚了所以记得要给你买个蛋糕补偿一下，那是，我还在期待今年会不会有礼物<br>28号，你被垃圾老师弄的很生气，你渐渐变得没有以前那样，你也会骂脏话，会和我狠狠的骂老师<br>29号，帮你弄题，我都不知道为什么自己会这么用心，可能，只是想让你知道我也是很重要的吧<br>30号，你看到了我给你写的信，你说你想了很多，说会和我好好聊一聊，我一直在等<br>31号，晚上你去看电影，说好要给我打电话，没等到，梦想中的礼物也不了了之，那天晚上我很难过，我不知道自己为什么要坚持下去，第一次喝酒到断片</p><h2 id="2022-1-6"><a href="#2022-1-6" class="headerlink" title="2022.1.6"></a>2022.1.6</h2><p>又是睡不着的一晚上，最近发生的事情太多了，有点不太能清楚分析了。<br>跨年夜那天断片的经历是人生第一次，我也不希望会有下一次，我依稀记得在电话里给zly说我到底为什么要坚持下去，说实话，哪怕是清醒的我也不知道，我到底是为了什么要像现在这样痛苦。或者说，我这样坚持是不是只是想知道自己会不会有那一个坚定的目标呢？我说不清楚，可能只是因为感觉自己真的找到心仪的她，或者是因为不愿意去再像现在这样用心去对一个人，现在能做的就是苦苦的继续坚持。为什么在这段感情里自己要处于这么卑微的一个状态呢，明明应该是双向奔赴的感情却好像总是自己的一厢情愿，有点累，有点无助。难道爱情就应该是现在这种感觉吗，这么长时间回想起来却没办法想到多少甜蜜的感觉，仔细想来真的有些好笑，值得吗？<br>最近真的感觉两个人有越走越远的感觉了，这次投票我能感觉到她背后的家庭是多么强大，我相比人家可能真的平平无奇，有时候会想自己要足够强大，这样才能配的上她，才能让人家家里人放心的将她的下半生交给我，但是仔细想想我能做到吗？或者说，我尽心尽力去做的能达到人家的要求吗，从来没有对我们未来的日子这么迷茫过，能想象到的只有很多很多的困难，会是我真的想多了吧，但是总感觉自己像是小说里的那个种平凡的男生，费尽心思追到想要伴随一生的人却因为种种原因没办法得到，这种天生的家庭差距会不会在未来真的变成我们两个之间的隔阂，我不想多想，明明当下都不知道怎么办为什么还要想那么多，我哪怕再怎么拉人能做到的也不及人家家里的百分之一，就这样的我真的能够和她在一起吗。我曾经也相信过爱情，相信走过高三那段时间就可以开始真正的恋爱，但哪怕到了现在我也没感受过什么叫甜蜜的爱，能感觉到的只有无尽的压力，我真的好羡慕那种可以天天一起打游戏，一起出去旅行，天天都能陪在身边的情侣，和他们相比感觉我这真的算是在恋爱吗……<br>说句实话，她一个学期和我发信息的语气渐渐变得没有以前的那种撒娇，就感觉只是普普通通的工作聊天，没有表情包，没有任何恋爱的感觉，以前真的不是这样的。我不知道是不是成熟的爱情就应该这样，每次和别人问我都说什么老夫老妻了这些不重要，但是问问自己的内心，真的不重要吗？可能真的是她很累了吧，但是我想要的真的是这样吗？<br>无助，迷茫，真的不知道感情到现在这个样子该怎么办，下定决心假期和她好好说这件事真的能说出来吗，要是没有任何进展的话自己还能坚持下去吗……我觉得可能不行了吧，我真的真的不喜欢这种压抑的感觉了，希望假期的见面真的能改变这种状态吧。<br>晚安，快去睡觉吧</p><p>补：<br>在我看来，两个人出现不合的情况有两种，一种是不爱了，一种是两个人爱的方式不一样了，第二种对我来说是可以接受的，但是需要两个人去交流，第一种就可以放手了，何必互相为难对方呢？<br>我相信，是第二种</p><h2 id="2022-1-11"><a href="#2022-1-11" class="headerlink" title="2022.1.11"></a>2022.1.11</h2><p>印象里上一次这么长时间没有收到回复是她爷爷去世的时候，也是从那时候开始，你渐渐变了，有一阵你可能真的有抑郁症的倾向，所以我选择一直陪着你，最近我们的交流少到可怜，以至于今天早上醒过来我甚至有一种没有过你的感觉，很恐怖，两个人的感情到了现在这个样子我真的不知道该怎么办了。可能你真的因为比赛很忙很忙，但是真的忙到连消息也看不到吗，我不知道，我不敢多想。<br>从来没用过这种怀疑自己的感觉，一时间我不知道我是不是还爱你，我仔细回想过来总是想不到有什么开心的事情，真的，要结束了吗？<br>今天又翻看以前的聊天记录，只能感觉到真的变了，是我的错觉吗，你是不是真的只是在敷衍我了？这是我这么长时间第一次有这种感觉，但好像又没有那么难过了，好像真的只有怅然了吧。我，尽力了吗？尽力了吧。</p><h2 id="2022-1-21"><a href="#2022-1-21" class="headerlink" title="2022.1.21"></a>2022.1.21</h2><p>距离上次见面已经过去了四天了，我们可能谁都没法想到我们三周年的那一天会变成那个样子，种种三年积压下来的矛盾在那天之后一下子全部爆发了出来，在这几天，我想了很多很多，从在最开始的对你的愧疚，到对自己的反省，到理性的分析我们之间的关系。在当面你把你对我的种种不满一下子倾倒出来的时候，我脑子里真的一片空告，我没有想到在你眼里我竟然是那么的不堪，那么恶劣，在你眼里我竟然是自己最讨厌的那个样子，在那种情况之下，我能做到的就是对自己所做的愧疚，但等我回到家仔细分析的时候，我发现问题可能并不是我真的做的不好，所以我第一次向你说了异地这么长时间一直以来的想法，一直以来我都不愿意将我们之间的关系变成你的负担，这个世界对你已经很糟糕了，我想要给你的是一份陪伴，一份温暖。但是好像我做的一切改变在你眼里都微不足道，我开始反省自己，反思自己是不是应该这么做，那天我把你买的蛋糕带回家给妈妈，妈妈真的很开心，那一刻我真的发现原来这么长时间我对你的付出甚至比起家里至情之人都少了很多，哪怕只以金钱来衡量，在你身上的付出可能会比我这么多年对家里人总和都要多，可能在你看我做的微不足道的事情在妈妈眼里却能让她开心很久。只能说，只有至情之人才会无条件不求回报的对自己好啊。<br>这几天最大的感受就是，很多曾经只是听个调子的歌，现在竟然能一下子明白了其中歌词的含义，可能这就是成长吧。在最迷茫的时候，我甚至把我的想法发到了一个论坛里，得到的回复竟然都是劝我分手，可能是我的描述带有我的主观性吧，但是这清一色的回复还是让我挺难过的，这么长时间的坚持，到最后其实也就是世俗所能预料到的结果吗? 可能要不要分手这种想法在很早之前就有过了，在你复读的时候是想要陪着你坚持下去拿到本应属于你的成绩，在你去看心理医生的时候是想要一直一直坚持做你的后盾，可能每个时间段都会有能让我坚持下去的理由，哪怕到了现在，在你说你因为你爸妈的情况开始害怕爱情后我的理由都会是想要让你在我身上重新期待爱情，期待生活。因为我知道，你真的是一个特别特别好的女孩，如果因为这种事情而在你心里结下一个心结，对你来说是不公平的，也是我不想看到的。<br>我也意识到了，这次可能真的是目前为止我们最有可能分道扬镳的一次了，我们两个人真的有很多很多还需要解决的问题，不管是你我家庭的情况还是你我两个人对爱情的看法，可能在我看来爱情应该是平等的吧，所以在我一次次付出之后渐渐开始考虑做这件事的意义，在我付出了这些之后你会不会也会这样对我。可能对你来说你所希望的爱情是能让你能感受到在经历的是你心中的美好爱情吧，这么长时间你也从来没有和我说过对我有什么期望，希望的爱情是什么样子的，可能你现在真的不愿意去想爱情吧，如果我和你是朋友，是闺蜜，我们都不会有这些矛盾。你说做不好当下，怎么去谈未来，但我觉得，未来是为了让我们能更好的做好当下，没有一个目标，你为什么要做好当下呢? 我也很羡慕别人女朋友会给她的男孩买鞋子、织围巾，会陪她的男孩子一起玩游戏，一起听歌，但我觉得不能因为你没有做这些就说你是不好的，每个人的情况都是不一样的。所以我一直在等，等你说你真的也愿意为我们两个的未来努力，等你说你期望的未来是有我的。但是这么长时间了，我一直没有等到，甚至会感觉越来越等不到了，所以我选择和你好好聊一聊这些事情。在我看来我既然选择了要和你在一起，那就是为了以后，如果只是为了当下的快乐，那又何必选择这条崎岖的路呢。所以我哪怕觉得可能会出现现在的情况，也决定说出来这些。<br>其实之前那几次对我们之间的感情的怀疑最后都是感性占了上风，但这次我能感觉到自己真的理性了很多，我不会再觉得自己对你真的有我想象的那么重要，我想要的是你的回答，而不是我的一厢情愿。但是不管最后的结果怎么样，我都希望你能知道，和你的这三年真的让我成长了很多，我真的很感谢你的出现，可能在这段感情中，我收获的真的比你要多吧，所以我不会强求你什么，你是怎么想的我都会尊重你的想法。我不想再这么等下去了，继续还是分开，都会是上天给我们这段感情的安排吧。</p><p><em>你会不会偶尔想起，十几岁只图你感情的人？</em><br><a href="https://b23.tv/YTZymNu">https://b23.tv/YTZymNu</a></p><h2 id="2022-2-7"><a href="#2022-2-7" class="headerlink" title="2022.2.7"></a>2022.2.7</h2><p>在那次吵架之后，我真的平静了很多，但是不管自己怎么劝说自己不要去关心那么多，她的情况还是让我很担心，可能之前对我来说是在陪伴她，现在自己是真心想要去帮助她，在和她一起走出现在的困境的过程中自己成长，仔细想想，为什么我非得要去和她一起呢？她对我就那么重要？可能对我来说我只是不想她一个很好很好的女孩会因为现在这些事情变得堕落，变成我们最讨厌的样子吧。这个假期我真的能看到当一个倾听者的重要性，我一直在尝试变成她的倾听者，我相信她不会背叛我，现在对我来说，现在做这些的意义可能会是有一天她能真心真义的希望我能陪在她身边，一起面对这糟糕的生活。</p><h2 id="2022-2-19"><a href="#2022-2-19" class="headerlink" title="2022.2.19"></a>2022.2.19</h2><p>嘿 20岁的小朋友<br>说是小朋友，但是在我看来你真的已经不是那个我以前认识的王奕飞了，我也不是以前的那个我了，时间的痕迹渐渐的转变了我们俩的思想，改变着我们的关系。今天突然突发奇想翻看着曾经的相册，翻看我们20年那个夏天的聊天记录，原来从那个时候开始，我就已经让你失望了，那个时候的我，还不知道怎么样去关心自己爱的人，只知道疯狂的倾诉自己的想法，但那个时候的你，还爱着我，还会和我说喜欢我，会和我撒娇，会在我身边像一个小朋友。</p><p>看着曾经我们的爱情，我都在想如果当时自己想现在一样看清了一部分，你会不会已经走出了现在的困境，会不会变得开心一点。一个假期过去，我渐渐开始理解你的行为，会觉得我上次见你所说的是多幼稚的想法，其实我们都没有错，但是你经历的已经改变了你太多，我在努力的让自己成长，但是还是跟不上你的变化。可能是我曾经伤害了你太多，或者是你现在真的不想面对我们的感情，你开始对我关上了那扇爱情的门，藏起了对我喜欢的火苗，无止尽的黑暗笼罩在我们两个之间，我看不到你，也看不到我们的未来。我开始慌张，害怕你会在黑暗中迷失方向，被黑暗腐蚀变成我们两个最讨厌的样子，所以我想要为你指引道路，想要陪着你寻找那束光。虽然我也没有拥有那扇门的钥匙，我也不清楚光的位置，但是我一直觉得我有那个责任陪着你，但也只能陪着。</p><p>可是又有谁愿意一直坚持这种看不到结果的摸索呢，当我发现你甚至不愿意在黑暗中拉住我的手的时候，我真的好想放弃，会想没有我也有更好的人陪着你，可能他还有那把钥匙，不安和怀疑冲垮了我，所以我选择和你聊清关系，那怕付出的代价是分离。最后得到的结果虽然不是我想要的，但是也让我明白了这片黑暗比我想象中更难逃脱，对你的影响更大。再加上一个假期所经历的各种各样的事情，我才看清自己做了什么。你说你开始怀疑爱情，我又何尝不是呢，和你在一起的这几年里，我开始习惯没有联系，开始习惯独自的生活，开始失去对异性的兴趣，开始嘲笑那种纯洁的爱情。一个假期过去，我真的不想再因为你而整天抑郁不欢，因为没有你的回应而焦躁不安。</p><p>所有人都觉得我看起来已经很累很累了，我还能再坚持下去吗？这个假期我最大的收获一个是知道自己现在有多么幸福，另一个是知道对于身在困境的人来说不经意的支持是能够改变他的。有一天半夜那个曾经抑郁症的朋友对我说他要继续向前，他的后盾们有我在其中，我忽然明白能够帮到自己真的愿意帮的人是多幸福的事情。</p><p>所以我接受我们现在这种可能并不能称之为在恋爱的情况，我想要陪着你走过你这段困难的时刻，为了认识你的三年，也为了改变我这么多的曾经的你，我会在你需要我的时候陪在你的身边，可能我没有办法像以前那样爱你，如果有一天我能陪着你走出来，我希望我做到的能让你找回喜欢我的那微弱的火苗，在以后你能发现在我的陪伴下你能变成你想要的样子，记得有一个青涩少年在二十岁的时候为了不留下遗憾而坚定的陪在你的身边，记得我们在二十岁的年纪都对互相没有什么遗憾。</p><p>我相信只要一个人对每一段情感的付出投入是真诚的，那最后结果让人遗憾伤痛，也是没有办法。我希望对我们来说那怕我们之间结束了，我们这么长时间的爱情都不是失败的，都是有所收获的。我更希望你能从现在的琐事中走出来，想想自己的以后，不被各种各样负面的东西影响自己的本心，你要记住你身后有很多很多关心你的人，家人也好朋友也好，他们都是因为你的优秀才愿意和你站在一起，自信一点，至少在我眼里，你一直很棒，以后也会。</p><p>如果有一天在经历了这么多之后你能够很坚定的说出愿意和我一直在一起的话，是对我的努力的最大肯定。我也等着那天的到来。在那天之后，我要带你去旅行，去埃菲尔铁塔下面深深的吻你，去意大利街头的咖啡店看着你打盹，在世界的任何地方留下我们的回忆，去享受这个不完美的人生。</p><p>一起加油吧，要好好生活，为了我们身后的人，也为了我们自己。</p><p>生日快乐，我的小朋友</p><h2 id="2022-2-21"><a href="#2022-2-21" class="headerlink" title="2022.2.21"></a>2022.2.21</h2><p>朋友，恋人，我一时不知道我在期待着什么关系，当你真正对你自己爱的人说出我们之间不如朋友的时候，你是有多么累，多么无助，有些事情不是你想做就能得到的，生活就是这样，你最想抓住的，往往都会离你远去</p><h2 id="2022-3-12"><a href="#2022-3-12" class="headerlink" title="2022.3.12"></a>2022.3.12</h2><p>没想到最后竟然是这样草草结束了我们的寒假，这个寒假开始之前我曾对自己做出过承诺，如果没有解决我们两个之间的问题的话，就要狠下心来结束它，现在时间已至，可能真的想说的都说了吧，最终结果好像并没有什么变化，变化的只是我的心态，我疯狂的告诉自己不要再那么重视你，我们之间可以像现在这样的朋友关系，没有爱。但这样真的是对的吗？我不知道，现在的感觉就是没有什么意义继续下去，也没有什么理由去放弃，我能感觉到这样继续下去只会越来越远，但是我怎么忍心只是在网络上去和你道别呢……也许下一次见面，就是我放弃的时候吧。渐渐的我开始不去理会那不回复的消息，不去想以后会不会有你，但是有时候夜晚的梦还会是我们两个在一起的样子，醒来之后的落差真的让我很难过，我想要的不是现在的这个样子，当一段感情变不成你想要的样子，继续坚持下去又有什么意义呢？不管你的情况是不是真的这样，我都选择完完全全的相信，因为这样我可以少很多的难过，迷惑自己让自己以为还会好起来的。可能，我也不会再爱了吧，当那个火苗熄灭之后，我，还能找到自己想要的那个样子吗？现在这个情况继续下去，又有什么不好的吗？我已经不想让自己那么累了，我也不想因为这个伤害自己太多，真的不值得的。这个时代的人，还需要爱情吗？</p><h2 id="2022-3-22"><a href="#2022-3-22" class="headerlink" title="2022.3.22"></a>2022.3.22</h2><p>当你发现自己在不知不觉中没有以前那么关心她了，是好事还是坏事呢？现在真的没有在去想以后的我们了，心里会轻松好多，但是真的是对的吗？</p><h2 id="2022-4-6"><a href="#2022-4-6" class="headerlink" title="2022.4.6"></a>2022.4.6</h2><p>现在好像渐渐明白为什么长大会渐渐失去热爱，会失去热情，当你经历了很多之后，失望越来越多，很多时候，你都没有自己想象的那么那么重要，不是吗。那些曾经的期待，在一次一次的失望后已经不复存在了，到最后，就不敢再去期待什么了。<br>我好像，已经快要失去那份期待了。<br>其实看到你身边有那么多对你好的人，心里不知道该怎么想，真心为你高兴，也不知道自己为什么要继续坚持下去，明明，已经不需要我了，不是吗？</p><h2 id="2022-4-18"><a href="#2022-4-18" class="headerlink" title="2022.4.18"></a>2022.4.18</h2><p>苏州疫情又反复了，这个学期大概率是要在家待上一整个学期了，可能做梦都想不到大学会是以这个样子度过两年吧，有时候会想如果没有疫情，我们两个之间会不会更好，但是一切都不会有如果，要习惯现状。渐渐的我明白了自己其实一点都不重要，也没有必要那么重要，我做不到我眼中的最好，只能像现在这样如虚无缥缈一般在你身边，曾经的我也幻想过我想要的生活，幻想过曾经奢求的爱情，但是时间流逝，是我已经无力去想象了吧，维持现状吧。疫情让我将自己的社交降到了最低，我不知道两年的大学生活我得到了什么，身边多了什么值得自己相信的人，做什么事情会变得越来越功利，每天都在带着危机感混混度日，很多很多的计划都没能实践下来。可能我的大二就这么过去了吧，如果没有疫情，我会变成这样吗？有时候真的很羡慕你在大学里能有那么多关系好的同学，有那么多人对你好，相反我大学两年越来越感觉孤独，越来越感觉这个世界是我一个人的世界，真的很久没有感受到有人突然关心我的感动了，之前看到关系好的哥们在状态不好的时候收到了来自自己认识很久的女生的祝福的时候真的很羡慕很羡慕，但是我什么都做不了，之能感叹一句这个世界还是很好的。只能看看吧，我还是只能像个无业游民一般混在家里，每天做做饭上上课打打游戏，日子一天天变得无趣起来了。原来成长的代价是失去曾经的拿份热爱和期盼吧。</p><p>看着身着礼服美如天仙的你，会幻想有一天你会为我盛装打扮吧，可能吧。</p><p><a href="https://sm.ms/image/R7T8qibSgMwuhGY" target="_blank"><img src="https://s2.loli.net/2021/12/24/R7T8qibSgMwuhGY.jpg" ></a></p><h2 id="2022-4-25"><a href="#2022-4-25" class="headerlink" title="2022.4.25"></a>2022.4.25</h2><p>情理之中，意料之外，这篇博客也走到了尽头了。<br>没想到才刚刚熟悉现在的感觉就分开了，虽然总归有些不舍，但是更多的是释怀，好像什么都没变。可能你说的对，陪伴在身后的朋友就是最好的陪伴，你没有那么需要我了，我也从你那得不到我想要的了，只能说命运的安排吧，我们都很好，但是确实是两条轨道上的人了，没有什么好多说的，还是那句话，谢谢你，让我成长了这么多，对不起，不能陪你继续面对这个世界。</p><h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><h1 id="2022-8-16"><a href="#2022-8-16" class="headerlink" title="2022.8.16"></a>2022.8.16</h1><p>祝你幸福 祝我幸福</p><p><strong>全篇完</strong></p><hr />版权信息]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 想法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matlab笔记</title>
      <link href="/2022/01/17/matlab/"/>
      <url>/2022/01/17/matlab/</url>
      
        <content type="html"><![CDATA[<p><a href="https://sm.ms/image/pstS2TFVXGEo71x" target="_blank"><img src="https://s2.loli.net/2022/01/17/pstS2TFVXGEo71x.jpg" ></a></p><p><strong>前言</strong></p><p>matlab笔记，备战美赛</p><p>冲鸭！！！</p><span id="more"></span><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="矩阵和数组"><a href="#矩阵和数组" class="headerlink" title="矩阵和数组"></a>矩阵和数组</h2><p>所有 MATLAB 变量都是多维数组，与数据类型无关。矩阵是指通常用来进行线性代数运算的二维数组。</p><h3 id="数组创建"><a href="#数组创建" class="headerlink" title="数组创建"></a>数组创建</h3><ol><li>用空格或者逗号(,)分隔数据<br>a = [1 2 3 4]</li><li>用分号;分隔多行数据<br>a = [1 3 5; 2 4 6; 7 8 10]</li><li>创建矩阵的另一种方法是使用 ones、zeros 或 rand 等函数。<br>zeros全部为零</li></ol><p>ones全部为 1</p><p>rand均匀分布的随机元素</p><p>randn正态分布的随机元素</p><p>z = zeros(5,1)</p><h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><ol><li><p>用单一运算符处理矩阵中的所有值<br><a href="https://sm.ms/image/uTdrzlhOf4jVIJq" target="_blank"><img src="https://s2.loli.net/2022/01/17/uTdrzlhOf4jVIJq.jpg" style="width:60%"></a></p></li><li><p>转置矩阵使用单引号<br>a’<br>撇号运算符（例如，A’）执行复共轭转置。它会围绕主对角线翻转矩阵，并且还会更改矩阵的任何复数元素的虚部符号。点撇号运算符 (A.’) 转置矩阵，但不会影响复数元素的符号。对于包含所有实数元素的矩阵，这两个运算符返回相同结果。</p></li><li><p>inv()<br>计算方阵x的逆矩阵</p></li><li><p>使用 * 执行矩阵乘法<br><a href="https://sm.ms/image/aZrP1lmifzCGKJM" target="_blank"><img src="https://s2.loli.net/2022/01/17/aZrP1lmifzCGKJM.jpg" style="width:60%" ></a></p></li><li><p>使用 format 命令可以显示更多小数位数<br>format long<br>format short</p></li><li><p>执行元素级乘法 .* 运算符<br>乘法、除法和幂的矩阵运算符分别具有执行元素级运算的对应数组运算符。</p></li><li><p>串联<br>连接数组以便形成更大数组的过程，成对的方括号 [] 即为串联运算符。<br><a href="https://sm.ms/image/QPu2vlSCEnIe15g" target="_blank"><img src="https://s2.loli.net/2022/01/17/QPu2vlSCEnIe15g.jpg" style="width:60%"></a></p></li><li><p>复数<br>表示虚部用 i j<br>c = [3+4i, 4+3j; -i, 10j]<br>c = 2×2 complex</p><p>3.0000 + 4.0000i   4.0000 + 3.0000i<br>0.0000 - 1.0000i   0.0000 +10.0000i</p></li><li><p>sum()<br>S = sum(A) 返回 A 沿大小不等于 1 的第一个数组维度的元素之和。</p></li></ol><p>如果 A 是向量，则 sum(A) 返回元素之和。</p><p>如果 A 是矩阵，则 sum(A) 将返回包含每列总和的行向量。</p><p>如果 A 是多维数组，则 sum(A) 沿大小不等于 1 的第一个数组维度计算，并将这些元素视为向量。此维度会变为 1，而所有其他维度的大小保持不变。</p><p>S = sum(A,dim) 沿维度 dim 返回总和。例如，如果 A 为矩阵，则 sum(A,2) 是包含每一行总和的列向量。</p><p>S = sum(A,’all’) 计算 A 的所有元素的总和。</p><p>使用 sum 和 diag 函数可以获取主对角线上的元素的总和：</p><p>sum(diag(A))</p><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>A = 4×4</p><pre><code> 1     2     3     4 5     6     7     8 9    10    11    1213    14    15    16</code></pre><ol><li><p>指定行和列下标<br>A(4,2)<br>ans = 14</p></li><li><p>单一下标按顺序向下遍历每一列<br>A(8)<br>ans = 14</p></li><li><p>要引用多个数组元素，请使用冒号运算符，这使您可以指定一个格式为 start:end 的范围<br>A(1:3,2)<br>ans = 3×1</p><p>  2<br>  6<br> 10<br>单独的冒号（没有起始值或结束值）指定该维中的所有元素。<br>A(3,:)<br>ans = 1×5</p><p>  9    10    11    12<br>冒号运算符还允许您使用较通用的格式 start:step:end 创建等间距向量值。默认步长为1<br>B = 0:10:100<br>B = 1×11</p><p>  0    10    20    30    40    50    60    70    80    90   100</p></li><li><p>包含冒号的下标表达式引用部分矩阵：<br>A(1:k,j)<br>表示 A 第 j 列中的前 k 个元素。因此，<br>sum(A(1:4,4)) 计算第四列的总和。<br>但是，执行此计算有一种更好的方法。冒号本身引用矩阵行或列中的所有元素，而关键字 end 引用最后一个行或列。<br>sum(A(:,end))</p></li><li><p>删除行和列<br>只需使用一对方括号即可从矩阵中删除行和列。首先<br>X = A<br>然后，要删除 X 的第二列，请使用<br>X(:,2) = []<br>这会将 X 更改为<br>X =<br> 16     2    13<br>  5    11     8<br>  9     7    12<br>  4    14     1<br>如果您删除矩阵中的单个元素，结果将不再是矩阵。因此，以下类似表达式<br>X(1,2) = []<br>将会导致错误。<br>但是，使用单一下标可以删除一个元素或元素序列，并将其余元素重构为一个行向量。因此<br>X(2:2:10) = []<br>生成<br>X =<br> 16     9     2     7    13    12     1</p></li></ol><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>结构体是多维 MATLAB 数组，包含可按文本字段标志符访问的元素。例如，<br>S.name = ‘Ed Plum’;<br>S.score = 83;<br>S.grade = ‘B+’<br>创建一个具有三个字段的标量结构体：<br>S =<br>     name: ‘Ed Plum’<br>    score: 83<br>    grade: ‘B+’<br>与 MATLAB 环境中的所有其他内容一样，结构体也为数组，因此可以插入其他元素。在本示例中，数组的每个元素都是一个具有若干字段的结构体。可以一次添加一个字段，<br>S(2).name = ‘Toni Miller’;<br>S(2).score = 91;<br>S(2).grade = ‘A-‘;<br>也可以使用一个语句添加整个元素：<br>S(3) = struct(‘name’,’Jerry Garcia’,… ‘score’,70,’grade’,’C’)</p><h2 id="工作区变量"><a href="#工作区变量" class="headerlink" title="工作区变量"></a>工作区变量</h2><p>使用<br>whos 查看工作区内容<br>save 保存数据 系统使用.mat拓展名将工作区保存在当前工作文件夹中一个名为 MAT 文件的压缩文件中<br>load 还原到工作区<br><a href="https://ww2.mathworks.cn/help/matlab/learn_matlab/workspace.html">https://ww2.mathworks.cn/help/matlab/learn_matlab/workspace.html</a></p><h2 id="字符串和文本"><a href="#字符串和文本" class="headerlink" title="字符串和文本"></a>字符串和文本</h2><p>处理文本时，将字符序列括在双引号中<br>strlength 函数求数组中每个字符串的长度<br>是个数组，每个元素包含单个字符<br><a href="https://ww2.mathworks.cn/help/matlab/learn_matlab/character-strings.html">https://ww2.mathworks.cn/help/matlab/learn_matlab/character-strings.html</a></p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>输入参数括在圆括号</p><p>存在多个输入参数，请使用逗号加以分隔</p><p>存在多个输出参数，请将其括在方括号中<br>[maxA,location] = max(A)<br>maxA = 5<br>location = 3</p><p>字符输入括在单引号中</p><p>有关初等数学函数的列表，请键入</p><p>help elfun<br>有关更多高等数学函数和矩阵函数的列表，请键入</p><p>help specfun<br>help elmat</p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="矩阵运算符"><a href="#矩阵运算符" class="headerlink" title="矩阵运算符"></a>矩阵运算符</h3><p>表达式使用大家熟悉的算术运算符和优先法则。</p><ul><li>加法</li></ul><ul><li>减法</li></ul><ul><li>乘法</li></ul><p>/ 除法</p><p>\ 左除</p><p>^ 幂</p><p>‘ 复共轭转置</p><p>( )指定计算顺序</p><h3 id="数组运算符"><a href="#数组运算符" class="headerlink" title="数组运算符"></a>数组运算符</h3><p>如果矩阵不用于线性代数运算，则成为二维数值数组。数组的算术运算按元素执行。这意味着，加法和减法运算对数组和矩阵都是相同的，但乘法运算不相同。MATLAB 的乘法数组运算表示法中包含点，也就是小数点。</p><p>运算符列表包括</p><ul><li>加法</li></ul><ul><li>减法</li></ul><p>.* 逐元素乘法</p><p>./ 逐元素除法</p><p>.\ 逐元素左除</p><p>.^ 逐元素幂</p><p>.’ 非共轭数组转置</p><h3 id="构建表"><a href="#构建表" class="headerlink" title="构建表"></a>构建表</h3><p>数组运算对构建表非常有用。假定 n 为列向量</p><p>n = (0:9)’;<br>然后，</p><p>pows = [n  n.^2  2.^n]<br>构建一个平方和 2 次幂的表：</p><p>pows =<br>     0     0     1<br>     1     1     2<br>     2     4     4<br>     3     9     8<br>     4    16    16<br>     5    25    32<br>     6    36    64<br>     7    49   128<br>     8    64   256<br>     9    81   512</p><h3 id="常用常量值"><a href="#常用常量值" class="headerlink" title="常用常量值"></a>常用常量值</h3><p>pi 3.14159265…</p><p>i 虚数单位 </p><p>j 与 i 相同</p><p>eps 浮点相对精度 ε=2^−52</p><p>realmin 最小浮点数 2^−1022</p><p>realmax 最大浮点数 (2−ε)2^1023</p><p>Inf 无穷</p><p>NaN 非数字</p><h2 id="二维图和三维图"><a href="#二维图和三维图" class="headerlink" title="二维图和三维图"></a>二维图和三维图</h2><p><a href="https://ww2.mathworks.cn/help/matlab/learn_matlab/basic-plotting-functions.html#responsive_offcanvas">https://ww2.mathworks.cn/help/matlab/learn_matlab/basic-plotting-functions.html#responsive_offcanvas</a></p><h3 id="线图"><a href="#线图" class="headerlink" title="线图"></a>线图</h3><p>要创建二维线图，请使用 plot 函数<br>plot(x,y,’r–’)</p><p>x 数据范围<br>x = 0:pi/100:2*pi;<br><em>0到2pi，中间以pi/100为间距取点</em><br><em>x分别取0，pi/100,2pi/100,3pi/100…….2pi</em></p><p>y 函数<br>y = sin(x);</p><p>‘r–’ 线条设定。每个设定可包含表示线条颜色、样式和标记的字符。</p><p>默认情况下，每次调用绘图函数、重置坐标区及其他元素以准备新绘图时，MATLAB® 都会清空图窗。</p><p>要将绘图添加到现有图窗中，请使用 hold on。在使用 hold off 或关闭窗口之前，当前图窗窗口中会显示所有绘图。</p><h3 id="三维绘图"><a href="#三维绘图" class="headerlink" title="三维绘图"></a>三维绘图</h3><p>surf(X,Y,Z)<br>z = f (x,y)<br>要计算 z，请首先使用 meshgrid 在此函数的域中创建一组 (x,y) 点。</p><p>[X,Y] = meshgrid(-2:.2:2);<br><em>.2表示0.2 (-2:.2:2)表示在-2到2的区间上以0.2的长度为间隔的向量</em><br>Z = X .* exp(-X.^2 - Y.^2);<br>然后，创建曲面图。</p><p>surf(X,Y,Z)<br>surf 函数及其伴随函数 mesh 以三维形式显示曲面图。surf 使用颜色显示曲面图的连接线和面。mesh 生成仅以颜色标记连接定义点的线条的线框曲面图。</p><h3 id="子图"><a href="#子图" class="headerlink" title="子图"></a>子图</h3><p>subplot 函数可以在同一窗口的不同子区域显示多个绘图<br>subplot 的前两个输入表示每行和每列中的绘图数。第三个输入指定绘图是否处于活动状态。</p><h2 id="编程和脚本"><a href="#编程和脚本" class="headerlink" title="编程和脚本"></a>编程和脚本</h2><h3 id="基本语言"><a href="#基本语言" class="headerlink" title="基本语言"></a>基本语言</h3><ol><li><p>创建脚本<br>edit name</p></li><li><p>注释 %</p></li><li><p>运行脚本 输入当前脚本名称</p></li></ol><h3 id="实时脚本"><a href="#实时脚本" class="headerlink" title="实时脚本"></a>实时脚本</h3><p>要使用 edit 命令创建新的实时脚本，请在文件名中包含 .mlx 扩展名：</p><p>edit newfile.mlx</p><h3 id="循环和条件语句"><a href="#循环和条件语句" class="headerlink" title="循环和条件语句"></a>循环和条件语句</h3><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">N = 100;</span><br><span class="line">f(1) = 1;</span><br><span class="line">f(2) = 1;</span><br><span class="line">%循环%</span><br><span class="line">for n = 3:N</span><br><span class="line">    f(n) = f(n-1) + f(n-2);</span><br><span class="line">end</span><br><span class="line">f(1:10)</span><br><span class="line">%条件%</span><br><span class="line">num = randi(100)</span><br><span class="line">if num &lt; 34</span><br><span class="line">   sz = &#x27;low&#x27;</span><br><span class="line">elseif num &lt; 67</span><br><span class="line">   sz = &#x27;medium&#x27;</span><br><span class="line">else</span><br><span class="line">   sz = &#x27;high&#x27;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="函数总结"><a href="#函数总结" class="headerlink" title="函数总结"></a>函数总结</h1><h2 id="magic-n"><a href="#magic-n" class="headerlink" title="magic(n)"></a>magic(n)</h2><p>M = magic(n) 返回由 1 到 n2 的整数构成并且总行数和总列数相等的 n×n 矩阵。n 的阶数必须是大于或等于 3 的标量才能创建有效的幻方矩阵。</p><h2 id="inv"><a href="#inv" class="headerlink" title="inv()"></a>inv()</h2><p>Y = inv(X) 计算方阵 X 的 逆矩阵。</p><h2 id="clc"><a href="#clc" class="headerlink" title="clc"></a>clc</h2><p>clc 函数清空命令行窗口。</p><h2 id="meshgrid-x-y"><a href="#meshgrid-x-y" class="headerlink" title="meshgrid(x,y)"></a>meshgrid(x,y)</h2><p>语法</p><p>[X,Y] = meshgrid(x,y)<br>[X,Y] = meshgrid(x)<br>[X,Y,Z] = meshgrid(x,y,z)<br>[X,Y,Z] = meshgrid(x)</p><p>说明<br>[X,Y] = meshgrid(x,y) 基于向量 x 和 y 中包含的坐标返回二维网格坐标。X 是一个矩阵，每一行是 x 的一个副本；Y 也是一个矩阵，每一列是 y 的一个副本。坐标 X 和 Y 表示的网格有 length(y) 个行和 length(x) 个列。</p><p>[X,Y] = meshgrid(x) 与 [X,Y] = meshgrid(x,x) 相同，并返回网格大小为 length(x)×length(x) 的方形网格坐标。</p><p>[X,Y,Z] = meshgrid(x,y,z) 返回由向量 x、y 和 z 定义的三维网格坐标。X、Y 和 Z 表示的网格的大小为 length(y)×length(x)×length(z)。</p><p>[X,Y,Z] = meshgrid(x) 与 [X,Y,Z] = meshgrid(x,x,x) 相同，并返回网格大小为 length(x)×length(x)×length(x) 的三维网格坐标。</p><h2 id="exp-x"><a href="#exp-x" class="headerlink" title="exp(x)"></a>exp(x)</h2><p>Y = exp(X) 为数组 X 中的每个元素返回指数 ex。 </p><h2 id="cylinder"><a href="#cylinder" class="headerlink" title="cylinder()"></a>cylinder()</h2><p>创建圆柱<br>[X,Y,Z] = cylinder 返回三个 2×21 矩阵，其中包含圆柱的 x、y 和 z 坐标，但不对其绘图。圆柱的半径为 1，圆周上有 20 个等间距点。底面平行于 xy 平面。</p><p>要绘制圆柱，请将 X、Y 和 Z 传递给 surf 或 mesh 函数。<br><a href="https://ww2.mathworks.cn/help/matlab/ref/cylinder.html?searchHighlight=cylinder&amp;s_tid=srchtitle_cylinder_1">https://ww2.mathworks.cn/help/matlab/ref/cylinder.html?searchHighlight=cylinder&amp;s_tid=srchtitle_cylinder_1</a></p><hr />版权信息]]></content>
      
      
      <categories>
          
          <category> matlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前中后缀表达式</title>
      <link href="/2022/01/08/%E5%89%8D%E4%B8%AD%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2022/01/08/%E5%89%8D%E4%B8%AD%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>栈的应用，四则运算表达式求值</p><span id="more"></span><h1 id="后缀表达式计算结果"><a href="#后缀表达式计算结果" class="headerlink" title="后缀表达式计算结果"></a>后缀表达式计算结果</h1><p>遍历每个数字和符号，遇到数字就进栈，遇到符号，将处于栈顶的两个数字出栈，运算后将结果进栈，直到得到最终结果</p><p>例：<br>   后缀表达式为：9 3 1 - 3 * + 10 2 / +</p><p>   规则为：从左到右遍历表达式的每个数字和符号，遇到是数字就进栈，遇到是符号，就将处于栈顶两个数字出栈，进行运算，运算结果进栈，一直到最终获得结果。</p><p>   a.初始化一个空栈。此栈用来对要运算的数字进行进出使用。</p><p>   b.后缀表达式中前三个是、都是数字，所以9 3 1 进栈。</p><p>   c.接下来是“-”，所以将栈中的1出栈作为减数，3出栈作为被减数，并运算3-1得到2，再讲2进栈。</p><p>   d.接着是数字3进栈。</p><p>   e.后面是“*”，也就意味着栈中3和2出栈，2与3相乘，得到6，并将6进栈。</p><p>   f.下面是“+”，所以栈中6和9出栈，9和6相加，得到15，将15进栈。</p><p>   g.接着是10和2两数字进栈。</p><p>   h.接下来是符号“/”，因此，栈顶的2与10出栈，10与2相除，得到5，将5进栈。</p><p>   i.最后一个是符号“+”，所以15与5出栈并相加，得到20，讲20进栈。</p><p>   j.结果是20出栈，栈变为空。</p><h1 id="中缀表达式转后缀表达式"><a href="#中缀表达式转后缀表达式" class="headerlink" title="中缀表达式转后缀表达式"></a>中缀表达式转后缀表达式</h1><p>遍历每个数字和符号，遇到数字就输出，若是符号则判断其与栈顶符号的优先级。是右括号或优先级不高于栈顶符号的则将栈顶元素依次出栈并输出，之后将当前符号进栈，直到得到最终结果</p><p>例：<br>　　以中缀表达式“9+（（3*2）+（3-1））/2”的转化为例介绍栈s1和栈s2的情况：</p><p>　　注：数字和符号的顺序是按在栈中的顺序排列的。</p><p>　　（1）遍历到字符“9”时：</p><p>　　　　栈s1：9 ；</p><p>　　　　栈s2：空 ；</p><p>　　（1）遍历到符号“+”时：</p><p>　　　　栈s1：9 ；</p><p>　　　　栈s2：+ ；</p><p>　　（1）遍历到符号“(”时：</p><p>　　　　栈s1：9 ；</p><p>　　　　栈s2：( + ；</p><p>　　（2）遍历到符号“(”时：</p><p>　　　　栈s1：9 ；</p><p>　　　　栈s2：( ( + ；</p><p>　　（3）遍历到字符“3”时：</p><p>　　　　栈s1：3 9 ；</p><p>　　　　栈s2：( ( +；</p><p>　　（4）遍历到符号“*”时：</p><p>　　　　栈s1：3 9 ；</p><p>　　　　栈s2：* ( ( + ；</p><p>　　（5）遍历到字符“2”时：</p><p>　　　　栈s1：2 3 9 ；</p><p>　　　　栈s2：* ( ( + ；</p><p>　　（6）遍历到符号“)”时：</p><p>　　　　栈s1：2 3 9 ；</p><p>　　　　栈s2：* ( ( + ；</p><p>　　　　此时开始比较，比较之后：</p><p>　　　　栈s1：* 2 3 9 ；</p><p>　　　　栈s2：( + ；</p><p>　　（7）遍历到符号“+”时：</p><p>　　　　栈s1：* 2 3 9 ；</p><p>　　　　栈s2：+ ( +；</p><p>　　（8）遍历到符号“(”时：</p><p>　　　　栈s1：* 2 3 9 ；</p><p>　　　　栈s2：( + ( + ；</p><p>　　（9）遍历到字符“3”时：</p><p>　　　　栈s1：3 * 2 3 9 ；</p><p>　　　　栈s2：( + ( + ；</p><p>　　（10）遍历到符号“-”时：</p><p>　　　　栈s1：3 * 2 3 9 ；</p><p>　　　　栈s2：- ( + ( + ；</p><p>　　（11）遍历到字符“1”时：</p><p>　　　　栈s1：1 3 * 2 3 9 ；</p><p>　　　　栈s2：- ( + ( + ；</p><p>　　（12）遍历到符号“)”时：</p><p>　　　　栈s1：1 3 * 2 3 9 ；</p><p>　　　　栈s2：- ( + ( + ；</p><p>　　　　此时开始比较，比较之后：</p><p>　　　　栈s1：- 1 3 * 2 3 9 ；</p><p>　　　　栈s2：+ ( +；</p><p>　　（13）遍历到符号“)”时：</p><p>　　　　栈s1：- 1 3 * 2 3 9 ；</p><p>　　　　栈s2：+ ( +；</p><p>　　　　此时开始比较，比较之后：</p><p>　　　　栈s1：+ - 1 3 * 2 3 9 ；</p><p>　　　　栈s2：+；</p><p>　　（14）遍历到符号“/”时：</p><p>　　　　栈s1：+ - 1 3 * 2 3 9 ；</p><p>　　　　栈s2：/ + ；</p><p>　　（15）遍历到字符“2”时：</p><p>　　　　栈s1：2 + - 1 3 * 2 3 9 ；</p><p>　　　　栈s2：/ + ；</p><p>　　（16）遍历结束，但栈s2中还有符号，所以将栈s2中的符号全部依次压入栈s1中，此时：</p><p>　　　　栈s1：+ / 2 + - 1 3 * 2 3 9 ；</p><p>　　　　栈s2：空；</p><p>　　　所以后缀表达式为：9 3 2 * 3 1 - + 2 / + ；</p><h1 id="xx3x"><a href="#xx3x" class="headerlink" title="xx3x"></a>xx3x</h1><hr />版权信息]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串</title>
      <link href="/2022/01/07/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2022/01/07/%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>串和简单模式匹配算法KMP算法</p><span id="more"></span><h1 id="字符串基本概念"><a href="#字符串基本概念" class="headerlink" title="字符串基本概念"></a>字符串基本概念</h1><p><a href="https://sm.ms/image/r348tomKAB6kvcN" target="_blank"><img src="https://s2.loli.net/2022/01/08/r348tomKAB6kvcN.jpg" ></a></p><h1 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h1><p>在查找字符串前先对查找字符串做一个分析</p><h2 id="求next数组"><a href="#求next数组" class="headerlink" title="求next数组"></a>求next数组</h2><p>转载自B站视频<br><a href="https://www.bilibili.com/video/BV1nF411e7gq?from=search&amp;seid=2280439246733213375&amp;spm_id_from=333.337.0.0">https://www.bilibili.com/video/BV1nF411e7gq?from=search&amp;seid=2280439246733213375&amp;spm_id_from=333.337.0.0</a></p><p><a href="https://sm.ms/image/UY2CGIdsinNZjXA" target="_blank"><img src="https://s2.loli.net/2022/01/08/UY2CGIdsinNZjXA.jpg" ></a></p><h2 id="nexval数组"><a href="#nexval数组" class="headerlink" title="nexval数组"></a>nexval数组</h2><p><a href="https://sm.ms/image/2DZzaKm4sRT35dc" target="_blank"><img src="https://s2.loli.net/2022/01/08/2DZzaKm4sRT35dc.jpg" ></a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/* 通过计算返回子串T的next数组。 */</span><br><span class="line">void get_next(String T, int *next) </span><br><span class="line">&#123;</span><br><span class="line">int i,k;</span><br><span class="line">  i=1;</span><br><span class="line">  k=0;</span><br><span class="line">  next[1]=0;</span><br><span class="line">  while (i&lt;T[0])  /* 此处T[0]表示串T的长度 */</span><br><span class="line"> &#123;</span><br><span class="line">    if(k==0 || T[i]== T[k]) </span><br><span class="line">&#123;</span><br><span class="line">      ++i;  </span><br><span class="line">++k;  </span><br><span class="line">next[i] = k;</span><br><span class="line">    &#125; </span><br><span class="line">else </span><br><span class="line">k= next[k];/* 若字符不相同，则k值回溯 */</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 返回子串T在主串S中第pos个字符之后的位置。若不存在，则函数返回值为0。 */</span><br><span class="line">/*  T非空，1≤pos≤StrLength(S)。 */</span><br><span class="line">int Index_KMP(String S, String T, int pos) </span><br><span class="line">&#123;</span><br><span class="line">int i = pos;/* i用于主串S中当前位置下标值，若pos不为1，则从pos位置开始匹配 */</span><br><span class="line">int j = 1;/* j用于子串T中当前位置下标值 */</span><br><span class="line">int next[255];/* 定义一next数组 */</span><br><span class="line">get_next(T, next);/* 对串T作分析，得到next数组 */</span><br><span class="line">while (i &lt;= S[0] &amp;&amp; j &lt;= T[0]) /* 若i小于S的长度并且j小于T的长度时，循环继续 */</span><br><span class="line">&#123;</span><br><span class="line">if (j==0 || S[i] == T[j]) /* 两字母相等则继续，与朴素算法增加了j=0判断 */</span><br><span class="line">      &#123;</span><br><span class="line">         ++i;</span><br><span class="line">         ++j; </span><br><span class="line">      &#125; </span><br><span class="line">      else /* 指针后退重新开始匹配 */</span><br><span class="line">       j = next[j];/* j退回合适的位置，i值不变 */</span><br><span class="line">&#125;</span><br><span class="line">if (j &gt; T[0]) </span><br><span class="line">return i-T[0];</span><br><span class="line">else </span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 求模式串T的next函数修正值并存入数组nextval */</span><br><span class="line">void get_nextval(String T, int *nextval) </span><br><span class="line">&#123;</span><br><span class="line">  int i,k;</span><br><span class="line">  i=1;</span><br><span class="line">  k=0;</span><br><span class="line">  nextval[1]=0;</span><br><span class="line">  while (i&lt;T[0])  /* 此处T[0]表示串T的长度 */</span><br><span class="line"> &#123;</span><br><span class="line">    if(k==0 || T[i]== T[k]) /* T[i]表示后缀的单个字符，T[k]表示前缀的单个字符 */</span><br><span class="line">&#123;</span><br><span class="line">      ++i;  </span><br><span class="line">++k;  </span><br><span class="line">if (T[i]!=T[k])      /* 若当前字符与前缀字符不同 */</span><br><span class="line">nextval[i] = k;/* 则当前的j为nextval在i位置的值 */</span><br><span class="line">      else </span><br><span class="line">nextval[i] = nextval[k];/* 如果与前缀字符相同，则将前缀字符的 */</span><br><span class="line">/* nextval值赋值给nextval在i位置的值 */</span><br><span class="line">    &#125; </span><br><span class="line">else </span><br><span class="line">k= nextval[k];/* 若字符不相同，则k值回溯 */</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Index_KMP1(String S, String T, int pos) </span><br><span class="line">&#123;</span><br><span class="line">int i = pos;/* i用于主串S中当前位置下标值，若pos不为1，则从pos位置开始匹配 */</span><br><span class="line">int j = 1;/* j用于子串T中当前位置下标值 */</span><br><span class="line">int next[255];/* 定义一next数组 */</span><br><span class="line">get_nextval(T, next);/* 对串T作分析，得到next数组 */</span><br><span class="line">while (i &lt;= S[0] &amp;&amp; j &lt;= T[0]) /* 若i小于S的长度并且j小于T的长度时，循环继续 */</span><br><span class="line">&#123;</span><br><span class="line">if (j==0 || S[i] == T[j]) /* 两字母相等则继续，与朴素算法增加了j=0判断 */</span><br><span class="line">      &#123;</span><br><span class="line">         ++i;</span><br><span class="line">         ++j; </span><br><span class="line">      &#125; </span><br><span class="line">      else /* 指针后退重新开始匹配 */</span><br><span class="line">       j = next[j];/* j退回合适的位置，i值不变 */</span><br><span class="line">&#125;</span><br><span class="line">if (j &gt; T[0]) </span><br><span class="line">return i-T[0];</span><br><span class="line">else </span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr />版权信息]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> KMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性表</title>
      <link href="/2022/01/04/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
      <url>/2022/01/04/%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>总结一些线性表有关的知识点和代码<br>参考博客:<br><a href="https://blog.csdn.net/weixin_38984030/article/details/86076074">https://blog.csdn.net/weixin_38984030/article/details/86076074</a><br><a href="https://sm.ms/image/eaOZdNzFQPDE5hl" target="_blank"><img src="https://s2.loli.net/2022/01/07/eaOZdNzFQPDE5hl.jpg" ></a></p><span id="more"></span><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>线性表是最基本、最简单、也是最常用的一种数据结构。线性表（linear list）是数据结构的一种，一个线性表是n个具有相同特性的数据元素的有限序列。</p><p>特点：</p><p>1．集合中必存在唯一的一个“第一元素”。</p><p>2．集合中必存在唯一的一个 “最后元素” 。</p><p>3．除最后一个元素之外，均有唯一的后继(后件)。</p><p>4．除第一个元素之外，均有唯一的前驱(前件)。</p><p>线性表、包括顺序表和链表，顺序表里面元素的地址是连续的。链表里面节点的地址不是连续的，是通过指针连起来的。</p><h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><p>线性表除第一个元素外，每个元素有且仅有一个直接 前驱 ， 除最后一个元素外，每个元素有且仅有一个直接 后继 。</p><h2 id="顺序储存"><a href="#顺序储存" class="headerlink" title="顺序储存"></a>顺序储存</h2><p>占用一片连续的存储单元<br>数组实现<br>插入操作原理为将第i个元素及其后的所有元素右移一个位置，并在空的位置插入新元素<br><a href="https://sm.ms/image/qWOwAFaJUh6EumR" target="_blank"><img src="https://s2.loli.net/2022/01/07/qWOwAFaJUh6EumR.jpg" style="width:80%"></a><br>最坏时间复杂度为O(n)</p><h2 id="链式储存"><a href="#链式储存" class="headerlink" title="链式储存"></a>链式储存</h2><p><a href="https://sm.ms/image/qhQrPEnkX8IWeG2" target="_blank"><img src="https://s2.loli.net/2022/01/07/qhQrPEnkX8IWeG2.jpg" style="width:80%"></a><br>头指针和头结点<br>头节点数据域无信息，指针域指向线性表第一个元素，方便运算的实现<br>头指针来指示一个单链表，指向链表的第一个结点</p><p>插入/删除<br><a href="https://sm.ms/image/Vn6sfuehNIzb4Xv" target="_blank"><img src="https://s2.loli.net/2022/01/07/Vn6sfuehNIzb4Xv.jpg" style="width:80%"></a><br><a href="https://sm.ms/image/ZJb9WkBKsoXzTiE" target="_blank"><img src="https://s2.loli.net/2022/01/07/ZJb9WkBKsoXzTiE.jpg" style="width:80%"></a></p><h2 id="不引用新节点实现逆置"><a href="#不引用新节点实现逆置" class="headerlink" title="不引用新节点实现逆置"></a>不引用新节点实现逆置</h2><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void inversionList(LNode *L)&#123;</span><br><span class="line">LNode *p,*q;</span><br><span class="line">p = L-&gt;next;//记录节点信息 </span><br><span class="line">L-&gt;next = NULL;//将头结点置为空作为新的头节点</span><br><span class="line">//将链表中原有的元素作为新元素头插法插入到链表中 </span><br><span class="line">while(p != NULL)&#123;</span><br><span class="line">q = p-&gt;next;//q用来记录下一个节点信息 </span><br><span class="line">p-&gt;next = L-&gt;next;</span><br><span class="line">L-&gt;next = p;</span><br><span class="line">p = q;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h2><p>定义<br><a href="https://sm.ms/image/XbTEpZahBcMCfRt" target="_blank"><img src="https://s2.loli.net/2022/01/07/XbTEpZahBcMCfRt.jpg" style="width:80%"></a><br>插入删除<br><a href="https://sm.ms/image/j3LxdU6hsKwE2BZ" target="_blank"><img src="https://s2.loli.net/2022/01/07/j3LxdU6hsKwE2BZ.jpg" style="width:80%"></a></p><h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><p>每一个元素都有后继<br>最后一个结点的后继为头节点<br><a href="https://sm.ms/image/5NCF8SyT93ijn7X" target="_blank"><img src="https://s2.loli.net/2022/01/07/5NCF8SyT93ijn7X.jpg" style="width:80%"></a></p><h1 id="顺序储存结构代码"><a href="#顺序储存结构代码" class="headerlink" title="顺序储存结构代码"></a>顺序储存结构代码</h1><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#define MAXSIZE 20          /* 存储空间初始分配量 */</span><br><span class="line">typedef int ElemType;       /* ElemType类型根据实际情况而定，这里假设为int */</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    ElemType data[MAXSIZE]; /* 数组，存储数据元素 */</span><br><span class="line">    int length;             /* 线性表当前长度 */</span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line">typedef int Status;         /* Status是函数的类型,其值是函数结果状态代码，如OK等 */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Status visit(ElemType c)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;%d &quot;,c);</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 初始化顺序线性表 */</span><br><span class="line">Status InitList(SqList *L) </span><br><span class="line">&#123; </span><br><span class="line">    L-&gt;length=0;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 初始条件：顺序线性表L已存在。操作结果：若L为空表，则返回TRUE，否则返回FALSE */</span><br><span class="line">Status ListEmpty(SqList L)</span><br><span class="line">&#123; </span><br><span class="line">if(L.length==0)</span><br><span class="line">return TRUE;</span><br><span class="line">else</span><br><span class="line">return FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 初始条件：顺序线性表L已存在。操作结果：将L重置为空表 */</span><br><span class="line">Status ClearList(SqList *L)</span><br><span class="line">&#123; </span><br><span class="line">    L-&gt;length=0;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 初始条件：顺序线性表L已存在。操作结果：返回L中数据元素个数 */</span><br><span class="line">int ListLength(SqList L)</span><br><span class="line">&#123;</span><br><span class="line">return L.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) */</span><br><span class="line">/* 操作结果：用e返回L中第i个数据元素的值,注意i是指位置，第1个位置的数组是从0开始 */</span><br><span class="line">Status GetElem(SqList L,int i,ElemType *e)</span><br><span class="line">&#123;</span><br><span class="line">    if(L.length==0 || i&lt;1 || i&gt;L.length)</span><br><span class="line">            return ERROR;</span><br><span class="line">    *e=L.data[i-1];</span><br><span class="line"></span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 初始条件：顺序线性表L已存在 */</span><br><span class="line">/* 操作结果：返回L中第1个与e满足关系的数据元素的位序。 */</span><br><span class="line">/* 若这样的数据元素不存在，则返回值为0 */</span><br><span class="line">int LocateElem(SqList L,ElemType e)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    if (L.length==0)</span><br><span class="line">            return 0;</span><br><span class="line">    for(i=0;i&lt;L.length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">            if (L.data[i]==e)</span><br><span class="line">                    break;</span><br><span class="line">    &#125;</span><br><span class="line">    if(i&gt;=L.length)</span><br><span class="line">            return 0;</span><br><span class="line"></span><br><span class="line">    return i+1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* 初始条件：顺序线性表L已存在,1≤i≤ListLength(L)， */</span><br><span class="line">/* 操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1 */</span><br><span class="line">Status ListInsert(SqList *L,int i,ElemType e)</span><br><span class="line">&#123; </span><br><span class="line">int k;</span><br><span class="line">if (L-&gt;length==MAXSIZE)  /* 顺序线性表已经满 */</span><br><span class="line">return ERROR;</span><br><span class="line">if (i&lt;1 || i&gt;L-&gt;length+1)/* 当i比第一位置小或者比最后一位置后一位置还要大时 */</span><br><span class="line">return ERROR;</span><br><span class="line"></span><br><span class="line">if (i&lt;=L-&gt;length)        /* 若插入数据位置不在表尾 */</span><br><span class="line">&#123;</span><br><span class="line">for(k=L-&gt;length-1;k&gt;=i-1;k--)  /* 将要插入位置之后的数据元素向后移动一位 */</span><br><span class="line">L-&gt;data[k+1]=L-&gt;data[k];</span><br><span class="line">&#125;</span><br><span class="line">L-&gt;data[i-1]=e;          /* 将新元素插入 */</span><br><span class="line">L-&gt;length++;</span><br><span class="line"></span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) */</span><br><span class="line">/* 操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1 */</span><br><span class="line">Status ListDelete(SqList *L,int i,ElemType *e) </span><br><span class="line">&#123; </span><br><span class="line">    int k;</span><br><span class="line">    if (L-&gt;length==0)               /* 线性表为空 */</span><br><span class="line">return ERROR;</span><br><span class="line">    if (i&lt;1 || i&gt;L-&gt;length)         /* 删除位置不正确 */</span><br><span class="line">        return ERROR;</span><br><span class="line">    *e=L-&gt;data[i-1];</span><br><span class="line">    if (i&lt;L-&gt;length)                /* 如果删除不是最后位置 */</span><br><span class="line">    &#123;</span><br><span class="line">        for(k=i;k&lt;L-&gt;length;k++)/* 将删除位置后继元素前移 */</span><br><span class="line">L-&gt;data[k-1]=L-&gt;data[k];</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;length--;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 初始条件：顺序线性表L已存在 */</span><br><span class="line">/* 操作结果：依次对L的每个数据元素输出 */</span><br><span class="line">Status ListTraverse(SqList L)</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">    for(i=0;i&lt;L.length;i++)</span><br><span class="line">            visit(L.data[i]);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*将所有的在线性表Lb中但不在La中的数据元素插入到La中*/</span><br><span class="line">void unionL(SqList *La,SqList Lb)</span><br><span class="line">&#123;</span><br><span class="line">int La_len,Lb_len,i;</span><br><span class="line">ElemType e;                        /*声明与La和Lb相同的数据元素e*/</span><br><span class="line">La_len=ListLength(*La);            /*求线性表的长度 */</span><br><span class="line">Lb_len=ListLength(Lb);</span><br><span class="line">for (i=1;i&lt;=Lb_len;i++)</span><br><span class="line">&#123;</span><br><span class="line">GetElem(Lb,i,&amp;e);              /*取Lb中第i个数据元素赋给e*/</span><br><span class="line">if (!LocateElem(*La,e))        /*La中不存在和e相同数据元素*/</span><br><span class="line">ListInsert(La,++La_len,e); /*插入*/</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="链式储存结构"><a href="#链式储存结构" class="headerlink" title="链式储存结构"></a>链式储存结构</h1><h2 id="单链表代码"><a href="#单链表代码" class="headerlink" title="单链表代码"></a>单链表代码</h2><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#define MAXSIZE 20 /* 存储空间初始分配量 */</span><br><span class="line"></span><br><span class="line">typedef int Status;/* Status是函数的类型,其值是函数结果状态代码，如OK等 */</span><br><span class="line">typedef int ElemType;/* ElemType类型根据实际情况而定，这里假设为int */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Status visit(ElemType c)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;%d &quot;,c);</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">typedef struct Node</span><br><span class="line">&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    struct Node *next;</span><br><span class="line">&#125;Node;</span><br><span class="line">typedef struct Node *LinkList; /* 定义LinkList */</span><br><span class="line"></span><br><span class="line">/* 初始化链式线性表 */</span><br><span class="line">Status InitList(LinkList *L) </span><br><span class="line">&#123; </span><br><span class="line">    *L=(LinkList)malloc(sizeof(Node)); /* 产生头结点,并使L指向此头结点 */</span><br><span class="line">    if(!(*L)) /* 存储分配失败 */</span><br><span class="line">            return ERROR;</span><br><span class="line">    (*L)-&gt;next=NULL; /* 指针域为空 */</span><br><span class="line"></span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 初始条件：链式线性表L已存在。操作结果：若L为空表，则返回TRUE，否则返回FALSE */</span><br><span class="line">Status ListEmpty(LinkList L)</span><br><span class="line">&#123; </span><br><span class="line">    if(L-&gt;next)</span><br><span class="line">            return FALSE;</span><br><span class="line">    else</span><br><span class="line">            return TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 初始条件：链式线性表L已存在。操作结果：将L重置为空表 */</span><br><span class="line">Status ClearList(LinkList *L)</span><br><span class="line">&#123; </span><br><span class="line">LinkList p,q;</span><br><span class="line">p=(*L)-&gt;next;           /*  p指向第一个结点 */</span><br><span class="line">while(p)                /*  没到表尾 */</span><br><span class="line">&#123;</span><br><span class="line">q=p-&gt;next;</span><br><span class="line">free(p);</span><br><span class="line">p=q;</span><br><span class="line">&#125;</span><br><span class="line">(*L)-&gt;next=NULL;        /* 头结点指针域为空 */</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 初始条件：链式线性表L已存在。操作结果：返回L中数据元素个数 */</span><br><span class="line">int ListLength(LinkList L)</span><br><span class="line">&#123;</span><br><span class="line">    int i=0;</span><br><span class="line">    LinkList p=L-&gt;next; /* p指向第一个结点 */</span><br><span class="line">    while(p)                        </span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 初始条件：链式线性表L已存在，1≤i≤ListLength(L) */</span><br><span class="line">/* 操作结果：用e返回L中第i个数据元素的值 */</span><br><span class="line">Status GetElem(LinkList L,int i,ElemType *e)</span><br><span class="line">&#123;</span><br><span class="line">int j;</span><br><span class="line">LinkList p;/* 声明一结点p */</span><br><span class="line">p = L-&gt;next;/* 让p指向链表L的第一个结点 */</span><br><span class="line">j = 1;/*  j为计数器 */</span><br><span class="line">while (p &amp;&amp; j&lt;i)  /* p不为空或者计数器j还没有等于i时，循环继续 */</span><br><span class="line">&#123;   </span><br><span class="line">p = p-&gt;next;  /* 让p指向下一个结点 */</span><br><span class="line">++j;</span><br><span class="line">&#125;</span><br><span class="line">if ( !p || j&gt;i ) </span><br><span class="line">return ERROR;  /*  第i个元素不存在 */</span><br><span class="line">*e = p-&gt;data;   /*  取第i个元素的数据 */</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 初始条件：链式线性表L已存在 */</span><br><span class="line">/* 操作结果：返回L中第1个与e满足关系的数据元素的位序。 */</span><br><span class="line">/* 若这样的数据元素不存在，则返回值为0 */</span><br><span class="line">int LocateElem(LinkList L,ElemType e)</span><br><span class="line">&#123;</span><br><span class="line">    int i=0;</span><br><span class="line">    LinkList p=L-&gt;next;</span><br><span class="line">    while(p)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">        if(p-&gt;data==e) /* 找到这样的数据元素 */</span><br><span class="line">                return i;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* 初始条件：链式线性表L已存在,1≤i≤ListLength(L)， */</span><br><span class="line">/* 操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1 */</span><br><span class="line">Status ListInsert(LinkList *L,int i,ElemType e)</span><br><span class="line">&#123; </span><br><span class="line">int j;</span><br><span class="line">LinkList p,s;</span><br><span class="line">p = *L;   </span><br><span class="line">j = 1;</span><br><span class="line">while (p &amp;&amp; j &lt; i)     /* 寻找第i个结点 */</span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">++j;</span><br><span class="line">&#125; </span><br><span class="line">if (!p || j &gt; i) </span><br><span class="line">return ERROR;   /* 第i个元素不存在 */</span><br><span class="line">s = (LinkList)malloc(sizeof(Node));  /*  生成新结点(C语言标准函数) */</span><br><span class="line">s-&gt;data = e;  </span><br><span class="line">s-&gt;next = p-&gt;next;      /* 将p的后继结点赋值给s的后继  */</span><br><span class="line">p-&gt;next = s;          /* 将s赋值给p的后继 */</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 初始条件：链式线性表L已存在，1≤i≤ListLength(L) */</span><br><span class="line">/* 操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1 */</span><br><span class="line">Status ListDelete(LinkList *L,int i,ElemType *e) </span><br><span class="line">&#123; </span><br><span class="line">int j;</span><br><span class="line">LinkList p,q;</span><br><span class="line">p = *L;</span><br><span class="line">j = 1;</span><br><span class="line">while (p-&gt;next &amp;&amp; j &lt; i)/* 遍历寻找第i个元素 */</span><br><span class="line">&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        ++j;</span><br><span class="line">&#125;</span><br><span class="line">if (!(p-&gt;next) || j &gt; i) </span><br><span class="line">    return ERROR;           /* 第i个元素不存在 */</span><br><span class="line">q = p-&gt;next;</span><br><span class="line">p-&gt;next = q-&gt;next;/* 将q的后继赋值给p的后继 */</span><br><span class="line">*e = q-&gt;data;               /* 将q结点中的数据给e */</span><br><span class="line">free(q);                    /* 让系统回收此结点，释放内存 */</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 初始条件：链式线性表L已存在 */</span><br><span class="line">/* 操作结果：依次对L的每个数据元素输出 */</span><br><span class="line">Status ListTraverse(LinkList L)</span><br><span class="line">&#123;</span><br><span class="line">    LinkList p=L-&gt;next;</span><br><span class="line">    while(p)</span><br><span class="line">    &#123;</span><br><span class="line">        visit(p-&gt;data);</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*  随机产生n个元素的值，建立带表头结点的单链线性表L（头插法） */</span><br><span class="line">void CreateListHead(LinkList *L, int n) </span><br><span class="line">&#123;</span><br><span class="line">LinkList p;</span><br><span class="line">int i;</span><br><span class="line">srand(time(0));                         /* 初始化随机数种子 */</span><br><span class="line">*L = (LinkList)malloc(sizeof(Node));</span><br><span class="line">(*L)-&gt;next = NULL;                      /*  先建立一个带头结点的单链表 */</span><br><span class="line">for (i=0; i&lt;n; i++) </span><br><span class="line">&#123;</span><br><span class="line">p = (LinkList)malloc(sizeof(Node)); /*  生成新结点 */</span><br><span class="line">p-&gt;data = rand()%100+1;             /*  随机生成100以内的数字 */</span><br><span class="line">p-&gt;next = (*L)-&gt;next;    </span><br><span class="line">(*L)-&gt;next = p;/*  插入到表头 */</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*  随机产生n个元素的值，建立带表头结点的单链线性表L（尾插法） */</span><br><span class="line">void CreateListTail(LinkList *L, int n) </span><br><span class="line">&#123;</span><br><span class="line">LinkList p,r;</span><br><span class="line">int i;</span><br><span class="line">srand(time(0));                      /* 初始化随机数种子 */</span><br><span class="line">*L = (LinkList)malloc(sizeof(Node)); /* L为整个线性表 */</span><br><span class="line">r=*L;                                /* r为指向尾部的结点 */</span><br><span class="line">for (i=0; i&lt;n; i++) </span><br><span class="line">&#123;</span><br><span class="line">p = (Node *)malloc(sizeof(Node)); /*  生成新结点 */</span><br><span class="line">p-&gt;data = rand()%100+1;           /*  随机生成100以内的数字 */</span><br><span class="line">r-&gt;next=p;                        /* 将表尾终端结点的指针指向新结点 */</span><br><span class="line">r = p;                            /* 将当前的新结点定义为表尾终端结点 */</span><br><span class="line">&#125;</span><br><span class="line">r-&gt;next = NULL;                       /* 表示当前链表结束 */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr />版权信息]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 线性表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈和队列</title>
      <link href="/2022/01/04/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
      <url>/2022/01/04/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>栈与队列<br>期末秃头人限定<br><a href="https://sm.ms/image/Yd5sbtuagm9RUSA" target="_blank"><img src="https://s2.loli.net/2022/01/07/Yd5sbtuagm9RUSA.jpg"  style="width:80%"></a></p><span id="more"></span><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>栈是只允许在一端进行插入或删除的线性表。</strong><br><strong>先进后出</strong></p><h2 id="储存结构"><a href="#储存结构" class="headerlink" title="储存结构"></a>储存结构</h2><p><strong>先移动指针再入栈</strong><br><strong>先出栈再移动指针</strong></p><h3 id="顺序储存"><a href="#顺序储存" class="headerlink" title="顺序储存"></a>顺序储存</h3><p><strong>利用一组地址连续的储存单元存放自栈底到栈顶的数据元素</strong><br><strong>附设一个top指针指向栈顶元素</strong></p><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#define OK 1</span><br><span class="line">#define ERROR 0</span><br><span class="line">#define TRUE 1</span><br><span class="line">#define FALSE 0</span><br><span class="line">#define MAXSIZE 20 /* 存储空间初始分配量 */</span><br><span class="line"></span><br><span class="line">typedef int Status; </span><br><span class="line">typedef int SElemType; /* SElemType类型根据实际情况而定，这里假设为int */</span><br><span class="line"></span><br><span class="line">/* 顺序栈结构 */</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">        SElemType data[MAXSIZE];</span><br><span class="line">        int top; /* 用于栈顶指针 */</span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line">Status visit(SElemType c)</span><br><span class="line">&#123;</span><br><span class="line">        printf(&quot;%d &quot;,c);</span><br><span class="line">        return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*  构造一个空栈S */</span><br><span class="line">Status InitStack(SqStack *S)</span><br><span class="line">&#123; </span><br><span class="line">        /* S.data=(SElemType *)malloc(MAXSIZE*sizeof(SElemType)); */</span><br><span class="line">        S-&gt;top=-1;</span><br><span class="line">        return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 把S置为空栈 */</span><br><span class="line">Status ClearStack(SqStack *S)</span><br><span class="line">&#123; </span><br><span class="line">        S-&gt;top=-1;</span><br><span class="line">        return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 若栈S为空栈，则返回TRUE，否则返回FALSE */</span><br><span class="line">Status StackEmpty(SqStack S)</span><br><span class="line">&#123; </span><br><span class="line">        if (S.top==-1)</span><br><span class="line">                return TRUE;</span><br><span class="line">        else</span><br><span class="line">                return FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 返回S的元素个数，即栈的长度 */</span><br><span class="line">int StackLength(SqStack S)</span><br><span class="line">&#123; </span><br><span class="line">        return S.top+1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 若栈不空，则用e返回S的栈顶元素，并返回OK；否则返回ERROR */</span><br><span class="line">Status GetTop(SqStack S,SElemType *e)</span><br><span class="line">&#123;</span><br><span class="line">        if (S.top==-1)</span><br><span class="line">                return ERROR;</span><br><span class="line">        else</span><br><span class="line">                *e=S.data[S.top];</span><br><span class="line">        return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 插入元素e为新的栈顶元素 */</span><br><span class="line">Status Push(SqStack *S,SElemType e)</span><br><span class="line">&#123;</span><br><span class="line">        if(S-&gt;top == MAXSIZE -1) /* 栈满 */</span><br><span class="line">        &#123;</span><br><span class="line">                return ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">        S-&gt;top++;/* 栈顶指针增加一 */</span><br><span class="line">        S-&gt;data[S-&gt;top]=e;  /* 将新插入元素赋值给栈顶空间 */</span><br><span class="line">        return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR */</span><br><span class="line">Status Pop(SqStack *S,SElemType *e)</span><br><span class="line">&#123; </span><br><span class="line">        if(S-&gt;top==-1)</span><br><span class="line">                return ERROR;</span><br><span class="line">        *e=S-&gt;data[S-&gt;top];/* 将要删除的栈顶元素赋值给e */</span><br><span class="line">        S-&gt;top--;/* 栈顶指针减一 */</span><br><span class="line">        return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 从栈底到栈顶依次对栈中每个元素显示 */</span><br><span class="line">Status StackTraverse(SqStack S)</span><br><span class="line">&#123;</span><br><span class="line">        int i;</span><br><span class="line">        i=0;</span><br><span class="line">        while(i&lt;=S.top)</span><br><span class="line">        &#123;</span><br><span class="line">                visit(S.data[i++]);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">        return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="链式储存"><a href="#链式储存" class="headerlink" title="链式储存"></a>链式储存</h3><p><strong>单链表实现</strong><br><strong>规定所有操作都是在栈顶实现</strong></p><p>没有头结点</p><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">#define OK 1</span><br><span class="line">#define ERROR 0</span><br><span class="line">#define TRUE 1</span><br><span class="line">#define FALSE 0</span><br><span class="line">#define MAXSIZE 20 /* 存储空间初始分配量 */</span><br><span class="line"></span><br><span class="line">typedef int Status; </span><br><span class="line">typedef int SElemType; /* SElemType类型根据实际情况而定，这里假设为int */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* 链栈结构 */</span><br><span class="line">typedef struct StackNode</span><br><span class="line">&#123;</span><br><span class="line">        SElemType data;</span><br><span class="line">        struct StackNode *next;</span><br><span class="line">&#125;StackNode,*LinkStackPtr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">        LinkStackPtr top;</span><br><span class="line">        int count;</span><br><span class="line">&#125;LinkStack;</span><br><span class="line"></span><br><span class="line">Status visit(SElemType c)</span><br><span class="line">&#123;</span><br><span class="line">        printf(&quot;%d &quot;,c);</span><br><span class="line">        return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*  构造一个空栈S */</span><br><span class="line">Status InitStack(LinkStack *S)</span><br><span class="line">&#123; </span><br><span class="line">        S-&gt;top = (LinkStackPtr)malloc(sizeof(StackNode));</span><br><span class="line">        if(!S-&gt;top)</span><br><span class="line">                return ERROR;</span><br><span class="line">        S-&gt;top=NULL;</span><br><span class="line">        S-&gt;count=0;</span><br><span class="line">        return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 把S置为空栈 */</span><br><span class="line">Status ClearStack(LinkStack *S)</span><br><span class="line">&#123; </span><br><span class="line">        LinkStackPtr p,q;</span><br><span class="line">        p=S-&gt;top;</span><br><span class="line">        while(p)</span><br><span class="line">        &#123;  </span><br><span class="line">                q=p;</span><br><span class="line">                p=p-&gt;next;</span><br><span class="line">                free(q);</span><br><span class="line">        &#125; </span><br><span class="line">        S-&gt;count=0;</span><br><span class="line">        return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 若栈S为空栈，则返回TRUE，否则返回FALSE */</span><br><span class="line">Status StackEmpty(LinkStack S)</span><br><span class="line">&#123; </span><br><span class="line">        if (S.count==0)</span><br><span class="line">                return TRUE;</span><br><span class="line">        else</span><br><span class="line">                return FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 返回S的元素个数，即栈的长度 */</span><br><span class="line">int StackLength(LinkStack S)</span><br><span class="line">&#123; </span><br><span class="line">        return S.count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 若栈不空，则用e返回S的栈顶元素，并返回OK；否则返回ERROR */</span><br><span class="line">Status GetTop(LinkStack S,SElemType *e)</span><br><span class="line">&#123;</span><br><span class="line">        if (S.top==NULL)</span><br><span class="line">                return ERROR;</span><br><span class="line">        else</span><br><span class="line">                *e=S.top-&gt;data;</span><br><span class="line">        return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 插入元素e为新的栈顶元素 */</span><br><span class="line">Status Push(LinkStack *S,SElemType e)</span><br><span class="line">&#123;</span><br><span class="line">        LinkStackPtr s=(LinkStackPtr)malloc(sizeof(StackNode)); </span><br><span class="line">        s-&gt;data=e; </span><br><span class="line">        s-&gt;next=S-&gt;top;/* 把当前的栈顶元素赋值给新结点的直接后继，见图中① */</span><br><span class="line">        S-&gt;top=s;         /* 将新的结点s赋值给栈顶指针，见图中② */</span><br><span class="line">        S-&gt;count++;</span><br><span class="line">        return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR */</span><br><span class="line">Status Pop(LinkStack *S,SElemType *e)</span><br><span class="line">&#123; </span><br><span class="line">        LinkStackPtr p;</span><br><span class="line">        if(StackEmpty(*S))</span><br><span class="line">                return ERROR;</span><br><span class="line">        *e=S-&gt;top-&gt;data;</span><br><span class="line">        p=S-&gt;top;/* 将栈顶结点赋值给p，见图中③ */</span><br><span class="line">        S-&gt;top=S-&gt;top-&gt;next;    /* 使得栈顶指针下移一位，指向后一结点，见图中④ */</span><br><span class="line">        free(p);                    /* 释放结点p */        </span><br><span class="line">        S-&gt;count--;</span><br><span class="line">        return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Status StackTraverse(LinkStack S)</span><br><span class="line">&#123;</span><br><span class="line">        LinkStackPtr p;</span><br><span class="line">        p=S.top;</span><br><span class="line">        while(p)</span><br><span class="line">        &#123;</span><br><span class="line">                 visit(p-&gt;data);</span><br><span class="line">                 p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">        return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="共享栈"><a href="#共享栈" class="headerlink" title="共享栈"></a>共享栈</h2><p><a href="https://sm.ms/image/7aPM3FTuXfAI1JH" target="_blank"><img src="https://s2.loli.net/2022/01/07/7aPM3FTuXfAI1JH.jpg" ></a></p><h2 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h2><p>数据逆置算法、括号匹配的判断、后缀表达式求值算法</p><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p><strong>在表的一端经行输入，在另一端经行输出</strong></p><h2 id="储存结构-1"><a href="#储存结构-1" class="headerlink" title="储存结构"></a>储存结构</h2><h3 id="顺序储存-1"><a href="#顺序储存-1" class="headerlink" title="顺序储存"></a>顺序储存</h3><p><strong>分配一块连续的储存空间</strong><br><strong>两个指针一个指向指向队头(front),一个指向队尾(rear)</strong></p><p>入栈操作<br><strong>队不满时，先送值到队尾，再将队尾指针加1</strong></p><p>出栈操作<br><strong>队不空时，先取队头元素，在将队头指针加1</strong></p><p>队空条件<br><strong>Q.front == Q.rear == 0</strong></p><h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p><a href="https://sm.ms/image/qkyF3WwiMEUSGfJ" target="_blank"><img src="https://s2.loli.net/2022/01/07/qkyF3WwiMEUSGfJ.jpg" ></a></p><p>代码:</p><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#define OK 1</span><br><span class="line">#define ERROR 0</span><br><span class="line">#define TRUE 1</span><br><span class="line">#define FALSE 0</span><br><span class="line">#define MAXSIZE 20 /* 存储空间初始分配量 */</span><br><span class="line"></span><br><span class="line">typedef int Status; </span><br><span class="line">typedef int QElemType; /* QElemType类型根据实际情况而定，这里假设为int */</span><br><span class="line"></span><br><span class="line">/* 循环队列的顺序存储结构 */</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">QElemType data[MAXSIZE];</span><br><span class="line">int front;    /* 头指针 */</span><br><span class="line">int rear;/* 尾指针，若队列不空，指向队列尾元素的下一个位置 */</span><br><span class="line">&#125;SqQueue;</span><br><span class="line"></span><br><span class="line">Status visit(QElemType c)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d &quot;,c);</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 初始化一个空队列Q */</span><br><span class="line">Status InitQueue(SqQueue *Q)</span><br><span class="line">&#123;</span><br><span class="line">Q-&gt;front=0;</span><br><span class="line">Q-&gt;rear=0;</span><br><span class="line">return  OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 将Q清为空队列 */</span><br><span class="line">Status ClearQueue(SqQueue *Q)</span><br><span class="line">&#123;</span><br><span class="line">Q-&gt;front=Q-&gt;rear=0;</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 若队列Q为空队列,则返回TRUE,否则返回FALSE */</span><br><span class="line">Status QueueEmpty(SqQueue Q)</span><br><span class="line">&#123; </span><br><span class="line">if(Q.front==Q.rear) /* 队列空的标志 */</span><br><span class="line">return TRUE;</span><br><span class="line">else</span><br><span class="line">return FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 返回Q的元素个数，也就是队列的当前长度 */</span><br><span class="line">int QueueLength(SqQueue Q)</span><br><span class="line">&#123;</span><br><span class="line">return  (Q.rear-Q.front+MAXSIZE)%MAXSIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 若队列不空,则用e返回Q的队头元素,并返回OK,否则返回ERROR */</span><br><span class="line">Status GetHead(SqQueue Q,QElemType *e)</span><br><span class="line">&#123;</span><br><span class="line">if(Q.front==Q.rear) /* 队列空 */</span><br><span class="line">return ERROR;</span><br><span class="line">*e=Q.data[Q.front];</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 若队列未满，则插入元素e为Q新的队尾元素 */</span><br><span class="line">Status EnQueue(SqQueue *Q,QElemType e)</span><br><span class="line">&#123;</span><br><span class="line">if ((Q-&gt;rear+1)%MAXSIZE == Q-&gt;front)/* 队列满的判断 */</span><br><span class="line">return ERROR;</span><br><span class="line">Q-&gt;data[Q-&gt;rear]=e;/* 将元素e赋值给队尾 */</span><br><span class="line">Q-&gt;rear=(Q-&gt;rear+1)%MAXSIZE;/* rear指针向后移一位置， */</span><br><span class="line">/* 若到最后则转到数组头部 */</span><br><span class="line">return  OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 若队列不空，则删除Q中队头元素，用e返回其值 */</span><br><span class="line">Status DeQueue(SqQueue *Q,QElemType *e)</span><br><span class="line">&#123;</span><br><span class="line">if (Q-&gt;front == Q-&gt;rear)/* 队列空的判断 */</span><br><span class="line">return ERROR;</span><br><span class="line">*e=Q-&gt;data[Q-&gt;front];/* 将队头元素赋值给e */</span><br><span class="line">Q-&gt;front=(Q-&gt;front+1)%MAXSIZE;/* front指针向后移一位置， */</span><br><span class="line">/* 若到最后则转到数组头部 */</span><br><span class="line">return  OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 从队头到队尾依次对队列Q中每个元素输出 */</span><br><span class="line">Status QueueTraverse(SqQueue Q)</span><br><span class="line">&#123; </span><br><span class="line">int i;</span><br><span class="line">i=Q.front;</span><br><span class="line">while((i+Q.front)!=Q.rear)</span><br><span class="line">&#123;</span><br><span class="line">visit(Q.data[i]);</span><br><span class="line">i=(i+1)%MAXSIZE;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链式储存-1"><a href="#链式储存-1" class="headerlink" title="链式储存"></a>链式储存</h3><p><strong>同时带有队头指针和队尾指针的单链表</strong></p><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#define OK 1</span><br><span class="line">#define ERROR 0</span><br><span class="line">#define TRUE 1</span><br><span class="line">#define FALSE 0</span><br><span class="line">#define MAXSIZE 20 /* 存储空间初始分配量 */</span><br><span class="line"></span><br><span class="line">typedef int Status; </span><br><span class="line"></span><br><span class="line">typedef int QElemType; /* QElemType类型根据实际情况而定，这里假设为int */</span><br><span class="line"></span><br><span class="line">typedef struct QNode/* 结点结构 */</span><br><span class="line">&#123;</span><br><span class="line">   QElemType data;</span><br><span class="line">   struct QNode *next;</span><br><span class="line">&#125;QNode,*QueuePtr;</span><br><span class="line"></span><br><span class="line">typedef struct/* 队列的链表结构 */</span><br><span class="line">&#123;</span><br><span class="line">   QueuePtr front,rear; /* 队头、队尾指针 */</span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br><span class="line">Status visit(QElemType c)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d &quot;,c);</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 构造一个空队列Q */</span><br><span class="line">Status InitQueue(LinkQueue *Q)</span><br><span class="line">&#123; </span><br><span class="line">Q-&gt;front=Q-&gt;rear=(QueuePtr)malloc(sizeof(QNode));</span><br><span class="line">if(!Q-&gt;front)</span><br><span class="line">exit(OVERFLOW);</span><br><span class="line">Q-&gt;front-&gt;next=NULL;</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 销毁队列Q */</span><br><span class="line">Status DestroyQueue(LinkQueue *Q)</span><br><span class="line">&#123;</span><br><span class="line">while(Q-&gt;front)</span><br><span class="line">&#123;</span><br><span class="line"> Q-&gt;rear=Q-&gt;front-&gt;next;</span><br><span class="line"> free(Q-&gt;front);</span><br><span class="line"> Q-&gt;front=Q-&gt;rear;</span><br><span class="line">&#125;</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 将Q清为空队列 */</span><br><span class="line">Status ClearQueue(LinkQueue *Q)</span><br><span class="line">&#123;</span><br><span class="line">QueuePtr p,q;</span><br><span class="line">Q-&gt;rear=Q-&gt;front;</span><br><span class="line">p=Q-&gt;front-&gt;next;</span><br><span class="line">Q-&gt;front-&gt;next=NULL;</span><br><span class="line">while(p)</span><br><span class="line">&#123;</span><br><span class="line"> q=p;</span><br><span class="line"> p=p-&gt;next;</span><br><span class="line"> free(q);</span><br><span class="line">&#125;</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 若Q为空队列,则返回TRUE,否则返回FALSE */</span><br><span class="line">Status QueueEmpty(LinkQueue Q)</span><br><span class="line">&#123; </span><br><span class="line">if(Q.front==Q.rear)</span><br><span class="line">return TRUE;</span><br><span class="line">else</span><br><span class="line">return FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 求队列的长度 */</span><br><span class="line">int QueueLength(LinkQueue Q)</span><br><span class="line">&#123; </span><br><span class="line">int i=0;</span><br><span class="line">QueuePtr p;</span><br><span class="line">p=Q.front;</span><br><span class="line">while(Q.rear!=p)</span><br><span class="line">&#123;</span><br><span class="line"> i++;</span><br><span class="line"> p=p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">return i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 若队列不空,则用e返回Q的队头元素,并返回OK,否则返回ERROR */</span><br><span class="line">Status GetHead(LinkQueue Q,QElemType *e)</span><br><span class="line">&#123; </span><br><span class="line">QueuePtr p;</span><br><span class="line">if(Q.front==Q.rear)</span><br><span class="line">return ERROR;</span><br><span class="line">p=Q.front-&gt;next;</span><br><span class="line">*e=p-&gt;data;</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* 插入元素e为Q的新的队尾元素 */</span><br><span class="line">Status EnQueue(LinkQueue *Q,QElemType e)</span><br><span class="line">&#123; </span><br><span class="line">QueuePtr s=(QueuePtr)malloc(sizeof(QNode));</span><br><span class="line">if(!s) /* 存储分配失败 */</span><br><span class="line">exit(OVERFLOW);</span><br><span class="line">s-&gt;data=e;</span><br><span class="line">s-&gt;next=NULL;</span><br><span class="line">Q-&gt;rear-&gt;next=s;/* 把拥有元素e的新结点s赋值给原队尾结点的后继，见图中① */</span><br><span class="line">Q-&gt;rear=s;/* 把当前的s设置为队尾结点，rear指向s，见图中② */</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 若队列不空,删除Q的队头元素,用e返回其值,并返回OK,否则返回ERROR */</span><br><span class="line">Status DeQueue(LinkQueue *Q,QElemType *e)</span><br><span class="line">&#123;</span><br><span class="line">QueuePtr p;</span><br><span class="line">if(Q-&gt;front==Q-&gt;rear)</span><br><span class="line">return ERROR;</span><br><span class="line">p=Q-&gt;front-&gt;next;/* 将欲删除的队头结点暂存给p，见图中① */</span><br><span class="line">*e=p-&gt;data;/* 将欲删除的队头结点的值赋值给e */</span><br><span class="line">Q-&gt;front-&gt;next=p-&gt;next;/* 将原队头结点的后继p-&gt;next赋值给头结点后继，见图中② */</span><br><span class="line">if(Q-&gt;rear==p)/* 若队头就是队尾，则删除后将rear指向头结点，见图中③ */</span><br><span class="line">Q-&gt;rear=Q-&gt;front;</span><br><span class="line">free(p);</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 从队头到队尾依次对队列Q中每个元素输出 */</span><br><span class="line">Status QueueTraverse(LinkQueue Q)</span><br><span class="line">&#123;</span><br><span class="line">QueuePtr p;</span><br><span class="line">p=Q.front-&gt;next;</span><br><span class="line">while(p)</span><br><span class="line">&#123;</span><br><span class="line"> visit(p-&gt;data);</span><br><span class="line"> p=p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr />版权信息]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 栈 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不正经的2021总结</title>
      <link href="/2021/12/31/2021%E6%80%BB%E7%BB%93/"/>
      <url>/2021/12/31/2021%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p><a href="https://sm.ms/image/ghyrXm5CScL4RJN" target="_blank"><img src="https://s2.loli.net/2021/12/31/ghyrXm5CScL4RJN.jpg" ></a></p><p><strong>前言</strong></p><p>这是一篇不太正经的年度总结呢！</p><span id="more"></span><h1 id="很喜欢的一张画"><a href="#很喜欢的一张画" class="headerlink" title="很喜欢的一张画"></a>很喜欢的一张画</h1><p><a href="https://sm.ms/image/C3VqX8gh4vlpxUc" target="_blank"><img src="https://s2.loli.net/2021/12/31/C3VqX8gh4vlpxUc.jpg" style="width:50%"></a></p><h1 id="1-21"><a href="#1-21" class="headerlink" title="1.21"></a>1.21</h1><p>和小朋友在一起两年啦<br>假期有和她一起出去玩<br><a href="https://sm.ms/image/qFNkLcW1VgaA2O3" target="_blank"><img src="https://s2.loli.net/2021/12/31/qFNkLcW1VgaA2O3.jpg" style="width:50%"></a></p><h1 id="一些春天的照片"><a href="#一些春天的照片" class="headerlink" title="一些春天的照片"></a>一些春天的照片</h1><p>春天的雨后晚上和春天的园林<br>苏州在春天的时候会有很多古装小姐姐逛园子哦<br><a href="https://sm.ms/image/9dawstyPgzmK4nV" target="_blank"><img src="https://s2.loli.net/2021/12/31/9dawstyPgzmK4nV.jpg" style="width:50%"></a><br><a href="https://sm.ms/image/dYrW7meOPQGftgs" target="_blank"><img src="https://s2.loli.net/2021/12/31/dYrW7meOPQGftgs.jpg" style="width:50%"></a><br><a href="https://sm.ms/image/b8yfcjrSmlDZ3WX" target="_blank"><img src="https://s2.loli.net/2021/12/31/b8yfcjrSmlDZ3WX.jpg" style="width:50%"></a><br><a href="https://sm.ms/image/CVPFJioXN8ctRjq" target="_blank"><img src="https://s2.loli.net/2021/12/31/CVPFJioXN8ctRjq.jpg" style="width:50%"></a></p><h1 id="学期内"><a href="#学期内" class="headerlink" title="学期内"></a>学期内</h1><p><a href="https://sm.ms/image/Apa1b2NBndxcRKm" target="_blank"><img src="https://s2.loli.net/2021/12/31/Apa1b2NBndxcRKm.jpg" style="width:50%"></a><br>王者之志<br>见到了好多学校的专业运动员，见到了丹总</p><p><a href="https://sm.ms/image/sFOdqiKUSkh5BDm" target="_blank"><img src="https://s2.loli.net/2021/12/31/sFOdqiKUSkh5BDm.jpg" style="width:50%"></a></p><p>去LNG比赛现场志愿者*2<br>LNG 打 RNG 在现场，那种现场观赛的感觉超棒<br>更加喜欢lol，喜欢电竞<br><a href="https://sm.ms/image/zs6WRAciIYOwEPD" target="_blank"><img src="https://s2.loli.net/2021/12/31/zs6WRAciIYOwEPD.jpg"  style="width:50%"></a></p><h1 id="5-1-太湖"><a href="#5-1-太湖" class="headerlink" title="5.1 太湖"></a>5.1 太湖</h1><p>贴上今年最喜欢的照片之一<br>环太湖骑行是这几年最喜欢的骑行了<br>日落真的很好看，以后一定要带小朋友来看</p><p><a href="https://sm.ms/image/eihKcnoBGJ8DEjy" target="_blank"><img src="https://s2.loli.net/2021/12/31/eihKcnoBGJ8DEjy.jpg" style="width:80%"></a><br><a href="https://sm.ms/image/iBzvp7dA8KwOcDJ" target="_blank"><img src="https://s2.loli.net/2021/12/31/iBzvp7dA8KwOcDJ.jpg" style="width:80%"></a></p><h1 id="5-21-5-26"><a href="#5-21-5-26" class="headerlink" title="5.21 5.26"></a>5.21 5.26</h1><p>收到小朋友送的花花！</p><p><a href="https://sm.ms/image/CSvOKWcXdlRxoEe" target="_blank"><img src="https://s2.loli.net/2021/12/31/CSvOKWcXdlRxoEe.jpg" style="width:50%"></a></p><p>又长大了一岁！<br>有猫猫陪伴</p><p><a href="https://sm.ms/image/BIPhyqadpMwJzT7" target="_blank"><img src="https://s2.loli.net/2021/12/31/BIPhyqadpMwJzT7.jpg" style="width:50%"></a></p><h1 id="暑假"><a href="#暑假" class="headerlink" title="暑假"></a>暑假</h1><p>有初步学习微信小程序并且写了一个不太完整的demo(为了一个比赛来着，不过好像被咕了)<br>一定一定要记得不要参加那些不官方的比赛了</p><p>和好朋友们出去 玩玩玩</p><p>给小朋友们代课</p><p>科目三挂了。。。。。。。艹</p><p>开始习惯于自己做饭，厨艺渐长<br><a href="https://sm.ms/image/dfJ9EokF5tpLasI" target="_blank"><img src="https://s2.loli.net/2021/12/31/dfJ9EokF5tpLasI.jpg" style="width:50%"></a></p><h1 id="去四川"><a href="#去四川" class="headerlink" title="去四川"></a>去四川</h1><p>很长时间没有去旅行了，趁着放假的延长去了一次四川，不仅仅是去找她，还是为完成自己多年的愿望。<br>去了发现自己真的很喜欢四川的生活，饮食风格也好，生活节奏也好，这个城市可能是更适合我的吧<br>第一次一个人的旅行，过程中有时候会觉得自己很孤独，但是自己还是很喜欢这种自由自在的旅行<br>和小朋友过了过简单的二人世界，虽然没有去什么景点，就只是在自己租的民宿一起刷B站，去买菜做饭(虽然翻车了),去就近的电影院看电影，但是确能感到很开心，可能自己就喜欢这种过小日子的感觉吧<br><a href="https://sm.ms/image/QbgVYoi2FWeTkyt" target="_blank"><img src="https://s2.loli.net/2021/12/31/QbgVYoi2FWeTkyt.jpg" style="width:50%"></a><br><a href="https://sm.ms/image/EOaIyociGHZ93Vk" target="_blank"><img src="https://s2.loli.net/2021/12/31/EOaIyociGHZ93Vk.jpg" style="width:50%"></a><br><a href="https://sm.ms/image/6ZnBIAylVDHTFbh" target="_blank"><img src="https://s2.loli.net/2021/12/31/6ZnBIAylVDHTFbh.jpg" style="width:50%"></a><br><a href="https://sm.ms/image/GDEcbOs25CK7LYa" target="_blank"><img src="https://s2.loli.net/2021/12/31/GDEcbOs25CK7LYa.jpg" style="width:50%"></a><br><a href="https://sm.ms/image/ELhwWSACO4js5bo" target="_blank"><img src="https://s2.loli.net/2021/12/31/ELhwWSACO4js5bo.jpg" style="width:50%"></a><br><a href="https://sm.ms/image/PcLiplS8oO6aTEQ" target="_blank"><img src="https://s2.loli.net/2021/12/31/PcLiplS8oO6aTEQ.jpg" style="width:50%"></a></p><h1 id="大二下"><a href="#大二下" class="headerlink" title="大二下"></a>大二下</h1><p>大二下的一年里渐渐习惯晚上喝一两杯再睡觉，也可能是因为自己日常的压力逐渐增大，和其他人的关系也渐渐固化，不愿意去进行多余的交际，晚上总是会莫名其妙的难过，喝两杯，会舒服很多</p><p><a href="https://sm.ms/image/XwqzyhJcQtMIGOT" target="_blank"> <img src="https://s2.loli.net/2021/12/31/XwqzyhJcQtMIGOT.jpg" style="width:50%"></a></p><p>举办校赛，真的很忙很累，这种300+人参加的全校活动是第一次举办，详情转至博客</p><a href="/2021/12/06/thinking1/" title="一些胡思乱想">一些胡思乱想</a><a href="/2021/12/06/thinking1/" title="一些胡思乱想">一些胡思乱想</a><p>秋天的苏大，很美，但是一直是一个人<br><a href="https://sm.ms/image/jPNA9VfO5L1MKxr" target="_blank"><img src="https://s2.loli.net/2021/12/31/jPNA9VfO5L1MKxr.jpg" style="width:50%"></a></p><p>喜欢在学习的时候听爵士。</p><p>拿到了教练员证！</p><p>开始学习怎么写博客，学着记录自己的生活</p><p>认识了加油站，很有意思的音乐社团，大家都和很喜欢音乐，太喜欢那种弹吉他一起唱歌的感觉了</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>一些没用的年度总结</p><table>  <tr>      <td ><center><img src="https://s2.loli.net/2021/12/31/jgQIlwob5YHhnps.jpg" style="width:50%"> </center></td>      <td ><center><img src="https://s2.loli.net/2021/12/31/jheYux8wvbH7iZk.jpg" style="width:70%"> </center></td>  </tr>    <tr>      <td ><center><img src="https://s2.loli.net/2021/12/31/NRKzIqCEX7ktwyB.jpg" style="width:50%"> </center></td>      <td ><center><img src="https://s2.loli.net/2021/12/31/j5hR2guETlsADf7.jpg" style="width:80%"> </center></td>  </tr>    <tr>      <td ><center><img src="https://s2.loli.net/2021/12/31/tQA18sTuNSWyxCZ.jpg" style="width:50%"> </center></td>  </tr></table><p>2021身边的事情发生了太多太多，全球形势也好，网络舆论也好，给人的感觉是这一年负面情绪太多了，以至于现在的人们对于新的一年的期望远远没有之前更高，可能是疫情的原因吧，也可能是逐渐成年的原因，自己已经感觉不到那种跨年的喜悦，对于过年的渴望了，身边的人都在抱怨自己的生活怎样差劲，感觉在大学一年过去了什么都没有发生改变，但仔细一总结还是有很多收获的，有认识新的朋友圈子，有学习新的知识，有完成自己的小小心愿，虽然难过很多，崩溃常有，但是已经都过去了，负面情绪就让他在时间的长河中流逝，能留下来的，才是最珍贵的。</p><p>新的一年，继续加油吧！</p><hr />版权信息]]></content>
      
      
      <categories>
          
          <category> 年度总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最小生成树问题</title>
      <link href="/2021/12/24/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
      <url>/2021/12/24/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>实现生成最小生成树的原理和代码</p><p><em>普里姆(Prim)算法</em></p><p><em>克鲁斯卡尔(Kruskal)算法</em></p><span id="more"></span><h1 id="普里姆-Prim-算法"><a href="#普里姆-Prim-算法" class="headerlink" title="普里姆(Prim)算法"></a>普里姆(Prim)算法</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>每次迭代选择代价最小的边对应的点，加入到最小生成树中。算法从某一个顶点s开始，逐渐长大覆盖整个连通网的所有顶点。</p><p><a href="https://sm.ms/image/cJoNn5OkyBbvM1K" target="_blank"><img src="https://s2.loli.net/2021/12/24/cJoNn5OkyBbvM1K.jpg" style="width:80%"></a><br><a href="https://sm.ms/image/r2hfNoOITXntadm" target="_blank"><img src="https://s2.loli.net/2021/12/24/r2hfNoOITXntadm.jpg" style="width:80%"></a></p><h2 id="代码解读"><a href="#代码解读" class="headerlink" title="代码解读"></a>代码解读</h2><p>v表示从哪个结点开始</p><p>用有权的邻接矩阵实现</p><p>若两边不相邻，设为Infinty</p><p>定义两个数组</p><p>adjvex 存储lowcost中对应下标元素是从哪个结点为起点的</p><p>lowcost 中元素意思为现有的存在于最小生成树的结点到此下标结点的最小距离 当值为0时表示此元素以及存在于最小生成树中</p><p>定义函数  MinEdge 寻找lowcost中距离最小的下标 下标带入adjvex中找到结点的值</p><p>当寻找到最小下标时，将此结点写入最小生成树中，并遍历此结点所连接的边，若能到达的结点边权值小于lowcost中储存的，更新</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MaxSize = 10;</span><br><span class="line">const int Infinty = 10000;</span><br><span class="line"></span><br><span class="line">template&lt;typename DataType&gt; </span><br><span class="line">class MGraph&#123;</span><br><span class="line">public:</span><br><span class="line">    MGraph(DataType a[ ],int n, int e);</span><br><span class="line">    ~MGraph()&#123;&#125;;</span><br><span class="line">    void Prim(int v);</span><br><span class="line">    int MinEdge(int lowcost[],int vertexNum);</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    DataType vertex[MaxSize];</span><br><span class="line">    int edge[MaxSize][MaxSize];</span><br><span class="line">    int visited[MaxSize] = &#123;0&#125;;</span><br><span class="line">    int vertexNum,edgeNum;//结点数，边数</span><br><span class="line">    void clear()&#123;</span><br><span class="line">        for(int i=0;i&lt;MaxSize;i++)&#123;</span><br><span class="line">            visited[i] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename DataType&gt; </span><br><span class="line">MGraph&lt;DataType&gt;::MGraph(DataType a[ ],int n, int e)&#123;</span><br><span class="line">    int i,j,k,v;</span><br><span class="line">    vertexNum = n;</span><br><span class="line">    edgeNum = e;</span><br><span class="line">    for(i=0;i&lt;vertexNum;i++)&#123;</span><br><span class="line">        vertex[i] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for(i=0;i&lt;vertexNum;i++)&#123;</span><br><span class="line">        for(j=0;j&lt;vertexNum;j++)&#123;</span><br><span class="line">            edge[i][j] = Infinty;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(k=0;k&lt;edgeNum;k++)&#123;</span><br><span class="line">        cin &gt;&gt; i &gt;&gt; j &gt;&gt; v;</span><br><span class="line">        edge[i][j] = v;</span><br><span class="line">        edge[j][i] = v;</span><br><span class="line">    &#125;</span><br><span class="line">    for(k=0;k&lt;edgeNum;k++)&#123;</span><br><span class="line">        edge[k][k] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">template&lt;typename DataType&gt; </span><br><span class="line">void MGraph&lt;DataType&gt; :: Prim(int v)&#123;</span><br><span class="line">    int i,j,k;</span><br><span class="line">    int adjvex[MaxSize],lowcost[MaxSize];</span><br><span class="line">    // adjvex 存储lowcost中对应下标元素是从哪个结点为起点的</span><br><span class="line">    // lowcost 中元素意思为现有的存在于最小生成树的结点到此下标结点的最小距离</span><br><span class="line">    for( i =0;i&lt;vertexNum;i++)&#123; </span><br><span class="line">        adjvex[i] = v;</span><br><span class="line">        lowcost[i] = edge[v][i];</span><br><span class="line">    &#125;</span><br><span class="line">    // 初始化 adjvex lowcost</span><br><span class="line">    lowcost[v] = 0;</span><br><span class="line">    // lowcost[v] = 0 指下标为v的顶点已经在最小生成树中</span><br><span class="line"></span><br><span class="line">    for(k = 1;k&lt;vertexNum;k++)&#123;</span><br><span class="line">        j = MinEdge(lowcost,vertexNum);//寻找lowcost中最小权值结点的下标</span><br><span class="line">        cout &lt;&lt; adjvex[j] &lt;&lt;&#x27;-&#x27;&lt;&lt; j &lt;&lt;endl;</span><br><span class="line">        lowcost[j] =  0;// 写入最小生成树</span><br><span class="line">        for( i =0;i&lt;vertexNum;i++)&#123;</span><br><span class="line">            if(edge[j][i]&lt;lowcost[i] &amp;&amp; edge[j][i]&gt;0)&#123;</span><br><span class="line">                lowcost[i] = edge[j][i];</span><br><span class="line">                adjvex[i] = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">template&lt;typename DataType&gt; </span><br><span class="line">int MGraph&lt;DataType&gt; ::MinEdge(int lowcost[],int vertexNum)&#123;</span><br><span class="line">    int step = 0;</span><br><span class="line">    for(int j = 0;j&lt;vertexNum;j++)&#123;</span><br><span class="line">        if(lowcost[j]!=0)&#123;</span><br><span class="line">            step = j;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;vertexNum;i++)&#123;</span><br><span class="line">        if(lowcost[i]&lt;lowcost[step] &amp;&amp; lowcost[i]&gt;0)&#123;</span><br><span class="line">            step = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return step;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="克鲁斯卡尔-Kruskal-算法"><a href="#克鲁斯卡尔-Kruskal-算法" class="headerlink" title="克鲁斯卡尔(Kruskal)算法"></a>克鲁斯卡尔(Kruskal)算法</h1><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>先将权值最短的边挑出来，如果这条边两边的结点都已经连通，则跳过，知道最小生成树完成。</p><p><a href="https://sm.ms/image/zkfAPwc4WxG9KqN" target="_blank"><img src="https://s2.loli.net/2021/12/25/zkfAPwc4WxG9KqN.jpg" style="width:80%"></a><br><a href="https://sm.ms/image/nmRqi1F4GUvYocj" target="_blank"><img src="https://s2.loli.net/2021/12/25/nmRqi1F4GUvYocj.jpg" style="width:80%"></a></p><h2 id="代码解读-1"><a href="#代码解读-1" class="headerlink" title="代码解读"></a>代码解读</h2><p>定义边结构Edge出度结点入度结点边的权值</p><p>将邻接矩阵转化为边集数组edges并按权值大小排序</p><p>定义parent数组判断是否形成环</p><p>若parent数组下标所指示的元素不为0，表示此顶点已经在生成树中，所对应的元素值为此下标指向的结点</p><p>Find函数从结点f开始寻找连线顶点的尾部下标</p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">struct Edge&#123;</span><br><span class="line">    int begin;</span><br><span class="line">    int end;</span><br><span class="line">    int weight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void Kruskal(MGraph G)&#123;</span><br><span class="line">    int i,n m;</span><br><span class="line">    Edge edge[MAXEDGE];</span><br><span class="line">    int parent[MAXVEX];</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    此处省略将邻接矩阵G转化为边集数组edges并按权值大小排序代码</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    for(i=0;i&lt;G.vertexNum;i++)&#123;</span><br><span class="line">        parent[i] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    for(i=0;i&lt;G.edgeNum;i++)&#123;</span><br><span class="line">        n = Find(parent,edge[i].begin);</span><br><span class="line">        m = Find(parent,edge[i].end);</span><br><span class="line">        if(m!=n)&#123;</span><br><span class="line">            //  m，n不等，说明此边没有与现有生成树形成环路</span><br><span class="line">            parent[n] = m;</span><br><span class="line">            printf(edge[i].begin,edge[i].end)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Find(int *parent,int f)&#123;</span><br><span class="line">    while( parent[f]&gt;0)&#123;</span><br><span class="line">        f = parent[f];</span><br><span class="line">    &#125;</span><br><span class="line">    return f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><hr />版权信息]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> Prim </tag>
            
            <tag> Kruskal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>判断图是否为树/是否成环</title>
      <link href="/2021/12/22/%E5%88%A4%E6%96%AD%E5%9B%BE%E6%98%AF%E5%90%A6%E4%B8%BA%E6%A0%91-%E6%98%AF%E5%90%A6%E6%88%90%E7%8E%AF/"/>
      <url>/2021/12/22/%E5%88%A4%E6%96%AD%E5%9B%BE%E6%98%AF%E5%90%A6%E4%B8%BA%E6%A0%91-%E6%98%AF%E5%90%A6%E6%88%90%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>总结一下关于判断图是否成环的问题</p><p>参考博客:<br><a href="https://www.cnblogs.com/wangkundentisy/p/9320499.html">https://www.cnblogs.com/wangkundentisy/p/9320499.html</a><br><a href="https://blog.csdn.net/weixin_45697774/article/details/109528240">https://blog.csdn.net/weixin_45697774/article/details/109528240</a></p><span id="more"></span><h1 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h1><h2 id="利用DFS经行判断"><a href="#利用DFS经行判断" class="headerlink" title="利用DFS经行判断"></a>利用DFS经行判断</h2><ol><li>若在深搜的过程中遇到已经遍历过的边，则为环<br>可以定义visited数组，一个结点对应三种状态<br>x = 0 表示没有被访问过<br>x = 1 表示正在被访问<br>x = 2 表示生成树上的所有的子孙节点都已经访问完</li></ol><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class Graph</span><br><span class="line">&#123;</span><br><span class="line">    public:</span><br><span class="line">    int vertexNum;//顶点个数</span><br><span class="line">    int arcNum;//弧的个数</span><br><span class="line">    int vertex[MAX_NUM];//顶点表</span><br><span class="line">    int arc[MAX_NUM][MAX_NUM];//弧信息表</span><br><span class="line">&#125;;</span><br><span class="line">int visited[MAX_NUM];//顶点访问表</span><br><span class="line">int father[MAX_NUM];//父节点表</span><br><span class="line">void DFS(int v,Graph G)</span><br><span class="line">&#123;</span><br><span class="line">    visited[v] = 1;</span><br><span class="line">    for(int i = 0 ; i &lt; G.vertexNum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(i != v &amp;&amp; G.arc[v][i] != INF)//邻接矩阵中节点v的邻接点</span><br><span class="line">        &#123;</span><br><span class="line">            if(visited[i] == 1 &amp;&amp; father[v] != i)//vi不是父节点，而且还访问过(而且为状态1，说明不是回溯过来的顶点)，说明存在环(判断i不是v的父节点)</span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;&quot;图存在环&quot;;</span><br><span class="line">                int temp = v;</span><br><span class="line">                while(temp != i)</span><br><span class="line">                &#123;</span><br><span class="line">                    cout&lt;&lt;temp&lt;&lt;&quot;&lt;-&quot;;//输出环</span><br><span class="line">                    temp = father[temp];</span><br><span class="line">                &#125;</span><br><span class="line">                cout&lt;&lt;temp&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                if(visited[i] == 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    father[i] = v;//更新father数组</span><br><span class="line">                    DFS(i,G);</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[v] = 2;//遍历完所有的邻接点才变为状态2</span><br><span class="line">&#125;</span><br><span class="line">void DFSTraverse(Graph G)</span><br><span class="line">&#123;</span><br><span class="line">    memset(visited,0,sizeof(visited));</span><br><span class="line">    memset(father,-1,sizeof(father));</span><br><span class="line">    for(int i = 0 ; i &lt; G.vertexNum; i++)</span><br><span class="line">        if(!visited[i])</span><br><span class="line">            DFS(i,G);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h1><ol><li>拓扑排序判断是否成环 <a href="/2021/12/22/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/" title="拓扑排序">拓扑排序</a> <a href="/2021/12/22/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/" title="拓扑排序">拓扑排序</a></li></ol><h1 id="是否为树"><a href="#是否为树" class="headerlink" title="是否为树"></a>是否为树</h1><h2 id="无向图-1"><a href="#无向图-1" class="headerlink" title="无向图"></a>无向图</h2><p>对无向图来说，若连通且不成环，则为树<br>可以用定义来判断，即边数=结点数-1，并且在深度遍历整个图后所有边都被遍历过</p><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">int DFTraverse(int v,int edge[MaxSize][MaxSize],int vertexNum)&#123;</span><br><span class="line">    int sum_edge = 0;</span><br><span class="line">    visited[v] = 1;</span><br><span class="line">    for(int j = 0;j&lt;vertexNum;j++)&#123;</span><br><span class="line">        if(edge[v][j] == 1 &amp;&amp; visited[j] == 0) &#123;</span><br><span class="line">            sum_edge = sum_edge + DFTraverse(j,edge,vertexNum) +1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum_edge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void judge_tree(int edge[MaxSize][MaxSize],int vertexNum)</span><br><span class="line">&#123;</span><br><span class="line">    int edge_count = DFTraverse(0,edge,vertexNum);</span><br><span class="line">    int sum_edge = 0;</span><br><span class="line">    int node_count = vertexNum;</span><br><span class="line">    bool flag = true;</span><br><span class="line">    for(int i =0;i&lt;node_count;i++)&#123;</span><br><span class="line">        if(visited[i]==0)&#123;</span><br><span class="line">            flag = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int m =0;m&lt;node_count;m++)&#123;</span><br><span class="line">        for(int n =0;n&lt;node_count;n++)&#123;</span><br><span class="line">            if(edge[m][n]==1)&#123;</span><br><span class="line">                sum_edge++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(edge_count == node_count-1 &amp;&amp; flag &amp;&amp;sum_edge/2==edge_count)&#123;</span><br><span class="line">        cout &lt;&lt; &quot;is tree&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        cout &lt;&lt; &quot;is not tree&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="有向图-1"><a href="#有向图-1" class="headerlink" title="有向图"></a>有向图</h2><ol><li><p>若有一个结点的入度大于1，则不为树</p></li><li><p>同无向图判断成环，不成环为树</p></li></ol><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int Find(int x)</span><br><span class="line">&#123;</span><br><span class="line">    if(fa[x] == x)return x;</span><br><span class="line">    return fa[x] = Find(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool unions(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">    int fx = Find(x);</span><br><span class="line">    int fy = Find(y);</span><br><span class="line">    if(fx != fy)&#123;</span><br><span class="line">        fa[fy] = fx;//注意合并的是原来的点</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;//有环，不是树</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>详细代码见参考博客</p><hr />版权信息]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DFS </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>骑士周游问题</title>
      <link href="/2021/12/22/%E9%AA%91%E5%A3%AB%E5%91%A8%E6%B8%B8%E9%97%AE%E9%A2%98/"/>
      <url>/2021/12/22/%E9%AA%91%E5%A3%AB%E5%91%A8%E6%B8%B8%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong><br><a href="https://sm.ms/image/QhmFXdajT5IULBN" target="_blank"><img src="https://s2.loli.net/2021/12/25/QhmFXdajT5IULBN.jpg" style="width:50%"></a><br>骑士周游问题 马踏棋盘问题题解<br>还未优化！！</p><span id="more"></span><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>在一个棋盘上，一个棋子“马”（骑士），按照“马走日”的规则，从一个格子出发，走遍所有棋盘格恰好一次，一个这样的走棋序列称为一次“周游”。利用图的搜索算法，给出一个周游序列。</p><h1 id="方法解读"><a href="#方法解读" class="headerlink" title="方法解读"></a>方法解读</h1><p>递归深搜+回溯解决<br>可以使用贪心减少算法时间</p><p>参考博客:<br><a href="https://blog.csdn.net/u011718609/article/details/60873403">https://blog.csdn.net/u011718609/article/details/60873403</a><br><a href="https://www.cnblogs.com/Bone-ACE/p/4531306.html">https://www.cnblogs.com/Bone-ACE/p/4531306.html</a></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int MaxSize = 5;</span><br><span class="line"></span><br><span class="line"> int step_arr[8][2] = &#123;</span><br><span class="line">   &#123;-1,2&#125;,&#123;1,2&#125;,&#123;2,1&#125;,&#123;2,-1&#125;,&#123;1,-2&#125;,&#123;-1,-2&#125;,&#123;-2,-1&#125;,&#123;-2,1&#125;</span><br><span class="line">   &#125;;</span><br><span class="line"> </span><br><span class="line">//可移动的八个方向</span><br><span class="line">int ans_arr[5][5] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">void Dfs(int x, int y, int count,int step[5][5],int * flag)&#123;</span><br><span class="line"></span><br><span class="line">    if(*flag)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;    </span><br><span class="line">    if(count&gt;=25)&#123;</span><br><span class="line">        *flag = 1;</span><br><span class="line">        for(int i=0;i&lt;MaxSize;i++)&#123;</span><br><span class="line">            for(int j=0;j&lt;MaxSize;j++)&#123;</span><br><span class="line">                ans_arr[i][j] = step[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if(x&gt;=0&amp;&amp;x&lt;MaxSize&amp;&amp;y&gt;=0&amp;&amp;y&lt;MaxSize&amp;&amp;step[x][y]==0)&#123;  </span><br><span class="line">        count++;</span><br><span class="line">        step[x][y]=count;</span><br><span class="line">        for(int i=0;i&lt;8;i++)&#123;   </span><br><span class="line">            Dfs(x+step_arr[i][0],y+step_arr[i][1],count,step,flag);  </span><br><span class="line">        &#125;</span><br><span class="line">        step[x][y]=0;//回溯***</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">    int step[5][5] = &#123;0&#125;;</span><br><span class="line">    int x, y,flag = 0;</span><br><span class="line">    Dfs(0,2,0,step,&amp;flag);</span><br><span class="line">    for(int i=0;i&lt;MaxSize;i++)&#123;</span><br><span class="line">        for(int j=0;j&lt;MaxSize;j++)&#123;</span><br><span class="line">            cout &lt;&lt; ans_arr[i][j] &lt;&lt; &#x27; &#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr />版权信息]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> DFS </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拓扑排序</title>
      <link href="/2021/12/22/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
      <url>/2021/12/22/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>总结一下拓扑排序相关的知识点和代码</p><p><a href="https://sm.ms/image/9cDbKx6CoEXuWkF" target="_blank"><img src="https://s2.loli.net/2021/12/28/9cDbKx6CoEXuWkF.jpg" ></a></p><span id="more"></span><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>拓扑排序是对DAG（有向无环图）上的节点进行排序，使得对于每一条有向边 v -&gt; j ， v 都在 j 之前出现。简单地说，是在不破坏节点先后顺序的前提下，把DAG拉成一条链。如果以游戏中的科技树（虽然名字带树，其实常常不是树而只是DAG）举例，拓扑排序就是找到一种可能的点科技树的顺序。<br>参考文章:<br><a href="https://zhuanlan.zhihu.com/p/260112913">https://zhuanlan.zhihu.com/p/260112913</a></p><h1 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h1><p>从AVO网中选择一个入度为0的顶点输出，然后删除此结点，并删除以此顶点为尾的弧，继续重复此步骤，直到输出全部顶点或者AVO网中不存在入度为0的顶点为止。</p><h1 id="代码解读"><a href="#代码解读" class="headerlink" title="代码解读"></a>代码解读</h1><p>为AVO网建立一个邻接表，并在原基础上增加一个入度域<br>使用栈/队列来存储入度为0的结点<br>栈为深度优先实现<br>队列为广度优先实现<br>最后一步判断是否完成了拓扑排序。</p><p>若图成环，则一定不能构成拓扑排序<br>可以作为判断是否成环的方法之一</p><h1 id="完整代码实现"><a href="#完整代码实现" class="headerlink" title="完整代码实现"></a>完整代码实现</h1><figure class="highlight plaintext"><figcaption><span>[拓扑排序] [lang:C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// edges 邻接矩阵</span><br><span class="line">// deg是入度，在存图的时候需要录入数据</span><br><span class="line">// A是排序后的数组</span><br><span class="line">int deg[MAXN], A[MAXN];</span><br><span class="line">bool toposort(int n)</span><br><span class="line">&#123;</span><br><span class="line">    int cnt = 0;</span><br><span class="line">    queue&lt;int&gt; q;</span><br><span class="line">// 先将本没有入度的结点输入进队列</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i)</span><br><span class="line">        if (deg[i] == 0)</span><br><span class="line">            q.push(i);</span><br><span class="line">    while (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        int t = q.front();</span><br><span class="line">// 输出辅助队列中首位元素，并以此元素为下一次循环的判断准则</span><br><span class="line">        q.pop();</span><br><span class="line">        A[cnt++] = t;</span><br><span class="line">// 遍历上一个排序好的元素行的元素，判断此元素相邻的结点是否符合规则</span><br><span class="line">        for (auto to : edges[t])</span><br><span class="line">        &#123;</span><br><span class="line">            deg[to]--;</span><br><span class="line">            if (deg[to] == 0) // 出现了新的入度为0的点</span><br><span class="line">                q.push(to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return cnt == n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr />版权信息]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 排序 </tag>
            
            <tag> AOV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最短路径</title>
      <link href="/2021/12/22/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
      <url>/2021/12/22/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>对网来说，最短路径是指两顶点之间经过边上权值之和最少的路径，并且我们称路径上的第一个顶点是源点，最后一个是终点。</p><span id="more"></span><h1 id="迪杰斯特拉-Dijkstra-算法"><a href="#迪杰斯特拉-Dijkstra-算法" class="headerlink" title="迪杰斯特拉(Dijkstra)算法"></a>迪杰斯特拉(Dijkstra)算法</h1><p>参考博客：<br><a href="https://blog.csdn.net/wenqiang1208/article/details/76473984">https://blog.csdn.net/wenqiang1208/article/details/76473984</a></p><p>每次找到离源点最近的一个顶点，然后以该顶点为中心，然后得到源点到其他顶点的最短路径。<br>即一步步求出源点终点之间的顶点的最短路径</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Dijkstra 算法的基本思想是：将顶点集合 V 分成两个集合，一类是生长点的集合 S,包括源点和已经确定最短路径的顶点;另一类是非生长点的集合 V-S,包括所有尚未确定最短路径的顶点,并使用一个待定路径表,存储当前从源点v到每个非生长点v的最短路径。初始时,S只包含源点v,对vi∈V-S,待定路径表为从源点v到v1的有向边。然后在待定路径表中找到当前最短路径v…vk,将vk加入集合S中,对u∈V-S,将路径v…vkvi 与待定路径表中从源点v到vi;的最短路径相比较,取路径长度较小者为当前最短路径。重复上述过程，直到集合 V 中全部顶点加入到集合 S 中。<br>例：<br><a href="https://sm.ms/image/QCkDr4olYhTZUzu" target="_blank"><img src="https://s2.loli.net/2021/12/25/QCkDr4olYhTZUzu.jpg" style="width:50%"></a><br><a href="https://sm.ms/image/S8mTGXwvfHjtNLE" target="_blank"><img src="https://s2.loli.net/2021/12/25/S8mTGXwvfHjtNLE.jpg" style="width:80%"></a></p><h2 id="代码解读"><a href="#代码解读" class="headerlink" title="代码解读"></a>代码解读</h2><p>算法代码从87行开始</p><p>final数组是为了表示v0到某顶点vw是否求得了最短路径，如果有结果，final[w] = 1</p><p>最短路径下标 P<br>用于存储到各点最短路径的权值和 D</p><p>91-96 初始化数据<br>      (<em>D)[v] = G.arc[v0][v];/</em> 将与v0点有连线的顶点加上权值 */<br>      (<em>P)[v] = -1;                /</em> 初始化路径数组P为-1  */</p><p>101-123主循环每次循环求得v0与一个顶点的最小路径，<strong>所以v从1开始</strong></p><p>104-113 循环找到D中最小值，记录为min，并将此顶点计入最短路径中，并以此结点修数组D、P，新路径为min+需要走的路径长度</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">#include &quot;stdio.h&quot;    </span><br><span class="line">#include &quot;stdlib.h&quot;   </span><br><span class="line">#include &quot;io.h&quot;  </span><br><span class="line">#include &quot;math.h&quot;  </span><br><span class="line">#include &quot;time.h&quot;</span><br><span class="line"></span><br><span class="line">#define OK 1</span><br><span class="line">#define ERROR 0</span><br><span class="line">#define TRUE 1</span><br><span class="line">#define FALSE 0</span><br><span class="line"></span><br><span class="line">#define MAXEDGE 20</span><br><span class="line">#define MAXVEX 20</span><br><span class="line">#define GRAPH_INFINITY 65535</span><br><span class="line"></span><br><span class="line">typedef int Status;/* Status是函数的类型,其值是函数结果状态代码，如OK等 */ </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">int vexs[MAXVEX];</span><br><span class="line">int arc[MAXVEX][MAXVEX];</span><br><span class="line">int numVertexes, numEdges;</span><br><span class="line">&#125;MGraph;</span><br><span class="line"></span><br><span class="line">typedef int Patharc[MAXVEX];    /* 用于存储最短路径下标的数组 */</span><br><span class="line">typedef int ShortPathTable[MAXVEX];/* 用于存储到各点最短路径的权值和 */</span><br><span class="line"></span><br><span class="line">/* 构件图 */</span><br><span class="line">void CreateMGraph(MGraph *G)</span><br><span class="line">&#123;</span><br><span class="line">int i, j;</span><br><span class="line"></span><br><span class="line">/* printf(&quot;请输入边数和顶点数:&quot;); */</span><br><span class="line">G-&gt;numEdges=16;</span><br><span class="line">G-&gt;numVertexes=9;</span><br><span class="line"></span><br><span class="line">for (i = 0; i &lt; G-&gt;numVertexes; i++)/* 初始化图 */</span><br><span class="line">&#123;</span><br><span class="line">G-&gt;vexs[i]=i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (i = 0; i &lt; G-&gt;numVertexes; i++)/* 初始化图 */</span><br><span class="line">&#123;</span><br><span class="line">for ( j = 0; j &lt; G-&gt;numVertexes; j++)</span><br><span class="line">&#123;</span><br><span class="line">if (i==j)</span><br><span class="line">G-&gt;arc[i][j]=0;</span><br><span class="line">else</span><br><span class="line">G-&gt;arc[i][j] = G-&gt;arc[j][i] = GRAPH_INFINITY;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">G-&gt;arc[0][1]=1;</span><br><span class="line">G-&gt;arc[0][2]=5; </span><br><span class="line">G-&gt;arc[1][2]=3; </span><br><span class="line">G-&gt;arc[1][3]=7; </span><br><span class="line">G-&gt;arc[1][4]=5; </span><br><span class="line"></span><br><span class="line">G-&gt;arc[2][4]=1; </span><br><span class="line">G-&gt;arc[2][5]=7; </span><br><span class="line">G-&gt;arc[3][4]=2; </span><br><span class="line">G-&gt;arc[3][6]=3; </span><br><span class="line">G-&gt;arc[4][5]=3;</span><br><span class="line"></span><br><span class="line">G-&gt;arc[4][6]=6;</span><br><span class="line">G-&gt;arc[4][7]=9; </span><br><span class="line">G-&gt;arc[5][7]=5; </span><br><span class="line">G-&gt;arc[6][7]=2; </span><br><span class="line">G-&gt;arc[6][8]=7;</span><br><span class="line"></span><br><span class="line">G-&gt;arc[7][8]=4;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for(i = 0; i &lt; G-&gt;numVertexes; i++)</span><br><span class="line">&#123;</span><br><span class="line">for(j = i; j &lt; G-&gt;numVertexes; j++)</span><br><span class="line">&#123;</span><br><span class="line">G-&gt;arc[j][i] =G-&gt;arc[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*  Dijkstra算法，求有向网G的v0顶点到其余顶点v的最短路径P[v]及带权长度D[v] */    </span><br><span class="line">/*  P[v]的值为前驱顶点下标,D[v]表示v0到v的最短路径长度和 */  </span><br><span class="line">void ShortestPath_Dijkstra(MGraph G, int v0, Patharc *P, ShortPathTable *D)</span><br><span class="line">&#123;    </span><br><span class="line">int v,w,k,min;    </span><br><span class="line">int final[MAXVEX];/* final[w]=1表示求得顶点v0至vw的最短路径 */</span><br><span class="line">for(v=0; v&lt;G.numVertexes; v++)    /* 初始化数据 */</span><br><span class="line">&#123;        </span><br><span class="line">final[v] = 0;/* 全部顶点初始化为未知最短路径状态 */</span><br><span class="line">(*D)[v] = G.arc[v0][v];/* 将与v0点有连线的顶点加上权值 */</span><br><span class="line">(*P)[v] = -1;/* 初始化路径数组P为-1  */       </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(*D)[v0] = 0;  /* v0至v0路径为0 */  </span><br><span class="line">final[v0] = 1;    /* v0至v0不需要求路径 */        </span><br><span class="line">/* 开始主循环，每次求得v0到某个v顶点的最短路径 */   </span><br><span class="line">for(v=1; v&lt;G.numVertexes; v++)   </span><br><span class="line">&#123;</span><br><span class="line">min=GRAPH_INFINITY;    /* 当前所知离v0顶点的最近距离 */        </span><br><span class="line">for(w=0; w&lt;G.numVertexes; w++) /* 寻找离v0最近的顶点 */    </span><br><span class="line">&#123;            </span><br><span class="line">if(!final[w] &amp;&amp; (*D)[w]&lt;min)             </span><br><span class="line">&#123;                   </span><br><span class="line">k=w;                    </span><br><span class="line">min = (*D)[w];    /* w顶点离v0顶点更近 */            </span><br><span class="line">&#125;        </span><br><span class="line">&#125;        </span><br><span class="line">final[k] = 1;    /* 将目前找到的最近的顶点置为1 */</span><br><span class="line">for(w=0; w&lt;G.numVertexes; w++) /* 修正当前最短路径及距离 */</span><br><span class="line">&#123;</span><br><span class="line">/* 如果经过v顶点的路径比现在这条路径的长度短的话 */</span><br><span class="line">if(!final[w] &amp;&amp; (min+G.arc[k][w]&lt;(*D)[w]))   </span><br><span class="line">&#123; /*  说明找到了更短的路径，修改D[w]和P[w] */</span><br><span class="line">(*D)[w] = min + G.arc[k][w];  /* 修改当前路径长度 */               </span><br><span class="line">(*P)[w]=k;        </span><br><span class="line">&#125;       </span><br><span class="line">&#125;   </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;   </span><br><span class="line">int i,j,v0;</span><br><span class="line">MGraph G;    </span><br><span class="line">Patharc P;    </span><br><span class="line">ShortPathTable D; /* 求某点到其余各点的最短路径 */   </span><br><span class="line">v0=0;</span><br><span class="line"></span><br><span class="line">CreateMGraph(&amp;G);</span><br><span class="line"></span><br><span class="line">ShortestPath_Dijkstra(G, v0, &amp;P, &amp;D);  </span><br><span class="line"></span><br><span class="line">printf(&quot;最短路径倒序如下:\n&quot;);    </span><br><span class="line">for(i=1;i&lt;G.numVertexes;++i)   </span><br><span class="line">&#123;       </span><br><span class="line">printf(&quot;v%d - v%d : &quot;,v0,i);</span><br><span class="line">j=i;</span><br><span class="line">while(P[j]!=-1)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d &quot;,P[j]);</span><br><span class="line">j=P[j];</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;    </span><br><span class="line">printf(&quot;\n源点到各顶点的最短路径长度为:\n&quot;);  </span><br><span class="line">for(i=1;i&lt;G.numVertexes;++i)        </span><br><span class="line">printf(&quot;v%d - v%d : %d \n&quot;,G.vexs[0],G.vexs[i],D[i]);     </span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="弗洛伊德-Floyd-算法"><a href="#弗洛伊德-Floyd-算法" class="headerlink" title="弗洛伊德(Floyd)算法"></a>弗洛伊德(Floyd)算法</h1><p>参考博客:<br><a href="https://www.cnblogs.com/wangyuliang/p/9216365.html">https://www.cnblogs.com/wangyuliang/p/9216365.html</a></p><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>弗洛伊德（Floyd）算法过程：</p><p>１、用D[v][w]记录每一对顶点的最短距离。</p><p>２、依次扫描每一个点，并以其为基点再遍历所有每一对顶点D[][]的值，看看是否可用过该基点让这对顶点间的距离更小。</p><p>即公式<br>D(n+1)[v][w] = min{D(n)[v][w],D(n)[v][0]+D(n)[0][w]}</p><p><strong>Floyd所求的是所有顶点到所有顶点的最短路径。</strong></p><h2 id="代码解读-1"><a href="#代码解读-1" class="headerlink" title="代码解读"></a>代码解读</h2><p>9-16<br>初始化时数组D为邻接矩阵，数组P为P[i][j] = j</p><p>17-30<br>主循环，k=i时，程序判断以ki为中转点是否有更短的路径，如果有，则修改D[v][w]为新的路径值，并将P[v][w]改为P[v][k]</p><p>34-50<br>输出最小路径代码<br>算法运算完毕时，D[i][j] 表示vi到vj的最短路径权值和,P[i][j] 表示从vi到vj需要经过vP[i][j]</p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">typedef int Patharc[MAXVEX][MAXVEX];</span><br><span class="line">typedef int ShortPathTable[MAXVEX][MAXVEX];</span><br><span class="line"></span><br><span class="line">  /* Floyd算法，求网图G中各顶点v到其余顶点w的最短路径P[v][w]及带权长度D[v][w]。 */    </span><br><span class="line">void ShortestPath_Floyd(MGraph G, Patharc *P, ShortPathTable *D)</span><br><span class="line">&#123;    </span><br><span class="line">int v,w,k;    </span><br><span class="line">for(v=0; v&lt;G.numVertexes; ++v) /* 初始化D与P */  </span><br><span class="line">&#123;        </span><br><span class="line">for(w=0; w&lt;G.numVertexes; ++w)  </span><br><span class="line">&#123;</span><br><span class="line">(*D)[v][w]=G.arc[v][w];/* D[v][w]值即为对应点间的权值 */</span><br><span class="line">(*P)[v][w]=w;/* 初始化P */</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(k=0; k&lt;G.numVertexes; ++k)   </span><br><span class="line">&#123;</span><br><span class="line">for(v=0; v&lt;G.numVertexes; ++v)  </span><br><span class="line">&#123;        </span><br><span class="line">for(w=0; w&lt;G.numVertexes; ++w)    </span><br><span class="line">&#123;</span><br><span class="line">if ((*D)[v][w]&gt;(*D)[v][k]+(*D)[k][w])</span><br><span class="line">&#123;/* 如果经过下标为k顶点路径比原两点间路径更短 */</span><br><span class="line">(*D)[v][w]=(*D)[v][k]+(*D)[k][w];/* 将当前两点间权值设为更小的一个 */</span><br><span class="line">(*P)[v][w]=(*P)[v][k];/* 路径设置为经过下标为k的顶点 */</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  //输出代码</span><br><span class="line">printf(&quot;各顶点间最短路径如下:\n&quot;);    </span><br><span class="line">for(v=0; v&lt;G.numVertexes; ++v)   </span><br><span class="line">&#123;        </span><br><span class="line">for(w=v+1; w&lt;G.numVertexes; w++)  </span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;v%d-v%d weight: %d &quot;,v,w,D[v][w]);</span><br><span class="line">k=P[v][w];/* 获得第一个路径顶点下标 */</span><br><span class="line">printf(&quot; path: %d&quot;,v);/* 打印源点 */</span><br><span class="line">while(k!=w)/* 如果路径顶点下标不是终点 */</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot; -&gt; %d&quot;,k);/* 打印路径顶点 */</span><br><span class="line">k=P[k][w];/* 获得下一个路径顶点下标 */</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot; -&gt; %d\n&quot;,w);/* 打印终点 */</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr />版权信息]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> Dijkstra </tag>
            
            <tag> Floyd </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图的相关基础知识</title>
      <link href="/2021/12/22/%E5%9B%BE%E7%9A%84%E7%9B%B8%E5%85%B3/"/>
      <url>/2021/12/22/%E5%9B%BE%E7%9A%84%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<p><a href="https://sm.ms/image/8wFJZCRKifYUsz9" target="_blank"><img src="https://s2.loli.net/2021/12/24/8wFJZCRKifYUsz9.jpg" style="width:70%"></a></p><p><strong>前言</strong><br>整理一下图论相关的基础知识和代码<br>参考博客:<br><a href="https://blog.csdn.net/weixin_37853880/article/details/80320765">https://blog.csdn.net/weixin_37853880/article/details/80320765</a><br><a href="https://www.jianshu.com/p/bce71b2bdbc8">https://www.jianshu.com/p/bce71b2bdbc8</a></p><span id="more"></span><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p><a href="https://sm.ms/image/tuLMcfye9HkTaCx" target="_blank"><img src="https://s2.loli.net/2021/12/24/tuLMcfye9HkTaCx.jpg" style="width:50%"></a></p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>在计算机科学中，一个图就是一些顶点的集合，这些顶点通过一系列边结对（连接）。顶点用圆圈表示，边就是这些圆圈之间的连线。顶点之间通过边连接。</p><p>图有各种形状和大小。边可以有权重（weight），即每一条边会被分配一个正数或者负数值。考虑一个代表航线的图。各个城市就是顶点，航线就是边。那么边的权重可以是飞行时间，或者机票价格。</p><p>树是特殊的图</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ol><li>有向图、无向图</li></ol><p>如果边是有方向的则称为有向图，如果边没有方向则称为无向图</p><ol start="2"><li>简单图</li></ol><p>不含平行边与环的图</p><ol start="3"><li>完全图</li></ol><p><strong>任意两个顶点</strong>之间都存在一条边的简单图</p><p>无向完全图的边数为1/2<em>n</em>(n-1)</p><p>有向完全图的边数为n*(n-1)</p><ol start="4"><li>补图</li></ol><p>将图G补全成为完全图的G’</p><ol start="5"><li>连通图</li></ol><p>只有一个连通分支的图</p><p>强连通图:<br>有向图，任意一对结点相互互达</p><p>弱连通图:<br>有向图，略去方向所得无向图是连通图</p><ol start="6"><li>最大子图</li></ol><p>图所有结点用最少边相连的子图</p><p><a href="https://sm.ms/image/segQfnWRANqyvi4" target="_blank"><img src="https://s2.loli.net/2021/12/24/segQfnWRANqyvi4.jpg" style="width:50%"></a> </p><ol start="7"><li>路/回路</li></ol><p>若顶点vp和vq可以由若干条边连通，则称vp到vq存在一条路径</p><p>无权图的路径长就是路径上经过边数</p><p>带权图的路径长要乘以每条边的权</p><p>简单路径：除了起点和终点可以为同一个顶点外，其余顶点均不相同</p><p>起点和终点为同一个顶点的简单路径称为回路或环</p><ol start="8"><li>权</li></ol><p>与图的边相关的数</p><ol start="9"><li>度</li></ol><p>对于无向图，顶点v的度定义为和v相关联的边数</p><p>对于有向图，顶点v的度分为入度和出度</p><ol start="10"><li>点/边割集</li></ol><p>连通图G</p><p>V1 为G点/边割集</p><p>删除V1集合中所有 结点/边 ，使新的图G’不是连通图 且 删去V1子集所有 结点/边 G’仍为连通图(最大集合)</p><h2 id="矩阵表示"><a href="#矩阵表示" class="headerlink" title="矩阵表示"></a>矩阵表示</h2><p>完全关联矩阵/邻接矩阵/可达性矩阵<br><a href="https://sm.ms/image/POis6Sw3Ap5VBWI" target="_blank"><img src="https://s2.loli.net/2021/12/24/POis6Sw3Ap5VBWI.jpg" style="width:60%"></a> </p><h1 id="储存结构"><a href="#储存结构" class="headerlink" title="储存结构"></a>储存结构</h1><h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><p><a href="https://sm.ms/image/PeyuIZXrlOGpRaU" target="_blank"><img src="https://s2.loli.net/2021/12/24/PeyuIZXrlOGpRaU.jpg" style="width:50%"></a><br><a href="https://sm.ms/image/OB7hrixzskNUe6f" target="_blank"><img src="https://s2.loli.net/2021/12/24/OB7hrixzskNUe6f.jpg" style="width:50%"></a> </p><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">MGraph&lt;DataType&gt;::MGraph(DataType a[ ],int n, int e)&#123;</span><br><span class="line">    int i,j,k;</span><br><span class="line">    vertexNum = n;</span><br><span class="line">    edgeNum = e;</span><br><span class="line">    for(i=0;i&lt;vertexNum;i++)&#123;</span><br><span class="line">        vertex[i] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for(i=0;i&lt;vertexNum;i++)&#123;</span><br><span class="line">        for(j=0;j&lt;vertexNum;j++)&#123;</span><br><span class="line">            edge[i][j] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(k=0;k&lt;edgeNum;k++)&#123;</span><br><span class="line">        cin &gt;&gt; i &gt;&gt; j;</span><br><span class="line">        edge[i][j] = 1;</span><br><span class="line">        edge[j][i] = 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><p><a href="https://sm.ms/image/OyGYE7N8rDxtnF3" target="_blank"><img src="https://s2.loli.net/2021/12/24/OyGYE7N8rDxtnF3.jpg" style="width:50%"></a> </p><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ALGraph&lt;DataType&gt; :: ALGraph(DataType a[ ], int n, int e)&#123;</span><br><span class="line">    int i,j,k;</span><br><span class="line">    EdgeNode* s =nullptr;</span><br><span class="line">    vertexNum = n;</span><br><span class="line">    edgeNum = e;</span><br><span class="line">    for(i = 0;i&lt;vertexNum;i++)&#123;</span><br><span class="line">        adjlist[i].vertex = a[i];</span><br><span class="line">        adjlist[i].firstEdge = nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">    for(k = 0;k&lt;edgeNum;k++)&#123;</span><br><span class="line">        cin &gt;&gt; i &gt;&gt; j;</span><br><span class="line">        s = new EdgeNode;</span><br><span class="line">        s -&gt; next = adjlist[i].firstEdge;</span><br><span class="line">        adjlist[i].firstEdge = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h2><p>顶点表：           </p><p><a href="https://sm.ms/image/LzaYdCybNtjqrES" target="_blank"><img src="https://s2.loli.net/2021/12/24/LzaYdCybNtjqrES.jpg" style="width:50%"></a></p><p>firstin：入边表头指针，指向顶点入边表的第一个节点</p><p>firstout：出边表头指针，指向顶点出边表的第一个节点</p><p>边表：       </p><p><a href="https://sm.ms/image/PVqNWfJEkvwesSH" target="_blank"><img src="https://s2.loli.net/2021/12/24/PVqNWfJEkvwesSH.jpg" style="width:50%"></a> </p><p>tailvex是边起点在顶点表的下标，headvex边终点在顶点表的下标</p><p>headlink入边表指针，指向终点相同的下一条入边；taillink出边表指针，指向起点相同的下一条出边     </p><p><a href="https://sm.ms/image/AGIm63x5eN1vSXg" target="_blank"><img src="https://s2.loli.net/2021/12/24/AGIm63x5eN1vSXg.jpg" ></a>   </p><h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><h2 id="深度优先遍历DFS"><a href="#深度优先遍历DFS" class="headerlink" title="深度优先遍历DFS"></a>深度优先遍历DFS</h2><p>从图G中任选一顶点v作为初始出发点，首先访问出发点v，并将其标记为已访问过；然后依次搜索v的每个邻接点w，若w未曾访问过，则以w作为新的出发点，继续进行深度优先遍历，直到图中所有和v有路径相通的顶点都被访问到；若此时仍有顶点未被访问到（非连通图），则另选一个未访问过的顶点作为起点，重复上述过程，直到图中所有顶点都被访问到为止。</p><p><a href="https://sm.ms/image/cmJ5tTu2UqpICVA" target="_blank"><img src="https://s2.loli.net/2021/12/24/cmJ5tTu2UqpICVA.jpg" style="width:50%"></a> </p><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename DataType&gt; </span><br><span class="line">void MGraph&lt;DataType&gt;::DFTraverse_(int v)&#123;</span><br><span class="line">    cout &lt;&lt; vertex[v] ;</span><br><span class="line">    visited[v] = 1;</span><br><span class="line">    for(int j = 0;j&lt;vertexNum;j++)&#123;</span><br><span class="line">        if(edge[v][j] == 1 &amp;&amp; visited[j] == 0) &#123;</span><br><span class="line">            DFTraverse(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="广度优先遍历BFS"><a href="#广度优先遍历BFS" class="headerlink" title="广度优先遍历BFS"></a>广度优先遍历BFS</h2><p>广度优先搜索是一种按层次遍历的方法，基本思想是：从图G中任选一顶点Vi作为初始出发点，首先访问出发点Vi，接着依次访问Vi的所有未被访问过的邻接点Vi1，Vi2，…，Vit并均标记为已访问过，然后再按照Vi1，Vi2，…，Vit的次序，访问每一个顶点的所有未被访问过的邻接点并均标记为已访问过，依次类推，直到图中所有和Vi有路径相通的顶点都被访问到；若此时仍有顶点未被访问到（非连通图），则另选一个未访问过的顶点作为起点，重复上述过程，直到图中所有顶点都被访问到为止。</p><p><a href="https://sm.ms/image/pRf2EOKCJW8YtoH" target="_blank"><img src="https://s2.loli.net/2021/12/24/pRf2EOKCJW8YtoH.jpg" style="width:50%"></a> </p><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">template&lt;typename DataType&gt; </span><br><span class="line">void MGraph&lt;DataType&gt; :: BFTraverse(int v)&#123;</span><br><span class="line">    clear();</span><br><span class="line">    int w,j,Q[MaxSize];</span><br><span class="line">    int front = -1, rear = -1;</span><br><span class="line">    cout &lt;&lt; vertex[v] ;</span><br><span class="line">    visited[v] = 1;</span><br><span class="line">    Q[++rear] = v;</span><br><span class="line">    while(front != rear)&#123;</span><br><span class="line">        w = Q[++front];</span><br><span class="line">        for(j = 0;j&lt;vertexNum;j++)&#123;</span><br><span class="line">            if(edge[w][j]==1 &amp;&amp; visited[j] == 0)&#123;</span><br><span class="line">                cout &lt;&lt; vertex[j];</span><br><span class="line">                visited[j] = 1;</span><br><span class="line">                Q[++rear] = j;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="邻接矩阵-1"><a href="#邻接矩阵-1" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MaxSize = 10;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">template&lt;typename DataType&gt; </span><br><span class="line">class MGraph&#123;</span><br><span class="line">public:</span><br><span class="line">    MGraph(DataType a[ ],int n, int e);</span><br><span class="line">    ~MGraph()&#123;&#125;;</span><br><span class="line">    void DFTraverse(int v)&#123;</span><br><span class="line">        clear();</span><br><span class="line">        DFTraverse(v);</span><br><span class="line">    &#125;;//深度优点遍历</span><br><span class="line">    void DFTraverse_(int v);</span><br><span class="line">    void BFTraverse(int v);</span><br><span class="line">    void Prim(int v);</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    DataType vertex[MaxSize];</span><br><span class="line">    int edge[MaxSize][MaxSize];</span><br><span class="line">    int visited[MaxSize] = &#123;0&#125;;</span><br><span class="line">    int vertexNum,edgeNum;</span><br><span class="line">    void clear()&#123;</span><br><span class="line">        for(int i=0;i&lt;MaxSize;i++)&#123;</span><br><span class="line">            visited[i] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename DataType&gt; </span><br><span class="line">MGraph&lt;DataType&gt;::MGraph(DataType a[ ],int n, int e)&#123;</span><br><span class="line">    int i,j,k;</span><br><span class="line">    vertexNum = n;</span><br><span class="line">    edgeNum = e;</span><br><span class="line">    for(i=0;i&lt;vertexNum;i++)&#123;</span><br><span class="line">        vertex[i] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for(i=0;i&lt;vertexNum;i++)&#123;</span><br><span class="line">        for(j=0;j&lt;vertexNum;j++)&#123;</span><br><span class="line">            edge[i][j] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(k=0;k&lt;edgeNum;k++)&#123;</span><br><span class="line">        cin &gt;&gt; i &gt;&gt; j;</span><br><span class="line">        edge[i][j] = 1;</span><br><span class="line">        edge[j][i] = 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename DataType&gt; </span><br><span class="line">void MGraph&lt;DataType&gt;::DFTraverse_(int v)&#123;</span><br><span class="line">    cout &lt;&lt; vertex[v] ;</span><br><span class="line">    visited[v] = 1;</span><br><span class="line">    for(int j = 0;j&lt;vertexNum;j++)&#123;</span><br><span class="line">        if(edge[v][j] == 1 &amp;&amp; visited[j] == 0) &#123;</span><br><span class="line">            DFTraverse(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">template&lt;typename DataType&gt; </span><br><span class="line">void MGraph&lt;DataType&gt; :: BFTraverse(int v)&#123;</span><br><span class="line">    clear();</span><br><span class="line">    int w,j,Q[MaxSize];</span><br><span class="line">    int front = -1, rear = -1;</span><br><span class="line">    cout &lt;&lt; vertex[v] ;</span><br><span class="line">    visited[v] = 1;</span><br><span class="line">    Q[++rear] = v;</span><br><span class="line">    while(front != rear)&#123;</span><br><span class="line">        w = Q[++front];</span><br><span class="line">        for(j = 0;j&lt;vertexNum;j++)&#123;</span><br><span class="line">            if(edge[w][j]==1 &amp;&amp; visited[j] == 0)&#123;</span><br><span class="line">                cout &lt;&lt; vertex[j];</span><br><span class="line">                visited[j] = 1;</span><br><span class="line">                Q[++rear] = j;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="邻接表-1"><a href="#邻接表-1" class="headerlink" title="邻接表"></a>邻接表</h2><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MaxSize = 10;</span><br><span class="line">int visited[MaxSize] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">struct EdgeNode</span><br><span class="line">&#123;</span><br><span class="line">    int adjvex;</span><br><span class="line">    EdgeNode* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename DataType&gt; </span><br><span class="line">struct VertexNode</span><br><span class="line">&#123;</span><br><span class="line">    DataType vertex;</span><br><span class="line">    EdgeNode* firstEdge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename DataType&gt; </span><br><span class="line">class ALGraph&#123;</span><br><span class="line">public:</span><br><span class="line">    ALGraph(DataType a[ ], int n, int e);</span><br><span class="line">    ~ALGraph();</span><br><span class="line">    void DFTraverse(int v)&#123;</span><br><span class="line">        clear();</span><br><span class="line">        DFTraverse(v);</span><br><span class="line">    &#125;;//深度优点遍历</span><br><span class="line">    void DFTraverse_(int v);</span><br><span class="line">    void BFTraverse(int v);</span><br><span class="line">    void clear()&#123;</span><br><span class="line">        for(int i=0;i&lt;MaxSize;i++)&#123;</span><br><span class="line">            visited[i] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">private:</span><br><span class="line">    VertexNode&lt;DataType&gt; adjlist[MaxSize];</span><br><span class="line">    int vertexNum, edgeNum;</span><br><span class="line">    int MaxSize = 10;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename DataType&gt; </span><br><span class="line">ALGraph&lt;DataType&gt; :: ALGraph(DataType a[ ], int n, int e)&#123;</span><br><span class="line">    int i,j,k;</span><br><span class="line">    EdgeNode* s =nullptr;</span><br><span class="line">    vertexNum = n;</span><br><span class="line">    edgeNum = e;</span><br><span class="line">    for(i = 0;i&lt;vertexNum;i++)&#123;</span><br><span class="line">        adjlist[i].vertex = a[i];</span><br><span class="line">        adjlist[i].firstEdge = nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">    for(k = 0;k&lt;edgeNum;k++)&#123;</span><br><span class="line">        cin &gt;&gt; i &gt;&gt; j;</span><br><span class="line">        s = new EdgeNode;</span><br><span class="line">        s -&gt; next = adjlist[i].firstEdge;</span><br><span class="line">        adjlist[i].firstEdge = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;       </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">template&lt;typename DataType&gt; </span><br><span class="line">ALGraph&lt;DataType&gt;::~ALGraph()&#123;</span><br><span class="line">    EdgeNode*p = nullptr;</span><br><span class="line">    EdgeNode*q = nullptr;</span><br><span class="line">    for(int i = 0; i&lt;vertexNum; i++)&#123;</span><br><span class="line">        p = q = adjlist[i].firstEdge;</span><br><span class="line">        while(p != nullptr)&#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            delete q;</span><br><span class="line">            q = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">template&lt;typename DataType&gt; </span><br><span class="line">void ALGraph&lt;DataType&gt; :: DFTraverse_(int v)&#123;</span><br><span class="line">    int j;</span><br><span class="line">    EdgeNode *p = nullptr;</span><br><span class="line">    cout &lt;&lt; adjlist[v].vertex;</span><br><span class="line">    visited[v] = 1;</span><br><span class="line">    p = adjlist[v].firstEdge;</span><br><span class="line">    while(p != nullptr)&#123;</span><br><span class="line">        j = p -&gt; adjvex;</span><br><span class="line">        if(visited[j]==0)&#123;</span><br><span class="line">            DFTraverse_(j);</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">template&lt;typename DataType&gt;</span><br><span class="line">void ALGraph&lt;DataType&gt;::BFTraverse(int v)&#123;</span><br><span class="line">    int w,j,Q[MaxSize];</span><br><span class="line">    int front = -1,rear = -1;</span><br><span class="line">    clear();</span><br><span class="line">    EdgeNode *p = nullptr;</span><br><span class="line">    cout &lt;&lt; adjlist[v].vertex;</span><br><span class="line">    visited = 1;</span><br><span class="line">    Q[++rear] = v;</span><br><span class="line">    while(front != rear)&#123;</span><br><span class="line">        w = Q[++front];</span><br><span class="line">        p = adjlist[w].firstEdge;</span><br><span class="line">        while(p != nullptr)&#123;</span><br><span class="line">            j = p-&gt;adjvex;</span><br><span class="line">            if(visited[j] == 0 )&#123;</span><br><span class="line">                cout &lt;&lt; adjlist[j].vertex;</span><br><span class="line">                visited[j] = 1;</span><br><span class="line">                Q[++rear] = j;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><p>最小生成树：在连通网的所有生成树中，所有边的代价和最小的生成树，称为最小生成树。</p><a href="/2021/12/24/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/" title="最小生成树问题">最小生成树问题</a><a href="/2021/12/24/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/" title="最小生成树">最小生成树</a><h1 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h1><p>用于计算一个节点到其他所有节点的最短路径。主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。</p><a href="/2021/12/22/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/" title="最短路径">最短路径</a><a href="/2021/12/22/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/" title="最短路径">最短路径</a><h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><p>拓扑排序是对DAG（有向无环图）上的节点进行排序，使得对于每一条有向边 v -&gt; j ， v 都在 j 之前出现。简单地说，是在不破坏节点先后顺序的前提下，把DAG拉成一条链。如果以游戏中的科技树（虽然名字带树，其实常常不是树而只是DAG）举例，拓扑排序就是找到一种可能的点科技树的顺序。</p><a href="/2021/12/22/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/" title="拓扑排序">拓扑排序</a><a href="/2021/12/22/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/" title="拓扑排序">拓扑排序</a><h1 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h1><hr />版权信息]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> DFS </tag>
            
            <tag> 图论 </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>平衡二叉树详解</title>
      <link href="/2021/12/15/AVL%E6%A0%91/"/>
      <url>/2021/12/15/AVL%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p><strong>前言</strong></p><p>总结一下平衡二叉树 AVL树的一些用法和代码</p><p>引用文章：<br><a href="https://www.cnblogs.com/wasi-991017/p/13824039.html">https://www.cnblogs.com/wasi-991017/p/13824039.html</a></p><p><a href="https://sm.ms/image/Ag1Owom6QxB5c2s" target="_blank"><img src="https://s2.loli.net/2021/12/15/Ag1Owom6QxB5c2s.jpg" alt="RL.jpg"></a></p><span id="more"></span><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>平衡二叉树可以理解为是二叉排序树的优化版本，在二叉排序树的应用过程中会出现子树间深度差距大而导致查找性能下降的情况，所以就有了平衡二叉树这种优化方法。</p><p>可以得出平衡二叉树的定义</p><ol><li><p>基于二叉排序树</p></li><li><p>左右子树的深度之差的绝对值不超过1</p></li><li><p>左右子树都是平衡二叉树</p></li></ol><p>定义平衡因子为本根节点的 左子树深度 - 右子树深度</p><h1 id="关键部分-————-调整方法"><a href="#关键部分-————-调整方法" class="headerlink" title="关键部分 ———— 调整方法"></a>关键部分 ———— 调整方法</h1><h2 id="LL型"><a href="#LL型" class="headerlink" title="LL型"></a>LL型</h2><p>左子树平衡因子 大于 右子树 且 左子树的左子树平衡因子 大于 左子树的右子树平衡因子 ——两个子树也可用<br><img src="https://s2.loli.net/2021/12/15/QKY3xkvubPqNjgJ.jpg" alt="" style="width:100%" /> </p><h2 id="RR型"><a href="#RR型" class="headerlink" title="RR型"></a>RR型</h2><p>右子树平衡因子 大于 左子树 且 右子树的右子树平衡因子 大于 右子树的左子树——两个子树也可用<br><a href="https://sm.ms/image/lZ15qnmcpzQ7uM4" target="_blank"><img src="https://s2.loli.net/2021/12/15/lZ15qnmcpzQ7uM4.jpg" alt="RR.jpg"></a> </p><h2 id="LR型"><a href="#LR型" class="headerlink" title="LR型"></a>LR型</h2><p>左子树平衡因子 大于 右子树 且 左子树的右子树平衡因子 大于 左子树的左子树<br><a href="https://sm.ms/image/nOhJW9jx7ARqTlu" target="_blank"><img src="https://s2.loli.net/2021/12/15/nOhJW9jx7ARqTlu.jpg" alt="LR.jpg"></a></p><h2 id="RL型"><a href="#RL型" class="headerlink" title="RL型"></a>RL型</h2><p>右子树平衡因子 大于 左子树 且 右子树的左子树平衡因子 大于 右子树的右子树<br><a href="https://sm.ms/image/Ag1Owom6QxB5c2s" target="_blank"><img src="https://s2.loli.net/2021/12/15/Ag1Owom6QxB5c2s.jpg" alt="RL.jpg"></a></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>转自：<a href="https://www.cnblogs.com/wasi-991017/p/13824039.html">https://www.cnblogs.com/wasi-991017/p/13824039.html</a></p><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p>124 - 142 排序二叉树的插入操作 插入后做平衡操作者<br>209 - 230 平衡操作 判断情况并调用不同情况函数 LL RR LR RL<br>237 - 271 不同情况对应函数<br>注意旋转操作和插入操作都返回一个根节点(学习！！！)<br>eg：<br>subRoot-&gt;rChild = Insert(subRoot-&gt;rChild, k);</p><p>BalanceFactor() 返回某结点的平衡因子</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br></pre></td><td class="code"><pre><span class="line">/*******平衡二叉树（AVL）***********/</span><br><span class="line">#pragma once</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">///平衡二叉树结点结构</span><br><span class="line">struct AVLNode &#123;</span><br><span class="line">int data;</span><br><span class="line">AVLNode *lChild, *rChild;</span><br><span class="line">AVLNode(int a) &#123;</span><br><span class="line">data = a;</span><br><span class="line">lChild = NULL;</span><br><span class="line">rChild = NULL;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class AVLTree &#123;</span><br><span class="line">public:</span><br><span class="line">AVLTree() &#123;</span><br><span class="line">root = NULL;</span><br><span class="line">&#125;</span><br><span class="line">~AVLTree() &#123;</span><br><span class="line">destroy(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">///从命令行接受数据创建AVL树。使用其他方式创建原理一致</span><br><span class="line">void Create() &#123;</span><br><span class="line">cout &lt;&lt; &quot;input numbers to create AVL: &quot; &lt;&lt; endl;</span><br><span class="line">int temp;</span><br><span class="line">while (cin &gt;&gt; temp) &#123;</span><br><span class="line">root=Insert(root, temp);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; &quot;AVL创建完成！&quot; &lt;&lt; endl;</span><br><span class="line">Print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">///返回某结点为根节点的子树高度</span><br><span class="line">int Height(AVLNode *p) &#123;</span><br><span class="line">if (p == NULL)</span><br><span class="line">return 0;</span><br><span class="line">int i = Height(p-&gt;lChild);</span><br><span class="line">int j = Height(p-&gt;rChild);</span><br><span class="line">return i &gt; j ? i + 1 : j + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">///输出该排序树</span><br><span class="line">void Print() &#123;</span><br><span class="line">cout &lt;&lt; &quot;中序遍历为： &quot;;</span><br><span class="line">MidOrder(root);</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;先序遍历为： &quot;;</span><br><span class="line">PreOrder(root);</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">///先序遍历输出</span><br><span class="line">void PreOrder(AVLNode *p) &#123;</span><br><span class="line">if (p != NULL) &#123;</span><br><span class="line">cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;;</span><br><span class="line">PreOrder(p-&gt;lChild);</span><br><span class="line">PreOrder(p-&gt;rChild);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">///中序遍历输出</span><br><span class="line">void MidOrder(AVLNode *p) &#123;</span><br><span class="line">if (p != NULL) &#123;</span><br><span class="line">MidOrder(p-&gt;lChild);</span><br><span class="line">cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;;</span><br><span class="line">MidOrder(p-&gt;rChild);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">///简化版插入函数</span><br><span class="line">void Insert(const int x) &#123;</span><br><span class="line">root = Insert(root, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">///简化版删除函数</span><br><span class="line">void Remove(int x) &#123;</span><br><span class="line">root=Remove(root, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">///返回值为x的结点指针</span><br><span class="line">AVLNode* Search(int x) &#123;</span><br><span class="line">AVLNode *p = root;</span><br><span class="line">while (p) &#123;</span><br><span class="line">if (p-&gt;data == x)</span><br><span class="line">break;</span><br><span class="line">else if (p-&gt;data &lt; x)</span><br><span class="line">p = p-&gt;rChild;</span><br><span class="line">else</span><br><span class="line">p = p-&gt;lChild;</span><br><span class="line">&#125;</span><br><span class="line">return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">///返回子树最大值结点的指针</span><br><span class="line">AVLNode* TreeMax(AVLNode* subTree) &#123;</span><br><span class="line">if (!subTree)</span><br><span class="line">return NULL;</span><br><span class="line">while (subTree-&gt;rChild) &#123;</span><br><span class="line">subTree = subTree-&gt;rChild;</span><br><span class="line">&#125;</span><br><span class="line">return subTree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">///返回子树最小值结点的指针</span><br><span class="line">AVLNode* TreeMin(AVLNode* subTree) &#123;</span><br><span class="line">if (!subTree)</span><br><span class="line">return NULL;</span><br><span class="line">while (subTree-&gt;lChild) &#123;</span><br><span class="line">subTree = subTree-&gt;lChild;</span><br><span class="line">&#125;</span><br><span class="line">return subTree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">///根节点</span><br><span class="line">AVLNode *root;</span><br><span class="line"></span><br><span class="line">///插入（视为在某结点为根节点的子树上进行插入）</span><br><span class="line">//对子树上进行插入操作后都需要平衡操作，可能会改变该子树的根节点，</span><br><span class="line">//因此设置返回值记录完成操作后子树的根结点指针)</span><br><span class="line">AVLNode* Insert(AVLNode* subRoot, const int k) &#123;</span><br><span class="line">if (subRoot == NULL) &#123;</span><br><span class="line">subRoot = new AVLNode(k);</span><br><span class="line">&#125;</span><br><span class="line">else if (k &gt; subRoot-&gt;data) //需要在右子树上插入新的结点</span><br><span class="line">&#123;</span><br><span class="line">subRoot-&gt;rChild = Insert(subRoot-&gt;rChild, k);</span><br><span class="line">//在右子树上插入结点后可能导致不平衡，故需要对右子树进行平衡操作</span><br><span class="line">//而平衡操作可能会导致子树根结点产生变化，故需更新当前的子树根节点</span><br><span class="line">subRoot = Balancee(subRoot);</span><br><span class="line">&#125;</span><br><span class="line">else if (k &lt; subRoot-&gt;data) &#123; //需要在左子树上插入新的结点</span><br><span class="line">subRoot-&gt;lChild = Insert(subRoot-&gt;lChild, k);</span><br><span class="line">//和上面同理</span><br><span class="line">subRoot = Balancee(subRoot);</span><br><span class="line">&#125;</span><br><span class="line">//将新的子树根结点指针返回供原父节点更新孩子指针</span><br><span class="line">return subRoot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">///删除结点（视为在该结点为根节点的树上进行删除操作）</span><br><span class="line">AVLNode* Remove(AVLNode* subRoot, int x) &#123;</span><br><span class="line">if (!Search(x)) &#123;//不存在x的结点则直接返回</span><br><span class="line">cout &lt;&lt; &quot;不存在值为&quot; &lt;&lt; x &lt;&lt; &quot;的结点！&quot; &lt;&lt; endl;</span><br><span class="line">return root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (!root)  //root为空指针都直接返回NULL</span><br><span class="line">return root;</span><br><span class="line"></span><br><span class="line">if (subRoot-&gt;data == x)  //情况1：要删除的就是该树的根节点</span><br><span class="line">&#123;</span><br><span class="line">if (subRoot-&gt;lChild &amp;&amp; subRoot-&gt;rChild)//情况1.1：该树的左右子树都存在</span><br><span class="line">&#123;</span><br><span class="line">if (BalanceFactor(subRoot)&gt;0) </span><br><span class="line">&#123;</span><br><span class="line">//左子树高于右子树，则根节点的值替换为其直接前驱的值，然后转化为删除</span><br><span class="line">//其直接前驱(其位于左子树上，也就意味着去降低左子树高度)</span><br><span class="line">AVLNode *tmp = TreeMax(subRoot-&gt;lChild); //直接前驱就是左子树的最大值</span><br><span class="line">subRoot-&gt;data = tmp-&gt;data;</span><br><span class="line">//递归调用Remove()删除subRoot的左子树上的前驱结点后，Remove()返回可能为</span><br><span class="line">//新的subRoot的左子树根节点供subRoot更新左孩子结点((Remove()会调用Balance()函数平衡其操作的树))。</span><br><span class="line">subRoot-&gt;lChild = Remove(subRoot-&gt;lChild, tmp-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">//右子树高于左子树，则根节点的值替换为其直接后继的值，</span><br><span class="line">//然后转化为删除其直接后继(其位于右子树上，也就意味着去降低右子树高度)</span><br><span class="line">AVLNode *tmp = TreeMin(subRoot-&gt;rChild);</span><br><span class="line">subRoot-&gt;data = tmp-&gt;data;</span><br><span class="line">subRoot-&gt;rChild = Remove(subRoot-&gt;rChild, tmp-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else //情况1.2：只存在一颗子树或者都不存在</span><br><span class="line">&#123;</span><br><span class="line">//直接将根节点更新为其孩子结点(都不存在则为NULL)</span><br><span class="line">AVLNode * tmp = subRoot;</span><br><span class="line">subRoot = (subRoot-&gt;lChild) ? (subRoot-&gt;lChild) : (subRoot-&gt;rChild);</span><br><span class="line">delete tmp;</span><br><span class="line">tmp = NULL;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else if (x &lt; subRoot-&gt;data) &#123; //情况2：要删除的节点位于左子树上</span><br><span class="line">//递归调用,在subRoot的左子树上进行删除操作，并返回新的左子树根节点供subRoot更新左孩子指针</span><br><span class="line">subRoot-&gt;lChild = Remove(subRoot-&gt;lChild, x);</span><br><span class="line">//在subRoot的左子树上完成删除操作后,可能导致该树不平衡,故需要进行平衡操作并更新当前根节点</span><br><span class="line">if (BalanceFactor(subRoot) &lt; -1)</span><br><span class="line">subRoot = Balancee(root);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;//情况3：要删除的节点位于右子树上</span><br><span class="line">//递归调用,在subRoot的右子树上进行删除操作，并返回新的右子树根节点供subRoot更新右孩子指针</span><br><span class="line">subRoot-&gt;rChild = Remove(subRoot-&gt;rChild, x);</span><br><span class="line">//在subRoot的右子树上完成删除操作后,可能导致该树不平衡,故需要进行平衡操作并更新当前根节点</span><br><span class="line">if (BalanceFactor(subRoot) &gt;1)</span><br><span class="line">subRoot = Balancee(subRoot);</span><br><span class="line">&#125;</span><br><span class="line">//返回该树当前根节点供其父节点更新孩子节点</span><br><span class="line">return subRoot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">///返回某个节点的平衡因子</span><br><span class="line">int BalanceFactor(AVLNode *p) &#123;</span><br><span class="line">return Height(p-&gt;lChild) - Height(p-&gt;rChild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">///对某个结点进行平衡操作（根据平衡因子调用四种不同的旋转操作）</span><br><span class="line">AVLNode* Balancee(AVLNode* subRoot) &#123;</span><br><span class="line">int bf = BalanceFactor(subRoot);</span><br><span class="line">if (bf &gt; 1) //左子树更高</span><br><span class="line">&#123;</span><br><span class="line">if (BalanceFactor(subRoot-&gt;lChild) &gt; 0)</span><br><span class="line">//左孩子结点平衡因子&gt;0说明新节点多在了左子树上，因此调用LL_Rotation</span><br><span class="line">subRoot = LL_Rotation(subRoot);</span><br><span class="line">else</span><br><span class="line">//左孩子结点平衡因子&lt;0说明新节点多在了右子树上，因此调用LR_Rotation</span><br><span class="line">subRoot = LR_Rotation(subRoot);</span><br><span class="line">&#125;</span><br><span class="line">else if (bf &lt; -1) //右子树更高</span><br><span class="line">&#123;</span><br><span class="line">if (BalanceFactor(subRoot-&gt;rChild) &gt; 0)</span><br><span class="line">        //右孩子结点平衡因子&gt;0说明新节点多在了左子树上，因此调用RL_Rotation</span><br><span class="line">subRoot = RL_Rotation(subRoot);</span><br><span class="line">else</span><br><span class="line">    //右孩子结点平衡因子&lt;0说明新节点多在了右子树上上，因此调用RR_Rotation</span><br><span class="line">subRoot = RR_Rotation(subRoot);</span><br><span class="line">&#125;</span><br><span class="line">//对分支结点进行平衡操作后可能会更新该分支节点，故将新的分支结点返回供原父结点更新孩子指针</span><br><span class="line">return subRoot;</span><br><span class="line">&#125;</span><br><span class="line">/*****************************</span><br><span class="line">          四种旋转操作</span><br><span class="line">******************************/</span><br><span class="line">/// LL平衡旋转(右单旋转)</span><br><span class="line">//在左孩子(L)的左子树(L)上插入导致不平衡，需要向右旋转一次实现平衡</span><br><span class="line">AVLNode* LL_Rotation(AVLNode *subRoot) &#123;</span><br><span class="line">AVLNode* temp = subRoot-&gt;lChild;</span><br><span class="line">subRoot-&gt;lChild = temp-&gt;rChild;</span><br><span class="line">temp-&gt;rChild = subRoot;</span><br><span class="line">//完成旋转操作之后，该处分支结点(原为subRoot)发生了变化，</span><br><span class="line">//因此要返回新的分支节点指针供其父节点更新孩子指针</span><br><span class="line">return temp;</span><br><span class="line">&#125;</span><br><span class="line">/// RR平衡旋转(左单旋转)</span><br><span class="line">//在右孩子(R)的右子树(R)上插入导致不平衡，需要向左旋转一次实现平衡</span><br><span class="line">AVLNode* RR_Rotation(AVLNode *subRoot) &#123;</span><br><span class="line">AVLNode* temp = subRoot-&gt;rChild;</span><br><span class="line">subRoot-&gt;rChild = temp-&gt;lChild;</span><br><span class="line">temp-&gt;lChild = subRoot;</span><br><span class="line">//完成旋转操作之后，该处分支结点(原为subRoot)发生了变化，</span><br><span class="line">//因此要返回新的分支节点指针供其父节点更新孩子指针</span><br><span class="line">return temp;</span><br><span class="line">&#125;</span><br><span class="line">/***********下面两种情况可看作是对根节点和子节点进行上两种旋转操作的组合*****************/</span><br><span class="line">/// RL平衡旋转(先右后左双旋转)</span><br><span class="line">//在右孩子(R)的左子树(L)上插入导致不平衡，需要先对分支结点的右孩子进行一次右旋(LL_Rotation),</span><br><span class="line">//再对分支结点进行一次左旋(RR_Rotation)</span><br><span class="line">AVLNode* RL_Rotation(AVLNode *subRoot) &#123;</span><br><span class="line">//对subRoot右孩子结点LL旋转后，更新subRoot右结点指针</span><br><span class="line">subRoot-&gt;rChild=LL_Rotation(subRoot-&gt;rChild);  </span><br><span class="line">return RR_Rotation(subRoot);//返回新的分支结点供原分支节点的父节点更新孩子指针</span><br><span class="line">&#125;</span><br><span class="line">/// LR平衡旋转(先左后右双旋转)</span><br><span class="line">//在左孩子(L)的右子树(R)上插入导致不平衡,需要先对分支结点的左孩子进行一次左旋(RR_Rotation),</span><br><span class="line">//再对分支结点进行一次右旋(LL_Rotation)</span><br><span class="line">AVLNode* LR_Rotation(AVLNode *subRoot) &#123;</span><br><span class="line">//对subRoot左结点RR旋转后，更新subRoot左结点指针</span><br><span class="line">subRoot-&gt; lChild = RR_Rotation(subRoot-&gt;lChild);  </span><br><span class="line">return LL_Rotation(subRoot);//返回新的分支结点供原分支节点的父节点更新孩子指针</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">///销毁该树</span><br><span class="line">void destroy(AVLNode* p) &#123;</span><br><span class="line">if (p) &#123;</span><br><span class="line">destroy(p-&gt;lChild);</span><br><span class="line">destroy(p-&gt;rChild);</span><br><span class="line">delete p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr />版权信息]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AVL </tag>
            
            <tag> 查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树相关知识集合</title>
      <link href="/2021/12/13/Bitree/"/>
      <url>/2021/12/13/Bitree/</url>
      
        <content type="html"><![CDATA[<p><a href="https://sm.ms/image/xrORW4XFJqaLNTo" target="_blank"><img src="https://s2.loli.net/2021/12/15/xrORW4XFJqaLNTo.png" ></a></p><p><strong>前言</strong></p><p>整理一下二叉树的知识点</p><p><em>不定期更新  ︿(￣︶￣)︿</em></p><span id="more"></span><h1 id="二叉树基础"><a href="#二叉树基础" class="headerlink" title="二叉树基础"></a>二叉树基础</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>一棵二叉树是结点的一个有限集合，该集合或者为空，或者是由一个根结点加上两棵分别称为左子树和右子树的、互不相交的二叉树组成。二又树的特点是每个结点最多有两个子女，分别称为该结点的左子女和右子女。在二又树中不存在度大于2的结点，并且二又树的子树有左、右之分，其子树的次序不能颠倒。二又树是分支数最大不超过2的有根有序树。它可能有5种不同的形态。</p><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ol><li>在二叉树的第i层最多有2^(i-1)个结点</li><li>深度为k的二叉树最有2^k - 1 个结点 </li><li>叶子结点数等于度为2的结点数加1</li></ol><h1 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>一棵深度为k的有n个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为i（1≤i≤n）的结点与满二叉树中编号为i的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树。</p><h2 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h2><ol><li><p> 具有n个结点的完全二叉树的深度log2(n+1)</p></li><li><p>如果对一棵有n个结点的完全二叉树的结点按层序编号, 则对任一结点i (1≤i≤n) 有:<br> 如果i=1, 则结点i是二叉树的根, 无双亲;<br> 如果i&gt;1, 则其双亲parent (i) 是结点[i/2].<br> 如果2i&gt;n, 则结点i无左孩子, 否则其左孩子lchild (i) 是结点2i;<br> 如果2i+1&gt;n, 则结点i无右孩子, 否则其右孩子rchild (i) 是结点2i+1.</p></li><li><p>具有n个结点的完全二叉树的深度为log2(n)+1</p></li></ol><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="向量实现"><a href="#向量实现" class="headerlink" title="向量实现"></a>向量实现</h2><p><a href="https://blog.csdn.net/weixin_42100963/article/details/103639782">https://blog.csdn.net/weixin_42100963/article/details/103639782</a></p><p>以层序遍历在数组种存储</p><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">void CMyTreeArr&lt;T&gt;::prePrint(int index)</span><br><span class="line">&#123;</span><br><span class="line">    // 限制范围</span><br><span class="line">    if(index &lt; vecBuff.size() &amp;&amp; index &gt;= 0)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; vecBuff[index] &lt;&lt; &quot; &quot;;// 根</span><br><span class="line">        // 数组下标的方式   递归调用  找到计算规律文章底部将 画图演示 </span><br><span class="line">        prePrint(2 * index + 1);// 左子树 == 根结点 * 2 + 1</span><br><span class="line">        prePrint(2 * index + 2);// 右子树 == 根结点 * 2 + 2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">inline void CMyTreeArr&lt;T&gt;::inPrint(int index)</span><br><span class="line">&#123;</span><br><span class="line">    if(index &lt; vecBuff.size() &amp;&amp; index &gt;= 0)</span><br><span class="line">    &#123;</span><br><span class="line">        inPrint(2 * index + 1);</span><br><span class="line">        cout &lt;&lt; vecBuff[index] &lt;&lt; &quot; &quot;;// 根</span><br><span class="line">        inPrint(2 * index + 2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">inline void CMyTreeArr&lt;T&gt;::posPrint(int index)</span><br><span class="line">&#123;</span><br><span class="line">    if(index &lt; vecBuff.size() &amp;&amp; index &gt;= 0)</span><br><span class="line">    &#123;</span><br><span class="line">        inPrint(2 * index + 1);</span><br><span class="line">        inPrint(2 * index + 2);</span><br><span class="line">        cout &lt;&lt; vecBuff[index] &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">inline void CMyTreeArr&lt;T&gt;::levlPrint()</span><br><span class="line">&#123;</span><br><span class="line">    for(auto i : vecBuff)// 直接输入 vecBuff中的元素</span><br><span class="line">    &#123; </span><br><span class="line">        cout &lt;&lt; i &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="链表实现"><a href="#链表实现" class="headerlink" title="链表实现"></a>链表实现</h2><p>前中后序非递归<br><a href="https://blog.csdn.net/weixin_45599288/article/details/122345321">https://blog.csdn.net/weixin_45599288/article/details/122345321</a></p><figure class="highlight plaintext"><figcaption><span>[二叉树] [lang:C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template&lt;typename DataType&gt; </span><br><span class="line">struct BiNode</span><br><span class="line">&#123;</span><br><span class="line">    DataType data;</span><br><span class="line">    BiNode&lt;DataType&gt;*lchild, *rchild;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename DataType&gt; </span><br><span class="line">class BiTree&#123;</span><br><span class="line">public:</span><br><span class="line">    BiTree()&#123;root = Creat();&#125;</span><br><span class="line">    BiTree(BiTree&lt;DataType&gt;* b)&#123;</span><br><span class="line">        root = Copy(b-&gt;root);</span><br><span class="line">    &#125;</span><br><span class="line">    ~BiTree()&#123;Release(root);&#125;</span><br><span class="line">    void PreOrder()&#123;PreOrder(root);&#125;</span><br><span class="line">    void InOrder()&#123;InOrder(root);&#125;</span><br><span class="line">    void PostOrder()&#123;PostOrder(root);&#125;</span><br><span class="line">    int Leaf_count()&#123;</span><br><span class="line">        int ans =  Leaf_count(root);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    int Node_count()&#123;</span><br><span class="line">        int ans = Node_count(root);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    int Deep()&#123;</span><br><span class="line">        int ans = Deep(root);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void Judge_sort()&#123;</span><br><span class="line">        if(Judge_sort(root))&#123;</span><br><span class="line">            cout &lt;&lt; &quot;ture&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            cout &lt;&lt; &quot;fales&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void Find_bro(DataType x)&#123;</span><br><span class="line">        find_bro(root,x);</span><br><span class="line">    &#125;</span><br><span class="line">    bool Empty()&#123;</span><br><span class="line">        if(root == nullptr)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void insert(DataType insert_data, DataType step_data)&#123;</span><br><span class="line">        insert(root,insert_data, step_data);</span><br><span class="line">    &#125;</span><br><span class="line">    void LevelOrder();//层序遍历</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    int flag = 0;</span><br><span class="line">    BiNode&lt;DataType&gt;* root;</span><br><span class="line">    BiNode&lt;DataType&gt;* Creat();</span><br><span class="line">    BiNode&lt;DataType&gt;* Copy(BiNode&lt;DataType&gt;* node);</span><br><span class="line">    int Leaf_count(BiNode&lt;DataType&gt;* node);//计算叶子结点数</span><br><span class="line">    int Node_count(BiNode&lt;DataType&gt;* node);//计算结点数</span><br><span class="line">    int Deep(BiNode&lt;DataType&gt;* node);//计算深度</span><br><span class="line">    void Release(BiNode&lt;DataType&gt;* node);//析构函数</span><br><span class="line">    void PreOrder(BiNode&lt;DataType&gt;* node);//前序遍历</span><br><span class="line">    void InOrder(BiNode&lt;DataType&gt;* node);//中序遍历</span><br><span class="line">    void PostOrder(BiNode&lt;DataType&gt;* node);//后序遍历</span><br><span class="line">    void find_bro(BiNode&lt;DataType&gt;* node,DataType x);</span><br><span class="line">    bool Judge_sort(BiNode&lt;DataType&gt;* node);</span><br><span class="line">    </span><br><span class="line">    void inorDer();//非递归遍历</span><br><span class="line">    void insert(BiNode&lt;DataType&gt;* root, DataType insert_data, DataType step_data);//在指定值之后插入</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename DataType&gt; </span><br><span class="line">BiNode&lt;DataType&gt;* BiTree&lt;DataType&gt;::Creat()&#123;</span><br><span class="line">    BiNode&lt;DataType&gt;* node;</span><br><span class="line">    char cin_data;</span><br><span class="line">    cin &gt;&gt; cin_data;</span><br><span class="line">    //cin_data = my_data[i++];</span><br><span class="line">    if(cin_data==&#x27;#&#x27;)&#123;</span><br><span class="line">        node = nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        node = new BiNode&lt;DataType&gt;;</span><br><span class="line">        node-&gt;data = cin_data;</span><br><span class="line">        node-&gt;lchild = Creat();//左递归建造子树</span><br><span class="line">        node-&gt;rchild = Creat();//右递归建造子树</span><br><span class="line">    &#125;</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename DataType&gt; </span><br><span class="line">BiNode&lt;DataType&gt;* BiTree&lt;DataType&gt;::Copy(BiNode&lt;DataType&gt;* node)&#123;</span><br><span class="line">    if(node == nullptr)&#123;</span><br><span class="line">        return nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">    BiNode&lt;DataType&gt;* copy_node ;</span><br><span class="line">    copy_node-&gt;data = node-&gt;data;</span><br><span class="line">    copy_node-&gt;lchild = Copy(node-&gt;lchild);</span><br><span class="line">    copy_node-&gt;rchild = Copy(node-&gt;rchild);</span><br><span class="line">    return copy_node;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename DataType&gt; </span><br><span class="line">int BiTree&lt;DataType&gt;::Leaf_count(BiNode&lt;DataType&gt;* node)&#123;</span><br><span class="line">    int count ;</span><br><span class="line">    if(node == nullptr)&#123;</span><br><span class="line">        count = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(node-&gt;lchild == nullptr &amp;&amp; node-&gt;rchild == nullptr)&#123;</span><br><span class="line">        count = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        count = Leaf_count(node-&gt;lchild) + Leaf_count(node-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename DataType&gt; </span><br><span class="line">int BiTree&lt;DataType&gt;::Node_count(BiNode&lt;DataType&gt;* node)&#123;</span><br><span class="line">    int count ;</span><br><span class="line">    if(node == nullptr) count = 0;</span><br><span class="line">    else&#123;</span><br><span class="line">        count = Node_count(node-&gt;lchild) + Node_count(node-&gt;rchild) +1;</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename DataType&gt;</span><br><span class="line">int BiTree&lt;DataType&gt;::Deep(BiNode&lt;DataType&gt;* node)&#123;</span><br><span class="line">    int deep=0;</span><br><span class="line">    if(node)</span><br><span class="line">    &#123;</span><br><span class="line">        int leftdeep=Deep(node-&gt;lchild);</span><br><span class="line">        int rightdeep=Deep(node-&gt;rchild);</span><br><span class="line">        deep = leftdeep&gt;=rightdeep?leftdeep+1:rightdeep+1;</span><br><span class="line">    &#125;</span><br><span class="line">    return deep;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename DataType&gt; </span><br><span class="line">void BiTree&lt;DataType&gt;::Release(BiNode&lt;DataType&gt;* node)&#123;</span><br><span class="line">    if(node == nullptr) return;</span><br><span class="line">    else&#123;</span><br><span class="line">        Release(node-&gt;lchild);</span><br><span class="line">        Release(node-&gt;rchild);</span><br><span class="line">        delete node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename DataType&gt; </span><br><span class="line">void BiTree&lt;DataType&gt;::PreOrder(BiNode&lt;DataType&gt;* node)&#123;</span><br><span class="line">    if(node == nullptr) return;</span><br><span class="line">    else&#123;</span><br><span class="line">        cout &lt;&lt; node-&gt;data&lt;&lt;&#x27; &#x27;;</span><br><span class="line">        PreOrder(node-&gt;lchild);</span><br><span class="line">        PreOrder(node-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename DataType&gt; </span><br><span class="line">void BiTree&lt;DataType&gt;::InOrder(BiNode&lt;DataType&gt;* node)&#123;</span><br><span class="line">    if(node == nullptr) return;</span><br><span class="line">    else&#123;</span><br><span class="line">        </span><br><span class="line">        InOrder(node-&gt;lchild);</span><br><span class="line">        cout &lt;&lt; node-&gt;data&lt;&lt;&#x27; &#x27;;</span><br><span class="line">        InOrder(node-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename DataType&gt; </span><br><span class="line">void BiTree&lt;DataType&gt;::PostOrder(BiNode&lt;DataType&gt;* node)&#123;</span><br><span class="line">    if(node == nullptr) return;</span><br><span class="line">    else&#123;</span><br><span class="line">        </span><br><span class="line">        PostOrder(node-&gt;lchild);</span><br><span class="line">        PostOrder(node-&gt;rchild);</span><br><span class="line">        cout &lt;&lt; node-&gt;data&lt;&lt;&#x27; &#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename DataType&gt; </span><br><span class="line">bool BiTree&lt;DataType&gt;::Judge_sort(BiNode&lt;DataType&gt;* node)&#123;</span><br><span class="line">     if(!node || (!(node-&gt;lchild)&amp;&amp;!(node-&gt;rchild)))             </span><br><span class="line">        return true;</span><br><span class="line">    else if((node-&gt;lchild)&amp;&amp;!(node-&gt;rchild))&#123;  </span><br><span class="line">        if(node-&gt;lchild-&gt;data&gt;node-&gt;data)</span><br><span class="line">            return false;</span><br><span class="line">        else</span><br><span class="line">            return Judge_sort(node-&gt;lchild);</span><br><span class="line">    &#125;</span><br><span class="line">    else if((node-&gt;rchild)&amp;&amp;!(node-&gt;lchild))&#123;  </span><br><span class="line">        if(node-&gt;rchild-&gt;data&lt;node-&gt;data)</span><br><span class="line">            return false;</span><br><span class="line">        else</span><br><span class="line">            return Judge_sort(node-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;                           </span><br><span class="line">        if((node-&gt;lchild-&gt;data &gt; node-&gt;data) || (node-&gt;rchild-&gt;data &lt; node-&gt;data))</span><br><span class="line">            return false;</span><br><span class="line">        else</span><br><span class="line">            return (Judge_sort(node-&gt;lchild) &amp;&amp; Judge_sort(node-&gt;rchild));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename DataType&gt; </span><br><span class="line">void BiTree&lt;DataType&gt;::find_bro(BiNode&lt;DataType&gt;* node,DataType x)&#123;</span><br><span class="line">    if(node == nullptr) return;</span><br><span class="line">    else&#123;</span><br><span class="line">        if(node-&gt;lchild!=nullptr&amp;&amp;node-&gt;rchild!=nullptr)&#123;</span><br><span class="line">            if(node-&gt;lchild-&gt;data==x)&#123;</span><br><span class="line">                BiNode&lt;DataType&gt;* r = node-&gt;rchild;</span><br><span class="line">                cout &lt;&lt; r-&gt;data &lt;&lt; &quot;---&quot;&lt;&lt;r &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(node-&gt;rchild-&gt;data==x)&#123;</span><br><span class="line">               BiNode&lt;DataType&gt;* l = node-&gt;lchild;</span><br><span class="line">                cout &lt;&lt; l-&gt;data &lt;&lt; &quot;---&quot;&lt;&lt;l &lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        find_bro(node-&gt;lchild,x);</span><br><span class="line">        find_bro(node-&gt;rchild,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename DataType&gt;</span><br><span class="line">void BiTree&lt;DataType&gt;::LevelOrder()&#123;</span><br><span class="line">BiNode&lt;DataType&gt;*Q[100],*q=nullptr;</span><br><span class="line">int front = -1,rear = -1;</span><br><span class="line">if(root == nullptr)return;</span><br><span class="line">Q[++rear] = root;</span><br><span class="line">while(front!=rear)&#123;</span><br><span class="line">q = Q[++front];</span><br><span class="line">cout&lt;&lt;q-&gt;data&lt;&lt;&quot; &quot;;</span><br><span class="line">if(q-&gt;lchild != nullptr) Q[++rear] = q-&gt;lchild;</span><br><span class="line">if(q-&gt;rchild != nullptr) Q[++rear] = q-&gt;rchild;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename DataType&gt;</span><br><span class="line">void BiTree&lt;DataType&gt;::inorDer()&#123;</span><br><span class="line">if(root != nullptr)&#123;</span><br><span class="line">stack&lt;BiNode&lt;DataType&gt;*&gt; s;</span><br><span class="line">BiNode&lt;DataType&gt;*p = root;</span><br><span class="line">while(!s.empty() || p !=nullptr)&#123;</span><br><span class="line">while( p!= nullptr)&#123;</span><br><span class="line">s.push(p);</span><br><span class="line">p = p-&gt;lchild;</span><br><span class="line">&#125;</span><br><span class="line">if(!s.Empty())&#123;</span><br><span class="line">p = s.pop();</span><br><span class="line">cout &lt;&lt; p-&gt;data;</span><br><span class="line">p = p-&gt;rchild;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename DataType&gt;</span><br><span class="line">void BiTree&lt;DataType&gt;::insert(BiNode&lt;DataType&gt;* node, DataType insert_data, DataType step_data)&#123;</span><br><span class="line">        if(node == nullptr) return;</span><br><span class="line">    else&#123;</span><br><span class="line">        if(node-&gt;data == step_data)&#123;</span><br><span class="line">            BiNode&lt;DataType&gt;* node1;</span><br><span class="line">            BiNode&lt;DataType&gt;* node2;</span><br><span class="line">            //cout &lt;&lt; 233;</span><br><span class="line">            node1 = node-&gt;lchild;</span><br><span class="line">            </span><br><span class="line">            node2-&gt;data = insert_data;</span><br><span class="line">            node2-&gt;lchild = node1;</span><br><span class="line">            node2-&gt;rchild = nullptr;</span><br><span class="line">            node-&gt;lchild = node2;</span><br><span class="line">            </span><br><span class="line">           </span><br><span class="line">            //return;</span><br><span class="line">        &#125;</span><br><span class="line">        //cout &lt;&lt; node-&gt;data&lt;&lt;&#x27; &#x27;;</span><br><span class="line">        insert(node-&gt;lchild,insert_data,step_data);</span><br><span class="line">        insert(node-&gt;rchild,insert_data,step_data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="森林-二叉树互换"><a href="#森林-二叉树互换" class="headerlink" title="森林/二叉树互换"></a>森林/二叉树互换</h1><h2 id="树-gt-二叉树"><a href="#树-gt-二叉树" class="headerlink" title="树 -&gt;二叉树"></a>树 -&gt;二叉树</h2><ol><li>加线<br>在所有兄弟间加连线</li><li>去线<br>对树中每个结点，保留它与第一个孩子结点的连线</li><li>层次调整<br><a href="https://sm.ms/image/zSFrsZubHTy3gk6" target="_blank"><img src="https://s2.loli.net/2021/12/15/zSFrsZubHTy3gk6.jpg" ></a></li></ol><h2 id="二叉树-gt-树"><a href="#二叉树-gt-树" class="headerlink" title="二叉树 -&gt;树"></a>二叉树 -&gt;树</h2><ol><li>加线<br>若某结点左孩子存在，将次左孩子的n个右孩子结点等作为此结点的孩子连线</li><li>去线<br>删除原二叉树中所有结点与其右孩子的连线</li><li>调整层次<br><a href="https://sm.ms/image/XxcBefKZyNmoE81" target="_blank"><img src="https://s2.loli.net/2021/12/15/XxcBefKZyNmoE81.jpg" ></a></li></ol><h2 id="森林-gt-二叉树"><a href="#森林-gt-二叉树" class="headerlink" title="森林 -&gt; 二叉树"></a>森林 -&gt; 二叉树</h2><ol><li><p>将每个树转化为二叉树  </p></li><li><p>第一棵二叉树不动，从第二棵开始，依次把后一棵二叉树的根节点作为前一棵二叉树根节点的右孩子，连接<br><a href="https://sm.ms/image/RdUKizQjAZrnMph" target="_blank"><img src="https://s2.loli.net/2021/12/15/RdUKizQjAZrnMph.jpg" ></a></p></li></ol><h2 id="二叉树-gt-森林"><a href="#二叉树-gt-森林" class="headerlink" title="二叉树 -&gt; 森林"></a>二叉树 -&gt; 森林</h2><ol><li><p>从根节点开始若右孩子存在，则将其与右孩子的连线删除。 </p></li><li><p>对每一个分离后的二叉树，重复步骤1</p></li><li><p>再将分离后的二叉树转为树<br><a href="https://sm.ms/image/zqXHDlR62ZY5xiV" target="_blank"><img src="https://s2.loli.net/2021/12/15/zqXHDlR62ZY5xiV.jpg" ></a></p></li></ol><h1 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h1><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><p>一棵空树，或者是具有下列性质的二叉树：</p><ol><li>若左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>左、右子树也分别为二叉排序树；</li><li>没有键值相等的结点。</li></ol><img src="https://bkimg.cdn.bcebos.com/pic/94cad1c8a786c9179df9bed6c93d70cf3ac75763?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U4MA==,g_7,xp_5,yp_5/format,f_auto" alt="" style="width:100%" />  <h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h3 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h3><ol><li>若根结点的关键字值等于查找的关键字，成功。</li><li>否则，若小于根结点的关键字值，递归查左子树。</li><li>若大于根结点的关键字值，递归查右子树。</li><li>若子树为空，查找不成功。</li></ol><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>每个结点的C(i)为该结点的层次数。最坏情况下，当先后插入的关键字有序时，构成的二叉排序树蜕变为单支树，树的深度为其平均查找长度(n+1)/2(和顺序查找相同），最好的情况是二叉排序树的形态和折半查找的判定树相同，其平均查找长度和log 2 (n)成正比。<br>也就是说，最好情况下的算法时间复杂度为O(1)，最坏情况下的算法时间复杂度为O(n)。</p><h1 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h1><h2 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h2><p>平衡二叉查找树：简称平衡二叉树。由前苏联的数学家 Adelse-Velskil 和 Landis 在 1962 年提出的高度平衡的二叉树，根据科学家的英文名也称为 AVL 树。它具有如下几个性质：</p><ol><li>可以是空树。</li><li>假如不是空树，任何一个结点的左子树与右子树都是平衡二叉树，并且高度之差的绝对值不超过 1。</li></ol><h2 id="平衡二叉树调整"><a href="#平衡二叉树调整" class="headerlink" title="平衡二叉树调整"></a>平衡二叉树调整</h2><p>引用：<br><a href="https://www.cnblogs.com/zhangbaochong/p/5164994.html">https://www.cnblogs.com/zhangbaochong/p/5164994.html</a></p><ol><li>单旋转<img src="https://images2015.cnblogs.com/blog/805461/201601/805461-20160127220751410-639565779.jpg" alt="" style="width:100%" /> k2结点不满足平衡性，它的左子树k1比右子树z深两层，k1子树中更深的是k1的左子树x，因此属于左左情况。</li></ol><p>为了恢复平衡，我们把x上移一层，并把z下移一层，但此时实际已经超出了AVL树的性质要求。为此，重新安排结点以形成一颗等价的树。为使树恢复平衡，我们把k2变成这棵树的根节点，因为k2大于k1，把k2置于k1的右子树上，而原本在k1右子树的Y大于k1，小于k2，就把Y置于k2的左子树上，这样既满足了二叉查找树的性质，又满足了平衡二叉树的性质。</p><ol start="2"><li>双旋转<img src="https://images2015.cnblogs.com/blog/805461/201601/805461-20160127221858707-881408395.jpg" alt="" style="width:100%" /> 对于上图情况，为使树恢复平衡，我们需要进行两步，第一步，把k1作为根，进行一次右右旋转，旋转之后就变成了左左情况，所以第二步再进行一次左左旋转，最后得到了一棵以k2为根的平衡二叉树。</li></ol><h1 id="最大二叉树"><a href="#最大二叉树" class="headerlink" title="最大二叉树"></a>最大二叉树</h1><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>给定一个不含重复元素的整数数组 nums 。一个以此数组直接递归构建的 最大二叉树 定义如下：</p><ol><li>二叉树的根是数组 nums 中的最大元素。</li><li>左子树是通过数组中 最大值左边部分 递归构造出的最大二叉树。</li><li>右子树是通过数组中 最大值右边部分 递归构造出的最大二叉树。</li></ol><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/maximum-binary-tree">https://leetcode-cn.com/problems/maximum-binary-tree</a></p><img src="https://img-blog.csdnimg.cn/20210612003134409.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80ODI3NjI5OA==,size_16,color_FFFFFF,t_70>" alt="" style="width:100%" /> <h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight plaintext"><figcaption><span>[最大二叉树] [lang:C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void max_BiTree(int first,int max_index,int last)&#123;</span><br><span class="line">    int max_l = first,max_r = last-1;</span><br><span class="line">    if(first == last)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=first;i&lt;max_index;i++)&#123;</span><br><span class="line">        if(arr1[i]&gt;arr1[max_l])&#123;</span><br><span class="line">            max_l = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int j=max_index+1;j&lt;last;j++)&#123;</span><br><span class="line">        if(arr1[j]&gt;arr1[max_r])&#123;</span><br><span class="line">            max_r = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; arr1[max_index]&lt;&lt;&#x27; &#x27;;</span><br><span class="line">    max_BiTree(first,max_l,max_index);</span><br><span class="line">    max_BiTree(max_index+1,max_r,last);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h1><h2 id="定义与原理"><a href="#定义与原理" class="headerlink" title="定义与原理"></a>定义与原理</h2><p>给定N个权值作为N个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。</p><p>参考博客：<br><a href="http://c.biancheng.net/view/3398.html">http://c.biancheng.net/view/3398.html</a><br><a href="https://blog.csdn.net/Mr_GYF/article/details/121707714?utm_source=app&amp;app_version=4.20.0">https://blog.csdn.net/Mr_GYF/article/details/121707714?utm_source=app&amp;app_version=4.20.0</a></p><h2 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h2><h1 id=""><a href="#" class="headerlink" title=""></a></h1><hr />版权信息]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些胡思乱想</title>
      <link href="/2021/12/06/thinking1/"/>
      <url>/2021/12/06/thinking1/</url>
      
        <content type="html"><![CDATA[<img src="https://cdn.pixabay.com/photo/2016/05/06/01/22/couple-1375125_960_720.jpg" alt="" style="width:100%" />  <p><strong>前言</strong></p><p><strong>属于是不知道最近想了些什么一一列举出来记录一下吧</strong></p><p><strong>深夜emo警告！！！</strong></p><p><strong>一切的一切仅为个人观点，瞎想的，别认真</strong></p><span id="more"></span><h1 id="网上乱七八糟杂谈"><a href="#网上乱七八糟杂谈" class="headerlink" title="网上乱七八糟杂谈"></a>网上乱七八糟杂谈</h1><h2 id="2021-12-5"><a href="#2021-12-5" class="headerlink" title="2021.12.5"></a>2021.12.5</h2><p>感觉近几年有关于“女拳”的事情是越演越烈了啊，最开始也就是当看个热闹，不想深入，但现在出什么事情大家好像都在莫名其妙的往女权这条路上引啊。。。但还是觉得有些事情和女性有但没有到关于女性社会地位的地步，在我看来，小红楼事件关乎的是更深的道德层面的恶劣，这种事情发生的本质难道不是这种不应存在经济链条的问题吗。这已经不是关于女性社会地位的问题了，这是上升到国家法律法治的重大案件，在这个案例中，无辜的女性成为的是被摆布的棋子，这种迫害女性的想法是自古以来人类留存的难以改变的观点，我很反感大家还称现在的社会为男权社会，但我承认现在还是女性弱势的时代，这种情况不止是因为我们个人的意愿所导致的。我们不得不承认大部分情况下在社会取得令人铭记的成就时男性的功劳远远超过女性，这种人类社会天生存有的仰慕高能力的想法导致大家会忘记女性在社会中的重要性，我不知道怎么样改变这种情况，但我觉得社会已经在尽可能的改变了。我们不能因为某些道德恶劣的人的行经就上升到全社会。此处引用空间流传很广的说说中一句话<br><em>不论你是哪个阶层的女性，这是一个男性可以指认任何女性为妓女的时代！这是一个男性可以强迫女性然后指认她为妓女的时代！这是一个受害女性不敢站出来的时代！</em><br>这种言论在我看来和不理智的引战言论并无二样，我不知道这种情况越演越烈会造成什么，但我相信的是这种情况会让社会中的矛盾更加突出，使两性的问题更加得不到解决。还是希望大家可以理智对待事情，只能说现在这个社会不可能成为我们想象中的完美世界，总会有形形色色的人一次次干令人愤怒的事情，刷新自己的世界观，对于这种人，强烈批判，审视自我，不要因为垃圾的恶臭而腐败自己的心智才为最重要。</p><h2 id="2021-12-7"><a href="#2021-12-7" class="headerlink" title="2021.12.7"></a>2021.12.7</h2><p>今天突然发现身边的人好像很少有谈恋爱的了，无论是生活压力的剧增还是“女拳”盛行的结果，我能感觉到现在的年轻一代在渐渐远离真正的爱情，抛开爱情过后的生育等问题不谈，现在的年轻人很少有心思去认真开启一段感情了，这可能也是我自己坚持异地这么久的原因之一吧。未来，两性间那种只为上床的快餐感情会不会越来越多呢？我们这一代本就大部分都是独生子女，比起其他年代的人同龄间亲密的关系本就少，缺爱的我们可能只会越来越难受孤僻吧。</p><img src="https://cdn.pixabay.com/photo/2021/09/25/12/52/boho-art-6654957_960_720.jpg" alt="" style="width:50%" />  <h2 id="2021-12-20"><a href="#2021-12-20" class="headerlink" title="2021.12.20"></a>2021.12.20</h2><p>发现今年一年娱乐圈爆出来的瓜也太多了了吧，这种频率真的让人怀疑真的是纸包不住火了吗，还是有资本另有企图？<br>第一点显然是最有可能的，比起之前娱乐圈恶臭的新闻没能出现在大众的视野中很大一部分是大家的信息传播没有那么广泛，而且和现在社会中女性敢于向大家发出自己的处境有关。这是头顶头的好事，希望社会中受欺压的人们都可以将那黑暗的一面曝光出来，让我们醒悟，现在的社会问题还是很多，作为一个成年人，我们不能像小朋友一样成天幻想生活在一个完美的社会中，有些问题可能不是我们一个人所能更改的，但是要明白那些污染社会的小人的阴险，更不能成为他们。当然也和这乱成一锅粥的中国娱乐圈本身多年以来的不良风气有关，老话说的真的对，人怕出名猪怕壮，当一个人有了名气之后会不免想要更高的权力和物欲，这点也体现在贪污的官员身上。所以，我不追求多大的名气，我俗，有钱能养活自己，让自己快快活活活着不就挺好？</p><p>当然还有网上的一些评价让我更深层次的认识这些娱乐圈事件。仔细想来也蛮有道理，每次这种娱乐圈爆出的新闻总是能出现在一些高地位企业出现事故的情况之时。这不免让人想到会不会是这些企业为了转移大众视线呢？ 对于现在的大资本企业，我只能说我更相信他们能做出来这样的事情。但是身处于这种资本垄断的社会中，有钱有资本真的可以为所欲为，你又能怎么样呢？ 你不去追随资本，你哪来的生活？ 以前我还对国企嗤之以鼻，现在想想还是太年轻了啊，那有什么自由创造的工作环境，想要有资本，就得趟这潭浑水，一边是官场的尔虞我诈，一边是资本家的敲骨吸髓，现在想要生活，你没得选，可能怎么样才能出淤泥而不染，会成为我以后更想要思考的事情吧。</p><h2 id="未完待续。。。。。。"><a href="#未完待续。。。。。。" class="headerlink" title="未完待续。。。。。。"></a>未完待续。。。。。。</h2><h1 id="记校赛"><a href="#记校赛" class="headerlink" title="记校赛"></a>记校赛</h1><p>前前后后忙了一个多月，在经历一次延期之后，校赛终于是办完了。。。<br>这次算是自己第一次以负责人的身份举办这么大型的活动，真的得到了很多的锻炼。</p><p>无论是第一次处理发票，第一次叫救护车，第一次经历手机没电陌生老乡送来充电宝，第一次进行裁判员培训……<br>还是在经历各种突发情况之后保安大叔的帮助，裁判同行的协助。这些都让我体会到了一个活动举办的不易。<br>当然这次比赛还有很多没做好的地方，但是能听到大家对这次比赛的认可内心是真的很开心啊。<br>忙碌就这样告一段落叭，要好好准备考试了哦！！</p><h1 id="虎年的第一次夜晚小笔记"><a href="#虎年的第一次夜晚小笔记" class="headerlink" title="虎年的第一次夜晚小笔记"></a>虎年的第一次夜晚小笔记</h1><ol><li><p>关于我<br>一个假期以来从身边的各种人了解到了很多很多，不管是大家遇到的困难还是关于我们未来的方向，可能这个假期是我有史以来思考最多的一个假期。<br>对我来说，这个假期最直接的感受就是明白了之前自己的幼稚，明白了自己是真的很幸福的，自己的家人对自己有多重要。开始学会成为年夜饭的主厨，学会做各种各样长辈擅长的菜，看着渐渐苍老的奶奶和姥姥我在用自己的方式留住她们，留住她们的味道，我不会去回忆曾经爸妈的种种，我只需要知道他们真的是最关心我的那些人，这就足够了。</p></li><li><p>关于以后的生活<br>廖哥说的对我很有启发，考研，可能真的是我必须要去考虑的事情了，跨考也可能成为我的一条路线，学科交叉真的是一个很好的方向，就如同学长所说，硬通货，是我在未来两年需要考虑的事情，怎么样才能让自己的工具箱变得强于其他人，能不能搭建起自己想要的方向的大炮，是我下个学期需要好好注意到。可能在我现在看来我们专业行业的硬通货就是代码能力，项目能力，但是长久的去看这些，我真的不需要其他的了吗？</p></li></ol><h1 id="对于我们平凡人而言，生命中许多细微小事并没有什么特别缘故地就在心深处留下印记，天长地久便成为弥足珍贵的回忆"><a href="#对于我们平凡人而言，生命中许多细微小事并没有什么特别缘故地就在心深处留下印记，天长地久便成为弥足珍贵的回忆" class="headerlink" title="对于我们平凡人而言，生命中许多细微小事并没有什么特别缘故地就在心深处留下印记，天长地久便成为弥足珍贵的回忆"></a>对于我们平凡人而言，生命中许多细微小事并没有什么特别缘故地就在心深处留下印记，天长地久便成为弥足珍贵的回忆</h1><h1 id="蜕变-2022-2-14"><a href="#蜕变-2022-2-14" class="headerlink" title="蜕变 2022.2.14"></a>蜕变 2022.2.14</h1><p>有时候不经意的陪伴真的可以改变一个人的一生<br>看着你从最开始的掩面而泣，怀疑自己，否定自己，觉得自己不应得到现在得到的<br>到最后能拍着自己的胸脯说自己背后有很多很多的人的力量，自己现在拥有的是自己换来的，这种蜕变真的让我感觉好棒啊，甚至有点羡慕。<br>很开心能够成为改变你的一位朋友，也很开心能够成为给予你力量的人，每当我们仰望星空，关心你的人都会在天上看着你，默默给予你他们的关心和爱。<br>一起加油吧，为了在我们背后的人，我们会让他们更骄傲。<br>感谢这个假期，让我学到了这么多</p><h1 id="2022-6-11"><a href="#2022-6-11" class="headerlink" title="2022.6.11"></a>2022.6.11</h1><p>已经很久没有写过什么东西了，好像这么长时间的居家生活真的没有给我带来什么改变和思考，只是觉得自己对这个社会越来越明白，越来越失望。我不否认防疫工作者们的幸苦努力，我对他们抱有极高的敬意，我也不否认为社会治安贡献力量的人，他们都值得我去敬佩。但是我做不到成为他们，可以说我是很自私，我只想要过好我自己，照顾好身边的人，当疫情逐渐变成了资本掌控的吸金工具，当一个个无辜的生命因为法治的漏洞而消失，这个社会已经不值得我去改变了，我也没有那个能力去改变这些。我只能做到让我自己，让我身边的人过上我们想要的生活，剩下的我无能为力。</p><p>对于现在大家都在讨论的女性安全感这个问题上，我能做到的就是站在我认为值得我去守护的人身边，也就仅此而已。在这个社会，你远比你想象的要弱小的多。</p><h1 id="2022-6-26"><a href="#2022-6-26" class="headerlink" title="2022.6.26"></a>2022.6.26</h1><p>距离分开，已经过去两个月了，好像生活还是像之前那样简单平淡，只是现在是自己一个人待在空空的新家在写这些罢了。我不知道分开是好是坏，我更不知道还应不应该追回，我找到的继续下去的理由可能就是还能存在那么一个女生在我心里吧，我忘不掉她，看着身边的人一个个都在寻找着自己的另一半，在渴望着恋爱，我却不知道我自己真正想要的是什么，是有人陪伴？还是有人喜欢？ 在很多人眼里我好像还是不错的样子吧，可能是自己在逃避的原因吧，还是没能够去认识新的人，有的人在为过于繁多的异性消息苦恼，而我却还在等待着那几个人的回复。好像又回到了一个人的日子，看着游戏库里不少本地多人游戏，那时的自己幻想着可以和喜欢的女孩窝在小屋里打游戏，可以给喜欢的她做饭，可以一起过过小日子，到最后好像没有一个能够实现的，一切都是自己的幻想罢了。希望，这个假期可以带给我一些难忘的回忆吧，我真的太需要让我开心起来的事情来鼓舞我继续走下去。</p><h1 id="2022-7-7"><a href="#2022-7-7" class="headerlink" title="2022.7.7"></a>2022.7.7</h1><p>没想到期待的假期会变成现在这个样子，只能带着打了石膏的腿在家一个人待着，期待很久的自驾也不了了之了。可能这就是世界的残酷吧，有的人因为找到了心仪的女生开心不已，有的人因为父母的疾病痛苦不堪。有的人因为晚回家被爸妈罚款，有的人已经开始要自负担起自己的学费了，相比下来，可能我还算是幸运吧，至少现在家里没有给我带来什么负担，身边也有能倾诉的人，有关系很好的女生。<br>在你知道自己还不错的时候最害怕的可能是会失去这些吧，你会害怕家里人出现什么事情，会害怕身边的人离你而去，会害怕对你很重要的人像之前那样离开你，杳无音讯。能做到就是珍惜现在吧，谁能知道随着时间的推移自己会变成什么样子呢？</p><p>好像，现在又变的喜欢哭鼻子了吧</p><h1 id="2022-7-31"><a href="#2022-7-31" class="headerlink" title="2022.7.31"></a>2022.7.31</h1><p>疫情，伴随着我的大学已经过去了两年了，这个七月它又回来了，两周的封闭让我好好的感受了一下一个人的生活，自己照顾自己，自己给自己做饭，一个人生活。可能这种生活会持续整个暑假吧，期待中的暑假，不可能就要这样结束了吧。仅存的慰藉是还有能一起打游戏的好兄弟们，有可以天天聊天解闷的女孩，这个假期的很多承诺都还没有实现，等到解封那天，一定要一个一个的实现，因为，未能兑现的承诺已经很多了。<br>最近又开始听周董的歌了，不止是他的新专辑，其实真正觉得好听的歌也不是新专辑的歌，他老了，我也长大了。从只是喜欢他的歌的韵律到现在听懂了他的歌词，还是很开心有这样一个能一直追随的偶像吧。<br>关于那个已经不再联系的人，元酱可能说的是对的，不可能不会心动的，但是也只是心动那一下不是吗，何必在已经不再关心自己的人身上浪费心思呢？如果有可能，我更愿意去找寻那个可以天天陪我嘴贫的人吧。</p><h1 id="2022-9-11"><a href="#2022-9-11" class="headerlink" title="2022.9.11"></a>2022.9.11</h1><p>没有想到结局会变成现在这个样子，我好像又一次失去了自己的那份心动，一切的一切，就只是因为那次冲动吧。我做不到原谅她，感觉到最后又是自己在受伤，真的好累，可能这个时代会逼得我变成自己不喜欢的那个样子吧。</p><p>还是先做好自己吧，尽早调整过来，生活嘛，还是要继续下去的。</p><hr />版权信息]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 想法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>五种排序</title>
      <link href="/2021/12/01/%E6%8E%92%E5%BA%8F/"/>
      <url>/2021/12/01/%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<img src="https://" alt="" style="width:100%" />  <p><strong>前言</strong></p><p><em>关于顺序储存结构——数组结构中实现的五种常用排序算法</em></p><pre><code>void InsertSort();//插入排序void SelectSort();//选择排序void QuickSort(int first,int last);//快排void HeapSort();//堆排序void MergeSort(int first,int last);//归并排序</code></pre><span id="more"></span><!-- toc --><h1 id="1-代码"><a href="#1-代码" class="headerlink" title="1.代码"></a><strong>1.代码</strong></h1><figure class="highlight plaintext"><figcaption><span>[排序] [lang:C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line">class Sort&#123;</span><br><span class="line">public:</span><br><span class="line">Sort(int arr[],int len)&#123;</span><br><span class="line">data = new int[len];</span><br><span class="line">for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">data[i] = arr[i];</span><br><span class="line">&#125;</span><br><span class="line">length = len;</span><br><span class="line">&#125;;</span><br><span class="line">void Print()&#123;</span><br><span class="line"></span><br><span class="line">// for(int i=0;i&lt;length;i++)&#123;</span><br><span class="line">// cout &lt;&lt; data[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">// &#125;</span><br><span class="line">// cout &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;key count&quot; &lt;&lt; count1&lt;&lt;  &quot;  moving count&quot; &lt;&lt; count2 &lt;&lt;endl;</span><br><span class="line">&#125;;</span><br><span class="line">void InsertSort();//插入排序</span><br><span class="line">void SelectSort();//选择排序</span><br><span class="line">void QuickSort(int first,int last);//快排</span><br><span class="line">void HeapSort();//堆排序</span><br><span class="line">void MergeSort(int first,int last);//归并排序</span><br><span class="line">long long count1;//关键字查找次数</span><br><span class="line">long long count2;//记录移动次数</span><br><span class="line">private:</span><br><span class="line">int part(int first,int last);</span><br><span class="line">void merge(int first,int last1,int last2);</span><br><span class="line">void Heap(int i,int last);</span><br><span class="line">int *data;</span><br><span class="line">int length;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void Sort::InsertSort()&#123;</span><br><span class="line">int j,temp;</span><br><span class="line">count1=0,count2=0;</span><br><span class="line">for(int i=1;i&lt;length;i++)&#123;</span><br><span class="line">temp = data[i];</span><br><span class="line">for(j = i-1;j&gt;=0&amp;&amp;temp&lt;data[j];j--)&#123;</span><br><span class="line">data[j+1] = data[j];</span><br><span class="line">count1++;</span><br><span class="line">&#125;</span><br><span class="line">data[j+1] = temp;</span><br><span class="line">count2++;</span><br><span class="line">&#125;</span><br><span class="line">//cout &lt;&lt; &quot;InsertSort:key count&quot; &lt;&lt; count1&lt;&lt;  &quot;  moving count&quot; &lt;&lt; count2 &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Sort::part(int first,int last)&#123;</span><br><span class="line">int i=first,j=last,temp;</span><br><span class="line">while(i&lt;j)&#123;</span><br><span class="line">while(i&lt;j&amp;&amp;data[i]&lt;=data[j])&#123;</span><br><span class="line">count1++;</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line">if(i&lt;j)&#123;</span><br><span class="line">temp = data[i];</span><br><span class="line">data[i] = data[j];</span><br><span class="line">data[j] = temp;</span><br><span class="line">count2++;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">while(i&lt;j&amp;&amp;data[i]&lt;=data[j])&#123;</span><br><span class="line">count1++;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">if(i&lt;j)&#123;</span><br><span class="line">temp = data[i];</span><br><span class="line">data[i] = data[j];</span><br><span class="line">data[j] = temp;</span><br><span class="line">count2++;</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Sort::QuickSort(int first,int last)&#123;</span><br><span class="line">if(first&gt;=last) return;</span><br><span class="line">else&#123;</span><br><span class="line">int locate = Sort::part(first,last);</span><br><span class="line">QuickSort(first,locate-1);</span><br><span class="line">QuickSort(locate+1,last);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Sort::SelectSort()&#123;</span><br><span class="line">int step,temp;</span><br><span class="line">for(int i=0;i&lt;length-1;i++)&#123;</span><br><span class="line">step = i;</span><br><span class="line">for(int j=i;j&lt;length;j++)&#123;</span><br><span class="line">count1++;</span><br><span class="line">if(data[j]&lt;data[step])&#123;</span><br><span class="line">step = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(step != i)&#123;</span><br><span class="line">temp = data[i];</span><br><span class="line">data[i] = data[step];</span><br><span class="line">data[step] = temp;</span><br><span class="line">count2++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Sort::Heap(int i,int last)&#123;</span><br><span class="line">int temp  = data[i];</span><br><span class="line">for(int k  = i*2+1;k&lt;last;k=k*2+1)&#123;</span><br><span class="line">if(k+1&lt;last&amp;&amp;data[k]&lt;data[k+1])&#123;</span><br><span class="line">k++;</span><br><span class="line">count1++;</span><br><span class="line">&#125;</span><br><span class="line">if(data[k]&gt;temp)&#123;</span><br><span class="line">data[i] = data[k];</span><br><span class="line">i=k;</span><br><span class="line">count2++;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">data[i] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Sort::HeapSort()&#123;</span><br><span class="line">int temp;</span><br><span class="line">    for(int i=length/2-1;i&gt;=0;i--)&#123;</span><br><span class="line">Heap(i,length);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//Print();</span><br><span class="line">for(int j=length-1;j&gt;0;j--)&#123;</span><br><span class="line">temp = data[0];</span><br><span class="line">data[0] = data[j];</span><br><span class="line">data[j] = temp;</span><br><span class="line">Heap(0,j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Sort::merge(int first,int mid,int last)&#123;</span><br><span class="line">    int *temp = new int [length];</span><br><span class="line">    int i = first,j = mid+1,step = first;</span><br><span class="line">    while(i&lt;=mid&amp;&amp;j&lt;=last)&#123;</span><br><span class="line">        count1++;</span><br><span class="line">        if(data[i]&lt;data[j])&#123;</span><br><span class="line">            temp[step++] = data[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            temp[step++] = data[j++];</span><br><span class="line">            count2++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while(i&lt;=mid)&#123;</span><br><span class="line">        temp[step++] = data[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    while(j&lt;=last)&#123;</span><br><span class="line">        temp[step++] = data[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    for(i=first;i&lt;=last;i++)&#123;</span><br><span class="line">        data[i] = temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    delete[]  temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Sort::MergeSort(int first,int last)&#123;</span><br><span class="line">    if(first == last) return ;</span><br><span class="line">    else&#123;</span><br><span class="line">        int mid = (first+last)/2;</span><br><span class="line">        MergeSort(first,mid);</span><br><span class="line">        MergeSort(mid+1,last);</span><br><span class="line">        merge(first,mid,last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure><!-- toc --><h1 id="2-可视化过程"><a href="#2-可视化过程" class="headerlink" title="2.可视化过程"></a><strong>2.可视化过程</strong></h1><p> <a href="https://visualgo.net/en/sorting">https://visualgo.net/en/sorting</a></p><hr />版权信息]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表下的归并排序</title>
      <link href="/2021/11/28/%E9%93%BE%E8%A1%A8%E5%BD%92%E5%B9%B6/"/>
      <url>/2021/11/28/%E9%93%BE%E8%A1%A8%E5%BD%92%E5%B9%B6/</url>
      
        <content type="html"><![CDATA[<p><em>链表下的归并排序</em><br><em>属于是不知道为什么老师会安排这种作业了</em></p><span id="more"></span><h1 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h1><p><em>原理两个函数可以解决</em><br><em>66行——生成可移动的头节点 并不影响返回调用头节点</em><br><em>49-54 快慢指针寻找链表的中点</em></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight plaintext"><figcaption><span>[链表的归并排序] [lang:C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename DataType&gt;</span><br><span class="line">void LinkList&lt;DataType&gt; ::merge_sort()&#123;</span><br><span class="line">    recursive_merge_sort(first);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename DataType&gt;</span><br><span class="line">void LinkList&lt;DataType&gt; ::recursive_merge_sort(Node&lt;DataType&gt; * &amp;sub_list)&#123;</span><br><span class="line">    divide_from(sub_list);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename DataType&gt;</span><br><span class="line">Node&lt;DataType&gt; *LinkList&lt;DataType&gt; ::divide_from(Node&lt;DataType&gt; *sub_list)&#123;</span><br><span class="line">    </span><br><span class="line">    Node&lt;DataType&gt;* fast = sub_list-&gt;next;</span><br><span class="line">    Node&lt;DataType&gt;* slow = sub_list;</span><br><span class="line">    Node&lt;DataType&gt;* head = slow;</span><br><span class="line">    </span><br><span class="line">    if(sub_list-&gt;next==nullptr||sub_list==nullptr)&#123;</span><br><span class="line">        return sub_list;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    while (fast != nullptr &amp;&amp; fast-&gt;next != nullptr) &#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    Node&lt;DataType&gt;* tmp = slow-&gt;next;</span><br><span class="line">    slow-&gt;next = nullptr;</span><br><span class="line">    </span><br><span class="line">    Node&lt;DataType&gt; *pa = divide_from(head);</span><br><span class="line">    //test(head);</span><br><span class="line">    Node&lt;DataType&gt; *pb = divide_from(tmp);</span><br><span class="line">    //test(tmp);</span><br><span class="line">    return merge(pa,pb);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename DataType&gt;</span><br><span class="line">Node&lt;DataType&gt; * LinkList&lt;DataType&gt;::merge(Node&lt;DataType&gt; *pa, Node&lt;DataType&gt; *pb)&#123;</span><br><span class="line"></span><br><span class="line">    Node&lt;DataType&gt;*  res = new Node&lt;DataType&gt;;</span><br><span class="line">    Node&lt;DataType&gt;* cur = res;</span><br><span class="line">    Node&lt;DataType&gt; * cur1=pa;</span><br><span class="line">    Node&lt;DataType&gt; * cur2=pb;</span><br><span class="line">    while(cur1!=nullptr&amp;&amp;cur2!=nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        if(cur1-&gt;data&lt;=cur2-&gt;data)</span><br><span class="line">        &#123;</span><br><span class="line">            cur-&gt;next=cur1;</span><br><span class="line">            cur1=cur1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            cur-&gt;next=cur2;</span><br><span class="line">            cur2=cur2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur=cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    if(cur1==nullptr)                </span><br><span class="line">        cur-&gt;next=cur2;</span><br><span class="line">    else</span><br><span class="line">        cur-&gt;next=cur1;</span><br><span class="line">    //cout &lt;&lt; cur-&gt;data&lt;&lt;&quot;---&quot;;</span><br><span class="line">    //test(res-&gt;next);</span><br><span class="line">    //cout &lt;&lt; res-&gt;next-&gt;next-&gt;data&lt;&lt;endl;</span><br><span class="line">    return res-&gt;next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr />]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 归并排序 </tag>
            
            <tag> 线性表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编程用笔记(更新ing)</title>
      <link href="/2021/11/08/my-note/"/>
      <url>/2021/11/08/my-note/</url>
      
        <content type="html"><![CDATA[<p><strong>前言</strong></p><p><em>收集一些经常要搜的编程小知识</em><br><em>不定期更新  ︿(￣︶￣)︿</em></p> <img src="https://s2.loli.net/2021/12/15/2eoquz8pm6ArHMQ.jpg" style="width:50%"><span id="more"></span><h1 id="环境变量配置"><a href="#环境变量配置" class="headerlink" title="环境变量配置"></a>环境变量配置</h1><p>文件夹<br>不要用大写<br>不要用大写<br>不要用大写</p><h1 id="vscode-常用快捷键"><a href="#vscode-常用快捷键" class="headerlink" title="vscode 常用快捷键"></a>vscode 常用快捷键</h1><p>链接指路<br><a href="https://blog.csdn.net/hypon2016/article/details/80831266?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163767461216780265485668%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163767461216780265485668&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-80831266.first_rank_v2_pc_rank_v29&amp;utm_term=vscode%E5%BF%AB%E6%8D%B7%E9%94%AE&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/hypon2016/article/details/80831266?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163767461216780265485668%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163767461216780265485668&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-80831266.first_rank_v2_pc_rank_v29&amp;utm_term=vscode%E5%BF%AB%E6%8D%B7%E9%94%AE&amp;spm=1018.2226.3001.4187</a></p><p>Shift+Alt + ↓ / ↑    向上/向下复制行 Copy line up/down<br>Ctrl+Home    转到文件开头 Go to beginning of file<br>Ctrl+End    转到文件末尾 Go to end of file<br>Ctrl+Enter    在下面插入行 Insert line below<br>Ctrl+Shift+Enter    在上面插入行 Insert line above<br>Ctrl+Shift+\    跳到匹配的括号 Jump to matching bracket<br>Ctrl+Shift+K    删除行 Delete line</p><p>Ctrl+Shift+[    折叠（折叠）区域 Fold (collapse) region<br>Ctrl+Shift+]    展开（未折叠）区域 Unfold (uncollapse) region<br>Ctrl+K Ctrl+[    折叠（未折叠）所有子区域 Fold (collapse) all subregions<br>Ctrl+K Ctrl+]    展开（未折叠）所有子区域 Unfold (uncollapse) all subregions<br>Ctrl+K Ctrl+0    折叠（折叠）所有区域 Fold (collapse) all regions<br>Ctrl+K Ctrl+J    展开（未折叠）所有区域 Unfold (uncollapse) all regions多光标和选择 Multi-cursor and selection</p><p>Alt +单击    插入光标 Insert cursor<br>Ctrl + Alt +↑/↓    在上/下插入光标 Insert cursor above / below<br>Ctrl + U    撤消上一个光标操作 Undo last cursor operation<br>Shift + Alt + I    在选定的每一行的末尾插入光标 Insert cursor at end of each line selected<br>Shift + Alt + →    展开选择 Expand selection<br>Shift + Alt + ←    缩小选择 Shrink selection</p><h1 id="C-时间函数"><a href="#C-时间函数" class="headerlink" title="C++ 时间函数"></a>C++ 时间函数</h1><p>头文件：<br>#include &lt;windows.h&gt;</p><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">clock_t time_start, time_end;</span><br><span class="line"></span><br><span class="line">/* 获取开始时间 */</span><br><span class="line">time_start = GetTickCount(); //从操作系统启动经过的毫秒数</span><br><span class="line"></span><br><span class="line">time_end = GetTickCount();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;Time = &quot; &lt;&lt; (time_end - time_start) &lt;&lt; &quot;ms\n &quot;;</span><br></pre></td></tr></table></figure><h1 id="C-随机函数"><a href="#C-随机函数" class="headerlink" title="C++ 随机函数"></a>C++ 随机函数</h1><p>#define random(x) (rand()%x)<br>要取得[0,n)  就是rand（）%n     表示 从0到n-1的数</p><p>要取得[a,b)的随机整数，使用(rand() % (b-a))+ a;<br>要取得[a,b]的随机整数，使用(rand() % (b-a+1))+ a;<br>要取得(a,b]的随机整数，使用(rand() % (b-a))+ a + 1;<br>通用公式:a + rand() % n；其中的a是起始值，n是整数的范围。<br>要取得a到b之间的随机整数，另一种表示：a + (int)b * rand() / (RAND_MAX + 1)。<br>要取得0～1之间的浮点数，可以使用rand() / double(RAND_MAX)。</p><h1 id="malloc解析"><a href="#malloc解析" class="headerlink" title="malloc解析"></a>malloc解析</h1><p>引用：<br><a href="https://zhuanlan.zhihu.com/p/105090421">https://zhuanlan.zhihu.com/p/105090421</a></p><p>头文件：#include &lt;malloc.h&gt; 或 #include &lt;alloc.h&gt; (注意：alloc.h 与 malloc.h 的内容是完全一致的。)</p><p>功能：分配长度为num_bytes字节的内存块</p><p>说明：如果分配成功则返回指向被分配内存的指针，否则返回空指针NULL。</p><p>当内存不再使用时，应使用free()函数将内存块释放。</p><p>解析：<br>malloc的意义是向 堆区 要了一块sizeof(int) * N 这么大的空间。<br>返回的是指针，所以在后期使用时要解引用。</p><p>代码：</p><figure class="highlight plaintext"><figcaption><span>[malloc解析] [lang:C++]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">    int i = 0;</span><br><span class="line">    int N = 0;</span><br><span class="line">    int* arr;</span><br><span class="line"></span><br><span class="line">    printf(&quot;请输入数组的大小\n&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;N);</span><br><span class="line"></span><br><span class="line">    arr = (int*)malloc(sizeof(int) * N);</span><br><span class="line"></span><br><span class="line">    printf(&quot;请输入%d个数</span><br></pre></td></tr></table></figure><h1 id="auto的循环用法"><a href="#auto的循环用法" class="headerlink" title="auto的循环用法"></a>auto的循环用法</h1><p>for(auto &amp;a :b)</p><p>输出的结果就是0—9这十个数。</p><p>for(auto &amp;a : arr)中“auto &amp;a”就是变量名就和上一个for循环中的“int i”一样，</p><p>与for(int i=0;i&lt;sizeof(arr)/sizeof(arr[0]);i++)是一样的。</p><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int arr[10];</span><br><span class="line">for(int i=0;i&lt;10;i++)</span><br><span class="line">&#123;</span><br><span class="line">  arr[i]=i;</span><br><span class="line">&#125;</span><br><span class="line">for(auto &amp;a:arr)</span><br><span class="line">&#123;</span><br><span class="line">  cout &lt;&lt; a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>未完待续 (°ー°〃)</strong></p><hr />版权信息]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo使用指南</title>
      <link href="/2021/11/01/hexo-note/"/>
      <url>/2021/11/01/hexo-note/</url>
      
        <content type="html"><![CDATA[<img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.zyiz.net%2Fupload%2F202002%2F18%2F202002182223498227.png&refer=http%3A%2F%2Fwww.zyiz.net&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1640944017&t=77d83c28c44b14310d74a639bf7b5d62/" alt="" style="width:100%" />  <p><strong>前言</strong></p><p>记录一下hexo搭建博客的操作和一些小知识 </p><span id="more"></span><h1 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a><strong>常用操作</strong></h1><figure class="highlight plaintext"><figcaption><span>[] []</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">hexo d 上传至github</span><br><span class="line">hexo new [layout] &lt;title&gt;</span><br><span class="line">eg: hexo new post name 新建页面</span><br><span class="line">hexo help  # 查看帮助</span><br><span class="line">hexo version  #查看Hexo的版本</span><br><span class="line">hexo algolia  # 更新search庫</span><br><span class="line">hexo clean #清除部署緩存</span><br><span class="line">hexo n == hexo new #新建文章</span><br><span class="line">hexo g == hexo generate #生成静态页面至public目录</span><br><span class="line">hexo s == hexo server #开启预览访问端口（默认端口4000，&#x27;ctrl + c&#x27;关闭server）</span><br><span class="line">hexo d == hexo deploy #将.deploy目录部署到GitHub</span><br><span class="line">hexo d -g #生成加部署</span><br><span class="line">hexo s -g #生成加预览</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="常用语言用法"><a href="#常用语言用法" class="headerlink" title="常用语言用法"></a>常用语言用法</h1><figure class="highlight plaintext"><figcaption><span>[xxxxxx] [lang:]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    代码块</span><br><span class="line">    &lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;figcaption&gt;&lt;span&gt;[xxxxxx] [lang:]&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</span><br><span class="line"></span><br><span class="line">&lt;pre&gt;&lt;code&gt;图片</span><br><span class="line">&amp;lt;img src=&amp;quot;&amp;quot; alt=&amp;quot;&amp;quot; style=&amp;quot;width:100%&amp;quot; /&amp;gt; </span><br><span class="line"></span><br><span class="line">博客内页面跳转</span><br><span class="line">&amp;#123;% post_link 最小生成树 %&amp;#125;</span><br><span class="line">&amp;#123;% post_link 最小生成树 最小生成树 %&amp;#125;</span><br><span class="line"></span><br><span class="line">&amp;lt;table&amp;gt;</span><br><span class="line">    &amp;lt;tr&amp;gt;</span><br><span class="line">        &amp;lt;td &amp;gt;&amp;lt;center&amp;gt;&amp;lt;img src=&amp;quot;&amp;quot; &amp;gt;图1 &amp;lt;/center&amp;gt;&amp;lt;/td&amp;gt;</span><br><span class="line">        &amp;lt;td &amp;gt;&amp;lt;center&amp;gt;&amp;lt;img src=&amp;quot;&amp;quot; &amp;gt;图2 &amp;lt;/center&amp;gt;&amp;lt;/td&amp;gt;</span><br><span class="line">    &amp;lt;/tr&amp;gt;</span><br><span class="line"></span><br><span class="line">&amp;lt;/table&amp;gt;</span><br><span class="line"></span><br><span class="line">制表</span><br><span class="line">|  序号 | 方法 | 描述 |</span><br><span class="line">|:-----|:-----|:-----| </span><br><span class="line">|       |       |       |</span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br></pre></td></tr></table></figure><h1 id="Hexo部署出现错误err-Error-Spawn-failed解决方式"><a href="#Hexo部署出现错误err-Error-Spawn-failed解决方式" class="headerlink" title="Hexo部署出现错误err: Error: Spawn failed解决方式"></a>Hexo部署出现错误err: Error: Spawn failed解决方式</h1><ol><li>##进入站点根目录<br>cd /usr/local/src/hexo/hanyubolg/</li></ol><p>##删除git提交内容文件夹<br>rm -rf .deploy_git/</p><p>##执行<br>git config –global core.autocrlf false</p><p>##最后<br>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</p><ol start="2"><li>##进入站点根目录<br>cd /usr/local/src/hexo/hanyubolg/</li></ol><p>##删除git提交内容文件夹<br>vim _config.yml</p><p>##修改<br>deploy:</p><p>type: git</p><p>repo: <a href="https://github.com/yourname/yourname.github.io.git">https://github.com/yourname/yourname.github.io.git</a> -&gt; <a href="mailto:&#x67;&#x69;&#x74;&#64;&#x67;&#x69;&#116;&#104;&#117;&#98;&#x2e;&#99;&#111;&#x6d;">&#x67;&#x69;&#x74;&#64;&#x67;&#x69;&#116;&#104;&#117;&#98;&#x2e;&#99;&#111;&#x6d;</a>:a956551943/weixiaohui.github.io.git</p><p>branch: master</p><p>##最后<br>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
